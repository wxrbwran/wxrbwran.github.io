{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/justified-gallery/justifiedGallery.min.css","path":"vendor/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/justified-gallery/jquery.justifiedGallery.min.js","path":"vendor/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/styles.css","path":"vendor/open-sans/styles.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/source-code-pro/styles.css","path":"vendor/source-code-pro/styles.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/font-awesome/css/font-awesome.min.css","path":"vendor/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/font-awesome/css/font-awesome.css","path":"vendor/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.eot","path":"vendor/lightgallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.ttf","path":"vendor/lightgallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.woff","path":"vendor/lightgallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.css.map","path":"vendor/lightgallery/css/lg-fb-comment-box.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.css","path":"vendor/lightgallery/css/lg-fb-comment-box.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.min.css","path":"vendor/lightgallery/css/lg-fb-comment-box.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.css","path":"vendor/lightgallery/css/lg-transitions.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.css.map","path":"vendor/lightgallery/css/lg-transitions.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.min.css","path":"vendor/lightgallery/css/lg-transitions.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.css","path":"vendor/lightgallery/css/lightgallery.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.css.map","path":"vendor/lightgallery/css/lightgallery.css.map","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/img/loading.gif","path":"vendor/lightgallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/img/video-play.png","path":"vendor/lightgallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/img/vimeo-play.png","path":"vendor/lightgallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.min.css","path":"vendor/lightgallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-fullscreen.js","path":"vendor/lightgallery/js/lg-fullscreen.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/img/youtube-play.png","path":"vendor/lightgallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-autoplay.min.js","path":"vendor/lightgallery/js/lg-autoplay.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-autoplay.js","path":"vendor/lightgallery/js/lg-autoplay.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-fullscreen.min.js","path":"vendor/lightgallery/js/lg-fullscreen.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-pager.js","path":"vendor/lightgallery/js/lg-pager.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-hash.min.js","path":"vendor/lightgallery/js/lg-hash.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-hash.js","path":"vendor/lightgallery/js/lg-hash.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-pager.min.js","path":"vendor/lightgallery/js/lg-pager.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-share.min.js","path":"vendor/lightgallery/js/lg-share.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-thumbnail.js","path":"vendor/lightgallery/js/lg-thumbnail.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-share.js","path":"vendor/lightgallery/js/lg-share.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-thumbnail.min.js","path":"vendor/lightgallery/js/lg-thumbnail.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-video.js","path":"vendor/lightgallery/js/lg-video.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-video.min.js","path":"vendor/lightgallery/js/lg-video.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-zoom.min.js","path":"vendor/lightgallery/js/lg-zoom.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-zoom.js","path":"vendor/lightgallery/js/lg-zoom.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lightgallery.min.js","path":"vendor/lightgallery/js/lightgallery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lightgallery.js","path":"vendor/lightgallery/js/lightgallery.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.svg","path":"vendor/lightgallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","path":"vendor/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.eot","path":"vendor/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.woff","path":"vendor/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/FontAwesome.otf","path":"vendor/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendor/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/jquery/2.1.3/jquery.min.js","path":"vendor/jquery/2.1.3/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendor/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.svg","path":"vendor/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/icarus/README.md","hash":"25c75503f044b817297995a96621c92ce037a098","modified":1496227487000},{"_id":"themes/icarus/LICENSE","hash":"df00918fa95de563927fd92b26f14c7affdc3052","modified":1496227487000},{"_id":"themes/icarus/.gitignore","hash":"35572c0f161a751b9f30ae3a9935ac045dba5220","modified":1496227487000},{"_id":"themes/icarus/_config.yml","hash":"96935b5667242c79287eb5e015c1f3cfd889cfd1","modified":1496227487000},{"_id":"themes/icarus/_config.yml.example","hash":"2bfcb6fa9078f7c5ffe2fc6c482248783711387f","modified":1496227487000},{"_id":"themes/icarus/package.json","hash":"1bc52ef10a33df23e56bd73c927f605019c87d41","modified":1496227487000},{"_id":"source/_posts/ES2015中的箭头函数.md","hash":"6309eac6de47da03002111db3dd3503e4618accf","modified":1496227487000},{"_id":"source/_posts/ES2015中的数组扩展.md","hash":"84425ce9a7ef1fcdb22b4a06f998036a870d2f91","modified":1496227487000},{"_id":"source/_posts/ES2015中的解构.md","hash":"5783ca9231579869410fa83fa1d07567a2014a3a","modified":1496227487000},{"_id":"source/_posts/ES2015之Class.md","hash":"2a7f71356b9cc90eee4f14d1e4c9f59a933154fd","modified":1496227487000},{"_id":"source/_posts/ES2015之let-和-const.md","hash":"4f02a846a24ff7b7adf024da9db875a859115b8b","modified":1496227487000},{"_id":"source/_posts/ES2015函数默认值,rest参数及扩展运算符.md","hash":"0b19ff380adddb89f9140e8019b09ffe78d12730","modified":1496227487000},{"_id":"source/_posts/ES2015字符串扩展.md","hash":"b43d3270488b428511200b2dbd61e9245295ed15","modified":1496227487000},{"_id":"source/_posts/ES2015新的数据结构Set和Map.md","hash":"c20d98c668001cbfa647a110a41e602dbc363d4f","modified":1496227487000},{"_id":"source/_posts/ES2015的数值扩展.md","hash":"11178f0d96d9a3b84bbaea4444b217f1403154fa","modified":1496227487000},{"_id":"source/_posts/ES2015的尾调用优化.md","hash":"ad5a2cb08d79e570771fbf27f94be295c8ebe5fc","modified":1496227487000},{"_id":"source/_posts/ES2015的模块化.md","hash":"ad5320aaf4e5997e531f33b6e0e6e2128743e2f1","modified":1496227487000},{"_id":"source/_posts/ES2015第七种数据结构Symbols.md","hash":"cb128b9c441af07eef9877bbe0a5a4373494fa4e","modified":1496227487000},{"_id":"source/_posts/Vue2-中的生命周期.md","hash":"8966496144326b9699a8b0ad39e3352a11713a97","modified":1496227487000},{"_id":"source/_posts/Html5的file-API.md","hash":"e19dc391a39745564ab428fb7ecda0e2de486bef","modified":1496227487000},{"_id":"source/_posts/hexo＋Travis-ci＋github构建自动化博客.md","hash":"4d10be77eece7e347e11b8dbc1cc6ec422122cb5","modified":1496288538000},{"_id":"source/_posts/Vue中的过渡效果.md","hash":"50238245a2dace7c07e02dcbcf74be103fcb3144","modified":1496227487000},{"_id":"source/_posts/flex.md","hash":"ec658b40b7fffb49fe7458bcdc63522197614be2","modified":1496227487000},{"_id":"source/_posts/javascript数据结构-队列.md","hash":"678621fe92f87e432759de1e006303ad3b89f5c4","modified":1496227487000},{"_id":"source/_posts/javascript-数据结构-栈.md","hash":"82c53cab7d5ccffc70402b879432d9b66cedc2ad","modified":1496227487000},{"_id":"source/_posts/css3笔记.md","hash":"bc9116f9d4f9fb7784a9d2175ef09373bd769d88","modified":1496227487000},{"_id":"source/_posts/key之后push还要输入账号密码的解决方法.md","hash":"42e882e2492907d5cb26cda1f84920d9017cdc20","modified":1496227487000},{"_id":"source/_posts/linux-交换alt和ctrl按键.md","hash":"f3ceeb8efce26e813ee2f014cb649f448b448c96","modified":1496227487000},{"_id":"source/_posts/react中context的使用.md","hash":"d91860ab2ff9c3b0606c0d5a2d778c6e2eb2050f","modified":1496227487000},{"_id":"source/_posts/ubuntu 设置杂记.mkd","hash":"c90ce5f330079638ca1f9293181d3f3fd1dfe043","modified":1496227487000},{"_id":"source/_posts/linux中使用deepinQQ.md","hash":"f8ac439d4c5dfab1ca51aa0d63e158d0150a9f60","modified":1496227487000},{"_id":"source/_posts/vue-router2的一些变化.md","hash":"100975176a157432076bf868b9983888192521ab","modified":1496227487000},{"_id":"source/_posts/ubuntu1604-git结合beyond-compare.md","hash":"33063f3333c37b9fde734c221b6f764517e4cd30","modified":1496227487000},{"_id":"source/_posts/vuex2-的一些变化.md","hash":"556107d4ce04b126392cb4924e44f2e85b4b9514","modified":1496227487000},{"_id":"source/_posts/你可能并不需要jQuery.md","hash":"da4f8fa790143ccdf2abebdfdbc329c28f7b6206","modified":1496227487000},{"_id":"source/_posts/使用ES2015全局对象--webpack下添加polyfill.md","hash":"53b41de64666ed28e1eb06a8d7d74b35cc73d6b3","modified":1496227487000},{"_id":"source/_posts/使用MockJs进行独立于后端的前端开发.md","hash":"3255bb804ce324eb8e0eff3339b0e951a4de4363","modified":1496227487000},{"_id":"source/_posts/使用nvm安装node.md","hash":"e4f5d7ca78f31281503150b56d6f912c2155c404","modified":1496227487000},{"_id":"source/_posts/使用webpack压缩图片遇到的问题.md","hash":"86364e961f8d2ae53ce42c6bbfbff0ed817ebd67","modified":1496227487000},{"_id":"source/_posts/如何避免打开谷歌自动跳转-香港GOOGLE-COM-HK.md","hash":"4b2032dac38e57a4f1fc980df4a2ffe48e900f61","modified":1496227487000},{"_id":"source/_posts/在ubuntu上安装apache2及mysql.md","hash":"b9c02b5f70faadf37f2798c731e55ef35c99c059","modified":1496227487000},{"_id":"source/_posts/安装ubuntu后要做的几件事.md","hash":"f072851ddfc51efdbd17a858f0b85460e1466ccd","modified":1496227487000},{"_id":"source/_posts/调试手机端微信X5浏览器.md","hash":"ac27bc0dd46c598959d5d079b48dacf74b3c35ea","modified":1496227487000},{"_id":"source/_posts/使用requestAnimationFrame做动画控制.md","hash":"a5474f83dff58cf65f474f65ae0034920eeb33fd","modified":1496227487000},{"_id":"source/_posts/网易云音乐官方linux版！.md","hash":"376aa99718cf8505c016e88ad18ff63f0c6f79ac","modified":1496227487000},{"_id":"source/tags/index.md","hash":"a67a8548c76a91b869497f190d9edf0001ca5778","modified":1496227487000},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"9393fd3dbc943f1544facb66af7fd8b7a5b9ddbb","modified":1496227487000},{"_id":"themes/icarus/languages/fr.yml","hash":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1496227487000},{"_id":"themes/icarus/languages/en.yml","hash":"ade241498b85503a8953a1deca963222f47067a7","modified":1496227487000},{"_id":"themes/icarus/languages/es.yml","hash":"d7432219be5bee4cb569331378ade61b749688e0","modified":1496227487000},{"_id":"themes/icarus/languages/id.yml","hash":"70ec9ab2ac04cf882e81377ca5ad15bf8adceca8","modified":1496227487000},{"_id":"themes/icarus/languages/ja.yml","hash":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1496227487000},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1496227487000},{"_id":"themes/icarus/languages/ko.yml","hash":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1496227487000},{"_id":"themes/icarus/languages/ru.yml","hash":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1496227487000},{"_id":"themes/icarus/languages/tr.yml","hash":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1496227487000},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"3dc8ec524805afd090438be717908750da439204","modified":1496227487000},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1496227487000},{"_id":"themes/icarus/layout/archive.ejs","hash":"c1ecf667f40f34d61ab33eed46bab143eb1af36d","modified":1496227487000},{"_id":"themes/icarus/layout/categories.ejs","hash":"aa95629b770cff8cca9d663aeb6b17928f070de5","modified":1496227487000},{"_id":"themes/icarus/layout/category.ejs","hash":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1496227487000},{"_id":"themes/icarus/layout/layout.ejs","hash":"6f01b3d46d184a820297f9542497808b152bb09e","modified":1496227487000},{"_id":"themes/icarus/layout/index.ejs","hash":"43e971ebc35657b18e08a049559790348a16666f","modified":1496227487000},{"_id":"themes/icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1496227487000},{"_id":"themes/icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1496227487000},{"_id":"themes/icarus/layout/tag.ejs","hash":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1496227487000},{"_id":"themes/icarus/scripts/meta.js","hash":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1496227487000},{"_id":"themes/icarus/layout/tags.ejs","hash":"b0fcea68d7c11e5899bf0375d80997685111653f","modified":1496227487000},{"_id":"themes/icarus/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1496227487000},{"_id":"themes/icarus/_source/about/index.md","hash":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1496227487000},{"_id":"themes/icarus/_source/categories/index.md","hash":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1496227487000},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"1b32a90f400dc580f4b8298de75b94429ca6de68","modified":1496227487000},{"_id":"themes/icarus/_source/tags/index.md","hash":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1496227487000},{"_id":"themes/icarus/layout/comment/index.ejs","hash":"d45635e78a3fc40e424a401e983f2c8eef6ebcfd","modified":1496227487000},{"_id":"themes/icarus/layout/comment/duoshuo.ejs","hash":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1496227487000},{"_id":"themes/icarus/layout/comment/counter.ejs","hash":"e109d3256b004b027d029bd5bd67feeb72dc5388","modified":1496227487000},{"_id":"themes/icarus/layout/comment/youyan.ejs","hash":"6fe807992832939caf6c3e7651d052df9520d88e","modified":1496227487000},{"_id":"themes/icarus/layout/comment/scripts.ejs","hash":"8a9a20f72ba0923afa776396fb67d8c5d446a666","modified":1496227487000},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"cbfe560fcab445d42ceeb5d1beba5957d5be5eaa","modified":1496227487000},{"_id":"themes/icarus/layout/common/article.ejs","hash":"9aee307b2387f6762ff6e8226ade2c1c31251132","modified":1496227487000},{"_id":"themes/icarus/layout/common/head.ejs","hash":"cad8b2aec0ae4304bddd5c7c0f41f8d6e6dfa691","modified":1496227487000},{"_id":"themes/icarus/layout/common/header.ejs","hash":"738c6a923b2a6de6a81c4892c8a47e03d8b34f88","modified":1496227487000},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"c0a1a9e53f89440c42c325d5bd8c7234652c8937","modified":1496227487000},{"_id":"themes/icarus/layout/common/profile.ejs","hash":"0d5a9622d490652599e3ba3e4077a7d6bb2eb38e","modified":1496227487000},{"_id":"themes/icarus/layout/common/sidebar.ejs","hash":"6e80fa52d23c9c39bfa357a1e00c26fc8b851b82","modified":1496227487000},{"_id":"themes/icarus/layout/common/timeline.ejs","hash":"6420e34e0332c9b6670011519f341340db989343","modified":1496227487000},{"_id":"themes/icarus/layout/common/thumbnail.ejs","hash":"b1eae576510aed8279bedd5b5871f345b831b54c","modified":1496227487000},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"6a7bee18e666e627e62541a5e30906f87ba1bfe8","modified":1496227487000},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"349f08b6521a16e79046b1f94f04317ac74f556e","modified":1496227487000},{"_id":"themes/icarus/layout/plugin/scripts.ejs","hash":"a3c92f1f299e7ba11f2660457d8dcd41acf74640","modified":1496227487000},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1496227487000},{"_id":"themes/icarus/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1496227487000},{"_id":"themes/icarus/layout/search/index.ejs","hash":"24935e32e61d4706454b174ea3bed0726ae7fb34","modified":1496227487000},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"130fe3d33ac71da0b50f7fee6a87979f30938a1b","modified":1496227487000},{"_id":"themes/icarus/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1496227487000},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1496227487000},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"a1e772c5a6f174d585b0c1e574058f75dc8e2898","modified":1496227487000},{"_id":"themes/icarus/layout/share/default.ejs","hash":"ebfb919dc525b3ed61a6a5ee05ee71410eedc541","modified":1496227487000},{"_id":"themes/icarus/layout/share/index.ejs","hash":"2a2c0095b95b11e5692bd8ad6a2337aa644189a2","modified":1496227487000},{"_id":"themes/icarus/layout/share/jiathis.ejs","hash":"21ebaa51e828cba2cefbeeaccb01514643565755","modified":1496227487000},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"d9ebbb7f6ce2f25df5ae25e4a1fef3c08f7054b9","modified":1496227487000},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"583bda80cf15b3ef11fefbd1b502897dfff40100","modified":1496227487000},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"aad118699718b62c0d3f3cfd6f17a181139a76af","modified":1496227487000},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"2ca923465275fb38a7ac7d67211d6e94a977e957","modified":1496227487000},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"3b8ae5953990436893da9d68f910ebe592005659","modified":1496227487000},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"ca8c7bf555fb6ce4904f2c59160548405c2c8a82","modified":1496227487000},{"_id":"themes/icarus/source/css/_extend.styl","hash":"9a5c72663c0da1b32ecb6a75773a5ccfb8c467ca","modified":1496227487000},{"_id":"themes/icarus/source/css/_variables.styl","hash":"d62af931be6612ec8c3a917836379a8cd92fbce1","modified":1496227487000},{"_id":"themes/icarus/source/css/style.styl","hash":"865de42ad496af928252d5bcfa0e0bbb534b0df5","modified":1496227487000},{"_id":"themes/icarus/source/js/main.js","hash":"a70daacbd0c0099aae0763b29a7fec20ce222d7a","modified":1496227487000},{"_id":"themes/icarus/source/js/insight.js","hash":"6ee84c42c2b230ff9e9bf605a444bd671d44f9e3","modified":1496227487000},{"_id":"source/_posts/.Archive/javascript数据结构-栈.md/2016-09-14 16-02-49.md","hash":"d8057b048e1af9deca9aea4e1ade4fd072525443","modified":1496227487000},{"_id":"source/_posts/.Archive/test.md/2016-08-30 11-35-56.md","hash":"7de1fc5cbfe4c8f6c546c1baa76b2b62dfbcc07a","modified":1496227487000},{"_id":"source/_posts/.Archive/javascript数据结构-栈.md/2016-09-14 16-03-49.md","hash":"0fce63c0bfdc81ecc3d521a1089203502412ff50","modified":1496227487000},{"_id":"source/_posts/.Archive/test.md/2016-08-30 11-38-38.md","hash":"6fb64e084aad3f8affe047bbf685c8090403fd77","modified":1496227487000},{"_id":"source/_posts/.Archive/test.md/2016-08-30 11-43-53.md","hash":"fd8f755cf9c2ad06a1f395f1949d813727cc605f","modified":1496227487000},{"_id":"source/_posts/.Archive/test.md/2016-08-30 11-39-45.md","hash":"2725be37a59a703ce9eeeaf2bef0ed00391a8a41","modified":1496227487000},{"_id":"source/_posts/.Archive/test.md/2016-08-30 11-42-52.md","hash":"751aeb9607fc2eae6a9402a285f0faed618d67ff","modified":1496227487000},{"_id":"source/_posts/.Archive/test.md/2016-09-06 16-14-35.md","hash":"e8bd7759ed8678929f65ee5e46357b309d93fdf7","modified":1496227487000},{"_id":"source/tags/.Archive/index.md/2016-09-06 16-00-55.md","hash":"483c4583f8331ce5dd8b64728300f41d5ee92a86","modified":1496227487000},{"_id":"themes/icarus/layout/common/post/banner.ejs","hash":"47ced3f03525698c79c6b1c07b48383fb6c496b2","modified":1496227487000},{"_id":"themes/icarus/layout/common/post/date.ejs","hash":"45cb0bcad461036cdd1fe2e3fbb5f2f19940025c","modified":1496227487000},{"_id":"themes/icarus/layout/common/post/gallery.ejs","hash":"659f019761116313169148ec61773e7b84abb739","modified":1496227487000},{"_id":"themes/icarus/layout/common/post/category.ejs","hash":"75c9dda2e7ec041943855ca163a6b1c4c8b4f260","modified":1496227487000},{"_id":"themes/icarus/layout/common/post/nav.ejs","hash":"d7cd611e642327f33dff3963ef869c2b46824a11","modified":1496227487000},{"_id":"themes/icarus/layout/common/post/tag.ejs","hash":"2e966216256321aa0c76fe1b9be689601c76ef31","modified":1496227487000},{"_id":"themes/icarus/layout/common/post/title.ejs","hash":"669ddb46fefa100856588351a7a2d30ad996b755","modified":1496227487000},{"_id":"themes/icarus/source/css/_partial/archive.styl","hash":"d35088c83ddd7a197d6d94e16a2ce3a7e29fa1dc","modified":1496227487000},{"_id":"themes/icarus/source/css/_partial/footer.styl","hash":"484776654e4c1691dc844e6e93786a08855c1c99","modified":1496227487000},{"_id":"themes/icarus/source/css/_partial/comment.styl","hash":"784646796184d4f27918c22395288a2fafbf9554","modified":1496227487000},{"_id":"themes/icarus/source/css/_partial/article.styl","hash":"5dda40a3767646502722bcf810e289f89f1fd998","modified":1496227487000},{"_id":"themes/icarus/source/css/_partial/header.styl","hash":"1e351f741144135871a3373fe7e969dc961b65e7","modified":1496227487000},{"_id":"themes/icarus/source/css/_partial/insight.styl","hash":"19833cd127f26ad90b06c115f8a96a30e0c0e53b","modified":1496227487000},{"_id":"themes/icarus/source/css/_partial/timeline.styl","hash":"c813b98f4fc45b64d2e07e5d944745a654c8c943","modified":1496227487000},{"_id":"themes/icarus/source/css/_partial/sidebar.styl","hash":"f528ca7064d9fcecd737b9b71c9c54601365d7d3","modified":1496227487000},{"_id":"themes/icarus/source/css/_partial/profile.styl","hash":"fb0170075dc2a41e01dd11bbfdbccbed544c479a","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1496227487000},{"_id":"themes/icarus/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1496227487000},{"_id":"themes/icarus/source/css/_util/mixin.styl","hash":"c8e1ddfc0fe9108bab592c7a73b73ce9344991fd","modified":1496227487000},{"_id":"themes/icarus/source/css/_util/grid.styl","hash":"93fb6f1e2f40cd7d88ad0d56dd73d3f9a7bc853e","modified":1496227487000},{"_id":"themes/icarus/source/css/images/logo.png","hash":"e606a0584f98268b2fe92303f3254520862ef659","modified":1496227487000},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1496227487000},{"_id":"themes/icarus/source/css/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1496227487000},{"_id":"themes/icarus/source/vendor/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1496227487000},{"_id":"themes/icarus/source/vendor/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/styles.css","hash":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1496227487000},{"_id":"themes/icarus/source/vendor/source-code-pro/styles.css","hash":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1496227487000},{"_id":"themes/icarus/source/vendor/font-awesome/css/font-awesome.min.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1496227487000},{"_id":"themes/icarus/source/vendor/font-awesome/css/font-awesome.css","hash":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.css.map","hash":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.css","hash":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.min.css","hash":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.css","hash":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.css.map","hash":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.min.css","hash":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.css","hash":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.css.map","hash":"3175b4107078674d25798979f7666f4daf31e624","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/img/loading.gif","hash":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/img/video-play.png","hash":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/img/vimeo-play.png","hash":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.min.css","hash":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-fullscreen.js","hash":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/img/youtube-play.png","hash":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-autoplay.min.js","hash":"d845741bcaf961579622880eb2a445257efad1ac","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-autoplay.js","hash":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-fullscreen.min.js","hash":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-pager.js","hash":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-hash.min.js","hash":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-hash.js","hash":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-pager.min.js","hash":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-share.min.js","hash":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-thumbnail.js","hash":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-share.js","hash":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-thumbnail.min.js","hash":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-video.js","hash":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-video.min.js","hash":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-zoom.min.js","hash":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-zoom.js","hash":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lightgallery.min.js","hash":"956ef9b706755318da69ad0b5d7786339d831251","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","hash":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","hash":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/js/lightgallery.js","hash":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1496227487000},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","hash":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","hash":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","hash":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","hash":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","hash":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","hash":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","hash":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","hash":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","hash":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","hash":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","hash":"5067c81462c15422853c94d21a1726865a61634f","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","hash":"d22904914469be735490e3c8cb093c7862896dd5","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","hash":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","hash":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","hash":"e75607ba1417181397c700775b84303d5a2957b9","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","hash":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","hash":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","hash":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1496227487000},{"_id":"themes/icarus/source/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","hash":"942addaec4d3a60af33947a84a3d85f926015947","modified":1496227487000},{"_id":"themes/icarus/source/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","hash":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1496227487000},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","hash":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1496227487000},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1496227487000},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1496227487000},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1496227487000},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1496227487000},{"_id":"themes/icarus/source/vendor/jquery/2.1.3/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1496227487000},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1496227487000},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1496227487000}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2016-09-06T07:59:27.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-09-06 15:59:27\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-05-31T10:44:47.000Z","path":"tags/index.html","layout":"page","_id":"cj3dvkfdk0015zk4ohtlob60y","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ES2015中的箭头函数","date":"2016-11-01T08:23:40.000Z","_content":"\n## 箭头函数\n\n### 基本用法\n\nES6允许使用“箭头”（`=>`）定义函数。\n\n```javascript\nvar f = v => v;\n```\n\n上面的箭头函数等同于：\n\n```javascript\nvar f = function(v) {\n  return v;\n};\n```\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n\n```javascript\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n```\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回。\n\n```javascript\nvar sum = (num1, num2) => { return num1 + num2; }\n```\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。\n\n```javascript\nvar getTempItem = id => ({ id: id, name: \"Temp\" });\n```\n\n箭头函数可以与变量解构结合使用。\n\n```javascript\nconst full = ({ first, last }) => first + ' ' + last;\n\n// 等同于\nfunction full(person) {\n  return person.first + ' ' + person.last;\n}\n```\n\n箭头函数使得表达更加简洁。\n\n```javascript\nconst isEven = n => n % 2 == 0;\nconst square = n => n * n;\n```\n\n上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。\n\n箭头函数的一个用处是简化回调函数。\n\n```javascript\n// 正常函数写法\n[1,2,3].map(function (x) {\n  return x * x;\n});\n\n// 箭头函数写法\n[1,2,3].map(x => x * x);\n```\n\n另一个例子是\n\n```javascript\n// 正常函数写法\nvar result = values.sort(function (a, b) {\n  return a - b;\n});\n\n// 箭头函数写法\nvar result = values.sort((a, b) => a - b);\n```\n\n下面是rest参数与箭头函数结合的例子。\n\n```javascript\nconst numbers = (...nums) => nums;\n\nnumbers(1, 2, 3, 4, 5)\n// [1,2,3,4,5]\n\nconst headAndTail = (head, ...tail) => [head, tail];\n\nheadAndTail(1, 2, 3, 4, 5)\n// [1,[2,3,4,5]]\n```\n<!--more-->\n### 使用注意点\n\n箭头函数有几个使用注意点。\n\n（1）函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n（2）不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n\n（3）不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n\n（4）不可以使用`yield`命令，因此箭头函数不能用作Generator函数。\n\n上面四点中，第一点尤其值得注意。`this`对象的指向是可变的，但是在箭头函数中，它是固定的。\n\n```javascript\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\nvar id = 21;\n\nfoo.call({ id: 42 });\n// id: 42\n```\n\n上面代码中，`setTimeout`的参数是一个箭头函数，这个箭头函数的定义生效是在`foo`函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时`this`应该指向全局对象`window`，这时应该输出`21`。但是，箭头函数导致`this`总是指向函数定义生效时所在的对象（本例是`{id: 42}`），所以输出的是`42`。\n\n箭头函数可以让`this`指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。\n\n```javascript\nvar handler = {\n  id: '123456',\n\n  init: function() {\n    document.addEventListener('click',\n      event => this.doSomething(event.type), false);\n  },\n\n  doSomething: function(type) {\n    console.log('Handling ' + type  + ' for ' + this.id);\n  }\n};\n```\n\n上面代码的`init`方法中，使用了箭头函数，这导致这个箭头函数里面的`this`，总是指向`handler`对象。否则，回调函数运行时，`this.doSomething`这一行会报错，因为此时`this`指向`document`对象。\n\n`this`指向的固定化，并不是因为箭头函数内部有绑定`this`的机制，实际原因是箭头函数根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`。正是因为它没有`this`，所以也就不能用作构造函数。\n\n所以，箭头函数转成ES5的代码如下。\n\n```javascript\n// ES6\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\n// ES5\nfunction foo() {\n  var _this = this;\n\n  setTimeout(function () {\n    console.log('id:', _this.id);\n  }, 100);\n}\n```\n\n上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的`this`，而是引用外层的`this`。\n在ES6中，不需要再hackthis了，但你需要遵循以下规则：\n\n - 通过object.method()语法调用的方法使用非箭头函数定义，这些函数需要从调用者的作用域中获取一个有意义的this值。\n - 其它情况全都使用箭头函数。\n\n```javascript\n// ES6\n{\n    ...\n    addAll: function addAll(pieces) {\n    _.each(pieces, piece => this.add(piece));\n    },\n    ...\n }\n```\n在ES6的版本中，注意addAll方法从它的调用者处获取了this值，内部函数是一个箭头函数，所以它继承了外围作用域的this值。\n\n超赞的是，在ES6中你可以用更简洁的方式编写对象字面量中的方法，所以上面这段代码可以简化成：\n```javascript\n// ES6的方法语法\n{\n  ...\n  addAll(pieces) {\n    _.each(pieces, piece => this.add(piece));\n  },\n  ...\n}\n```\n在方法和箭头函数之间，我再也不会错写functoin了，这真是一个绝妙的设计思想！\n\n请问下面的代码之中有几个`this`？\n\n```javascript\nfunction foo() {\n  return () => {\n    return () => {\n      return () => {\n        console.log('id:', this.id);\n      };\n    };\n  };\n}\n\nvar f = foo.call({id: 1});\n\nvar t1 = f.call({id: 2})()(); // id: 1\nvar t2 = f().call({id: 3})(); // id: 1\nvar t3 = f()().call({id: 4}); // id: 1\n```\n\n上面代码之中，只有一个`this`，就是函数`foo`的`this`，所以`t1`、`t2`、`t3`都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的`this`，它们的`this`其实都是最外层`foo`函数的`this`。\n\n除了`this`，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：`arguments`、`super`、`new.target`。\n\n```javascript\nfunction foo() {\n  setTimeout(() => {\n    console.log('args:', arguments);\n  }, 100);\n}\n\nfoo(2, 4, 6, 8)\n// args: [2, 4, 6, 8]\n```\n\n上面代码中，箭头函数内部的变量`arguments`，其实是函数`foo`的`arguments`变量。\n\n另外，由于箭头函数没有自己的`this`，所以当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变`this`的指向。\n\n```javascript\n(function() {\n  return [\n    (() => this.x).bind({ x: 'inner' })()\n  ];\n}).call({ x: 'outer' });\n// ['outer']\n```\n\n上面代码中，箭头函数没有自己的`this`，所以`bind`方法无效，内部的`this`指向外部的`this`。\n\n长期以来，JavaScript语言的`this`对象一直是一个令人头痛的问题，在对象方法中使用`this`，必须非常小心。箭头函数”绑定”`this`，很大程度上解决了这个困扰。\n\n### 嵌套的箭头函数\n\n下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。\n\n```javascript\nconst pipeline = (...funcs) =>\n  val => funcs.reduce((a, b) => b(a), val);\n\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\nconst addThenMult = pipeline(plus1, mult2);\n\naddThenMult(5)\n// 12\n```\n\n如果觉得上面的写法可读性比较差，也可以采用下面的写法。\n\n```javascript\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\n\nmult2(plus1(5))\n// 12\n```\n\n","source":"_posts/ES2015中的箭头函数.md","raw":"---\ntitle: ES2015中的箭头函数\ndate: 2016-11-01 16:23:40\ntags: ES2015\n---\n\n## 箭头函数\n\n### 基本用法\n\nES6允许使用“箭头”（`=>`）定义函数。\n\n```javascript\nvar f = v => v;\n```\n\n上面的箭头函数等同于：\n\n```javascript\nvar f = function(v) {\n  return v;\n};\n```\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n\n```javascript\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n```\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回。\n\n```javascript\nvar sum = (num1, num2) => { return num1 + num2; }\n```\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。\n\n```javascript\nvar getTempItem = id => ({ id: id, name: \"Temp\" });\n```\n\n箭头函数可以与变量解构结合使用。\n\n```javascript\nconst full = ({ first, last }) => first + ' ' + last;\n\n// 等同于\nfunction full(person) {\n  return person.first + ' ' + person.last;\n}\n```\n\n箭头函数使得表达更加简洁。\n\n```javascript\nconst isEven = n => n % 2 == 0;\nconst square = n => n * n;\n```\n\n上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。\n\n箭头函数的一个用处是简化回调函数。\n\n```javascript\n// 正常函数写法\n[1,2,3].map(function (x) {\n  return x * x;\n});\n\n// 箭头函数写法\n[1,2,3].map(x => x * x);\n```\n\n另一个例子是\n\n```javascript\n// 正常函数写法\nvar result = values.sort(function (a, b) {\n  return a - b;\n});\n\n// 箭头函数写法\nvar result = values.sort((a, b) => a - b);\n```\n\n下面是rest参数与箭头函数结合的例子。\n\n```javascript\nconst numbers = (...nums) => nums;\n\nnumbers(1, 2, 3, 4, 5)\n// [1,2,3,4,5]\n\nconst headAndTail = (head, ...tail) => [head, tail];\n\nheadAndTail(1, 2, 3, 4, 5)\n// [1,[2,3,4,5]]\n```\n<!--more-->\n### 使用注意点\n\n箭头函数有几个使用注意点。\n\n（1）函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n（2）不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n\n（3）不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。\n\n（4）不可以使用`yield`命令，因此箭头函数不能用作Generator函数。\n\n上面四点中，第一点尤其值得注意。`this`对象的指向是可变的，但是在箭头函数中，它是固定的。\n\n```javascript\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\nvar id = 21;\n\nfoo.call({ id: 42 });\n// id: 42\n```\n\n上面代码中，`setTimeout`的参数是一个箭头函数，这个箭头函数的定义生效是在`foo`函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时`this`应该指向全局对象`window`，这时应该输出`21`。但是，箭头函数导致`this`总是指向函数定义生效时所在的对象（本例是`{id: 42}`），所以输出的是`42`。\n\n箭头函数可以让`this`指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。\n\n```javascript\nvar handler = {\n  id: '123456',\n\n  init: function() {\n    document.addEventListener('click',\n      event => this.doSomething(event.type), false);\n  },\n\n  doSomething: function(type) {\n    console.log('Handling ' + type  + ' for ' + this.id);\n  }\n};\n```\n\n上面代码的`init`方法中，使用了箭头函数，这导致这个箭头函数里面的`this`，总是指向`handler`对象。否则，回调函数运行时，`this.doSomething`这一行会报错，因为此时`this`指向`document`对象。\n\n`this`指向的固定化，并不是因为箭头函数内部有绑定`this`的机制，实际原因是箭头函数根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`。正是因为它没有`this`，所以也就不能用作构造函数。\n\n所以，箭头函数转成ES5的代码如下。\n\n```javascript\n// ES6\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\n// ES5\nfunction foo() {\n  var _this = this;\n\n  setTimeout(function () {\n    console.log('id:', _this.id);\n  }, 100);\n}\n```\n\n上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的`this`，而是引用外层的`this`。\n在ES6中，不需要再hackthis了，但你需要遵循以下规则：\n\n - 通过object.method()语法调用的方法使用非箭头函数定义，这些函数需要从调用者的作用域中获取一个有意义的this值。\n - 其它情况全都使用箭头函数。\n\n```javascript\n// ES6\n{\n    ...\n    addAll: function addAll(pieces) {\n    _.each(pieces, piece => this.add(piece));\n    },\n    ...\n }\n```\n在ES6的版本中，注意addAll方法从它的调用者处获取了this值，内部函数是一个箭头函数，所以它继承了外围作用域的this值。\n\n超赞的是，在ES6中你可以用更简洁的方式编写对象字面量中的方法，所以上面这段代码可以简化成：\n```javascript\n// ES6的方法语法\n{\n  ...\n  addAll(pieces) {\n    _.each(pieces, piece => this.add(piece));\n  },\n  ...\n}\n```\n在方法和箭头函数之间，我再也不会错写functoin了，这真是一个绝妙的设计思想！\n\n请问下面的代码之中有几个`this`？\n\n```javascript\nfunction foo() {\n  return () => {\n    return () => {\n      return () => {\n        console.log('id:', this.id);\n      };\n    };\n  };\n}\n\nvar f = foo.call({id: 1});\n\nvar t1 = f.call({id: 2})()(); // id: 1\nvar t2 = f().call({id: 3})(); // id: 1\nvar t3 = f()().call({id: 4}); // id: 1\n```\n\n上面代码之中，只有一个`this`，就是函数`foo`的`this`，所以`t1`、`t2`、`t3`都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的`this`，它们的`this`其实都是最外层`foo`函数的`this`。\n\n除了`this`，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：`arguments`、`super`、`new.target`。\n\n```javascript\nfunction foo() {\n  setTimeout(() => {\n    console.log('args:', arguments);\n  }, 100);\n}\n\nfoo(2, 4, 6, 8)\n// args: [2, 4, 6, 8]\n```\n\n上面代码中，箭头函数内部的变量`arguments`，其实是函数`foo`的`arguments`变量。\n\n另外，由于箭头函数没有自己的`this`，所以当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变`this`的指向。\n\n```javascript\n(function() {\n  return [\n    (() => this.x).bind({ x: 'inner' })()\n  ];\n}).call({ x: 'outer' });\n// ['outer']\n```\n\n上面代码中，箭头函数没有自己的`this`，所以`bind`方法无效，内部的`this`指向外部的`this`。\n\n长期以来，JavaScript语言的`this`对象一直是一个令人头痛的问题，在对象方法中使用`this`，必须非常小心。箭头函数”绑定”`this`，很大程度上解决了这个困扰。\n\n### 嵌套的箭头函数\n\n下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。\n\n```javascript\nconst pipeline = (...funcs) =>\n  val => funcs.reduce((a, b) => b(a), val);\n\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\nconst addThenMult = pipeline(plus1, mult2);\n\naddThenMult(5)\n// 12\n```\n\n如果觉得上面的写法可读性比较差，也可以采用下面的写法。\n\n```javascript\nconst plus1 = a => a + 1;\nconst mult2 = a => a * 2;\n\nmult2(plus1(5))\n// 12\n```\n\n","slug":"ES2015中的箭头函数","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfb40000zk4owcydopda","content":"<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v;</div></pre></td></tr></table></figure>\n<p>上面的箭头函数等同于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> v;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">5</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> &#123; <span class=\"keyword\">return</span> num1 + num2; &#125;</div></pre></td></tr></table></figure>\n<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getTempItem = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> (&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">name</span>: <span class=\"string\">\"Temp\"</span> &#125;);</div></pre></td></tr></table></figure>\n<p>箭头函数可以与变量解构结合使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> full = <span class=\"function\">(<span class=\"params\">&#123; first, last &#125;</span>) =&gt;</span> first + <span class=\"string\">' '</span> + last;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">full</span>(<span class=\"params\">person</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> person.first + <span class=\"string\">' '</span> + person.last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>箭头函数使得表达更加简洁。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * n;</div></pre></td></tr></table></figure>\n<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>\n<p>箭头函数的一个用处是简化回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 正常函数写法</span></div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x * x;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 箭头函数写法</span></div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x);</div></pre></td></tr></table></figure>\n<p>另一个例子是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 正常函数写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> result = values.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a - b;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 箭头函数写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> result = values.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</div></pre></td></tr></table></figure>\n<p>下面是rest参数与箭头函数结合的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> numbers = <span class=\"function\">(<span class=\"params\">...nums</span>) =&gt;</span> nums;</div><div class=\"line\"></div><div class=\"line\">numbers(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// [1,2,3,4,5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> headAndTail = <span class=\"function\">(<span class=\"params\">head, ...tail</span>) =&gt;</span> [head, tail];</div><div class=\"line\"></div><div class=\"line\">headAndTail(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// [1,[2,3,4,5]]</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h3><p>箭头函数有几个使用注意点。</p>\n<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>\n<p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>\n<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>\n<p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'id:'</span>, <span class=\"keyword\">this</span>.id);</div><div class=\"line\">  &#125;, <span class=\"number\">100</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"number\">21</span>;</div><div class=\"line\"></div><div class=\"line\">foo.call(&#123; <span class=\"attr\">id</span>: <span class=\"number\">42</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// id: 42</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>{id: 42}</code>），所以输出的是<code>42</code>。</p>\n<p>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> handler = &#123;</div><div class=\"line\">  <span class=\"attr\">id</span>: <span class=\"string\">'123456'</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>,</div><div class=\"line\">      event =&gt; <span class=\"keyword\">this</span>.doSomething(event.type), <span class=\"literal\">false</span>);</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">doSomething</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Handling '</span> + type  + <span class=\"string\">' for '</span> + <span class=\"keyword\">this</span>.id);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码的<code>init</code>方法中，使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象。否则，回调函数运行时，<code>this.doSomething</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p>\n<p><code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p>\n<p>所以，箭头函数转成ES5的代码如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'id:'</span>, <span class=\"keyword\">this</span>.id);</div><div class=\"line\">  &#125;, <span class=\"number\">100</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'id:'</span>, _this.id);</div><div class=\"line\">  &#125;, <span class=\"number\">100</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。<br>在ES6中，不需要再hackthis了，但你需要遵循以下规则：</p>\n<ul>\n<li>通过object.method()语法调用的方法使用非箭头函数定义，这些函数需要从调用者的作用域中获取一个有意义的this值。</li>\n<li>其它情况全都使用箭头函数。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\">&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    addAll: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAll</span>(<span class=\"params\">pieces</span>) </span>&#123;</div><div class=\"line\">    _.each(pieces, piece =&gt; <span class=\"keyword\">this</span>.add(piece));</div><div class=\"line\">    &#125;,</div><div class=\"line\">    ...</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>在ES6的版本中，注意addAll方法从它的调用者处获取了this值，内部函数是一个箭头函数，所以它继承了外围作用域的this值。</p>\n<p>超赞的是，在ES6中你可以用更简洁的方式编写对象字面量中的方法，所以上面这段代码可以简化成：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6的方法语法</span></div><div class=\"line\">&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  addAll(pieces) &#123;</div><div class=\"line\">    _.each(pieces, piece =&gt; <span class=\"keyword\">this</span>.add(piece));</div><div class=\"line\">  &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在方法和箭头函数之间，我再也不会错写functoin了，这真是一个绝妙的设计思想！</p>\n<p>请问下面的代码之中有几个<code>this</code>？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'id:'</span>, <span class=\"keyword\">this</span>.id);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> f = foo.call(&#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> t1 = f.call(&#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>&#125;)()(); <span class=\"comment\">// id: 1</span></div><div class=\"line\"><span class=\"keyword\">var</span> t2 = f().call(&#123;<span class=\"attr\">id</span>: <span class=\"number\">3</span>&#125;)(); <span class=\"comment\">// id: 1</span></div><div class=\"line\"><span class=\"keyword\">var</span> t3 = f()().call(&#123;<span class=\"attr\">id</span>: <span class=\"number\">4</span>&#125;); <span class=\"comment\">// id: 1</span></div></pre></td></tr></table></figure>\n<p>上面代码之中，只有一个<code>this</code>，就是函数<code>foo</code>的<code>this</code>，所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。</p>\n<p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'args:'</span>, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">  &#125;, <span class=\"number\">100</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>)</div><div class=\"line\"><span class=\"comment\">// args: [2, 4, 6, 8]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，箭头函数内部的变量<code>arguments</code>，其实是函数<code>foo</code>的<code>arguments</code>变量。</p>\n<p>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [</div><div class=\"line\">    <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> <span class=\"keyword\">this</span>.x).bind(&#123; <span class=\"attr\">x</span>: <span class=\"string\">'inner'</span> &#125;)()</div><div class=\"line\">  ];</div><div class=\"line\">&#125;).call(&#123; <span class=\"attr\">x</span>: <span class=\"string\">'outer'</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// ['outer']</span></div></pre></td></tr></table></figure>\n<p>上面代码中，箭头函数没有自己的<code>this</code>，所以<code>bind</code>方法无效，内部的<code>this</code>指向外部的<code>this</code>。</p>\n<p>长期以来，JavaScript语言的<code>this</code>对象一直是一个令人头痛的问题，在对象方法中使用<code>this</code>，必须非常小心。箭头函数”绑定”<code>this</code>，很大程度上解决了这个困扰。</p>\n<h3 id=\"嵌套的箭头函数\"><a href=\"#嵌套的箭头函数\" class=\"headerlink\" title=\"嵌套的箭头函数\"></a>嵌套的箭头函数</h3><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> pipeline = <span class=\"function\">(<span class=\"params\">...funcs</span>) =&gt;</span></div><div class=\"line\">  val =&gt; funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b(a), val);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> plus1 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> mult2 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a * <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> addThenMult = pipeline(plus1, mult2);</div><div class=\"line\"></div><div class=\"line\">addThenMult(<span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// 12</span></div></pre></td></tr></table></figure>\n<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> plus1 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> mult2 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a * <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">mult2(plus1(<span class=\"number\">5</span>))</div><div class=\"line\"><span class=\"comment\">// 12</span></div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v;</div></pre></td></tr></table></figure>\n<p>上面的箭头函数等同于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> v;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">5</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> num1 + num2;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> &#123; <span class=\"keyword\">return</span> num1 + num2; &#125;</div></pre></td></tr></table></figure>\n<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getTempItem = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> (&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">name</span>: <span class=\"string\">\"Temp\"</span> &#125;);</div></pre></td></tr></table></figure>\n<p>箭头函数可以与变量解构结合使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> full = <span class=\"function\">(<span class=\"params\">&#123; first, last &#125;</span>) =&gt;</span> first + <span class=\"string\">' '</span> + last;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">full</span>(<span class=\"params\">person</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> person.first + <span class=\"string\">' '</span> + person.last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>箭头函数使得表达更加简洁。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * n;</div></pre></td></tr></table></figure>\n<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>\n<p>箭头函数的一个用处是简化回调函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 正常函数写法</span></div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x * x;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 箭头函数写法</span></div><div class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x);</div></pre></td></tr></table></figure>\n<p>另一个例子是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 正常函数写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> result = values.sort(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a - b;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 箭头函数写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> result = values.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</div></pre></td></tr></table></figure>\n<p>下面是rest参数与箭头函数结合的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> numbers = <span class=\"function\">(<span class=\"params\">...nums</span>) =&gt;</span> nums;</div><div class=\"line\"></div><div class=\"line\">numbers(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// [1,2,3,4,5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> headAndTail = <span class=\"function\">(<span class=\"params\">head, ...tail</span>) =&gt;</span> [head, tail];</div><div class=\"line\"></div><div class=\"line\">headAndTail(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// [1,[2,3,4,5]]</span></div></pre></td></tr></table></figure>","more":"<h3 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h3><p>箭头函数有几个使用注意点。</p>\n<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>\n<p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>\n<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>\n<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>\n<p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'id:'</span>, <span class=\"keyword\">this</span>.id);</div><div class=\"line\">  &#125;, <span class=\"number\">100</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"number\">21</span>;</div><div class=\"line\"></div><div class=\"line\">foo.call(&#123; <span class=\"attr\">id</span>: <span class=\"number\">42</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// id: 42</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>{id: 42}</code>），所以输出的是<code>42</code>。</p>\n<p>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> handler = &#123;</div><div class=\"line\">  <span class=\"attr\">id</span>: <span class=\"string\">'123456'</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">init</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>,</div><div class=\"line\">      event =&gt; <span class=\"keyword\">this</span>.doSomething(event.type), <span class=\"literal\">false</span>);</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">doSomething</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Handling '</span> + type  + <span class=\"string\">' for '</span> + <span class=\"keyword\">this</span>.id);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码的<code>init</code>方法中，使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象。否则，回调函数运行时，<code>this.doSomething</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p>\n<p><code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p>\n<p>所以，箭头函数转成ES5的代码如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'id:'</span>, <span class=\"keyword\">this</span>.id);</div><div class=\"line\">  &#125;, <span class=\"number\">100</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'id:'</span>, _this.id);</div><div class=\"line\">  &#125;, <span class=\"number\">100</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。<br>在ES6中，不需要再hackthis了，但你需要遵循以下规则：</p>\n<ul>\n<li>通过object.method()语法调用的方法使用非箭头函数定义，这些函数需要从调用者的作用域中获取一个有意义的this值。</li>\n<li>其它情况全都使用箭头函数。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\">&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    addAll: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAll</span>(<span class=\"params\">pieces</span>) </span>&#123;</div><div class=\"line\">    _.each(pieces, piece =&gt; <span class=\"keyword\">this</span>.add(piece));</div><div class=\"line\">    &#125;,</div><div class=\"line\">    ...</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n<p>在ES6的版本中，注意addAll方法从它的调用者处获取了this值，内部函数是一个箭头函数，所以它继承了外围作用域的this值。</p>\n<p>超赞的是，在ES6中你可以用更简洁的方式编写对象字面量中的方法，所以上面这段代码可以简化成：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6的方法语法</span></div><div class=\"line\">&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  addAll(pieces) &#123;</div><div class=\"line\">    _.each(pieces, piece =&gt; <span class=\"keyword\">this</span>.add(piece));</div><div class=\"line\">  &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在方法和箭头函数之间，我再也不会错写functoin了，这真是一个绝妙的设计思想！</p>\n<p>请问下面的代码之中有几个<code>this</code>？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'id:'</span>, <span class=\"keyword\">this</span>.id);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> f = foo.call(&#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> t1 = f.call(&#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>&#125;)()(); <span class=\"comment\">// id: 1</span></div><div class=\"line\"><span class=\"keyword\">var</span> t2 = f().call(&#123;<span class=\"attr\">id</span>: <span class=\"number\">3</span>&#125;)(); <span class=\"comment\">// id: 1</span></div><div class=\"line\"><span class=\"keyword\">var</span> t3 = f()().call(&#123;<span class=\"attr\">id</span>: <span class=\"number\">4</span>&#125;); <span class=\"comment\">// id: 1</span></div></pre></td></tr></table></figure>\n<p>上面代码之中，只有一个<code>this</code>，就是函数<code>foo</code>的<code>this</code>，所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。</p>\n<p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'args:'</span>, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">  &#125;, <span class=\"number\">100</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>)</div><div class=\"line\"><span class=\"comment\">// args: [2, 4, 6, 8]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，箭头函数内部的变量<code>arguments</code>，其实是函数<code>foo</code>的<code>arguments</code>变量。</p>\n<p>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [</div><div class=\"line\">    <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> <span class=\"keyword\">this</span>.x).bind(&#123; <span class=\"attr\">x</span>: <span class=\"string\">'inner'</span> &#125;)()</div><div class=\"line\">  ];</div><div class=\"line\">&#125;).call(&#123; <span class=\"attr\">x</span>: <span class=\"string\">'outer'</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// ['outer']</span></div></pre></td></tr></table></figure>\n<p>上面代码中，箭头函数没有自己的<code>this</code>，所以<code>bind</code>方法无效，内部的<code>this</code>指向外部的<code>this</code>。</p>\n<p>长期以来，JavaScript语言的<code>this</code>对象一直是一个令人头痛的问题，在对象方法中使用<code>this</code>，必须非常小心。箭头函数”绑定”<code>this</code>，很大程度上解决了这个困扰。</p>\n<h3 id=\"嵌套的箭头函数\"><a href=\"#嵌套的箭头函数\" class=\"headerlink\" title=\"嵌套的箭头函数\"></a>嵌套的箭头函数</h3><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> pipeline = <span class=\"function\">(<span class=\"params\">...funcs</span>) =&gt;</span></div><div class=\"line\">  val =&gt; funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> b(a), val);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> plus1 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> mult2 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a * <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> addThenMult = pipeline(plus1, mult2);</div><div class=\"line\"></div><div class=\"line\">addThenMult(<span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// 12</span></div></pre></td></tr></table></figure>\n<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> plus1 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> mult2 = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a * <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\">mult2(plus1(<span class=\"number\">5</span>))</div><div class=\"line\"><span class=\"comment\">// 12</span></div></pre></td></tr></table></figure>"},{"title":"Es2015中的数组扩展","date":"2016-11-01T06:57:43.000Z","_content":"\n## Array.from()\n\n`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。\n\n下面是一个类似数组的对象，`Array.from`将它转为真正的数组。\n\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n\n实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的`arguments`对象。`Array.from`都可以将它们转为真正的数组。\n\n```javascript\n// NodeList对象\nlet ps = document.querySelectorAll('p');\nArray.from(ps).forEach(function (p) {\n  console.log(p);\n});\n\n// arguments对象\nfunction foo() {\n  var args = Array.from(arguments);\n  // ...\n}\n```\n\n上面代码中，`querySelectorAll`方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用`forEach`方法。\n\n只要是部署了Iterator接口的数据结构，`Array.from`都能将其转为数组。\n\n```javascript\nArray.from('hello')\n// ['h', 'e', 'l', 'l', 'o']\n\nlet namesSet = new Set(['a', 'b'])\nArray.from(namesSet) // ['a', 'b']\n```\n\n上面代码中，字符串和Set结构都具有Iterator接口，因此可以被`Array.from`转为真正的数组。\n\n如果参数是一个真正的数组，`Array.from`会返回一个一模一样的新数组。深复制。\n\n```javascript\nArray.from([1, 2, 3])\n// [1, 2, 3]\n```\n\n值得提醒的是，扩展运算符（`...`）也可以将某些数据结构转为数组。\n\n```javascript\n// arguments对象\nfunction foo() {\n  var args = [...arguments];\n}\n\n// NodeList对象\n[...document.querySelectorAll('div')]\n```\n\n扩展运算符背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。`Array.from`方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有`length`属性。因此，任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。\n\n```javascript\nArray.from({ length: 3 });\n// [ undefined, undefined, undefined ]\n```\n\n上面代码中，`Array.from`返回了一个具有三个成员的数组，每个位置的值都是`undefined`。扩展运算符转换不了这个对象。\n\n对于还没有部署该方法的浏览器，可以用`Array.prototype.slice`方法替代。\n\n```javascript\nconst toArray = (() =>\n  Array.from ? Array.from : obj => [].slice.call(obj)\n)();\n```\n\n`Array.from`还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\n```javascript\nArray.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\n\nArray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n```\n\n下面的例子是取出一组DOM节点的文本内容。\n\n```javascript\nlet spans = document.querySelectorAll('span.name');\n\n// map()\nlet names1 = Array.prototype.map.call(spans, s => s.textContent);\n\n// Array.from()\nlet names2 = Array.from(spans, s => s.textContent)\n```\n\n下面的例子将数组中布尔值为`false`的成员转为`0`。\n\n```javascript\nArray.from([1, , 2, , 3], (n) => n || 0)\n// [1, 0, 2, 0, 3]\n```\n\n另一个例子是返回各种数据的类型。\n\n```javascript\nfunction typesOf () {\n  return Array.from(arguments, value => typeof value)\n}\ntypesOf(null, [], NaN)\n// ['object', 'object', 'number']\n```\n\n如果`map`函数里面用到了`this`关键字，还可以传入`Array.from`的第三个参数，用来绑定`this`。\n\n`Array.from()`可以将各种值转为真正的数组，并且还提供`map`功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。\n\n```javascript\nArray.from({ length: 2 }, () => 'jack')\n// ['jack', 'jack']\n```\n\n上面代码中，`Array.from`的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。\n\n`Array.from()`的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于`\\uFFFF`的Unicode字符，算作两个字符的bug。\n\n```javascript\nfunction countSymbols(string) {\n  return Array.from(string).length;\n}\n```\n<!--more-->\n## Array.of()\n\n`Array.of`方法用于将一组值，转换为数组。\n\n```javascript\nArray.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n```\n\n这个方法的主要目的，是弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。\n\n```javascript\nArray() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n```\n\n上面代码中，`Array`方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，`Array()`才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。\n\n`Array.of`基本上可以用来替代`Array()`或`new Array()`，并且不存在由于参数不同而导致的重载。它的行为非常统一。\n\n```javascript\nArray.of() // []\nArray.of(undefined) // [undefined]\nArray.of(1) // [1]\nArray.of(1, 2) // [1, 2]\n```\n\n`Array.of`总是返回参数值组成的数组。如果没有参数，就返回一个空数组。\n\n`Array.of`方法可以用下面的代码模拟实现。\n\n```javascript\nfunction ArrayOf(){\n  return [].slice.call(arguments);\n}\n```\n\n## 数组实例的find()和findIndex()\n\n数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。\n\n```javascript\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n```\n\n上面代码找出数组中第一个小于0的成员。\n\n```javascript\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n```\n\n上面代码中，`find`方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。\n\n数组实例的`findIndex`方法的用法与`find`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。\n\n```javascript\n[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n```\n\n这两个方法都可以接受第二个参数，用来绑定回调函数的`this`对象。\n\n另外，这两个方法都可以发现`NaN`，弥补了数组的`IndexOf`方法的不足。\n\n```javascript\n[NaN].indexOf(NaN)\n// -1\n\n[NaN].findIndex(y => Object.is(NaN, y))\n// 0\n```\n\n上面代码中，`indexOf`方法无法识别数组的`NaN`成员，但是`findIndex`方法可以借助`Object.is`方法做到。\n\n## 数组实例的fill()\n\n`fill`方法使用给定值，填充一个数组。\n\n```javascript\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n```\n\n上面代码表明，`fill`方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。\n\n`fill`方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n\n```javascript\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n```\n\n上面代码表示，`fill`方法从1号位开始，向原数组填充7，到2号位之前结束。\n\n## 数组实例的entries()，keys()和values()\n\nES6提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。\n\n```javascript\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n\n如果不使用`for...of`循环，可以手动调用遍历器对象的`next`方法，进行遍历。\n\n```javascript\nlet letter = ['a', 'b', 'c'];\nlet entries = letter.entries();\nconsole.log(entries.next().value); // [0, 'a']\nconsole.log(entries.next().value); // [1, 'b']\nconsole.log(entries.next().value); // [2, 'c']\n```\n**Array.values()目前chrome/ff等浏览器均未支持！**循环时直接使用``for(let i of arr)``就可以了\n## 数组实例的includes()\n\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但Babel转码器已经支持。\n\n```javascript\n[1, 2, 3].includes(2);     // true\n[1, 2, 3].includes(4);     // false\n[1, 2, NaN].includes(NaN); // true\n```\n\n该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。\n\n```javascript\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n```\n\n没有该方法之前，我们通常使用数组的`indexOf`方法，检查是否包含某个值。\n\n```javascript\nif (arr.indexOf(el) !== -1) {\n  // ...\n}\n```\n\n`indexOf`方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对`NaN`的误判。\n\n```javascript\n[NaN].indexOf(NaN)\n// -1\n```\n\n`includes`使用的是不一样的判断算法，就没有这个问题。\n\n```javascript\n[NaN].includes(NaN)\n// true\n```\n\n下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。\n\n```javascript\nconst contains = (() =>\n  Array.prototype.includes\n    ? (arr, value) => arr.includes(value)\n    : (arr, value) => arr.some(el => el === value)\n)();\ncontains([\"foo\", \"bar\"], \"baz\"); // => false\n```\n\n另外，Map和Set数据结构有一个`has`方法，需要注意与`includes`区分。\n\n- Map结构的`has`方法，是用来查找键名的，比如`Map.prototype.has(key)`、`WeakMap.prototype.has(key)`、`Reflect.has(target, propertyKey)`。\n- Set结构的`has`方法，是用来查找值的，比如`Set.prototype.has(value)`、`WeakSet.prototype.has(value)`。\n\n## 数组实例的copyWithin()\n\n数组实例的`copyWithin`方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。\n\n```javascript\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n```\n\n它接受三个参数。\n\n- target（必需）：从该位置开始替换数据。\n- start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。\n- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。\n\n这三个参数都应该是数值，如果不是，会自动转为数值。\n\n```javascript\n[1, 2, 3, 4, 5].copyWithin(0, 3)\n// [4, 5, 3, 4, 5]\n```\n\n上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。\n\n下面是更多例子。\n\n```javascript\n// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4)\n// [4, 2, 3, 4, 5]\n\n// -2相当于3号位，-1相当于4号位\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1)\n// [4, 2, 3, 4, 5]\n\n// 将3号位复制到0号位\n[].copyWithin.call({length: 5, 3: 1}, 0, 3)\n// {0: 1, 3: 1, length: 5}\n\n// 将2号位到数组结束，复制到0号位\nvar i32a = new Int32Array([1, 2, 3, 4, 5]);\ni32a.copyWithin(0, 2);\n// Int32Array [3, 4, 5, 4, 5]\n\n// 对于没有部署TypedArray的copyWithin方法的平台\n// 需要采用下面的写法\n[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);\n// Int32Array [4, 2, 3, 4, 5]\n```\n\n## 数组的空位\n\n数组的空位指，数组的某一个位置没有任何值。比如，`Array`构造函数返回的数组都是空位。\n\n```javascript\nArray(3) // [, , ,]\n```\n\n上面代码中，`Array(3)`返回一个具有3个空位的数组。\n\n注意，空位不是`undefined`，一个位置的值等于`undefined`，依然是有值的。空位是没有任何值，`in`运算符可以说明这一点。\n\n```javascript\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n```\n\n上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。\n\nES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。\n\n- `forEach()`, `filter()`, `every()` 和`some()`都会跳过空位。\n- `map()`会跳过空位，但会保留这个值\n- `join()`和`toString()`会将空位视为`undefined`，而`undefined`和`null`会被处理成空字符串。\n\n```javascript\n// forEach方法\n[,'a'].forEach((x,i) => console.log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a##\"\n\n// toString方法\n[,'a',undefined,null].toString() // \",a,,\"\n```\n\nES6则是明确将空位转为`undefined`。\n\n`Array.from`方法会将数组的空位，转为`undefined`，也就是说，这个方法不会忽略空位。\n\n```javascript\nArray.from(['a',,'b'])\n// [ \"a\", undefined, \"b\" ]\n```\n\n扩展运算符（`...`）也会将空位转为`undefined`。\n\n```javascript\n[...['a',,'b']]\n// [ \"a\", undefined, \"b\" ]\n```\n\n`copyWithin()`会连空位一起拷贝。\n\n```javascript\n[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]\n```\n\n`fill()`会将空位视为正常的数组位置。\n\n```javascript\nnew Array(3).fill('a') // [\"a\",\"a\",\"a\"]\n```\n\n`for...of`循环也会遍历空位。\n\n```javascript\nlet arr = [, ,];\nfor (let i of arr) {\n  console.log(1);\n}\n// 1\n// 1\n```\n\n上面代码中，数组`arr`有两个空位，`for...of`并没有忽略它们。如果改成`map`方法遍历，空位是会跳过的。\n\n`entries()`、`keys()`、`values()`、`find()`和`findIndex()`会将空位处理成`undefined`。\n\n```javascript\n// entries()\n[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]\n\n// keys()\n[...[,'a'].keys()] // [0,1]\n\n// values()\n[...[,'a'].values()] // [undefined,\"a\"]\n\n// find()\n[,'a'].find(x => true) // undefined\n\n// findIndex()\n[,'a'].findIndex(x => true) // 0\n```\n\n由于空位的处理规则非常不统一，所以建议避免出现空位。\n\n","source":"_posts/ES2015中的数组扩展.md","raw":"---\ntitle: Es2015中的数组扩展\ndate: 2016-11-01 14:57:43\ntags: ES2015\n---\n\n## Array.from()\n\n`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。\n\n下面是一个类似数组的对象，`Array.from`将它转为真正的数组。\n\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n\n实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的`arguments`对象。`Array.from`都可以将它们转为真正的数组。\n\n```javascript\n// NodeList对象\nlet ps = document.querySelectorAll('p');\nArray.from(ps).forEach(function (p) {\n  console.log(p);\n});\n\n// arguments对象\nfunction foo() {\n  var args = Array.from(arguments);\n  // ...\n}\n```\n\n上面代码中，`querySelectorAll`方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用`forEach`方法。\n\n只要是部署了Iterator接口的数据结构，`Array.from`都能将其转为数组。\n\n```javascript\nArray.from('hello')\n// ['h', 'e', 'l', 'l', 'o']\n\nlet namesSet = new Set(['a', 'b'])\nArray.from(namesSet) // ['a', 'b']\n```\n\n上面代码中，字符串和Set结构都具有Iterator接口，因此可以被`Array.from`转为真正的数组。\n\n如果参数是一个真正的数组，`Array.from`会返回一个一模一样的新数组。深复制。\n\n```javascript\nArray.from([1, 2, 3])\n// [1, 2, 3]\n```\n\n值得提醒的是，扩展运算符（`...`）也可以将某些数据结构转为数组。\n\n```javascript\n// arguments对象\nfunction foo() {\n  var args = [...arguments];\n}\n\n// NodeList对象\n[...document.querySelectorAll('div')]\n```\n\n扩展运算符背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。`Array.from`方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有`length`属性。因此，任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。\n\n```javascript\nArray.from({ length: 3 });\n// [ undefined, undefined, undefined ]\n```\n\n上面代码中，`Array.from`返回了一个具有三个成员的数组，每个位置的值都是`undefined`。扩展运算符转换不了这个对象。\n\n对于还没有部署该方法的浏览器，可以用`Array.prototype.slice`方法替代。\n\n```javascript\nconst toArray = (() =>\n  Array.from ? Array.from : obj => [].slice.call(obj)\n)();\n```\n\n`Array.from`还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\n```javascript\nArray.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\n\nArray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n```\n\n下面的例子是取出一组DOM节点的文本内容。\n\n```javascript\nlet spans = document.querySelectorAll('span.name');\n\n// map()\nlet names1 = Array.prototype.map.call(spans, s => s.textContent);\n\n// Array.from()\nlet names2 = Array.from(spans, s => s.textContent)\n```\n\n下面的例子将数组中布尔值为`false`的成员转为`0`。\n\n```javascript\nArray.from([1, , 2, , 3], (n) => n || 0)\n// [1, 0, 2, 0, 3]\n```\n\n另一个例子是返回各种数据的类型。\n\n```javascript\nfunction typesOf () {\n  return Array.from(arguments, value => typeof value)\n}\ntypesOf(null, [], NaN)\n// ['object', 'object', 'number']\n```\n\n如果`map`函数里面用到了`this`关键字，还可以传入`Array.from`的第三个参数，用来绑定`this`。\n\n`Array.from()`可以将各种值转为真正的数组，并且还提供`map`功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。\n\n```javascript\nArray.from({ length: 2 }, () => 'jack')\n// ['jack', 'jack']\n```\n\n上面代码中，`Array.from`的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。\n\n`Array.from()`的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于`\\uFFFF`的Unicode字符，算作两个字符的bug。\n\n```javascript\nfunction countSymbols(string) {\n  return Array.from(string).length;\n}\n```\n<!--more-->\n## Array.of()\n\n`Array.of`方法用于将一组值，转换为数组。\n\n```javascript\nArray.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n```\n\n这个方法的主要目的，是弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。\n\n```javascript\nArray() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n```\n\n上面代码中，`Array`方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，`Array()`才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。\n\n`Array.of`基本上可以用来替代`Array()`或`new Array()`，并且不存在由于参数不同而导致的重载。它的行为非常统一。\n\n```javascript\nArray.of() // []\nArray.of(undefined) // [undefined]\nArray.of(1) // [1]\nArray.of(1, 2) // [1, 2]\n```\n\n`Array.of`总是返回参数值组成的数组。如果没有参数，就返回一个空数组。\n\n`Array.of`方法可以用下面的代码模拟实现。\n\n```javascript\nfunction ArrayOf(){\n  return [].slice.call(arguments);\n}\n```\n\n## 数组实例的find()和findIndex()\n\n数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为`true`的成员，然后返回该成员。如果没有符合条件的成员，则返回`undefined`。\n\n```javascript\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n```\n\n上面代码找出数组中第一个小于0的成员。\n\n```javascript\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n```\n\n上面代码中，`find`方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。\n\n数组实例的`findIndex`方法的用法与`find`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1`。\n\n```javascript\n[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n```\n\n这两个方法都可以接受第二个参数，用来绑定回调函数的`this`对象。\n\n另外，这两个方法都可以发现`NaN`，弥补了数组的`IndexOf`方法的不足。\n\n```javascript\n[NaN].indexOf(NaN)\n// -1\n\n[NaN].findIndex(y => Object.is(NaN, y))\n// 0\n```\n\n上面代码中，`indexOf`方法无法识别数组的`NaN`成员，但是`findIndex`方法可以借助`Object.is`方法做到。\n\n## 数组实例的fill()\n\n`fill`方法使用给定值，填充一个数组。\n\n```javascript\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n```\n\n上面代码表明，`fill`方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。\n\n`fill`方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n\n```javascript\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n```\n\n上面代码表示，`fill`方法从1号位开始，向原数组填充7，到2号位之前结束。\n\n## 数组实例的entries()，keys()和values()\n\nES6提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。\n\n```javascript\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n\n如果不使用`for...of`循环，可以手动调用遍历器对象的`next`方法，进行遍历。\n\n```javascript\nlet letter = ['a', 'b', 'c'];\nlet entries = letter.entries();\nconsole.log(entries.next().value); // [0, 'a']\nconsole.log(entries.next().value); // [1, 'b']\nconsole.log(entries.next().value); // [2, 'c']\n```\n**Array.values()目前chrome/ff等浏览器均未支持！**循环时直接使用``for(let i of arr)``就可以了\n## 数组实例的includes()\n\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但Babel转码器已经支持。\n\n```javascript\n[1, 2, 3].includes(2);     // true\n[1, 2, 3].includes(4);     // false\n[1, 2, NaN].includes(NaN); // true\n```\n\n该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。\n\n```javascript\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n```\n\n没有该方法之前，我们通常使用数组的`indexOf`方法，检查是否包含某个值。\n\n```javascript\nif (arr.indexOf(el) !== -1) {\n  // ...\n}\n```\n\n`indexOf`方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对`NaN`的误判。\n\n```javascript\n[NaN].indexOf(NaN)\n// -1\n```\n\n`includes`使用的是不一样的判断算法，就没有这个问题。\n\n```javascript\n[NaN].includes(NaN)\n// true\n```\n\n下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。\n\n```javascript\nconst contains = (() =>\n  Array.prototype.includes\n    ? (arr, value) => arr.includes(value)\n    : (arr, value) => arr.some(el => el === value)\n)();\ncontains([\"foo\", \"bar\"], \"baz\"); // => false\n```\n\n另外，Map和Set数据结构有一个`has`方法，需要注意与`includes`区分。\n\n- Map结构的`has`方法，是用来查找键名的，比如`Map.prototype.has(key)`、`WeakMap.prototype.has(key)`、`Reflect.has(target, propertyKey)`。\n- Set结构的`has`方法，是用来查找值的，比如`Set.prototype.has(value)`、`WeakSet.prototype.has(value)`。\n\n## 数组实例的copyWithin()\n\n数组实例的`copyWithin`方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。\n\n```javascript\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n```\n\n它接受三个参数。\n\n- target（必需）：从该位置开始替换数据。\n- start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。\n- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。\n\n这三个参数都应该是数值，如果不是，会自动转为数值。\n\n```javascript\n[1, 2, 3, 4, 5].copyWithin(0, 3)\n// [4, 5, 3, 4, 5]\n```\n\n上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。\n\n下面是更多例子。\n\n```javascript\n// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4)\n// [4, 2, 3, 4, 5]\n\n// -2相当于3号位，-1相当于4号位\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1)\n// [4, 2, 3, 4, 5]\n\n// 将3号位复制到0号位\n[].copyWithin.call({length: 5, 3: 1}, 0, 3)\n// {0: 1, 3: 1, length: 5}\n\n// 将2号位到数组结束，复制到0号位\nvar i32a = new Int32Array([1, 2, 3, 4, 5]);\ni32a.copyWithin(0, 2);\n// Int32Array [3, 4, 5, 4, 5]\n\n// 对于没有部署TypedArray的copyWithin方法的平台\n// 需要采用下面的写法\n[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);\n// Int32Array [4, 2, 3, 4, 5]\n```\n\n## 数组的空位\n\n数组的空位指，数组的某一个位置没有任何值。比如，`Array`构造函数返回的数组都是空位。\n\n```javascript\nArray(3) // [, , ,]\n```\n\n上面代码中，`Array(3)`返回一个具有3个空位的数组。\n\n注意，空位不是`undefined`，一个位置的值等于`undefined`，依然是有值的。空位是没有任何值，`in`运算符可以说明这一点。\n\n```javascript\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n```\n\n上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。\n\nES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。\n\n- `forEach()`, `filter()`, `every()` 和`some()`都会跳过空位。\n- `map()`会跳过空位，但会保留这个值\n- `join()`和`toString()`会将空位视为`undefined`，而`undefined`和`null`会被处理成空字符串。\n\n```javascript\n// forEach方法\n[,'a'].forEach((x,i) => console.log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a##\"\n\n// toString方法\n[,'a',undefined,null].toString() // \",a,,\"\n```\n\nES6则是明确将空位转为`undefined`。\n\n`Array.from`方法会将数组的空位，转为`undefined`，也就是说，这个方法不会忽略空位。\n\n```javascript\nArray.from(['a',,'b'])\n// [ \"a\", undefined, \"b\" ]\n```\n\n扩展运算符（`...`）也会将空位转为`undefined`。\n\n```javascript\n[...['a',,'b']]\n// [ \"a\", undefined, \"b\" ]\n```\n\n`copyWithin()`会连空位一起拷贝。\n\n```javascript\n[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]\n```\n\n`fill()`会将空位视为正常的数组位置。\n\n```javascript\nnew Array(3).fill('a') // [\"a\",\"a\",\"a\"]\n```\n\n`for...of`循环也会遍历空位。\n\n```javascript\nlet arr = [, ,];\nfor (let i of arr) {\n  console.log(1);\n}\n// 1\n// 1\n```\n\n上面代码中，数组`arr`有两个空位，`for...of`并没有忽略它们。如果改成`map`方法遍历，空位是会跳过的。\n\n`entries()`、`keys()`、`values()`、`find()`和`findIndex()`会将空位处理成`undefined`。\n\n```javascript\n// entries()\n[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]\n\n// keys()\n[...[,'a'].keys()] // [0,1]\n\n// values()\n[...[,'a'].values()] // [undefined,\"a\"]\n\n// find()\n[,'a'].find(x => true) // undefined\n\n// findIndex()\n[,'a'].findIndex(x => true) // 0\n```\n\n由于空位的处理规则非常不统一，所以建议避免出现空位。\n\n","slug":"ES2015中的数组扩展","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfba0001zk4oskurn0dr","content":"<h2 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h2><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>\n<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</div><div class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</div><div class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</div><div class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</div><div class=\"line\">    <span class=\"attr\">length</span>: <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [].slice.call(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></div></pre></td></tr></table></figure>\n<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NodeList对象</span></div><div class=\"line\"><span class=\"keyword\">let</span> ps = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'p'</span>);</div><div class=\"line\"><span class=\"built_in\">Array</span>.from(ps).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(p);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// arguments对象</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用<code>forEach</code>方法。</p>\n<p>只要是部署了Iterator接口的数据结构，<code>Array.from</code>都能将其转为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"string\">'hello'</span>)</div><div class=\"line\"><span class=\"comment\">// ['h', 'e', 'l', 'l', 'o']</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> namesSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>])</div><div class=\"line\"><span class=\"built_in\">Array</span>.from(namesSet) <span class=\"comment\">// ['a', 'b']</span></div></pre></td></tr></table></figure>\n<p>上面代码中，字符串和Set结构都具有Iterator接口，因此可以被<code>Array.from</code>转为真正的数组。</p>\n<p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组。深复制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"comment\">// [1, 2, 3]</span></div></pre></td></tr></table></figure>\n<p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// arguments对象</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> args = [...arguments];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// NodeList对象</span></div><div class=\"line\">[...document.querySelectorAll(<span class=\"string\">'div'</span>)]</div></pre></td></tr></table></figure>\n<p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<code>Array.from</code>方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(&#123; <span class=\"attr\">length</span>: <span class=\"number\">3</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// [ undefined, undefined, undefined ]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。</p>\n<p>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> toArray = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span></div><div class=\"line\">  <span class=\"built_in\">Array</span>.from ? <span class=\"built_in\">Array</span>.from : <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> [].slice.call(obj)</div><div class=\"line\">)();</div></pre></td></tr></table></figure>\n<p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike, x =&gt; x * x);</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike).map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (x) =&gt; x * x)</div><div class=\"line\"><span class=\"comment\">// [1, 4, 9]</span></div></pre></td></tr></table></figure>\n<p>下面的例子是取出一组DOM节点的文本内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> spans = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'span.name'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// map()</span></div><div class=\"line\"><span class=\"keyword\">let</span> names1 = <span class=\"built_in\">Array</span>.prototype.map.call(spans, s =&gt; s.textContent);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Array.from()</span></div><div class=\"line\"><span class=\"keyword\">let</span> names2 = <span class=\"built_in\">Array</span>.from(spans, s =&gt; s.textContent)</div></pre></td></tr></table></figure>\n<p>下面的例子将数组中布尔值为<code>false</code>的成员转为<code>0</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, , <span class=\"number\">2</span>, , <span class=\"number\">3</span>], (n) =&gt; n || <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"comment\">// [1, 0, 2, 0, 3]</span></div></pre></td></tr></table></figure>\n<p>另一个例子是返回各种数据的类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">typesOf</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>, value =&gt; <span class=\"keyword\">typeof</span> value)</div><div class=\"line\">&#125;</div><div class=\"line\">typesOf(<span class=\"literal\">null</span>, [], <span class=\"literal\">NaN</span>)</div><div class=\"line\"><span class=\"comment\">// ['object', 'object', 'number']</span></div></pre></td></tr></table></figure>\n<p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>。</p>\n<p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(&#123; <span class=\"attr\">length</span>: <span class=\"number\">2</span> &#125;, () =&gt; <span class=\"string\">'jack'</span>)</div><div class=\"line\"><span class=\"comment\">// ['jack', 'jack']</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Array.from</code>的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>\n<p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于<code>\\uFFFF</code>的Unicode字符，算作两个字符的bug。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countSymbols</span>(<span class=\"params\">string</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(string).length;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h2><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3,11,8]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>) <span class=\"comment\">// [3]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>).length <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>() <span class=\"comment\">// []</span></div><div class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3, 11, 8]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>\n<p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.of() <span class=\"comment\">// []</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"literal\">undefined</span>) <span class=\"comment\">// [undefined]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>) <span class=\"comment\">// [1]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// [1, 2]</span></div></pre></td></tr></table></figure>\n<p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>\n<p><code>Array.of</code>方法可以用下面的代码模拟实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ArrayOf</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [].slice.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"数组实例的find-和findIndex\"><a href=\"#数组实例的find-和findIndex\" class=\"headerlink\" title=\"数组实例的find()和findIndex()\"></a>数组实例的find()和findIndex()</h2><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">-5</span>, <span class=\"number\">10</span>].find(<span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> n &lt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"comment\">// -5</span></div></pre></td></tr></table></figure>\n<p>上面代码找出数组中第一个小于0的成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> value &gt; <span class=\"number\">9</span>;</div><div class=\"line\">&#125;) <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>\n<p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].findIndex(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> value &gt; <span class=\"number\">9</span>;</div><div class=\"line\">&#125;) <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>\n<p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>IndexOf</code>方法的不足。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"literal\">NaN</span>].indexOf(<span class=\"literal\">NaN</span>)</div><div class=\"line\"><span class=\"comment\">// -1</span></div><div class=\"line\"></div><div class=\"line\">[<span class=\"literal\">NaN</span>].findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, y))</div><div class=\"line\"><span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p>\n<h2 id=\"数组实例的fill\"><a href=\"#数组实例的fill\" class=\"headerlink\" title=\"数组实例的fill()\"></a>数组实例的fill()</h2><p><code>fill</code>方法使用给定值，填充一个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></div></pre></td></tr></table></figure>\n<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>\n<p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">// ['a', 7, 'c']</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，<code>fill</code>方法从1号位开始，向原数组填充7，到2号位之前结束。</p>\n<h2 id=\"数组实例的entries-，keys-和values\"><a href=\"#数组实例的entries-，keys-和values\" class=\"headerlink\" title=\"数组实例的entries()，keys()和values()\"></a>数组实例的entries()，keys()和values()</h2><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].keys()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(index);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> elem <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].values()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(elem);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 'a'</span></div><div class=\"line\"><span class=\"comment\">// 'b'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, elem] <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].entries()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(index, elem);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 0 \"a\"</span></div><div class=\"line\"><span class=\"comment\">// 1 \"b\"</span></div></pre></td></tr></table></figure>\n<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> letter = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> entries = letter.entries();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(entries.next().value); <span class=\"comment\">// [0, 'a']</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(entries.next().value); <span class=\"comment\">// [1, 'b']</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(entries.next().value); <span class=\"comment\">// [2, 'c']</span></div></pre></td></tr></table></figure>\n<p><strong>Array.values()目前chrome/ff等浏览器均未支持！</strong>循环时直接使用<code>for(let i of arr)</code>就可以了</p>\n<h2 id=\"数组实例的includes\"><a href=\"#数组实例的includes\" class=\"headerlink\" title=\"数组实例的includes()\"></a>数组实例的includes()</h2><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但Babel转码器已经支持。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">2</span>);     <span class=\"comment\">// true</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">4</span>);     <span class=\"comment\">// false</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">NaN</span>].includes(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// false</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">-1</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (arr.indexOf(el) !== <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对<code>NaN</code>的误判。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"literal\">NaN</span>].indexOf(<span class=\"literal\">NaN</span>)</div><div class=\"line\"><span class=\"comment\">// -1</span></div></pre></td></tr></table></figure>\n<p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"literal\">NaN</span>].includes(<span class=\"literal\">NaN</span>)</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> contains = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span></div><div class=\"line\">  <span class=\"built_in\">Array</span>.prototype.includes</div><div class=\"line\">    ? <span class=\"function\">(<span class=\"params\">arr, value</span>) =&gt;</span> arr.includes(value)</div><div class=\"line\">    : <span class=\"function\">(<span class=\"params\">arr, value</span>) =&gt;</span> arr.some(<span class=\"function\"><span class=\"params\">el</span> =&gt;</span> el === value)</div><div class=\"line\">)();</div><div class=\"line\">contains([<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>], <span class=\"string\">\"baz\"</span>); <span class=\"comment\">// =&gt; false</span></div></pre></td></tr></table></figure>\n<p>另外，Map和Set数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>\n<ul>\n<li>Map结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>\n<li>Set结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>\n</ul>\n<h2 id=\"数组实例的copyWithin\"><a href=\"#数组实例的copyWithin\" class=\"headerlink\" title=\"数组实例的copyWithin()\"></a>数组实例的copyWithin()</h2><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.prototype.copyWithin(target, start = <span class=\"number\">0</span>, end = <span class=\"keyword\">this</span>.length)</div></pre></td></tr></table></figure>\n<p>它接受三个参数。</p>\n<ul>\n<li>target（必需）：从该位置开始替换数据。</li>\n<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>\n<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>\n</ul>\n<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>\n<p>下面是更多例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将3号位复制到0号位</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</div><div class=\"line\"><span class=\"comment\">// [4, 2, 3, 4, 5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// -2相当于3号位，-1相当于4号位</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-1</span>)</div><div class=\"line\"><span class=\"comment\">// [4, 2, 3, 4, 5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将3号位复制到0号位</span></div><div class=\"line\">[].copyWithin.call(&#123;<span class=\"attr\">length</span>: <span class=\"number\">5</span>, <span class=\"number\">3</span>: <span class=\"number\">1</span>&#125;, <span class=\"number\">0</span>, <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// &#123;0: 1, 3: 1, length: 5&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将2号位到数组结束，复制到0号位</span></div><div class=\"line\"><span class=\"keyword\">var</span> i32a = <span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</div><div class=\"line\">i32a.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">// Int32Array [3, 4, 5, 4, 5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对于没有部署TypedArray的copyWithin方法的平台</span></div><div class=\"line\"><span class=\"comment\">// 需要采用下面的写法</span></div><div class=\"line\">[].copyWithin.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]), <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</div><div class=\"line\"><span class=\"comment\">// Int32Array [4, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<h2 id=\"数组的空位\"><a href=\"#数组的空位\" class=\"headerlink\" title=\"数组的空位\"></a>数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Array(3)</code>返回一个具有3个空位的数组。</p>\n<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>] <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [, , ,] <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。</p>\n<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>\n<ul>\n<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>\n<li><code>map()</code>会跳过空位，但会保留这个值</li>\n<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// forEach方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].forEach(<span class=\"function\">(<span class=\"params\">x,i</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(i)); <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// filter方法</span></div><div class=\"line\">[<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"literal\">true</span>) <span class=\"comment\">// ['a','b']</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// every方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].every(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x===<span class=\"string\">'a'</span>) <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// some方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].some(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x !== <span class=\"string\">'a'</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// map方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"number\">1</span>) <span class=\"comment\">// [,1]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// join方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"literal\">undefined</span>,<span class=\"literal\">null</span>].join(<span class=\"string\">'#'</span>) <span class=\"comment\">// \"#a##\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// toString方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"literal\">undefined</span>,<span class=\"literal\">null</span>].toString() <span class=\"comment\">// \",a,,\"</span></div></pre></td></tr></table></figure>\n<p>ES6则是明确将空位转为<code>undefined</code>。</p>\n<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>])</div><div class=\"line\"><span class=\"comment\">// [ \"a\", undefined, \"b\" ]</span></div></pre></td></tr></table></figure>\n<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...[<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>]]</div><div class=\"line\"><span class=\"comment\">// [ \"a\", undefined, \"b\" ]</span></div></pre></td></tr></table></figure>\n<p><code>copyWithin()</code>会连空位一起拷贝。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,,].copyWithin(<span class=\"number\">2</span>,<span class=\"number\">0</span>) <span class=\"comment\">// [,\"a\",,\"a\"]</span></div></pre></td></tr></table></figure>\n<p><code>fill()</code>会将空位视为正常的数组位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"string\">'a'</span>) <span class=\"comment\">// [\"a\",\"a\",\"a\"]</span></div></pre></td></tr></table></figure>\n<p><code>for...of</code>循环也会遍历空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr = [, ,];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>\n<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// entries()</span></div><div class=\"line\">[...[,<span class=\"string\">'a'</span>].entries()] <span class=\"comment\">// [[0,undefined], [1,\"a\"]]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// keys()</span></div><div class=\"line\">[...[,<span class=\"string\">'a'</span>].keys()] <span class=\"comment\">// [0,1]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// values()</span></div><div class=\"line\">[...[,<span class=\"string\">'a'</span>].values()] <span class=\"comment\">// [undefined,\"a\"]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// find()</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].find(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"literal\">true</span>) <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// findIndex()</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].findIndex(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"literal\">true</span>) <span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h2><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>\n<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</div><div class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</div><div class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</div><div class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</div><div class=\"line\">    <span class=\"attr\">length</span>: <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [].slice.call(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></div></pre></td></tr></table></figure>\n<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// NodeList对象</span></div><div class=\"line\"><span class=\"keyword\">let</span> ps = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'p'</span>);</div><div class=\"line\"><span class=\"built_in\">Array</span>.from(ps).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(p);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// arguments对象</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用<code>forEach</code>方法。</p>\n<p>只要是部署了Iterator接口的数据结构，<code>Array.from</code>都能将其转为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"string\">'hello'</span>)</div><div class=\"line\"><span class=\"comment\">// ['h', 'e', 'l', 'l', 'o']</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> namesSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>])</div><div class=\"line\"><span class=\"built_in\">Array</span>.from(namesSet) <span class=\"comment\">// ['a', 'b']</span></div></pre></td></tr></table></figure>\n<p>上面代码中，字符串和Set结构都具有Iterator接口，因此可以被<code>Array.from</code>转为真正的数组。</p>\n<p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组。深复制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"comment\">// [1, 2, 3]</span></div></pre></td></tr></table></figure>\n<p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// arguments对象</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> args = [...arguments];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// NodeList对象</span></div><div class=\"line\">[...document.querySelectorAll(<span class=\"string\">'div'</span>)]</div></pre></td></tr></table></figure>\n<p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<code>Array.from</code>方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(&#123; <span class=\"attr\">length</span>: <span class=\"number\">3</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// [ undefined, undefined, undefined ]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。</p>\n<p>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> toArray = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span></div><div class=\"line\">  <span class=\"built_in\">Array</span>.from ? <span class=\"built_in\">Array</span>.from : <span class=\"function\"><span class=\"params\">obj</span> =&gt;</span> [].slice.call(obj)</div><div class=\"line\">)();</div></pre></td></tr></table></figure>\n<p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike, x =&gt; x * x);</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike).map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (x) =&gt; x * x)</div><div class=\"line\"><span class=\"comment\">// [1, 4, 9]</span></div></pre></td></tr></table></figure>\n<p>下面的例子是取出一组DOM节点的文本内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> spans = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'span.name'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// map()</span></div><div class=\"line\"><span class=\"keyword\">let</span> names1 = <span class=\"built_in\">Array</span>.prototype.map.call(spans, s =&gt; s.textContent);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Array.from()</span></div><div class=\"line\"><span class=\"keyword\">let</span> names2 = <span class=\"built_in\">Array</span>.from(spans, s =&gt; s.textContent)</div></pre></td></tr></table></figure>\n<p>下面的例子将数组中布尔值为<code>false</code>的成员转为<code>0</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, , <span class=\"number\">2</span>, , <span class=\"number\">3</span>], (n) =&gt; n || <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"comment\">// [1, 0, 2, 0, 3]</span></div></pre></td></tr></table></figure>\n<p>另一个例子是返回各种数据的类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">typesOf</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>, value =&gt; <span class=\"keyword\">typeof</span> value)</div><div class=\"line\">&#125;</div><div class=\"line\">typesOf(<span class=\"literal\">null</span>, [], <span class=\"literal\">NaN</span>)</div><div class=\"line\"><span class=\"comment\">// ['object', 'object', 'number']</span></div></pre></td></tr></table></figure>\n<p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>。</p>\n<p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from(&#123; <span class=\"attr\">length</span>: <span class=\"number\">2</span> &#125;, () =&gt; <span class=\"string\">'jack'</span>)</div><div class=\"line\"><span class=\"comment\">// ['jack', 'jack']</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Array.from</code>的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>\n<p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于<code>\\uFFFF</code>的Unicode字符，算作两个字符的bug。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countSymbols</span>(<span class=\"params\">string</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(string).length;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<h2 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h2><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3,11,8]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>) <span class=\"comment\">// [3]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>).length <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>() <span class=\"comment\">// []</span></div><div class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3, 11, 8]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Array</code>方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，<code>Array()</code>才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>\n<p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.of() <span class=\"comment\">// []</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"literal\">undefined</span>) <span class=\"comment\">// [undefined]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>) <span class=\"comment\">// [1]</span></div><div class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// [1, 2]</span></div></pre></td></tr></table></figure>\n<p><code>Array.of</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>\n<p><code>Array.of</code>方法可以用下面的代码模拟实现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ArrayOf</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [].slice.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"数组实例的find-和findIndex\"><a href=\"#数组实例的find-和findIndex\" class=\"headerlink\" title=\"数组实例的find()和findIndex()\"></a>数组实例的find()和findIndex()</h2><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">-5</span>, <span class=\"number\">10</span>].find(<span class=\"function\">(<span class=\"params\">n</span>) =&gt;</span> n &lt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"comment\">// -5</span></div></pre></td></tr></table></figure>\n<p>上面代码找出数组中第一个小于0的成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> value &gt; <span class=\"number\">9</span>;</div><div class=\"line\">&#125;) <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>\n<p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].findIndex(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> value &gt; <span class=\"number\">9</span>;</div><div class=\"line\">&#125;) <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>\n<p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>IndexOf</code>方法的不足。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"literal\">NaN</span>].indexOf(<span class=\"literal\">NaN</span>)</div><div class=\"line\"><span class=\"comment\">// -1</span></div><div class=\"line\"></div><div class=\"line\">[<span class=\"literal\">NaN</span>].findIndex(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, y))</div><div class=\"line\"><span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p>\n<h2 id=\"数组实例的fill\"><a href=\"#数组实例的fill\" class=\"headerlink\" title=\"数组实例的fill()\"></a>数组实例的fill()</h2><p><code>fill</code>方法使用给定值，填充一个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></div></pre></td></tr></table></figure>\n<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>\n<p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">// ['a', 7, 'c']</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，<code>fill</code>方法从1号位开始，向原数组填充7，到2号位之前结束。</p>\n<h2 id=\"数组实例的entries-，keys-和values\"><a href=\"#数组实例的entries-，keys-和values\" class=\"headerlink\" title=\"数组实例的entries()，keys()和values()\"></a>数组实例的entries()，keys()和values()</h2><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].keys()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(index);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> elem <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].values()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(elem);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 'a'</span></div><div class=\"line\"><span class=\"comment\">// 'b'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, elem] <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].entries()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(index, elem);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 0 \"a\"</span></div><div class=\"line\"><span class=\"comment\">// 1 \"b\"</span></div></pre></td></tr></table></figure>\n<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> letter = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> entries = letter.entries();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(entries.next().value); <span class=\"comment\">// [0, 'a']</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(entries.next().value); <span class=\"comment\">// [1, 'b']</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(entries.next().value); <span class=\"comment\">// [2, 'c']</span></div></pre></td></tr></table></figure>\n<p><strong>Array.values()目前chrome/ff等浏览器均未支持！</strong>循环时直接使用<code>for(let i of arr)</code>就可以了</p>\n<h2 id=\"数组实例的includes\"><a href=\"#数组实例的includes\" class=\"headerlink\" title=\"数组实例的includes()\"></a>数组实例的includes()</h2><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但Babel转码器已经支持。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">2</span>);     <span class=\"comment\">// true</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">4</span>);     <span class=\"comment\">// false</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">NaN</span>].includes(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// false</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">-1</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (arr.indexOf(el) !== <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对<code>NaN</code>的误判。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"literal\">NaN</span>].indexOf(<span class=\"literal\">NaN</span>)</div><div class=\"line\"><span class=\"comment\">// -1</span></div></pre></td></tr></table></figure>\n<p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"literal\">NaN</span>].includes(<span class=\"literal\">NaN</span>)</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> contains = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span></div><div class=\"line\">  <span class=\"built_in\">Array</span>.prototype.includes</div><div class=\"line\">    ? <span class=\"function\">(<span class=\"params\">arr, value</span>) =&gt;</span> arr.includes(value)</div><div class=\"line\">    : <span class=\"function\">(<span class=\"params\">arr, value</span>) =&gt;</span> arr.some(<span class=\"function\"><span class=\"params\">el</span> =&gt;</span> el === value)</div><div class=\"line\">)();</div><div class=\"line\">contains([<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>], <span class=\"string\">\"baz\"</span>); <span class=\"comment\">// =&gt; false</span></div></pre></td></tr></table></figure>\n<p>另外，Map和Set数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>\n<ul>\n<li>Map结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>\n<li>Set结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>\n</ul>\n<h2 id=\"数组实例的copyWithin\"><a href=\"#数组实例的copyWithin\" class=\"headerlink\" title=\"数组实例的copyWithin()\"></a>数组实例的copyWithin()</h2><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.prototype.copyWithin(target, start = <span class=\"number\">0</span>, end = <span class=\"keyword\">this</span>.length)</div></pre></td></tr></table></figure>\n<p>它接受三个参数。</p>\n<ul>\n<li>target（必需）：从该位置开始替换数据。</li>\n<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>\n<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>\n</ul>\n<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>\n<p>下面是更多例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将3号位复制到0号位</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</div><div class=\"line\"><span class=\"comment\">// [4, 2, 3, 4, 5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// -2相当于3号位，-1相当于4号位</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-1</span>)</div><div class=\"line\"><span class=\"comment\">// [4, 2, 3, 4, 5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将3号位复制到0号位</span></div><div class=\"line\">[].copyWithin.call(&#123;<span class=\"attr\">length</span>: <span class=\"number\">5</span>, <span class=\"number\">3</span>: <span class=\"number\">1</span>&#125;, <span class=\"number\">0</span>, <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// &#123;0: 1, 3: 1, length: 5&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将2号位到数组结束，复制到0号位</span></div><div class=\"line\"><span class=\"keyword\">var</span> i32a = <span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</div><div class=\"line\">i32a.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">// Int32Array [3, 4, 5, 4, 5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对于没有部署TypedArray的copyWithin方法的平台</span></div><div class=\"line\"><span class=\"comment\">// 需要采用下面的写法</span></div><div class=\"line\">[].copyWithin.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]), <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</div><div class=\"line\"><span class=\"comment\">// Int32Array [4, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>\n<h2 id=\"数组的空位\"><a href=\"#数组的空位\" class=\"headerlink\" title=\"数组的空位\"></a>数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Array(3)</code>返回一个具有3个空位的数组。</p>\n<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>] <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [, , ,] <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。</p>\n<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>\n<ul>\n<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>\n<li><code>map()</code>会跳过空位，但会保留这个值</li>\n<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// forEach方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].forEach(<span class=\"function\">(<span class=\"params\">x,i</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(i)); <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// filter方法</span></div><div class=\"line\">[<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"literal\">true</span>) <span class=\"comment\">// ['a','b']</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// every方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].every(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x===<span class=\"string\">'a'</span>) <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// some方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].some(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x !== <span class=\"string\">'a'</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// map方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"number\">1</span>) <span class=\"comment\">// [,1]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// join方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"literal\">undefined</span>,<span class=\"literal\">null</span>].join(<span class=\"string\">'#'</span>) <span class=\"comment\">// \"#a##\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// toString方法</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"literal\">undefined</span>,<span class=\"literal\">null</span>].toString() <span class=\"comment\">// \",a,,\"</span></div></pre></td></tr></table></figure>\n<p>ES6则是明确将空位转为<code>undefined</code>。</p>\n<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>])</div><div class=\"line\"><span class=\"comment\">// [ \"a\", undefined, \"b\" ]</span></div></pre></td></tr></table></figure>\n<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...[<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>]]</div><div class=\"line\"><span class=\"comment\">// [ \"a\", undefined, \"b\" ]</span></div></pre></td></tr></table></figure>\n<p><code>copyWithin()</code>会连空位一起拷贝。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,,].copyWithin(<span class=\"number\">2</span>,<span class=\"number\">0</span>) <span class=\"comment\">// [,\"a\",,\"a\"]</span></div></pre></td></tr></table></figure>\n<p><code>fill()</code>会将空位视为正常的数组位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"string\">'a'</span>) <span class=\"comment\">// [\"a\",\"a\",\"a\"]</span></div></pre></td></tr></table></figure>\n<p><code>for...of</code>循环也会遍历空位。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr = [, ,];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>\n<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// entries()</span></div><div class=\"line\">[...[,<span class=\"string\">'a'</span>].entries()] <span class=\"comment\">// [[0,undefined], [1,\"a\"]]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// keys()</span></div><div class=\"line\">[...[,<span class=\"string\">'a'</span>].keys()] <span class=\"comment\">// [0,1]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// values()</span></div><div class=\"line\">[...[,<span class=\"string\">'a'</span>].values()] <span class=\"comment\">// [undefined,\"a\"]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// find()</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].find(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"literal\">true</span>) <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// findIndex()</span></div><div class=\"line\">[,<span class=\"string\">'a'</span>].findIndex(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"literal\">true</span>) <span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>"},{"title":"ES2015中的解构","date":"2016-10-30T15:37:17.000Z","_content":">  数组/对象/字符串都可以进行解构，尤其是对Json格式的返回值。\n解构可以进行嵌套，赋默认值(和 undefined 进行‘===’严格比较)。\n奇奇怪怪的用法就忽略吧...\n\n## 数组的解构赋值\n\n### 基本用法\n\nES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\n\n以前，为变量赋值，只能直接指定值。\n\n```javascript\nvar a = 1;\nvar b = 2;\nvar c = 3;\n```\n\nES6允许写成下面这样。\n\n```javascript\nvar [a, b, c] = [1, 2, 3];\n```\n\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\n\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\n\n```javascript\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n```\n\n如果解构不成功，变量的值就等于`undefined`。\n\n```javascript\nvar [foo] = [];\nvar [bar, foo] = [1];\n```\n\n以上两种情况都属于解构不成功，`foo`的值都会等于`undefined`。\n\n另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\n\n```javascript\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n```\n\n上面两个例子，都属于不完全解构，但是可以成功。\n\n如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。\n\n```javascript\n// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n```\n\n上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。\n\n解构赋值不仅适用于var命令，也适用于let和const命令。\n\n```javascript\nvar [v1, v2, ..., vN ] = array;\nlet [v1, v2, ..., vN ] = array;\nconst [v1, v2, ..., vN ] = array;\n```\n\n对于Set结构，也可以使用数组的解构赋值。\n\n```javascript\nlet [x, y, z] = new Set([\"a\", \"b\", \"c\"]);\nx // \"a\"\n```\n\n事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。\n\n```javascript\nfunction* fibs() {\n  var a = 0;\n  var b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nvar [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n```\n\n上面代码中，`fibs`是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。\n<!--more-->\n### 默认值\n\n解构赋值允许指定默认值。\n\n```javascript\nvar [foo = true] = [];\nfoo // true\n\n[x, y = 'b'] = ['a']; // x='a', y='b'\n[x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n```\n\n注意，ES6内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，如果一个数组成员不严格等于`undefined`，默认值是不会生效的。\n\n```javascript\nvar [x = 1] = [undefined];\nx // 1\n\nvar [x = 1] = [null];\nx // null\n```\n\n上面代码中，如果一个数组成员是`null`，默认值就不会生效，因为`null`不严格等于`undefined`。\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。\n\n```javascript\nfunction f() {\n  console.log('aaa');\n}\n\nlet [x = f()] = [1];\n```\n\n上面代码中，因为`x`能取到值，所以函数`f`根本不会执行。上面的代码其实等价于下面的代码。\n\n```javascript\nlet x;\nif ([1][0] === undefined) {\n  x = f();\n} else {\n  x = [1][0];\n}\n```\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n\n```javascript\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError\n```\n\n上面最后一个表达式之所以会报错，是因为`x`用到默认值`y`时，`y`还没有声明。\n\n## 对象的解构赋值\n\n解构不仅可以用于数组，还可以用于对象。\n\n```javascript\nvar { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n```\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\n```javascript\nvar { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nvar { baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // undefined\n```\n\n上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于`undefined`。\n\n如果变量名与属性名不一致，必须写成下面这样。\n\n```javascript\nvar { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n```\n\n这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。\n\n```javascript\nvar { foo: foo, bar: bar } = { foo: \"aaa\", bar: \"bbb\" };\n```\n\n也就是说，**对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者**。\n\n```javascript\nvar { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n```\n\n上面代码中，真正被赋值的是变量`baz`，而不是模式`foo`。\n\n注意，采用这种写法时，变量的声明和赋值是一体的。对于`let`和`const`来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。\n\n```javascript\nlet foo;\nlet {foo} = {foo: 1}; // SyntaxError: Duplicate declaration \"foo\"\n\nlet baz;\nlet {bar: baz} = {bar: 1}; // SyntaxError: Duplicate declaration \"baz\"\n```\n\n上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为`var`命令允许重新声明，所以这个错误只会在使用`let`和`const`命令时出现。如果没有第二个`let`命令，上面的代码就不会报错。\n\n```javascript\nlet foo;\n({foo} = {foo: 1}); // 成功\n\nlet baz;\n({bar: baz} = {bar: 1}); // 成功\n```\n\n上面代码中，`let`命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。\n\n和数组一样，解构也可以用于嵌套结构的对象。\n\n```javascript\nvar obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nvar { p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\n```\n\n注意，这时`p`是模式，不是变量，因此不会被赋值。\n\n```javascript\nvar node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nvar { loc: { start: { line }} } = node;\nline // 1\nloc  // error: loc is undefined\nstart // error: start is undefined\n```\n\n上面代码中，只有`line`是变量，`loc`和`start`都是模式，不会被赋值。\n\n下面是嵌套赋值的例子。\n\n```javascript\nlet obj = {};\nlet arr = [];\n\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\n\nobj // {prop:123}\narr // [true]\n```\n\n对象的解构也可以指定默认值。\n\n```javascript\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x:y = 3} = {};\ny // 3\n\nvar {x:y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"\n```\n\n默认值生效的条件是，对象的属性值严格等于`undefined`。\n\n```javascript\nvar {x = 3} = {x: undefined};\nx // 3\n\nvar {x = 3} = {x: null};\nx // null\n```\n\n上面代码中，如果`x`属性等于`null`，就不严格相等于`undefined`，导致默认值不会生效。\n\n如果解构失败，变量的值等于`undefined`。\n\n```javascript\nvar {foo} = {bar: 'baz'};\nfoo // undefined\n```\n\n如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。\n\n```javascript\n// 报错\nvar {foo: {bar}} = {baz: 'baz'};\n```\n\n上面代码中，等号左边对象的`foo`属性，对应一个子对象。该子对象的`bar`属性，解构时会报错。原因很简单，因为`foo`这时等于`undefined`，再取子属性就会报错，请看下面的代码。\n\n```javascript\nvar _tmp = {baz: 'baz'};\n_tmp.foo.bar // 报错\n```\n\n如果要将一个已经声明的变量用于解构赋值，必须非常小心。\n\n```javascript\n// 错误的写法\nvar x;\n{x} = {x: 1};\n// SyntaxError: syntax error\n```\n\n上面代码的写法会报错，因为JavaScript引擎会将`{x}`理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。\n\n```javascript\n// 正确的写法\n({x} = {x: 1});\n```\n对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。\n\n```javascript\nlet { log, sin, cos } = Math;\n```\n\n上面代码将`Math`对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。\n\n由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\n\n```javascript\nvar arr = [1, 2, 3];\nvar {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3\n```\n\n上面代码对数组进行对象解构。数组`arr`的`0`键对应的值是`1`，`[arr.length - 1]`就是`2`键，对应的值是`3`。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。\n\n## 字符串的解构赋值\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。\n\n```javascript\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值。\n\n```javascript\nlet {length : len} = 'hello';\nlen // 5\n```\n\n## 函数参数的解构赋值\n\n函数的参数也可以使用解构赋值。\n\n```javascript\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n```\n\n上面代码中，函数`add`的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量`x`和`y`。对于函数内部的代码来说，它们能感受到的参数就是`x`和`y`。\n\n下面是另一个例子。\n\n```javascript\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [ 3, 7 ]\n```\n`undefined`就会触发函数参数的默认值。\n\n```javascript\n[1, undefined, 3].map((x = 'yes') => x);\n// [ 1, 'yes', 3 ]\n```\n\n## 圆括号问题\n\n解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。\n\n由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。\n\n但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。\n\n### 不能使用圆括号的情况\n\n以下三种解构赋值不得使用圆括号。\n\n（1）变量声明语句中，不能带有圆括号。\n\n```javascript\n// 全部报错\nvar [(a)] = [1];\n\nvar {x: (c)} = {};\nvar ({x: c}) = {};\nvar {(x: c)} = {};\nvar {(x): c} = {};\n\nvar { o: ({ p: p }) } = { o: { p: 2 } };\n```\n\n上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。\n\n（2）函数参数中，模式不能带有圆括号。\n\n函数参数也属于变量声明，因此不能带有圆括号。\n\n```javascript\n// 报错\nfunction f([(z)]) { return z; }\n```\n\n（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。\n\n```javascript\n// 全部报错\n({ p: a }) = { p: 42 };\n([a]) = [5];\n```\n\n上面代码将整个模式放在圆括号之中，导致报错。\n\n```javascript\n// 报错\n[({ p: a }), { x: c }] = [{}, {}];\n```\n\n上面代码将嵌套模式的一层，放在圆括号之中，导致报错。\n\n### 可以使用圆括号的情况\n\n可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\n\n```javascript\n[(b)] = [3]; // 正确\n({ p: (d) } = {}); // 正确\n[(parseInt.prop)] = [3]; // 正确\n```\n\n上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。\n\n## 用途\n\n变量的解构赋值用途很多。\n\n**（1）交换变量的值**\n\n```javascript\n[x, y] = [y, x];\n```\n\n上面代码交换变量`x`和`y`的值，这样的写法不仅简洁，而且易读，语义非常清晰。\n\n**（2）从函数返回多个值**\n\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\n\n```javascript\n// 返回一个数组\n\nfunction example() {\n  return [1, 2, 3];\n}\nvar [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nvar { foo, bar } = example();\n```\n\n**（3）函数参数的定义**\n\n解构赋值可以方便地将一组参数与变量名对应起来。\n\n```javascript\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n```\n\n**（4）提取JSON数据**\n\n解构赋值对提取JSON对象中的数据，尤其有用。\n\n```javascript\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n\n上面代码可以快速提取JSON数据的值。\n\n**（5）函数参数的默认值**\n\n```javascript\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n}) {\n  // ... do stuff\n};\n```\n\n指定参数的默认值，就避免了在函数体内部再写`var foo = config.foo || 'default foo';`这样的语句。\n\n**（6）遍历Map结构**\n\n任何部署了Iterator接口的对象，都可以用`for...of`循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。\n\n```javascript\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n```\n\n如果只想获取键名，或者只想获取键值，可以写成下面这样。\n\n```javascript\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n```\n\n**（7）输入模块的指定方法**\n\n加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。\n\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n\n","source":"_posts/ES2015中的解构.md","raw":"---\ntitle: ES2015中的解构\ndate: 2016-10-30 23:37:17\ntags: ES2015\n---\n>  数组/对象/字符串都可以进行解构，尤其是对Json格式的返回值。\n解构可以进行嵌套，赋默认值(和 undefined 进行‘===’严格比较)。\n奇奇怪怪的用法就忽略吧...\n\n## 数组的解构赋值\n\n### 基本用法\n\nES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\n\n以前，为变量赋值，只能直接指定值。\n\n```javascript\nvar a = 1;\nvar b = 2;\nvar c = 3;\n```\n\nES6允许写成下面这样。\n\n```javascript\nvar [a, b, c] = [1, 2, 3];\n```\n\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\n\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\n\n```javascript\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n```\n\n如果解构不成功，变量的值就等于`undefined`。\n\n```javascript\nvar [foo] = [];\nvar [bar, foo] = [1];\n```\n\n以上两种情况都属于解构不成功，`foo`的值都会等于`undefined`。\n\n另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。\n\n```javascript\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n```\n\n上面两个例子，都属于不完全解构，但是可以成功。\n\n如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。\n\n```javascript\n// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n```\n\n上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。\n\n解构赋值不仅适用于var命令，也适用于let和const命令。\n\n```javascript\nvar [v1, v2, ..., vN ] = array;\nlet [v1, v2, ..., vN ] = array;\nconst [v1, v2, ..., vN ] = array;\n```\n\n对于Set结构，也可以使用数组的解构赋值。\n\n```javascript\nlet [x, y, z] = new Set([\"a\", \"b\", \"c\"]);\nx // \"a\"\n```\n\n事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。\n\n```javascript\nfunction* fibs() {\n  var a = 0;\n  var b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nvar [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n```\n\n上面代码中，`fibs`是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。\n<!--more-->\n### 默认值\n\n解构赋值允许指定默认值。\n\n```javascript\nvar [foo = true] = [];\nfoo // true\n\n[x, y = 'b'] = ['a']; // x='a', y='b'\n[x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n```\n\n注意，ES6内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，如果一个数组成员不严格等于`undefined`，默认值是不会生效的。\n\n```javascript\nvar [x = 1] = [undefined];\nx // 1\n\nvar [x = 1] = [null];\nx // null\n```\n\n上面代码中，如果一个数组成员是`null`，默认值就不会生效，因为`null`不严格等于`undefined`。\n\n如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。\n\n```javascript\nfunction f() {\n  console.log('aaa');\n}\n\nlet [x = f()] = [1];\n```\n\n上面代码中，因为`x`能取到值，所以函数`f`根本不会执行。上面的代码其实等价于下面的代码。\n\n```javascript\nlet x;\nif ([1][0] === undefined) {\n  x = f();\n} else {\n  x = [1][0];\n}\n```\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n\n```javascript\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError\n```\n\n上面最后一个表达式之所以会报错，是因为`x`用到默认值`y`时，`y`还没有声明。\n\n## 对象的解构赋值\n\n解构不仅可以用于数组，还可以用于对象。\n\n```javascript\nvar { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n```\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\n```javascript\nvar { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nvar { baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // undefined\n```\n\n上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于`undefined`。\n\n如果变量名与属性名不一致，必须写成下面这样。\n\n```javascript\nvar { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n```\n\n这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。\n\n```javascript\nvar { foo: foo, bar: bar } = { foo: \"aaa\", bar: \"bbb\" };\n```\n\n也就是说，**对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者**。\n\n```javascript\nvar { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n```\n\n上面代码中，真正被赋值的是变量`baz`，而不是模式`foo`。\n\n注意，采用这种写法时，变量的声明和赋值是一体的。对于`let`和`const`来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。\n\n```javascript\nlet foo;\nlet {foo} = {foo: 1}; // SyntaxError: Duplicate declaration \"foo\"\n\nlet baz;\nlet {bar: baz} = {bar: 1}; // SyntaxError: Duplicate declaration \"baz\"\n```\n\n上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为`var`命令允许重新声明，所以这个错误只会在使用`let`和`const`命令时出现。如果没有第二个`let`命令，上面的代码就不会报错。\n\n```javascript\nlet foo;\n({foo} = {foo: 1}); // 成功\n\nlet baz;\n({bar: baz} = {bar: 1}); // 成功\n```\n\n上面代码中，`let`命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。\n\n和数组一样，解构也可以用于嵌套结构的对象。\n\n```javascript\nvar obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nvar { p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\n```\n\n注意，这时`p`是模式，不是变量，因此不会被赋值。\n\n```javascript\nvar node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nvar { loc: { start: { line }} } = node;\nline // 1\nloc  // error: loc is undefined\nstart // error: start is undefined\n```\n\n上面代码中，只有`line`是变量，`loc`和`start`都是模式，不会被赋值。\n\n下面是嵌套赋值的例子。\n\n```javascript\nlet obj = {};\nlet arr = [];\n\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\n\nobj // {prop:123}\narr // [true]\n```\n\n对象的解构也可以指定默认值。\n\n```javascript\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x:y = 3} = {};\ny // 3\n\nvar {x:y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"\n```\n\n默认值生效的条件是，对象的属性值严格等于`undefined`。\n\n```javascript\nvar {x = 3} = {x: undefined};\nx // 3\n\nvar {x = 3} = {x: null};\nx // null\n```\n\n上面代码中，如果`x`属性等于`null`，就不严格相等于`undefined`，导致默认值不会生效。\n\n如果解构失败，变量的值等于`undefined`。\n\n```javascript\nvar {foo} = {bar: 'baz'};\nfoo // undefined\n```\n\n如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。\n\n```javascript\n// 报错\nvar {foo: {bar}} = {baz: 'baz'};\n```\n\n上面代码中，等号左边对象的`foo`属性，对应一个子对象。该子对象的`bar`属性，解构时会报错。原因很简单，因为`foo`这时等于`undefined`，再取子属性就会报错，请看下面的代码。\n\n```javascript\nvar _tmp = {baz: 'baz'};\n_tmp.foo.bar // 报错\n```\n\n如果要将一个已经声明的变量用于解构赋值，必须非常小心。\n\n```javascript\n// 错误的写法\nvar x;\n{x} = {x: 1};\n// SyntaxError: syntax error\n```\n\n上面代码的写法会报错，因为JavaScript引擎会将`{x}`理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。\n\n```javascript\n// 正确的写法\n({x} = {x: 1});\n```\n对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。\n\n```javascript\nlet { log, sin, cos } = Math;\n```\n\n上面代码将`Math`对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。\n\n由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。\n\n```javascript\nvar arr = [1, 2, 3];\nvar {0 : first, [arr.length - 1] : last} = arr;\nfirst // 1\nlast // 3\n```\n\n上面代码对数组进行对象解构。数组`arr`的`0`键对应的值是`1`，`[arr.length - 1]`就是`2`键，对应的值是`3`。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。\n\n## 字符串的解构赋值\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。\n\n```javascript\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n类似数组的对象都有一个`length`属性，因此还可以对这个属性解构赋值。\n\n```javascript\nlet {length : len} = 'hello';\nlen // 5\n```\n\n## 函数参数的解构赋值\n\n函数的参数也可以使用解构赋值。\n\n```javascript\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n```\n\n上面代码中，函数`add`的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量`x`和`y`。对于函数内部的代码来说，它们能感受到的参数就是`x`和`y`。\n\n下面是另一个例子。\n\n```javascript\n[[1, 2], [3, 4]].map(([a, b]) => a + b);\n// [ 3, 7 ]\n```\n`undefined`就会触发函数参数的默认值。\n\n```javascript\n[1, undefined, 3].map((x = 'yes') => x);\n// [ 1, 'yes', 3 ]\n```\n\n## 圆括号问题\n\n解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。\n\n由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。\n\n但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。\n\n### 不能使用圆括号的情况\n\n以下三种解构赋值不得使用圆括号。\n\n（1）变量声明语句中，不能带有圆括号。\n\n```javascript\n// 全部报错\nvar [(a)] = [1];\n\nvar {x: (c)} = {};\nvar ({x: c}) = {};\nvar {(x: c)} = {};\nvar {(x): c} = {};\n\nvar { o: ({ p: p }) } = { o: { p: 2 } };\n```\n\n上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。\n\n（2）函数参数中，模式不能带有圆括号。\n\n函数参数也属于变量声明，因此不能带有圆括号。\n\n```javascript\n// 报错\nfunction f([(z)]) { return z; }\n```\n\n（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。\n\n```javascript\n// 全部报错\n({ p: a }) = { p: 42 };\n([a]) = [5];\n```\n\n上面代码将整个模式放在圆括号之中，导致报错。\n\n```javascript\n// 报错\n[({ p: a }), { x: c }] = [{}, {}];\n```\n\n上面代码将嵌套模式的一层，放在圆括号之中，导致报错。\n\n### 可以使用圆括号的情况\n\n可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。\n\n```javascript\n[(b)] = [3]; // 正确\n({ p: (d) } = {}); // 正确\n[(parseInt.prop)] = [3]; // 正确\n```\n\n上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。\n\n## 用途\n\n变量的解构赋值用途很多。\n\n**（1）交换变量的值**\n\n```javascript\n[x, y] = [y, x];\n```\n\n上面代码交换变量`x`和`y`的值，这样的写法不仅简洁，而且易读，语义非常清晰。\n\n**（2）从函数返回多个值**\n\n函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。\n\n```javascript\n// 返回一个数组\n\nfunction example() {\n  return [1, 2, 3];\n}\nvar [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nvar { foo, bar } = example();\n```\n\n**（3）函数参数的定义**\n\n解构赋值可以方便地将一组参数与变量名对应起来。\n\n```javascript\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1});\n```\n\n**（4）提取JSON数据**\n\n解构赋值对提取JSON对象中的数据，尤其有用。\n\n```javascript\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n};\n\nlet { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number);\n// 42, \"OK\", [867, 5309]\n```\n\n上面代码可以快速提取JSON数据的值。\n\n**（5）函数参数的默认值**\n\n```javascript\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n}) {\n  // ... do stuff\n};\n```\n\n指定参数的默认值，就避免了在函数体内部再写`var foo = config.foo || 'default foo';`这样的语句。\n\n**（6）遍历Map结构**\n\n任何部署了Iterator接口的对象，都可以用`for...of`循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。\n\n```javascript\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n```\n\n如果只想获取键名，或者只想获取键值，可以写成下面这样。\n\n```javascript\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n```\n\n**（7）输入模块的指定方法**\n\n加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。\n\n```javascript\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n```\n\n\n","slug":"ES2015中的解构","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfbh0003zk4oykt5y2vz","content":"<blockquote>\n<p> 数组/对象/字符串都可以进行解构，尤其是对Json格式的返回值。<br>解构可以进行嵌套，赋默认值(和 undefined 进行‘===’严格比较)。<br>奇奇怪怪的用法就忽略吧…</p>\n</blockquote>\n<h2 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>\n<p>以前，为变量赋值，只能直接指定值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">3</span>;</div></pre></td></tr></table></figure>\n<p>ES6允许写成下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div></pre></td></tr></table></figure>\n<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>\n<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> [foo, [[bar], baz]] = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>], <span class=\"number\">3</span>]];</div><div class=\"line\">foo <span class=\"comment\">// 1</span></div><div class=\"line\">bar <span class=\"comment\">// 2</span></div><div class=\"line\">baz <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [ , , third] = [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>, <span class=\"string\">\"baz\"</span>];</div><div class=\"line\">third <span class=\"comment\">// \"baz\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [x, , y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">x <span class=\"comment\">// 1</span></div><div class=\"line\">y <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [head, ...tail] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</div><div class=\"line\">head <span class=\"comment\">// 1</span></div><div class=\"line\">tail <span class=\"comment\">// [2, 3, 4]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">'a'</span>];</div><div class=\"line\">x <span class=\"comment\">// \"a\"</span></div><div class=\"line\">y <span class=\"comment\">// undefined</span></div><div class=\"line\">z <span class=\"comment\">// []</span></div></pre></td></tr></table></figure>\n<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [foo] = [];</div><div class=\"line\"><span class=\"keyword\">var</span> [bar, foo] = [<span class=\"number\">1</span>];</div></pre></td></tr></table></figure>\n<p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p>\n<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> [x, y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">x <span class=\"comment\">// 1</span></div><div class=\"line\">y <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [a, [b], d] = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">4</span>];</div><div class=\"line\">a <span class=\"comment\">// 1</span></div><div class=\"line\">b <span class=\"comment\">// 2</span></div><div class=\"line\">d <span class=\"comment\">// 4</span></div></pre></td></tr></table></figure>\n<p>上面两个例子，都属于不完全解构，但是可以成功。</p>\n<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">false</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">NaN</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">undefined</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">null</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = &#123;&#125;;</div></pre></td></tr></table></figure>\n<p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p>\n<p>解构赋值不仅适用于var命令，也适用于let和const命令。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [v1, v2, ..., vN ] = array;</div><div class=\"line\"><span class=\"keyword\">let</span> [v1, v2, ..., vN ] = array;</div><div class=\"line\"><span class=\"keyword\">const</span> [v1, v2, ..., vN ] = array;</div></pre></td></tr></table></figure>\n<p>对于Set结构，也可以使用数组的解构赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> [x, y, z] = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>]);</div><div class=\"line\">x <span class=\"comment\">// \"a\"</span></div></pre></td></tr></table></figure>\n<p>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fibs</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> a;</div><div class=\"line\">    [a, b] = [b, a + b];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</div><div class=\"line\">sixth <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>fibs</code>是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。<br><a id=\"more\"></a></p>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p>解构赋值允许指定默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [foo = <span class=\"literal\">true</span>] = [];</div><div class=\"line\">foo <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\">[x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>]; <span class=\"comment\">// x='a', y='b'</span></div><div class=\"line\">[x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>, <span class=\"literal\">undefined</span>]; <span class=\"comment\">// x='a', y='b'</span></div></pre></td></tr></table></figure>\n<p>注意，ES6内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">undefined</span>];</div><div class=\"line\">x <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">null</span>];</div><div class=\"line\">x <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p>\n<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'aaa'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [x = f()] = [<span class=\"number\">1</span>];</div></pre></td></tr></table></figure>\n<p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x;</div><div class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"number\">1</span>][<span class=\"number\">0</span>] === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">  x = f();</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  x = [<span class=\"number\">1</span>][<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [];     <span class=\"comment\">// x=1; y=1</span></div><div class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [<span class=\"number\">2</span>];    <span class=\"comment\">// x=2; y=2</span></div><div class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]; <span class=\"comment\">// x=1; y=2</span></div><div class=\"line\"><span class=\"keyword\">let</span> [x = y, y = <span class=\"number\">1</span>] = [];     <span class=\"comment\">// ReferenceError</span></div></pre></td></tr></table></figure>\n<p>上面最后一个表达式之所以会报错，是因为<code>x</code>用到默认值<code>y</code>时，<code>y</code>还没有声明。</p>\n<h2 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h2><p>解构不仅可以用于数组，还可以用于对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; foo, bar &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div><div class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></div><div class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></div></pre></td></tr></table></figure>\n<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; bar, foo &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div><div class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></div><div class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div><div class=\"line\">baz <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p>\n<p>如果变量名与属性名不一致，必须写成下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">foo</span>: baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">bar</span>: <span class=\"string\">'bbb'</span> &#125;;</div><div class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">first</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">last</span>: <span class=\"string\">'world'</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">first</span>: f, <span class=\"attr\">last</span>: l &#125; = obj;</div><div class=\"line\">f <span class=\"comment\">// 'hello'</span></div><div class=\"line\">l <span class=\"comment\">// 'world'</span></div></pre></td></tr></table></figure>\n<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">foo</span>: foo, <span class=\"attr\">bar</span>: bar &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div></pre></td></tr></table></figure>\n<p>也就是说，<strong>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">foo</span>: baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div><div class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></div><div class=\"line\">foo <span class=\"comment\">// error: foo is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>\n<p>注意，采用这种写法时，变量的声明和赋值是一体的。对于<code>let</code>和<code>const</code>来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> foo;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123;foo&#125; = &#123;<span class=\"attr\">foo</span>: <span class=\"number\">1</span>&#125;; <span class=\"comment\">// SyntaxError: Duplicate declaration \"foo\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> baz;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">bar</span>: baz&#125; = &#123;<span class=\"attr\">bar</span>: <span class=\"number\">1</span>&#125;; <span class=\"comment\">// SyntaxError: Duplicate declaration \"baz\"</span></div></pre></td></tr></table></figure>\n<p>上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为<code>var</code>命令允许重新声明，所以这个错误只会在使用<code>let</code>和<code>const</code>命令时出现。如果没有第二个<code>let</code>命令，上面的代码就不会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> foo;</div><div class=\"line\">(&#123;foo&#125; = &#123;<span class=\"attr\">foo</span>: <span class=\"number\">1</span>&#125;); <span class=\"comment\">// 成功</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> baz;</div><div class=\"line\">(&#123;<span class=\"attr\">bar</span>: baz&#125; = &#123;<span class=\"attr\">bar</span>: <span class=\"number\">1</span>&#125;); <span class=\"comment\">// 成功</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>let</code>命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</p>\n<p>和数组一样，解构也可以用于嵌套结构的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">  <span class=\"attr\">p</span>: [</div><div class=\"line\">    <span class=\"string\">'Hello'</span>,</div><div class=\"line\">    &#123; <span class=\"attr\">y</span>: <span class=\"string\">'World'</span> &#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">p</span>: [x, &#123; y &#125;] &#125; = obj;</div><div class=\"line\">x <span class=\"comment\">// \"Hello\"</span></div><div class=\"line\">y <span class=\"comment\">// \"World\"</span></div></pre></td></tr></table></figure>\n<p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> node = &#123;</div><div class=\"line\">  <span class=\"attr\">loc</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">start</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">line</span>: <span class=\"number\">1</span>,</div><div class=\"line\">      <span class=\"attr\">column</span>: <span class=\"number\">5</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">loc</span>: &#123; <span class=\"attr\">start</span>: &#123; line &#125;&#125; &#125; = node;</div><div class=\"line\">line <span class=\"comment\">// 1</span></div><div class=\"line\">loc  <span class=\"comment\">// error: loc is undefined</span></div><div class=\"line\">start <span class=\"comment\">// error: start is undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不会被赋值。</p>\n<p>下面是嵌套赋值的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> arr = [];</div><div class=\"line\"></div><div class=\"line\">(&#123; <span class=\"attr\">foo</span>: obj.prop, <span class=\"attr\">bar</span>: arr[<span class=\"number\">0</span>] &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"number\">123</span>, <span class=\"attr\">bar</span>: <span class=\"literal\">true</span> &#125;);</div><div class=\"line\"></div><div class=\"line\">obj <span class=\"comment\">// &#123;prop:123&#125;</span></div><div class=\"line\">arr <span class=\"comment\">// [true]</span></div></pre></td></tr></table></figure>\n<p>对象的解构也可以指定默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;&#125;;</div><div class=\"line\">x <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;x, y = <span class=\"number\">5</span>&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;;</div><div class=\"line\">x <span class=\"comment\">// 1</span></div><div class=\"line\">y <span class=\"comment\">// 5</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">x</span>:y = <span class=\"number\">3</span>&#125; = &#123;&#125;;</div><div class=\"line\">y <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">x</span>:y = <span class=\"number\">3</span>&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">5</span>&#125;;</div><div class=\"line\">y <span class=\"comment\">// 5</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">message</span>: msg = <span class=\"string\">'Something went wrong'</span> &#125; = &#123;&#125;;</div><div class=\"line\">msg <span class=\"comment\">// \"Something went wrong\"</span></div></pre></td></tr></table></figure>\n<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"literal\">undefined</span>&#125;;</div><div class=\"line\">x <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"literal\">null</span>&#125;;</div><div class=\"line\">x <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果<code>x</code>属性等于<code>null</code>，就不严格相等于<code>undefined</code>，导致默认值不会生效。</p>\n<p>如果解构失败，变量的值等于<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;foo&#125; = &#123;<span class=\"attr\">bar</span>: <span class=\"string\">'baz'</span>&#125;;</div><div class=\"line\">foo <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">foo</span>: &#123;bar&#125;&#125; = &#123;<span class=\"attr\">baz</span>: <span class=\"string\">'baz'</span>&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错，请看下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _tmp = &#123;<span class=\"attr\">baz</span>: <span class=\"string\">'baz'</span>&#125;;</div><div class=\"line\">_tmp.foo.bar <span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 错误的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> x;</div><div class=\"line\">&#123;x&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// SyntaxError: syntax error</span></div></pre></td></tr></table></figure>\n<p>上面代码的写法会报错，因为JavaScript引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 正确的写法</span></div><div class=\"line\">(&#123;x&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;);</div></pre></td></tr></table></figure>\n<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> &#123; log, sin, cos &#125; = <span class=\"built_in\">Math</span>;</div></pre></td></tr></table></figure>\n<p>上面代码将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p>\n<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"number\">0</span> : first, [arr.length - <span class=\"number\">1</span>] : last&#125; = arr;</div><div class=\"line\">first <span class=\"comment\">// 1</span></div><div class=\"line\">last <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。</p>\n<h2 id=\"字符串的解构赋值\"><a href=\"#字符串的解构赋值\" class=\"headerlink\" title=\"字符串的解构赋值\"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">'hello'</span>;</div><div class=\"line\">a <span class=\"comment\">// \"h\"</span></div><div class=\"line\">b <span class=\"comment\">// \"e\"</span></div><div class=\"line\">c <span class=\"comment\">// \"l\"</span></div><div class=\"line\">d <span class=\"comment\">// \"l\"</span></div><div class=\"line\">e <span class=\"comment\">// \"o\"</span></div></pre></td></tr></table></figure>\n<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">length</span> : len&#125; = <span class=\"string\">'hello'</span>;</div><div class=\"line\">len <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure>\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">[x, y]</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">add([<span class=\"number\">1</span>, <span class=\"number\">2</span>]); <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p>\n<p>下面是另一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]].map(<span class=\"function\">(<span class=\"params\">[a, b]</span>) =&gt;</span> a + b);</div><div class=\"line\"><span class=\"comment\">// [ 3, 7 ]</span></div></pre></td></tr></table></figure>\n<p><code>undefined</code>就会触发函数参数的默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>, <span class=\"number\">3</span>].map(<span class=\"function\">(<span class=\"params\">x = <span class=\"string\">'yes'</span></span>) =&gt;</span> x);</div><div class=\"line\"><span class=\"comment\">// [ 1, 'yes', 3 ]</span></div></pre></td></tr></table></figure>\n<h2 id=\"圆括号问题\"><a href=\"#圆括号问题\" class=\"headerlink\" title=\"圆括号问题\"></a>圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>\n<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>\n<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>\n<h3 id=\"不能使用圆括号的情况\"><a href=\"#不能使用圆括号的情况\" class=\"headerlink\" title=\"不能使用圆括号的情况\"></a>不能使用圆括号的情况</h3><p>以下三种解构赋值不得使用圆括号。</p>\n<p>（1）变量声明语句中，不能带有圆括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全部报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> [(a)] = [<span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">x</span>: (c)&#125; = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> (&#123;<span class=\"attr\">x</span>: c&#125;) = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;(x: c)&#125; = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;(x): c&#125; = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">o</span>: (&#123; <span class=\"attr\">p</span>: p &#125;) &#125; = &#123; <span class=\"attr\">o</span>: &#123; <span class=\"attr\">p</span>: <span class=\"number\">2</span> &#125; &#125;;</div></pre></td></tr></table></figure>\n<p>上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p>\n<p>（2）函数参数中，模式不能带有圆括号。</p>\n<p>函数参数也属于变量声明，因此不能带有圆括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[(z</span>)]) </span>&#123; <span class=\"keyword\">return</span> z; &#125;</div></pre></td></tr></table></figure>\n<p>（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全部报错</span></div><div class=\"line\">(&#123; <span class=\"attr\">p</span>: a &#125;) = &#123; <span class=\"attr\">p</span>: <span class=\"number\">42</span> &#125;;</div><div class=\"line\">([a]) = [<span class=\"number\">5</span>];</div></pre></td></tr></table></figure>\n<p>上面代码将整个模式放在圆括号之中，导致报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\">[(&#123; <span class=\"attr\">p</span>: a &#125;), &#123; <span class=\"attr\">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</div></pre></td></tr></table></figure>\n<p>上面代码将嵌套模式的一层，放在圆括号之中，导致报错。</p>\n<h3 id=\"可以使用圆括号的情况\"><a href=\"#可以使用圆括号的情况\" class=\"headerlink\" title=\"可以使用圆括号的情况\"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[(b)] = [<span class=\"number\">3</span>]; <span class=\"comment\">// 正确</span></div><div class=\"line\">(&#123; <span class=\"attr\">p</span>: (d) &#125; = &#123;&#125;); <span class=\"comment\">// 正确</span></div><div class=\"line\">[(<span class=\"built_in\">parseInt</span>.prop)] = [<span class=\"number\">3</span>]; <span class=\"comment\">// 正确</span></div></pre></td></tr></table></figure>\n<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><p>变量的解构赋值用途很多。</p>\n<p><strong>（1）交换变量的值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[x, y] = [y, x];</div></pre></td></tr></table></figure>\n<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>\n<p><strong>（2）从函数返回多个值</strong></p>\n<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 返回一个数组</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> [a, b, c] = example();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 返回一个对象</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"number\">2</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure>\n<p><strong>（3）函数参数的定义</strong></p>\n<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 参数是一组有次序的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class=\"line\">f([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 参数是一组无次序的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class=\"line\">f(&#123;<span class=\"attr\">z</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;);</div></pre></td></tr></table></figure>\n<p><strong>（4）提取JSON数据</strong></p>\n<p>解构赋值对提取JSON对象中的数据，尤其有用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsonData = &#123;</div><div class=\"line\">  <span class=\"attr\">id</span>: <span class=\"number\">42</span>,</div><div class=\"line\">  <span class=\"attr\">status</span>: <span class=\"string\">\"OK\"</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: [<span class=\"number\">867</span>, <span class=\"number\">5309</span>]</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> &#123; id, status, <span class=\"attr\">data</span>: number &#125; = jsonData;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(id, status, number);</div><div class=\"line\"><span class=\"comment\">// 42, \"OK\", [867, 5309]</span></div></pre></td></tr></table></figure>\n<p>上面代码可以快速提取JSON数据的值。</p>\n<p><strong>（5）函数参数的默认值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.ajax = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">url, &#123;</span></span></div><div class=\"line\">  async = true,</div><div class=\"line\">  beforeSend = function () &#123;&#125;,</div><div class=\"line\">  cache = <span class=\"literal\">true</span>,</div><div class=\"line\">  complete = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  crossDomain = <span class=\"literal\">false</span>,</div><div class=\"line\">  global = <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"comment\">// ... more config</span></div><div class=\"line\">&#125;) &#123;</div><div class=\"line\">  <span class=\"comment\">// ... do stuff</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>\n<p><strong>（6）遍历Map结构</strong></p>\n<p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">map.set(<span class=\"string\">'first'</span>, <span class=\"string\">'hello'</span>);</div><div class=\"line\">map.set(<span class=\"string\">'second'</span>, <span class=\"string\">'world'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" is \"</span> + value);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// first is hello</span></div><div class=\"line\"><span class=\"comment\">// second is world</span></div></pre></td></tr></table></figure>\n<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取键名</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key] <span class=\"keyword\">of</span> map) &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取键值</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [,value] <span class=\"keyword\">of</span> map) &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>（7）输入模块的指定方法</strong></p>\n<p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">\"source-map\"</span>);</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p> 数组/对象/字符串都可以进行解构，尤其是对Json格式的返回值。<br>解构可以进行嵌套，赋默认值(和 undefined 进行‘===’严格比较)。<br>奇奇怪怪的用法就忽略吧…</p>\n</blockquote>\n<h2 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>\n<p>以前，为变量赋值，只能直接指定值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">3</span>;</div></pre></td></tr></table></figure>\n<p>ES6允许写成下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div></pre></td></tr></table></figure>\n<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>\n<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> [foo, [[bar], baz]] = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>], <span class=\"number\">3</span>]];</div><div class=\"line\">foo <span class=\"comment\">// 1</span></div><div class=\"line\">bar <span class=\"comment\">// 2</span></div><div class=\"line\">baz <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [ , , third] = [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>, <span class=\"string\">\"baz\"</span>];</div><div class=\"line\">third <span class=\"comment\">// \"baz\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [x, , y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">x <span class=\"comment\">// 1</span></div><div class=\"line\">y <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [head, ...tail] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</div><div class=\"line\">head <span class=\"comment\">// 1</span></div><div class=\"line\">tail <span class=\"comment\">// [2, 3, 4]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">'a'</span>];</div><div class=\"line\">x <span class=\"comment\">// \"a\"</span></div><div class=\"line\">y <span class=\"comment\">// undefined</span></div><div class=\"line\">z <span class=\"comment\">// []</span></div></pre></td></tr></table></figure>\n<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [foo] = [];</div><div class=\"line\"><span class=\"keyword\">var</span> [bar, foo] = [<span class=\"number\">1</span>];</div></pre></td></tr></table></figure>\n<p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p>\n<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> [x, y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">x <span class=\"comment\">// 1</span></div><div class=\"line\">y <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [a, [b], d] = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">4</span>];</div><div class=\"line\">a <span class=\"comment\">// 1</span></div><div class=\"line\">b <span class=\"comment\">// 2</span></div><div class=\"line\">d <span class=\"comment\">// 4</span></div></pre></td></tr></table></figure>\n<p>上面两个例子，都属于不完全解构，但是可以成功。</p>\n<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">false</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">NaN</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">undefined</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">null</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> [foo] = &#123;&#125;;</div></pre></td></tr></table></figure>\n<p>上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p>\n<p>解构赋值不仅适用于var命令，也适用于let和const命令。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [v1, v2, ..., vN ] = array;</div><div class=\"line\"><span class=\"keyword\">let</span> [v1, v2, ..., vN ] = array;</div><div class=\"line\"><span class=\"keyword\">const</span> [v1, v2, ..., vN ] = array;</div></pre></td></tr></table></figure>\n<p>对于Set结构，也可以使用数组的解构赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> [x, y, z] = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>]);</div><div class=\"line\">x <span class=\"comment\">// \"a\"</span></div></pre></td></tr></table></figure>\n<p>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fibs</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> a;</div><div class=\"line\">    [a, b] = [b, a + b];</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</div><div class=\"line\">sixth <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>fibs</code>是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。<br>","more":"</p>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p>解构赋值允许指定默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [foo = <span class=\"literal\">true</span>] = [];</div><div class=\"line\">foo <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\">[x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>]; <span class=\"comment\">// x='a', y='b'</span></div><div class=\"line\">[x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>, <span class=\"literal\">undefined</span>]; <span class=\"comment\">// x='a', y='b'</span></div></pre></td></tr></table></figure>\n<p>注意，ES6内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">undefined</span>];</div><div class=\"line\">x <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">null</span>];</div><div class=\"line\">x <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p>\n<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'aaa'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> [x = f()] = [<span class=\"number\">1</span>];</div></pre></td></tr></table></figure>\n<p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x;</div><div class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"number\">1</span>][<span class=\"number\">0</span>] === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">  x = f();</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  x = [<span class=\"number\">1</span>][<span class=\"number\">0</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [];     <span class=\"comment\">// x=1; y=1</span></div><div class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [<span class=\"number\">2</span>];    <span class=\"comment\">// x=2; y=2</span></div><div class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]; <span class=\"comment\">// x=1; y=2</span></div><div class=\"line\"><span class=\"keyword\">let</span> [x = y, y = <span class=\"number\">1</span>] = [];     <span class=\"comment\">// ReferenceError</span></div></pre></td></tr></table></figure>\n<p>上面最后一个表达式之所以会报错，是因为<code>x</code>用到默认值<code>y</code>时，<code>y</code>还没有声明。</p>\n<h2 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h2><p>解构不仅可以用于数组，还可以用于对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; foo, bar &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div><div class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></div><div class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></div></pre></td></tr></table></figure>\n<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; bar, foo &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div><div class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></div><div class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div><div class=\"line\">baz <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p>\n<p>如果变量名与属性名不一致，必须写成下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">foo</span>: baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'aaa'</span>, <span class=\"attr\">bar</span>: <span class=\"string\">'bbb'</span> &#125;;</div><div class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"attr\">first</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">last</span>: <span class=\"string\">'world'</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">first</span>: f, <span class=\"attr\">last</span>: l &#125; = obj;</div><div class=\"line\">f <span class=\"comment\">// 'hello'</span></div><div class=\"line\">l <span class=\"comment\">// 'world'</span></div></pre></td></tr></table></figure>\n<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">foo</span>: foo, <span class=\"attr\">bar</span>: bar &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div></pre></td></tr></table></figure>\n<p>也就是说，<strong>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">foo</span>: baz &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">\"aaa\"</span>, <span class=\"attr\">bar</span>: <span class=\"string\">\"bbb\"</span> &#125;;</div><div class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></div><div class=\"line\">foo <span class=\"comment\">// error: foo is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>\n<p>注意，采用这种写法时，变量的声明和赋值是一体的。对于<code>let</code>和<code>const</code>来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> foo;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123;foo&#125; = &#123;<span class=\"attr\">foo</span>: <span class=\"number\">1</span>&#125;; <span class=\"comment\">// SyntaxError: Duplicate declaration \"foo\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> baz;</div><div class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">bar</span>: baz&#125; = &#123;<span class=\"attr\">bar</span>: <span class=\"number\">1</span>&#125;; <span class=\"comment\">// SyntaxError: Duplicate declaration \"baz\"</span></div></pre></td></tr></table></figure>\n<p>上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为<code>var</code>命令允许重新声明，所以这个错误只会在使用<code>let</code>和<code>const</code>命令时出现。如果没有第二个<code>let</code>命令，上面的代码就不会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> foo;</div><div class=\"line\">(&#123;foo&#125; = &#123;<span class=\"attr\">foo</span>: <span class=\"number\">1</span>&#125;); <span class=\"comment\">// 成功</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> baz;</div><div class=\"line\">(&#123;<span class=\"attr\">bar</span>: baz&#125; = &#123;<span class=\"attr\">bar</span>: <span class=\"number\">1</span>&#125;); <span class=\"comment\">// 成功</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>let</code>命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</p>\n<p>和数组一样，解构也可以用于嵌套结构的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">  <span class=\"attr\">p</span>: [</div><div class=\"line\">    <span class=\"string\">'Hello'</span>,</div><div class=\"line\">    &#123; <span class=\"attr\">y</span>: <span class=\"string\">'World'</span> &#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">p</span>: [x, &#123; y &#125;] &#125; = obj;</div><div class=\"line\">x <span class=\"comment\">// \"Hello\"</span></div><div class=\"line\">y <span class=\"comment\">// \"World\"</span></div></pre></td></tr></table></figure>\n<p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> node = &#123;</div><div class=\"line\">  <span class=\"attr\">loc</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">start</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">line</span>: <span class=\"number\">1</span>,</div><div class=\"line\">      <span class=\"attr\">column</span>: <span class=\"number\">5</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">loc</span>: &#123; <span class=\"attr\">start</span>: &#123; line &#125;&#125; &#125; = node;</div><div class=\"line\">line <span class=\"comment\">// 1</span></div><div class=\"line\">loc  <span class=\"comment\">// error: loc is undefined</span></div><div class=\"line\">start <span class=\"comment\">// error: start is undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不会被赋值。</p>\n<p>下面是嵌套赋值的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> arr = [];</div><div class=\"line\"></div><div class=\"line\">(&#123; <span class=\"attr\">foo</span>: obj.prop, <span class=\"attr\">bar</span>: arr[<span class=\"number\">0</span>] &#125; = &#123; <span class=\"attr\">foo</span>: <span class=\"number\">123</span>, <span class=\"attr\">bar</span>: <span class=\"literal\">true</span> &#125;);</div><div class=\"line\"></div><div class=\"line\">obj <span class=\"comment\">// &#123;prop:123&#125;</span></div><div class=\"line\">arr <span class=\"comment\">// [true]</span></div></pre></td></tr></table></figure>\n<p>对象的解构也可以指定默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;&#125;;</div><div class=\"line\">x <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;x, y = <span class=\"number\">5</span>&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;;</div><div class=\"line\">x <span class=\"comment\">// 1</span></div><div class=\"line\">y <span class=\"comment\">// 5</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">x</span>:y = <span class=\"number\">3</span>&#125; = &#123;&#125;;</div><div class=\"line\">y <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">x</span>:y = <span class=\"number\">3</span>&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">5</span>&#125;;</div><div class=\"line\">y <span class=\"comment\">// 5</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">message</span>: msg = <span class=\"string\">'Something went wrong'</span> &#125; = &#123;&#125;;</div><div class=\"line\">msg <span class=\"comment\">// \"Something went wrong\"</span></div></pre></td></tr></table></figure>\n<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"literal\">undefined</span>&#125;;</div><div class=\"line\">x <span class=\"comment\">// 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"literal\">null</span>&#125;;</div><div class=\"line\">x <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果<code>x</code>属性等于<code>null</code>，就不严格相等于<code>undefined</code>，导致默认值不会生效。</p>\n<p>如果解构失败，变量的值等于<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> &#123;foo&#125; = &#123;<span class=\"attr\">bar</span>: <span class=\"string\">'baz'</span>&#125;;</div><div class=\"line\">foo <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">foo</span>: &#123;bar&#125;&#125; = &#123;<span class=\"attr\">baz</span>: <span class=\"string\">'baz'</span>&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错，请看下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _tmp = &#123;<span class=\"attr\">baz</span>: <span class=\"string\">'baz'</span>&#125;;</div><div class=\"line\">_tmp.foo.bar <span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 错误的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> x;</div><div class=\"line\">&#123;x&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// SyntaxError: syntax error</span></div></pre></td></tr></table></figure>\n<p>上面代码的写法会报错，因为JavaScript引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 正确的写法</span></div><div class=\"line\">(&#123;x&#125; = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;);</div></pre></td></tr></table></figure>\n<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> &#123; log, sin, cos &#125; = <span class=\"built_in\">Math</span>;</div></pre></td></tr></table></figure>\n<p>上面代码将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p>\n<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"number\">0</span> : first, [arr.length - <span class=\"number\">1</span>] : last&#125; = arr;</div><div class=\"line\">first <span class=\"comment\">// 1</span></div><div class=\"line\">last <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。</p>\n<h2 id=\"字符串的解构赋值\"><a href=\"#字符串的解构赋值\" class=\"headerlink\" title=\"字符串的解构赋值\"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">'hello'</span>;</div><div class=\"line\">a <span class=\"comment\">// \"h\"</span></div><div class=\"line\">b <span class=\"comment\">// \"e\"</span></div><div class=\"line\">c <span class=\"comment\">// \"l\"</span></div><div class=\"line\">d <span class=\"comment\">// \"l\"</span></div><div class=\"line\">e <span class=\"comment\">// \"o\"</span></div></pre></td></tr></table></figure>\n<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">length</span> : len&#125; = <span class=\"string\">'hello'</span>;</div><div class=\"line\">len <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure>\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">[x, y]</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">add([<span class=\"number\">1</span>, <span class=\"number\">2</span>]); <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p>\n<p>下面是另一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]].map(<span class=\"function\">(<span class=\"params\">[a, b]</span>) =&gt;</span> a + b);</div><div class=\"line\"><span class=\"comment\">// [ 3, 7 ]</span></div></pre></td></tr></table></figure>\n<p><code>undefined</code>就会触发函数参数的默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>, <span class=\"number\">3</span>].map(<span class=\"function\">(<span class=\"params\">x = <span class=\"string\">'yes'</span></span>) =&gt;</span> x);</div><div class=\"line\"><span class=\"comment\">// [ 1, 'yes', 3 ]</span></div></pre></td></tr></table></figure>\n<h2 id=\"圆括号问题\"><a href=\"#圆括号问题\" class=\"headerlink\" title=\"圆括号问题\"></a>圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>\n<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>\n<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>\n<h3 id=\"不能使用圆括号的情况\"><a href=\"#不能使用圆括号的情况\" class=\"headerlink\" title=\"不能使用圆括号的情况\"></a>不能使用圆括号的情况</h3><p>以下三种解构赋值不得使用圆括号。</p>\n<p>（1）变量声明语句中，不能带有圆括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全部报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> [(a)] = [<span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123;<span class=\"attr\">x</span>: (c)&#125; = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> (&#123;<span class=\"attr\">x</span>: c&#125;) = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;(x: c)&#125; = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123;(x): c&#125; = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">o</span>: (&#123; <span class=\"attr\">p</span>: p &#125;) &#125; = &#123; <span class=\"attr\">o</span>: &#123; <span class=\"attr\">p</span>: <span class=\"number\">2</span> &#125; &#125;;</div></pre></td></tr></table></figure>\n<p>上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p>\n<p>（2）函数参数中，模式不能带有圆括号。</p>\n<p>函数参数也属于变量声明，因此不能带有圆括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[(z</span>)]) </span>&#123; <span class=\"keyword\">return</span> z; &#125;</div></pre></td></tr></table></figure>\n<p>（3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 全部报错</span></div><div class=\"line\">(&#123; <span class=\"attr\">p</span>: a &#125;) = &#123; <span class=\"attr\">p</span>: <span class=\"number\">42</span> &#125;;</div><div class=\"line\">([a]) = [<span class=\"number\">5</span>];</div></pre></td></tr></table></figure>\n<p>上面代码将整个模式放在圆括号之中，导致报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\">[(&#123; <span class=\"attr\">p</span>: a &#125;), &#123; <span class=\"attr\">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</div></pre></td></tr></table></figure>\n<p>上面代码将嵌套模式的一层，放在圆括号之中，导致报错。</p>\n<h3 id=\"可以使用圆括号的情况\"><a href=\"#可以使用圆括号的情况\" class=\"headerlink\" title=\"可以使用圆括号的情况\"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[(b)] = [<span class=\"number\">3</span>]; <span class=\"comment\">// 正确</span></div><div class=\"line\">(&#123; <span class=\"attr\">p</span>: (d) &#125; = &#123;&#125;); <span class=\"comment\">// 正确</span></div><div class=\"line\">[(<span class=\"built_in\">parseInt</span>.prop)] = [<span class=\"number\">3</span>]; <span class=\"comment\">// 正确</span></div></pre></td></tr></table></figure>\n<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><p>变量的解构赋值用途很多。</p>\n<p><strong>（1）交换变量的值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[x, y] = [y, x];</div></pre></td></tr></table></figure>\n<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>\n<p><strong>（2）从函数返回多个值</strong></p>\n<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 返回一个数组</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> [a, b, c] = example();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 返回一个对象</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">bar</span>: <span class=\"number\">2</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure>\n<p><strong>（3）函数参数的定义</strong></p>\n<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 参数是一组有次序的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class=\"line\">f([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 参数是一组无次序的值</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class=\"line\">f(&#123;<span class=\"attr\">z</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;);</div></pre></td></tr></table></figure>\n<p><strong>（4）提取JSON数据</strong></p>\n<p>解构赋值对提取JSON对象中的数据，尤其有用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> jsonData = &#123;</div><div class=\"line\">  <span class=\"attr\">id</span>: <span class=\"number\">42</span>,</div><div class=\"line\">  <span class=\"attr\">status</span>: <span class=\"string\">\"OK\"</span>,</div><div class=\"line\">  <span class=\"attr\">data</span>: [<span class=\"number\">867</span>, <span class=\"number\">5309</span>]</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> &#123; id, status, <span class=\"attr\">data</span>: number &#125; = jsonData;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(id, status, number);</div><div class=\"line\"><span class=\"comment\">// 42, \"OK\", [867, 5309]</span></div></pre></td></tr></table></figure>\n<p>上面代码可以快速提取JSON数据的值。</p>\n<p><strong>（5）函数参数的默认值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.ajax = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">url, &#123;</span></span></div><div class=\"line\">  async = true,</div><div class=\"line\">  beforeSend = function () &#123;&#125;,</div><div class=\"line\">  cache = <span class=\"literal\">true</span>,</div><div class=\"line\">  complete = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</div><div class=\"line\">  crossDomain = <span class=\"literal\">false</span>,</div><div class=\"line\">  global = <span class=\"literal\">true</span>,</div><div class=\"line\">  <span class=\"comment\">// ... more config</span></div><div class=\"line\">&#125;) &#123;</div><div class=\"line\">  <span class=\"comment\">// ... do stuff</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>\n<p><strong>（6）遍历Map结构</strong></p>\n<p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">map.set(<span class=\"string\">'first'</span>, <span class=\"string\">'hello'</span>);</div><div class=\"line\">map.set(<span class=\"string\">'second'</span>, <span class=\"string\">'world'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" is \"</span> + value);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// first is hello</span></div><div class=\"line\"><span class=\"comment\">// second is world</span></div></pre></td></tr></table></figure>\n<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取键名</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key] <span class=\"keyword\">of</span> map) &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 获取键值</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [,value] <span class=\"keyword\">of</span> map) &#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>（7）输入模块的指定方法</strong></p>\n<p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">\"source-map\"</span>);</div></pre></td></tr></table></figure>"},{"title":"ES2015之Class","date":"2016-11-07T09:51:37.000Z","_content":"## Class基本语法\n\n### 概述\n\nJavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。\n\n```javascript\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n```\n\n上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\n\nES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过`class`关键字，可以定义类。基本上，ES6的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。\n\n```javascript\n//定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n\n上面代码定义了一个“类”，可以看到里面有一个`constructor`方法，这就是构造方法，而`this`关键字则代表实例对象。也就是说，ES5的构造函数`Point`，对应ES6的`Point`类的构造方法。\n\n`Point`类除了构造方法，还定义了一个`toString`方法。注意，定义“类”的方法的时候，前面不需要加上`function`这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\n\nES6的类，完全可以看作构造函数的另一种写法。\n\n```javascript\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor // true\n```\n\n上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\n\n使用的时候，也是直接对类使用`new`命令，跟构造函数的用法完全一致。\n\n```javascript\nclass Bar {\n  doStuff() {\n    console.log('stuff');\n  }\n}\n\nvar b = new Bar();\nb.doStuff() // \"stuff\"\n```\n\n构造函数的`prototype`属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype`属性上面。\n在类的实例上面调用方法，其实就是调用原型上的方法。\n\n```javascript\nclass B {}\nlet b = new B();\n\nb.constructor === B.prototype.constructor // true\n```\n\n上面代码中，`b`是B类的实例，它的`constructor`方法就是B类原型的`constructor`方法。\n\n由于类的方法都定义在`prototype`对象上面，所以类的新方法可以添加在`prototype`对象上面。`Object.assign`方法可以很方便地一次向类添加多个方法。\n\n```javascript\nclass Point {\n  constructor(){\n    // ...\n  }\n}\n\nObject.assign(Point.prototype, {\n  toString(){},\n  toValue(){}\n});\n```\n\n`prototype`对象的`constructor`属性，直接指向“类”的本身，这与ES5的行为是一致的。\n\n```javascript\nPoint.prototype.constructor === Point // true\n```\n\n另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n上面代码中，`toString`方法是`Point`类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。\n\n```javascript\nvar Point = function (x, y) {\n  // ...\n};\n\nPoint.prototype.toString = function() {\n  // ...\n};\n\nObject.keys(Point.prototype)\n// [\"toString\"]\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n上面代码采用ES5的写法，`toString`方法就是可枚举的。\n\n<!--more-->\n### constructor方法\n\n`constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。\n\n```javascript\nconstructor() {}\n```\n\n`constructor`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。\n\n```javascript\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nnew Foo() instanceof Foo\n// false\n```\n\n上面代码中，`constructor`函数返回一个全新的对象，结果导致实例对象不是`Foo`类的实例。\n\n类的构造函数，不使用`new`是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。\n\n```javascript\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nFoo()\n// TypeError: Class constructor Foo cannot be invoked without 'new'\n```\n\n### 类的实例对象\n\n生成类的实例对象的写法，与ES5完全一样，也是使用`new`命令。如果忘记加上`new`，像函数那样调用`Class`，将会报错。\n\n```javascript\n// 报错\nvar point = Point(2, 3);\n\n// 正确\nvar point = new Point(2, 3);\n```\n\n与ES5一样，实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。\n\n```javascript\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n上面代码中，`x`和`y`都是实例对象`point`自身的属性（因为定义在`this`变量上），所以`hasOwnProperty`方法返回`true`，而`toString`是原型对象的属性（因为定义在`Point`类上），所以`hasOwnProperty`方法返回`false`。这些都与ES5的行为保持一致。\n\n与ES5一样，类的所有实例共享一个原型对象。\n\n```javascript\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__ === p2.__proto__\n//true\n```\n\n上面代码中，`p1`和`p2`都是Point的实例，它们的原型都是Point，所以`__proto__`属性是相等的。\n\n这也意味着，可以通过实例的`__proto__`属性为Class添加方法。\n\n```javascript\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__.printName = function () { return 'Oops' };\n\np1.printName() // \"Oops\"\np2.printName() // \"Oops\"\n\nvar p3 = new Point(4,2);\np3.printName() // \"Oops\"\n```\n\n上面代码在`p1`的原型上添加了一个`printName`方法，由于`p1`的原型就是`p2`的原型，因此`p2`也可以调用这个方法。而且，此后新建的实例`p3`也可以调用这个方法。这意味着，使用实例的`__proto__`属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。\n\n### 不存在变量提升\n\nClass不存在变量提升（hoist），这一点与ES5完全不同。\n\n```javascript\nnew Foo(); // ReferenceError\nclass Foo {}\n```\n\n上面代码中，`Foo`类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\n\n```javascript\n{\n  let Foo = class {};\n  class Bar extends Foo {\n  }\n}\n```\n\n上面的代码不会报错，因为`class`继承`Foo`的时候，`Foo`已经有定义了。但是，如果存在`class`的提升，上面代码就会报错，因为`class`会被提升到代码头部，而`let`命令是不提升的，所以导致`class`继承`Foo`的时候，`Foo`还没有定义。\n\n### Class表达式\n\n与函数一样，类也可以使用表达式的形式定义。\n\n```javascript\nconst MyClass = class Me {\n  getClassName() {\n    return Me.name;\n  }\n};\n```\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是`MyClass`而不是`Me`，`Me`只在Class的内部代码可用，指代当前类。\n\n```javascript\nlet inst = new MyClass();\ninst.getClassName() // Me\nMe.name // ReferenceError: Me is not defined\n```\n\n上面代码表示，`Me`只在Class内部有定义。\n\n如果类的内部没用到的话，可以省略`Me`，也就是可以写成下面的形式。\n\n```javascript\nconst MyClass = class { /* ... */ };\n```\n\n采用Class表达式，可以写出立即执行的Class。\n\n```javascript\nlet person = new class {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayName() {\n    console.log(this.name);\n  }\n}('张三');\n\nperson.sayName(); // \"张三\"\n```\n\n上面代码中，`person`是一个立即执行的类的实例。\n\n### 私有方法\n\n私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。\n\n一种做法是在命名上加以区别。\n\n```javascript\nclass Widget {\n\n  // 公有方法\n  foo (baz) {\n    this._bar(baz);\n  }\n\n  // 私有方法\n  _bar(baz) {\n    return this.snaf = baz;\n  }\n\n  // ...\n}\n```\n\n上面代码中，`_bar`方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\n\n另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\n\n```javascript\nclass Widget {\n  foo (baz) {\n    bar.call(this, baz);\n  }\n\n  // ...\n}\n\nfunction bar(baz) {\n  return this.snaf = baz;\n}\n```\n\n上面代码中，`foo`是公有方法，内部调用了`bar.call(this, baz)`。这使得`bar`实际上成为了当前模块的私有方法。\n\n还有一种方法是利用`Symbol`值的唯一性，将私有方法的名字命名为一个`Symbol`值。\n\n```javascript\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass{\n\n  // 公有方法\n  foo(baz) {\n    this[bar](baz);\n  }\n\n  // 私有方法\n  [bar](baz) {\n    return this[snaf] = baz;\n  }\n\n  // ...\n};\n```\n\n上面代码中，`bar`和`snaf`都是`Symbol`值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。\n\n### this的指向\n\n类的方法内部如果含有`this`，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\n\n```javascript\nclass Logger {\n  printName(name = 'there') {\n    this.print(`Hello ${name}`);\n  }\n\n  print(text) {\n    console.log(text);\n  }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n```\n\n上面代码中，`printName`方法中的`this`，默认指向`Logger`类的实例。但是，如果将这个方法提取出来单独使用，`this`会指向该方法运行时所在的环境，因为找不到`print`方法而导致报错。\n\n一个比较简单的解决方法是，在构造方法中绑定`this`，这样就不会找不到`print`方法了。\n\n```javascript\nclass Logger {\n  constructor() {\n    this.printName = this.printName.bind(this);\n  }\n\n  // ...\n}\n```\n\n另一种解决方法是使用箭头函数。\n\n```javascript\nclass Logger {\n  constructor() {\n    this.printName = (name = 'there') => {\n      this.print(`Hello ${name}`);\n    };\n  }\n\n  // ...\n}\n```\n### name属性\n\n由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被`Class`继承，包括`name`属性。\n\n```javascript\nclass Point {}\nPoint.name // \"Point\"\n```\n\n`name`属性总是返回紧跟在`class`关键字后面的类名。\n\n## Class的继承\n\n### 基本用法\n\nClass之间可以通过`extends`关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。\n\n```javascript\nclass ColorPoint extends Point {}\n```\n\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\n\n```javascript\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n```\n\n上面代码中，`constructor`方法和`toString`方法之中，都出现了`super`关键字，它在这里表示父类的构造函数，用来新建父类的`this`对象。\n\n子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类没有自己的`this`对象，而是继承父类的`this`对象，然后对其进行加工。如果不调用`super`方法，子类就得不到`this`对象。\n\n```javascript\nclass Point { /* ... */ }\n\nclass ColorPoint extends Point {\n  constructor() {\n  }\n}\n\nlet cp = new ColorPoint(); // ReferenceError\n```\n\n上面代码中，`ColorPoint`继承了父类`Point`，但是它的构造函数没有调用`super`方法，导致新建实例时报错。\n\nES5的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6的继承机制完全不同，实质是先创造父类的实例对象`this`（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。\n\n如果子类没有定义`constructor`方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有`constructor`方法。\n\n```javascript\nconstructor(...args) {\n  super(...args);\n}\n```\n\n另一个需要注意的地方是，在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有`super`方法才能返回父类实例。\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n```\n\n上面代码中，子类的`constructor`方法没有调用`super`之前，就使用`this`关键字，结果报错，而放在`super`方法之后就是正确的。\n\n下面是生成子类实例的代码。\n\n```javascript\nlet cp = new ColorPoint(25, 8, 'green');\n\ncp instanceof ColorPoint // true\ncp instanceof Point // true\n```\n\n上面代码中，实例对象`cp`同时是`ColorPoint`和`Point`两个类的实例，这与ES5的行为完全一致。\n\n### 类的prototype属性和\\_\\_proto\\_\\_属性\n\n大多数浏览器的ES5实现之中，每一个对象都有`__proto__`属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和`__proto__`属性，因此同时存在两条继承链。\n\n（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类。\n\n（2）子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。\n\n```javascript\nclass A {\n}\n\nclass B extends A {\n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n```\n\n上面代码中，子类`B`的`__proto__`属性指向父类`A`，子类`B`的`prototype`属性的`__proto__`属性指向父类`A`的`prototype`属性。\n\n这两条继承链，可以这样理解：作为一个对象，子类（`B`）的原型（`__proto__`属性）是父类（`A`）；作为一个构造函数，子类（`B`）的原型（`prototype`属性）是父类的实例。\n\n```javascript\nObject.create(A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n```\n\n### Object.getPrototypeOf()\n\n`Object.getPrototypeOf`方法可以用来从子类上获取父类。\n\n```javascript\nObject.getPrototypeOf(ColorPoint) === Point\n// true\n```\n\n因此，可以使用这个方法判断，一个类是否继承了另一个类。\n\n### super关键字\n\n`super`这个关键字，有两种用法，含义不同。\n\n（1）作为函数调用时（即`super(...args)`），`super`代表父类的构造函数。\n\n（2）作为对象调用时（即`super.prop`或`super.method()`），`super`代表父类。注意，此时`super`既可以引用父类实例的属性和方法，也可以引用父类的静态方法。\n\n```javascript\nclass B extends A {\n  get m() {\n    return this._p * super._p;\n  }\n  set m() {\n    throw new Error('该属性只读');\n  }\n}\n```\n\n上面代码中，子类通过`super`关键字，调用父类实例的`_p`属性。\n\n由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用`super`关键字。\n\n```javascript\nvar obj = {\n  toString() {\n    return \"MyObject: \" + super.toString();\n  }\n};\n\nobj.toString(); // MyObject: [object Object]\n```\n\n## Class的取值函数（getter）和存值函数（setter）\n\n与ES5一样，在Class内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n```javascript\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n// setter: 123\n\ninst.prop\n// 'getter'\n```\n\n上面代码中，`prop`属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。\n\n存值函数和取值函数是设置在属性的descriptor对象上的。\n\n```javascript\nclass CustomHTMLElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerHTML;\n  }\n\n  set html(value) {\n    this.element.innerHTML = value;\n  }\n}\n\nvar descriptor = Object.getOwnPropertyDescriptor(\n  CustomHTMLElement.prototype, \"html\");\n\"get\" in descriptor  // true\n\"set\" in descriptor  // true\n```\n\n上面代码中，存值函数和取值函数是定义在`html`属性的描述对象上面，这与ES5完全一致。\n\n## Class的静态方法\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示**该方法不会被实例继承，而是直接通过类来调用**，这就称为“静态方法”。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n\n上面代码中，`Foo`类的`classMethod`方法前有`static`关键字，表明该方法是一个静态方法，可以直接在`Foo`类上调用（`Foo.classMethod()`），而不是在`Foo`类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n父类的静态方法，可以被子类继承。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod(); // 'hello'\n```\n\n上面代码中，父类`Foo`有一个静态方法，子类`Bar`可以调用这个方法。\n\n静态方法也是可以从`super`对象上调用的。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n  static classMethod() {\n    return super.classMethod() + ', too';\n  }\n}\n\nBar.classMethod();\n```\n\n## Class的静态属性和实例属性\n\n静态属性指的是Class本身的属性，即`Class.propname`，而不是定义在实例对象（`this`）上的属性。\n\n```javascript\nclass Foo {\n}\n\nFoo.prop = 1;\nFoo.prop // 1\n```\n\n上面的写法为`Foo`类定义了一个静态属性`prop`。\n\n目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。\n\n```javascript\n// 以下两种写法都无效\nclass Foo {\n  // 写法一\n  prop: 2\n\n  // 写法二\n  static prop: 2\n}\n\nFoo.prop // undefined\n```\n--------\nES7有一个静态属性的[提案](https://github.com/jeffmo/es-class-properties)，目前Babel转码器支持。\n\n这个提案对实例属性和静态属性，都规定了新的写法。\n\n（1）类的实例属性\n\n类的实例属性可以用等式，写入类的定义之中。\n\n```javascript\nclass MyClass {\n  myProp = 42;\n\n  constructor() {\n    console.log(this.myProp); // 42\n  }\n}\n```\n\n上面代码中，`myProp`就是`MyClass`的实例属性。在`MyClass`的实例上，可以读取这个属性。\n\n以前，我们定义实例属性，只能写在类的`constructor`方法里面。\n\n```javascript\nclass ReactCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n}\n```\n\n上面代码中，构造方法`constructor`里面，定义了`this.state`属性。\n\n有了新的写法以后，可以不在`constructor`方法里面定义。\n\n```javascript\nclass ReactCounter extends React.Component {\n  state = {\n    count: 0\n  };\n}\n```\n\n这种写法比以前更清晰。\n\n为了可读性的目的，对于那些在`constructor`里面已经定义的实例属性，新写法允许直接列出。\n\n```javascript\nclass ReactCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n  state;\n}\n```\n\n（2）类的静态属性\n\n类的静态属性只要在上面的实例属性写法前面，加上`static`关键字就可以了。\n\n```javascript\nclass MyClass {\n  static myStaticProp = 42;\n\n  constructor() {\n    console.log(MyClass.myProp); // 42\n  }\n}\n```\n\n同样的，这个新写法大大方便了静态属性的表达。\n\n```javascript\n// 老写法\nclass Foo {\n}\nFoo.prop = 1;\n\n// 新写法\nclass Foo {\n  static prop = 1;\n}\n```\n\n上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。\n\n## new.target属性\n\n`new`是从构造函数生成实例的命令。ES6为`new`命令引入了一个`new.target`属性，（在构造函数中）返回`new`命令作用于的那个构造函数。如果构造函数不是通过`new`命令调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是怎么调用的。\n\n```javascript\nfunction Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n```\n\n上面代码确保构造函数只能通过`new`命令调用。\n\nClass内部调用`new.target`，返回当前Class。\n\n```javascript\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n    this.length = length;\n    this.width = width;\n  }\n}\n\nvar obj = new Rectangle(3, 4); // 输出 true\n```\n\n需要注意的是，子类继承父类时，`new.target`会返回子类。\n\n```javascript\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n    // ...\n  }\n}\n\nclass Square extends Rectangle {\n  constructor(length) {\n    super(length, length);\n  }\n}\n\nvar obj = new Square(3); // 输出 false\n```\n\n上面代码中，`new.target`会返回子类。\n\n利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\n\n```javascript\nclass Shape {\n  constructor() {\n    if (new.target === Shape) {\n      throw new Error('本类不能实例化');\n    }\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(length, width) {\n    super();\n    // ...\n  }\n}\n\nvar x = new Shape();  // 报错\nvar y = new Rectangle(3, 4);  // 正确\n```\n\n上面代码中，`Shape`类不能被实例化，只能用于继承。\n\n注意，在函数外部，使用`new.target`会报错。\n","source":"_posts/ES2015之Class.md","raw":"---\ntitle: ES2015之Class\ndate: 2016-11-07 17:51:37\ntags: ES2015\n---\n## Class基本语法\n\n### 概述\n\nJavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。\n\n```javascript\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n```\n\n上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\n\nES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过`class`关键字，可以定义类。基本上，ES6的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。\n\n```javascript\n//定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n\n上面代码定义了一个“类”，可以看到里面有一个`constructor`方法，这就是构造方法，而`this`关键字则代表实例对象。也就是说，ES5的构造函数`Point`，对应ES6的`Point`类的构造方法。\n\n`Point`类除了构造方法，还定义了一个`toString`方法。注意，定义“类”的方法的时候，前面不需要加上`function`这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。\n\nES6的类，完全可以看作构造函数的另一种写法。\n\n```javascript\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor // true\n```\n\n上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\n\n使用的时候，也是直接对类使用`new`命令，跟构造函数的用法完全一致。\n\n```javascript\nclass Bar {\n  doStuff() {\n    console.log('stuff');\n  }\n}\n\nvar b = new Bar();\nb.doStuff() // \"stuff\"\n```\n\n构造函数的`prototype`属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype`属性上面。\n在类的实例上面调用方法，其实就是调用原型上的方法。\n\n```javascript\nclass B {}\nlet b = new B();\n\nb.constructor === B.prototype.constructor // true\n```\n\n上面代码中，`b`是B类的实例，它的`constructor`方法就是B类原型的`constructor`方法。\n\n由于类的方法都定义在`prototype`对象上面，所以类的新方法可以添加在`prototype`对象上面。`Object.assign`方法可以很方便地一次向类添加多个方法。\n\n```javascript\nclass Point {\n  constructor(){\n    // ...\n  }\n}\n\nObject.assign(Point.prototype, {\n  toString(){},\n  toValue(){}\n});\n```\n\n`prototype`对象的`constructor`属性，直接指向“类”的本身，这与ES5的行为是一致的。\n\n```javascript\nPoint.prototype.constructor === Point // true\n```\n\n另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n上面代码中，`toString`方法是`Point`类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。\n\n```javascript\nvar Point = function (x, y) {\n  // ...\n};\n\nPoint.prototype.toString = function() {\n  // ...\n};\n\nObject.keys(Point.prototype)\n// [\"toString\"]\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n\n上面代码采用ES5的写法，`toString`方法就是可枚举的。\n\n<!--more-->\n### constructor方法\n\n`constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。\n\n```javascript\nconstructor() {}\n```\n\n`constructor`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。\n\n```javascript\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nnew Foo() instanceof Foo\n// false\n```\n\n上面代码中，`constructor`函数返回一个全新的对象，结果导致实例对象不是`Foo`类的实例。\n\n类的构造函数，不使用`new`是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。\n\n```javascript\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nFoo()\n// TypeError: Class constructor Foo cannot be invoked without 'new'\n```\n\n### 类的实例对象\n\n生成类的实例对象的写法，与ES5完全一样，也是使用`new`命令。如果忘记加上`new`，像函数那样调用`Class`，将会报错。\n\n```javascript\n// 报错\nvar point = Point(2, 3);\n\n// 正确\nvar point = new Point(2, 3);\n```\n\n与ES5一样，实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。\n\n```javascript\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n\n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n\n上面代码中，`x`和`y`都是实例对象`point`自身的属性（因为定义在`this`变量上），所以`hasOwnProperty`方法返回`true`，而`toString`是原型对象的属性（因为定义在`Point`类上），所以`hasOwnProperty`方法返回`false`。这些都与ES5的行为保持一致。\n\n与ES5一样，类的所有实例共享一个原型对象。\n\n```javascript\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__ === p2.__proto__\n//true\n```\n\n上面代码中，`p1`和`p2`都是Point的实例，它们的原型都是Point，所以`__proto__`属性是相等的。\n\n这也意味着，可以通过实例的`__proto__`属性为Class添加方法。\n\n```javascript\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__.printName = function () { return 'Oops' };\n\np1.printName() // \"Oops\"\np2.printName() // \"Oops\"\n\nvar p3 = new Point(4,2);\np3.printName() // \"Oops\"\n```\n\n上面代码在`p1`的原型上添加了一个`printName`方法，由于`p1`的原型就是`p2`的原型，因此`p2`也可以调用这个方法。而且，此后新建的实例`p3`也可以调用这个方法。这意味着，使用实例的`__proto__`属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。\n\n### 不存在变量提升\n\nClass不存在变量提升（hoist），这一点与ES5完全不同。\n\n```javascript\nnew Foo(); // ReferenceError\nclass Foo {}\n```\n\n上面代码中，`Foo`类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。\n\n```javascript\n{\n  let Foo = class {};\n  class Bar extends Foo {\n  }\n}\n```\n\n上面的代码不会报错，因为`class`继承`Foo`的时候，`Foo`已经有定义了。但是，如果存在`class`的提升，上面代码就会报错，因为`class`会被提升到代码头部，而`let`命令是不提升的，所以导致`class`继承`Foo`的时候，`Foo`还没有定义。\n\n### Class表达式\n\n与函数一样，类也可以使用表达式的形式定义。\n\n```javascript\nconst MyClass = class Me {\n  getClassName() {\n    return Me.name;\n  }\n};\n```\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是`MyClass`而不是`Me`，`Me`只在Class的内部代码可用，指代当前类。\n\n```javascript\nlet inst = new MyClass();\ninst.getClassName() // Me\nMe.name // ReferenceError: Me is not defined\n```\n\n上面代码表示，`Me`只在Class内部有定义。\n\n如果类的内部没用到的话，可以省略`Me`，也就是可以写成下面的形式。\n\n```javascript\nconst MyClass = class { /* ... */ };\n```\n\n采用Class表达式，可以写出立即执行的Class。\n\n```javascript\nlet person = new class {\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayName() {\n    console.log(this.name);\n  }\n}('张三');\n\nperson.sayName(); // \"张三\"\n```\n\n上面代码中，`person`是一个立即执行的类的实例。\n\n### 私有方法\n\n私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。\n\n一种做法是在命名上加以区别。\n\n```javascript\nclass Widget {\n\n  // 公有方法\n  foo (baz) {\n    this._bar(baz);\n  }\n\n  // 私有方法\n  _bar(baz) {\n    return this.snaf = baz;\n  }\n\n  // ...\n}\n```\n\n上面代码中，`_bar`方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。\n\n另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\n\n```javascript\nclass Widget {\n  foo (baz) {\n    bar.call(this, baz);\n  }\n\n  // ...\n}\n\nfunction bar(baz) {\n  return this.snaf = baz;\n}\n```\n\n上面代码中，`foo`是公有方法，内部调用了`bar.call(this, baz)`。这使得`bar`实际上成为了当前模块的私有方法。\n\n还有一种方法是利用`Symbol`值的唯一性，将私有方法的名字命名为一个`Symbol`值。\n\n```javascript\nconst bar = Symbol('bar');\nconst snaf = Symbol('snaf');\n\nexport default class myClass{\n\n  // 公有方法\n  foo(baz) {\n    this[bar](baz);\n  }\n\n  // 私有方法\n  [bar](baz) {\n    return this[snaf] = baz;\n  }\n\n  // ...\n};\n```\n\n上面代码中，`bar`和`snaf`都是`Symbol`值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。\n\n### this的指向\n\n类的方法内部如果含有`this`，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\n\n```javascript\nclass Logger {\n  printName(name = 'there') {\n    this.print(`Hello ${name}`);\n  }\n\n  print(text) {\n    console.log(text);\n  }\n}\n\nconst logger = new Logger();\nconst { printName } = logger;\nprintName(); // TypeError: Cannot read property 'print' of undefined\n```\n\n上面代码中，`printName`方法中的`this`，默认指向`Logger`类的实例。但是，如果将这个方法提取出来单独使用，`this`会指向该方法运行时所在的环境，因为找不到`print`方法而导致报错。\n\n一个比较简单的解决方法是，在构造方法中绑定`this`，这样就不会找不到`print`方法了。\n\n```javascript\nclass Logger {\n  constructor() {\n    this.printName = this.printName.bind(this);\n  }\n\n  // ...\n}\n```\n\n另一种解决方法是使用箭头函数。\n\n```javascript\nclass Logger {\n  constructor() {\n    this.printName = (name = 'there') => {\n      this.print(`Hello ${name}`);\n    };\n  }\n\n  // ...\n}\n```\n### name属性\n\n由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被`Class`继承，包括`name`属性。\n\n```javascript\nclass Point {}\nPoint.name // \"Point\"\n```\n\n`name`属性总是返回紧跟在`class`关键字后面的类名。\n\n## Class的继承\n\n### 基本用法\n\nClass之间可以通过`extends`关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。\n\n```javascript\nclass ColorPoint extends Point {}\n```\n\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\n\n```javascript\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n```\n\n上面代码中，`constructor`方法和`toString`方法之中，都出现了`super`关键字，它在这里表示父类的构造函数，用来新建父类的`this`对象。\n\n子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类没有自己的`this`对象，而是继承父类的`this`对象，然后对其进行加工。如果不调用`super`方法，子类就得不到`this`对象。\n\n```javascript\nclass Point { /* ... */ }\n\nclass ColorPoint extends Point {\n  constructor() {\n  }\n}\n\nlet cp = new ColorPoint(); // ReferenceError\n```\n\n上面代码中，`ColorPoint`继承了父类`Point`，但是它的构造函数没有调用`super`方法，导致新建实例时报错。\n\nES5的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6的继承机制完全不同，实质是先创造父类的实例对象`this`（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。\n\n如果子类没有定义`constructor`方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有`constructor`方法。\n\n```javascript\nconstructor(...args) {\n  super(...args);\n}\n```\n\n另一个需要注意的地方是，在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有`super`方法才能返回父类实例。\n\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n```\n\n上面代码中，子类的`constructor`方法没有调用`super`之前，就使用`this`关键字，结果报错，而放在`super`方法之后就是正确的。\n\n下面是生成子类实例的代码。\n\n```javascript\nlet cp = new ColorPoint(25, 8, 'green');\n\ncp instanceof ColorPoint // true\ncp instanceof Point // true\n```\n\n上面代码中，实例对象`cp`同时是`ColorPoint`和`Point`两个类的实例，这与ES5的行为完全一致。\n\n### 类的prototype属性和\\_\\_proto\\_\\_属性\n\n大多数浏览器的ES5实现之中，每一个对象都有`__proto__`属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和`__proto__`属性，因此同时存在两条继承链。\n\n（1）子类的`__proto__`属性，表示构造函数的继承，总是指向父类。\n\n（2）子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。\n\n```javascript\nclass A {\n}\n\nclass B extends A {\n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n```\n\n上面代码中，子类`B`的`__proto__`属性指向父类`A`，子类`B`的`prototype`属性的`__proto__`属性指向父类`A`的`prototype`属性。\n\n这两条继承链，可以这样理解：作为一个对象，子类（`B`）的原型（`__proto__`属性）是父类（`A`）；作为一个构造函数，子类（`B`）的原型（`prototype`属性）是父类的实例。\n\n```javascript\nObject.create(A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n```\n\n### Object.getPrototypeOf()\n\n`Object.getPrototypeOf`方法可以用来从子类上获取父类。\n\n```javascript\nObject.getPrototypeOf(ColorPoint) === Point\n// true\n```\n\n因此，可以使用这个方法判断，一个类是否继承了另一个类。\n\n### super关键字\n\n`super`这个关键字，有两种用法，含义不同。\n\n（1）作为函数调用时（即`super(...args)`），`super`代表父类的构造函数。\n\n（2）作为对象调用时（即`super.prop`或`super.method()`），`super`代表父类。注意，此时`super`既可以引用父类实例的属性和方法，也可以引用父类的静态方法。\n\n```javascript\nclass B extends A {\n  get m() {\n    return this._p * super._p;\n  }\n  set m() {\n    throw new Error('该属性只读');\n  }\n}\n```\n\n上面代码中，子类通过`super`关键字，调用父类实例的`_p`属性。\n\n由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用`super`关键字。\n\n```javascript\nvar obj = {\n  toString() {\n    return \"MyObject: \" + super.toString();\n  }\n};\n\nobj.toString(); // MyObject: [object Object]\n```\n\n## Class的取值函数（getter）和存值函数（setter）\n\n与ES5一样，在Class内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n```javascript\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n// setter: 123\n\ninst.prop\n// 'getter'\n```\n\n上面代码中，`prop`属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。\n\n存值函数和取值函数是设置在属性的descriptor对象上的。\n\n```javascript\nclass CustomHTMLElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerHTML;\n  }\n\n  set html(value) {\n    this.element.innerHTML = value;\n  }\n}\n\nvar descriptor = Object.getOwnPropertyDescriptor(\n  CustomHTMLElement.prototype, \"html\");\n\"get\" in descriptor  // true\n\"set\" in descriptor  // true\n```\n\n上面代码中，存值函数和取值函数是定义在`html`属性的描述对象上面，这与ES5完全一致。\n\n## Class的静态方法\n\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示**该方法不会被实例继承，而是直接通过类来调用**，这就称为“静态方法”。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n\n上面代码中，`Foo`类的`classMethod`方法前有`static`关键字，表明该方法是一个静态方法，可以直接在`Foo`类上调用（`Foo.classMethod()`），而不是在`Foo`类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n父类的静态方法，可以被子类继承。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod(); // 'hello'\n```\n\n上面代码中，父类`Foo`有一个静态方法，子类`Bar`可以调用这个方法。\n\n静态方法也是可以从`super`对象上调用的。\n\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n  static classMethod() {\n    return super.classMethod() + ', too';\n  }\n}\n\nBar.classMethod();\n```\n\n## Class的静态属性和实例属性\n\n静态属性指的是Class本身的属性，即`Class.propname`，而不是定义在实例对象（`this`）上的属性。\n\n```javascript\nclass Foo {\n}\n\nFoo.prop = 1;\nFoo.prop // 1\n```\n\n上面的写法为`Foo`类定义了一个静态属性`prop`。\n\n目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。\n\n```javascript\n// 以下两种写法都无效\nclass Foo {\n  // 写法一\n  prop: 2\n\n  // 写法二\n  static prop: 2\n}\n\nFoo.prop // undefined\n```\n--------\nES7有一个静态属性的[提案](https://github.com/jeffmo/es-class-properties)，目前Babel转码器支持。\n\n这个提案对实例属性和静态属性，都规定了新的写法。\n\n（1）类的实例属性\n\n类的实例属性可以用等式，写入类的定义之中。\n\n```javascript\nclass MyClass {\n  myProp = 42;\n\n  constructor() {\n    console.log(this.myProp); // 42\n  }\n}\n```\n\n上面代码中，`myProp`就是`MyClass`的实例属性。在`MyClass`的实例上，可以读取这个属性。\n\n以前，我们定义实例属性，只能写在类的`constructor`方法里面。\n\n```javascript\nclass ReactCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n}\n```\n\n上面代码中，构造方法`constructor`里面，定义了`this.state`属性。\n\n有了新的写法以后，可以不在`constructor`方法里面定义。\n\n```javascript\nclass ReactCounter extends React.Component {\n  state = {\n    count: 0\n  };\n}\n```\n\n这种写法比以前更清晰。\n\n为了可读性的目的，对于那些在`constructor`里面已经定义的实例属性，新写法允许直接列出。\n\n```javascript\nclass ReactCounter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n  state;\n}\n```\n\n（2）类的静态属性\n\n类的静态属性只要在上面的实例属性写法前面，加上`static`关键字就可以了。\n\n```javascript\nclass MyClass {\n  static myStaticProp = 42;\n\n  constructor() {\n    console.log(MyClass.myProp); // 42\n  }\n}\n```\n\n同样的，这个新写法大大方便了静态属性的表达。\n\n```javascript\n// 老写法\nclass Foo {\n}\nFoo.prop = 1;\n\n// 新写法\nclass Foo {\n  static prop = 1;\n}\n```\n\n上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。\n\n## new.target属性\n\n`new`是从构造函数生成实例的命令。ES6为`new`命令引入了一个`new.target`属性，（在构造函数中）返回`new`命令作用于的那个构造函数。如果构造函数不是通过`new`命令调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是怎么调用的。\n\n```javascript\nfunction Person(name) {\n  if (new.target !== undefined) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\n// 另一种写法\nfunction Person(name) {\n  if (new.target === Person) {\n    this.name = name;\n  } else {\n    throw new Error('必须使用new生成实例');\n  }\n}\n\nvar person = new Person('张三'); // 正确\nvar notAPerson = Person.call(person, '张三');  // 报错\n```\n\n上面代码确保构造函数只能通过`new`命令调用。\n\nClass内部调用`new.target`，返回当前Class。\n\n```javascript\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n    this.length = length;\n    this.width = width;\n  }\n}\n\nvar obj = new Rectangle(3, 4); // 输出 true\n```\n\n需要注意的是，子类继承父类时，`new.target`会返回子类。\n\n```javascript\nclass Rectangle {\n  constructor(length, width) {\n    console.log(new.target === Rectangle);\n    // ...\n  }\n}\n\nclass Square extends Rectangle {\n  constructor(length) {\n    super(length, length);\n  }\n}\n\nvar obj = new Square(3); // 输出 false\n```\n\n上面代码中，`new.target`会返回子类。\n\n利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\n\n```javascript\nclass Shape {\n  constructor() {\n    if (new.target === Shape) {\n      throw new Error('本类不能实例化');\n    }\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(length, width) {\n    super();\n    // ...\n  }\n}\n\nvar x = new Shape();  // 报错\nvar y = new Rectangle(3, 4);  // 正确\n```\n\n上面代码中，`Shape`类不能被实例化，只能用于继承。\n\n注意，在函数外部，使用`new.target`会报错。\n","slug":"ES2015之Class","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfbk0004zk4o31975zfm","content":"<h2 id=\"Class基本语法\"><a href=\"#Class基本语法\" class=\"headerlink\" title=\"Class基本语法\"></a>Class基本语法</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">  <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</div></pre></td></tr></table></figure>\n<p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>\n<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。基本上，ES6的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5的构造函数<code>Point</code>，对应ES6的<code>Point</code>类的构造方法。</p>\n<p><code>Point</code>类除了构造方法，还定义了一个<code>toString</code>方法。注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>\n<p>ES6的类，完全可以看作构造函数的另一种写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typeof</span> Point <span class=\"comment\">// \"function\"</span></div><div class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>\n<p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> </span>&#123;</div><div class=\"line\">  doStuff() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'stuff'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Bar();</div><div class=\"line\">b.doStuff() <span class=\"comment\">// \"stuff\"</span></div></pre></td></tr></table></figure>\n<p>构造函数的<code>prototype</code>属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。<br>在类的实例上面调用方法，其实就是调用原型上的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</div><div class=\"line\"></div><div class=\"line\">b.constructor === B.prototype.constructor <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>b</code>是B类的实例，它的<code>constructor</code>方法就是B类原型的<code>constructor</code>方法。</p>\n<p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(Point.prototype, &#123;</div><div class=\"line\">  toString()&#123;&#125;,</div><div class=\"line\">  toValue()&#123;&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与ES5的行为是一致的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Point.prototype.constructor === Point <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</div><div class=\"line\"><span class=\"comment\">// []</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</div><div class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>toString</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Point = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</div><div class=\"line\"><span class=\"comment\">// [\"toString\"]</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</div><div class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></div></pre></td></tr></table></figure>\n<p>上面代码采用ES5的写法，<code>toString</code>方法就是可枚举的。</p>\n<a id=\"more\"></a>\n<h3 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h3><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>() &#123;&#125;</div></pre></td></tr></table></figure>\n<p><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Foo() <span class=\"keyword\">instanceof</span> Foo</div><div class=\"line\"><span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p>\n<p>类的构造函数，不使用<code>new</code>是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Foo()</div><div class=\"line\"><span class=\"comment\">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></div></pre></td></tr></table></figure>\n<h3 id=\"类的实例对象\"><a href=\"#类的实例对象\" class=\"headerlink\" title=\"类的实例对象\"></a>类的实例对象</h3><p>生成类的实例对象的写法，与ES5完全一样，也是使用<code>new</code>命令。如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> point = Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">point.toString() <span class=\"comment\">// (2, 3)</span></div><div class=\"line\"></div><div class=\"line\">point.hasOwnProperty(<span class=\"string\">'x'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">point.hasOwnProperty(<span class=\"string\">'y'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">point.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">// false</span></div><div class=\"line\">point.__proto__.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与ES5的行为保持一致。</p>\n<p>与ES5一样，类的所有实例共享一个原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">2</span>);</div><div class=\"line\"></div><div class=\"line\">p1.__proto__ === p2.__proto__</div><div class=\"line\"><span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>p1</code>和<code>p2</code>都是Point的实例，它们的原型都是Point，所以<code>__proto__</code>属性是相等的。</p>\n<p>这也意味着，可以通过实例的<code>__proto__</code>属性为Class添加方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">2</span>);</div><div class=\"line\"></div><div class=\"line\">p1.__proto__.printName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">'Oops'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\">p1.printName() <span class=\"comment\">// \"Oops\"</span></div><div class=\"line\">p2.printName() <span class=\"comment\">// \"Oops\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> Point(<span class=\"number\">4</span>,<span class=\"number\">2</span>);</div><div class=\"line\">p3.printName() <span class=\"comment\">// \"Oops\"</span></div></pre></td></tr></table></figure>\n<p>上面代码在<code>p1</code>的原型上添加了一个<code>printName</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。</p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Foo(); <span class=\"comment\">// ReferenceError</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> Foo = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;&#125;;</div><div class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码不会报错，因为<code>class</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>class</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p>\n<h3 id=\"Class表达式\"><a href=\"#Class表达式\" class=\"headerlink\" title=\"Class表达式\"></a>Class表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> MyClass = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Me</span> </span>&#123;</div><div class=\"line\">  getClassName() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Me.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>MyClass</code>而不是<code>Me</code>，<code>Me</code>只在Class的内部代码可用，指代当前类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> inst = <span class=\"keyword\">new</span> MyClass();</div><div class=\"line\">inst.getClassName() <span class=\"comment\">// Me</span></div><div class=\"line\">Me.name <span class=\"comment\">// ReferenceError: Me is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，<code>Me</code>只在Class内部有定义。</p>\n<p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> MyClass = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;;</div></pre></td></tr></table></figure>\n<p>采用Class表达式，可以写出立即执行的Class。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  sayName() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;(<span class=\"string\">'张三'</span>);</div><div class=\"line\"></div><div class=\"line\">person.sayName(); <span class=\"comment\">// \"张三\"</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p>\n<h3 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h3><p>私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。</p>\n<p>一种做法是在命名上加以区别。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 公有方法</span></div><div class=\"line\">  foo (baz) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._bar(baz);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 私有方法</span></div><div class=\"line\">  _bar(baz) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.snaf = baz;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>_bar</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>\n<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> </span>&#123;</div><div class=\"line\">  foo (baz) &#123;</div><div class=\"line\">    bar.call(<span class=\"keyword\">this</span>, baz);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">baz</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.snaf = baz;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>foo</code>是公有方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar</code>实际上成为了当前模块的私有方法。</p>\n<p>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'bar'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> snaf = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'snaf'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myClass</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 公有方法</span></div><div class=\"line\">  foo(baz) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>[bar](baz);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 私有方法</span></div><div class=\"line\">  [bar](baz) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>[snaf] = baz;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>\n<h3 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h3><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">  printName(name = <span class=\"string\">'there'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.print(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>`</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print(text) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(text);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"keyword\">new</span> Logger();</div><div class=\"line\"><span class=\"keyword\">const</span> &#123; printName &#125; = logger;</div><div class=\"line\">printName(); <span class=\"comment\">// TypeError: Cannot read property 'print' of undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境，因为找不到<code>print</code>方法而导致报错。</p>\n<p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.printName = <span class=\"keyword\">this</span>.printName.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另一种解决方法是使用箭头函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.printName = <span class=\"function\">(<span class=\"params\">name = <span class=\"string\">'there'</span></span>) =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.print(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>`</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h3><p>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;&#125;</div><div class=\"line\">Point.name <span class=\"comment\">// \"Point\"</span></div></pre></td></tr></table></figure>\n<p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p>\n<h2 id=\"Class的继承\"><a href=\"#Class的继承\" class=\"headerlink\" title=\"Class的继承\"></a>Class的继承</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>Class之间可以通过<code>extends</code>关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y, color) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(x, y); <span class=\"comment\">// 调用父类的constructor(x, y)</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color + <span class=\"string\">' '</span> + <span class=\"keyword\">super</span>.toString(); <span class=\"comment\">// 调用父类的toString()</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>\n<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"keyword\">new</span> ColorPoint(); <span class=\"comment\">// ReferenceError</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p>\n<p>ES5的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>\n<p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(...args) &#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>(...args);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y, color) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.color = color; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(x, y);</div><div class=\"line\">    <span class=\"keyword\">this</span>.color = color; <span class=\"comment\">// 正确</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p>\n<p>下面是生成子类实例的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">25</span>, <span class=\"number\">8</span>, <span class=\"string\">'green'</span>);</div><div class=\"line\"></div><div class=\"line\">cp <span class=\"keyword\">instanceof</span> ColorPoint <span class=\"comment\">// true</span></div><div class=\"line\">cp <span class=\"keyword\">instanceof</span> Point <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与ES5的行为完全一致。</p>\n<h3 id=\"类的prototype属性和-proto-属性\"><a href=\"#类的prototype属性和-proto-属性\" class=\"headerlink\" title=\"类的prototype属性和__proto__属性\"></a>类的prototype属性和__proto__属性</h3><p>大多数浏览器的ES5实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>\n<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>\n<p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">B.__proto__ === A <span class=\"comment\">// true</span></div><div class=\"line\">B.prototype.__proto__ === A.prototype <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p>\n<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型（<code>prototype</code>属性）是父类的实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.create(A.prototype);</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\">B.prototype.__proto__ = A.prototype;</div></pre></td></tr></table></figure>\n<h3 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a>Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(ColorPoint) === Point</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>\n<h3 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h3><p><code>super</code>这个关键字，有两种用法，含义不同。</p>\n<p>（1）作为函数调用时（即<code>super(...args)</code>），<code>super</code>代表父类的构造函数。</p>\n<p>（2）作为对象调用时（即<code>super.prop</code>或<code>super.method()</code>），<code>super</code>代表父类。注意，此时<code>super</code>既可以引用父类实例的属性和方法，也可以引用父类的静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">  get m() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._p * <span class=\"keyword\">super</span>._p;</div><div class=\"line\">  &#125;</div><div class=\"line\">  set m() &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'该属性只读'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，子类通过<code>super</code>关键字，调用父类实例的<code>_p</code>属性。</p>\n<p>由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"MyObject: \"</span> + <span class=\"keyword\">super</span>.toString();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">obj.toString(); <span class=\"comment\">// MyObject: [object Object]</span></div></pre></td></tr></table></figure>\n<h2 id=\"Class的取值函数（getter）和存值函数（setter）\"><a href=\"#Class的取值函数（getter）和存值函数（setter）\" class=\"headerlink\" title=\"Class的取值函数（getter）和存值函数（setter）\"></a>Class的取值函数（getter）和存值函数（setter）</h2><p>与ES5一样，在Class内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  get prop() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  set prop(value) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setter: '</span>+value);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> inst = <span class=\"keyword\">new</span> MyClass();</div><div class=\"line\"></div><div class=\"line\">inst.prop = <span class=\"number\">123</span>;</div><div class=\"line\"><span class=\"comment\">// setter: 123</span></div><div class=\"line\"></div><div class=\"line\">inst.prop</div><div class=\"line\"><span class=\"comment\">// 'getter'</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>\n<p>存值函数和取值函数是设置在属性的descriptor对象上的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomHTMLElement</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.element = element;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get html() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.element.innerHTML;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  set html(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.element.innerHTML = value;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(</div><div class=\"line\">  CustomHTMLElement.prototype, <span class=\"string\">\"html\"</span>);</div><div class=\"line\"><span class=\"string\">\"get\"</span> <span class=\"keyword\">in</span> descriptor  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"string\">\"set\"</span> <span class=\"keyword\">in</span> descriptor  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与ES5完全一致。</p>\n<h2 id=\"Class的静态方法\"><a href=\"#Class的静态方法\" class=\"headerlink\" title=\"Class的静态方法\"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示<strong>该方法不会被实例继承，而是直接通过类来调用</strong>，这就称为“静态方法”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Foo.classMethod() <span class=\"comment\">// 'hello'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</div><div class=\"line\">foo.classMethod()</div><div class=\"line\"><span class=\"comment\">// TypeError: foo.classMethod is not a function</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>\n<p>父类的静态方法，可以被子类继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Bar.classMethod(); <span class=\"comment\">// 'hello'</span></div></pre></td></tr></table></figure>\n<p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p>\n<p>静态方法也是可以从<code>super</code>对象上调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.classMethod() + <span class=\"string\">', too'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Bar.classMethod();</div></pre></td></tr></table></figure>\n<h2 id=\"Class的静态属性和实例属性\"><a href=\"#Class的静态属性和实例属性\" class=\"headerlink\" title=\"Class的静态属性和实例属性\"></a>Class的静态属性和实例属性</h2><p>静态属性指的是Class本身的属性，即<code>Class.propname</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Foo.prop = <span class=\"number\">1</span>;</div><div class=\"line\">Foo.prop <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p>\n<p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 以下两种写法都无效</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 写法一</span></div><div class=\"line\">  prop: <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 写法二</span></div><div class=\"line\">  <span class=\"keyword\">static</span> prop: <span class=\"number\">2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Foo.prop <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<hr>\n<p>ES7有一个静态属性的<a href=\"https://github.com/jeffmo/es-class-properties\" target=\"_blank\" rel=\"external\">提案</a>，目前Babel转码器支持。</p>\n<p>这个提案对实例属性和静态属性，都规定了新的写法。</p>\n<p>（1）类的实例属性</p>\n<p>类的实例属性可以用等式，写入类的定义之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</div><div class=\"line\">  myProp = <span class=\"number\">42</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.myProp); <span class=\"comment\">// 42</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>myProp</code>就是<code>MyClass</code>的实例属性。在<code>MyClass</code>的实例上，可以读取这个属性。</p>\n<p>以前，我们定义实例属性，只能写在类的<code>constructor</code>方法里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，构造方法<code>constructor</code>里面，定义了<code>this.state</code>属性。</p>\n<p>有了新的写法以后，可以不在<code>constructor</code>方法里面定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  state = &#123;</div><div class=\"line\">    <span class=\"attr\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种写法比以前更清晰。</p>\n<p>为了可读性的目的，对于那些在<code>constructor</code>里面已经定义的实例属性，新写法允许直接列出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  state;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）类的静态属性</p>\n<p>类的静态属性只要在上面的实例属性写法前面，加上<code>static</code>关键字就可以了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> myStaticProp = <span class=\"number\">42</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(MyClass.myProp); <span class=\"comment\">// 42</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，这个新写法大大方便了静态属性的表达。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 老写法</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Foo.prop = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 新写法</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> prop = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>\n<h2 id=\"new-target属性\"><a href=\"#new-target属性\" class=\"headerlink\" title=\"new.target属性\"></a>new.target属性</h2><p><code>new</code>是从构造函数生成实例的命令。ES6为<code>new</code>命令引入了一个<code>new.target</code>属性，（在构造函数中）返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>.target !== <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'必须使用new生成实例'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 另一种写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>.target === Person) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'必须使用new生成实例'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'张三'</span>); <span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">var</span> notAPerson = Person.call(person, <span class=\"string\">'张三'</span>);  <span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p>\n<p>Class内部调用<code>new.target</code>，返回当前Class。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(length, width) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span>.target === Rectangle);</div><div class=\"line\">    <span class=\"keyword\">this</span>.length = length;</div><div class=\"line\">    <span class=\"keyword\">this</span>.width = width;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>); <span class=\"comment\">// 输出 true</span></div></pre></td></tr></table></figure>\n<p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(length, width) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span>.target === Rectangle);</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(length) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(length, length);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Square(<span class=\"number\">3</span>); <span class=\"comment\">// 输出 false</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>new.target</code>会返回子类。</p>\n<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>.target === Shape) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'本类不能实例化'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(length, width) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>();</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> Shape();  <span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>);  <span class=\"comment\">// 正确</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Shape</code>类不能被实例化，只能用于继承。</p>\n<p>注意，在函数外部，使用<code>new.target</code>会报错。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Class基本语法\"><a href=\"#Class基本语法\" class=\"headerlink\" title=\"Class基本语法\"></a>Class基本语法</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">  <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</div></pre></td></tr></table></figure>\n<p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>\n<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。基本上，ES6的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5的构造函数<code>Point</code>，对应ES6的<code>Point</code>类的构造方法。</p>\n<p><code>Point</code>类除了构造方法，还定义了一个<code>toString</code>方法。注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>\n<p>ES6的类，完全可以看作构造函数的另一种写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typeof</span> Point <span class=\"comment\">// \"function\"</span></div><div class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>\n<p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> </span>&#123;</div><div class=\"line\">  doStuff() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'stuff'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> Bar();</div><div class=\"line\">b.doStuff() <span class=\"comment\">// \"stuff\"</span></div></pre></td></tr></table></figure>\n<p>构造函数的<code>prototype</code>属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。<br>在类的实例上面调用方法，其实就是调用原型上的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</div><div class=\"line\"></div><div class=\"line\">b.constructor === B.prototype.constructor <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>b</code>是B类的实例，它的<code>constructor</code>方法就是B类原型的<code>constructor</code>方法。</p>\n<p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(Point.prototype, &#123;</div><div class=\"line\">  toString()&#123;&#125;,</div><div class=\"line\">  toValue()&#123;&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与ES5的行为是一致的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Point.prototype.constructor === Point <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</div><div class=\"line\"><span class=\"comment\">// []</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</div><div class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>toString</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Point = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Point.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</div><div class=\"line\"><span class=\"comment\">// [\"toString\"]</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</div><div class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></div></pre></td></tr></table></figure>\n<p>上面代码采用ES5的写法，<code>toString</code>方法就是可枚举的。</p>","more":"<h3 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h3><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>() &#123;&#125;</div></pre></td></tr></table></figure>\n<p><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Foo() <span class=\"keyword\">instanceof</span> Foo</div><div class=\"line\"><span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p>\n<p>类的构造函数，不使用<code>new</code>是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Foo()</div><div class=\"line\"><span class=\"comment\">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></div></pre></td></tr></table></figure>\n<h3 id=\"类的实例对象\"><a href=\"#类的实例对象\" class=\"headerlink\" title=\"类的实例对象\"></a>类的实例对象</h3><p>生成类的实例对象的写法，与ES5完全一样，也是使用<code>new</code>命令。如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> point = Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//定义类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">point.toString() <span class=\"comment\">// (2, 3)</span></div><div class=\"line\"></div><div class=\"line\">point.hasOwnProperty(<span class=\"string\">'x'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">point.hasOwnProperty(<span class=\"string\">'y'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">point.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">// false</span></div><div class=\"line\">point.__proto__.hasOwnProperty(<span class=\"string\">'toString'</span>) <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与ES5的行为保持一致。</p>\n<p>与ES5一样，类的所有实例共享一个原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">2</span>);</div><div class=\"line\"></div><div class=\"line\">p1.__proto__ === p2.__proto__</div><div class=\"line\"><span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>p1</code>和<code>p2</code>都是Point的实例，它们的原型都是Point，所以<code>__proto__</code>属性是相等的。</p>\n<p>这也意味着，可以通过实例的<code>__proto__</code>属性为Class添加方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>,<span class=\"number\">2</span>);</div><div class=\"line\"></div><div class=\"line\">p1.__proto__.printName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">'Oops'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\">p1.printName() <span class=\"comment\">// \"Oops\"</span></div><div class=\"line\">p2.printName() <span class=\"comment\">// \"Oops\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p3 = <span class=\"keyword\">new</span> Point(<span class=\"number\">4</span>,<span class=\"number\">2</span>);</div><div class=\"line\">p3.printName() <span class=\"comment\">// \"Oops\"</span></div></pre></td></tr></table></figure>\n<p>上面代码在<code>p1</code>的原型上添加了一个<code>printName</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。</p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Foo(); <span class=\"comment\">// ReferenceError</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> Foo = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;&#125;;</div><div class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码不会报错，因为<code>class</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>class</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p>\n<h3 id=\"Class表达式\"><a href=\"#Class表达式\" class=\"headerlink\" title=\"Class表达式\"></a>Class表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> MyClass = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Me</span> </span>&#123;</div><div class=\"line\">  getClassName() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Me.name;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>MyClass</code>而不是<code>Me</code>，<code>Me</code>只在Class的内部代码可用，指代当前类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> inst = <span class=\"keyword\">new</span> MyClass();</div><div class=\"line\">inst.getClassName() <span class=\"comment\">// Me</span></div><div class=\"line\">Me.name <span class=\"comment\">// ReferenceError: Me is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，<code>Me</code>只在Class内部有定义。</p>\n<p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> MyClass = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;;</div></pre></td></tr></table></figure>\n<p>采用Class表达式，可以写出立即执行的Class。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  sayName() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;(<span class=\"string\">'张三'</span>);</div><div class=\"line\"></div><div class=\"line\">person.sayName(); <span class=\"comment\">// \"张三\"</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p>\n<h3 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h3><p>私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。</p>\n<p>一种做法是在命名上加以区别。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 公有方法</span></div><div class=\"line\">  foo (baz) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._bar(baz);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 私有方法</span></div><div class=\"line\">  _bar(baz) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.snaf = baz;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>_bar</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>\n<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> </span>&#123;</div><div class=\"line\">  foo (baz) &#123;</div><div class=\"line\">    bar.call(<span class=\"keyword\">this</span>, baz);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">baz</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.snaf = baz;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>foo</code>是公有方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar</code>实际上成为了当前模块的私有方法。</p>\n<p>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'bar'</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> snaf = <span class=\"built_in\">Symbol</span>(<span class=\"string\">'snaf'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myClass</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 公有方法</span></div><div class=\"line\">  foo(baz) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>[bar](baz);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 私有方法</span></div><div class=\"line\">  [bar](baz) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>[snaf] = baz;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>\n<h3 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h3><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">  printName(name = <span class=\"string\">'there'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.print(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>`</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  print(text) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(text);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"keyword\">new</span> Logger();</div><div class=\"line\"><span class=\"keyword\">const</span> &#123; printName &#125; = logger;</div><div class=\"line\">printName(); <span class=\"comment\">// TypeError: Cannot read property 'print' of undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境，因为找不到<code>print</code>方法而导致报错。</p>\n<p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.printName = <span class=\"keyword\">this</span>.printName.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另一种解决方法是使用箭头函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.printName = <span class=\"function\">(<span class=\"params\">name = <span class=\"string\">'there'</span></span>) =&gt;</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.print(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>`</span>);</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h3><p>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;&#125;</div><div class=\"line\">Point.name <span class=\"comment\">// \"Point\"</span></div></pre></td></tr></table></figure>\n<p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p>\n<h2 id=\"Class的继承\"><a href=\"#Class的继承\" class=\"headerlink\" title=\"Class的继承\"></a>Class的继承</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>Class之间可以通过<code>extends</code>关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y, color) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(x, y); <span class=\"comment\">// 调用父类的constructor(x, y)</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.color = color;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color + <span class=\"string\">' '</span> + <span class=\"keyword\">super</span>.toString(); <span class=\"comment\">// 调用父类的toString()</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>\n<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"keyword\">new</span> ColorPoint(); <span class=\"comment\">// ReferenceError</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p>\n<p>ES5的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>\n<p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">constructor</span>(...args) &#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>(...args);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有<code>super</code>方法才能返回父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">    <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(x, y, color) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.color = color; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(x, y);</div><div class=\"line\">    <span class=\"keyword\">this</span>.color = color; <span class=\"comment\">// 正确</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p>\n<p>下面是生成子类实例的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"keyword\">new</span> ColorPoint(<span class=\"number\">25</span>, <span class=\"number\">8</span>, <span class=\"string\">'green'</span>);</div><div class=\"line\"></div><div class=\"line\">cp <span class=\"keyword\">instanceof</span> ColorPoint <span class=\"comment\">// true</span></div><div class=\"line\">cp <span class=\"keyword\">instanceof</span> Point <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与ES5的行为完全一致。</p>\n<h3 id=\"类的prototype属性和-proto-属性\"><a href=\"#类的prototype属性和-proto-属性\" class=\"headerlink\" title=\"类的prototype属性和__proto__属性\"></a>类的prototype属性和__proto__属性</h3><p>大多数浏览器的ES5实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>\n<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>\n<p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">B.__proto__ === A <span class=\"comment\">// true</span></div><div class=\"line\">B.prototype.__proto__ === A.prototype <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p>\n<p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型（<code>prototype</code>属性）是父类的实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.create(A.prototype);</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\">B.prototype.__proto__ = A.prototype;</div></pre></td></tr></table></figure>\n<h3 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a>Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(ColorPoint) === Point</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>\n<h3 id=\"super关键字\"><a href=\"#super关键字\" class=\"headerlink\" title=\"super关键字\"></a>super关键字</h3><p><code>super</code>这个关键字，有两种用法，含义不同。</p>\n<p>（1）作为函数调用时（即<code>super(...args)</code>），<code>super</code>代表父类的构造函数。</p>\n<p>（2）作为对象调用时（即<code>super.prop</code>或<code>super.method()</code>），<code>super</code>代表父类。注意，此时<code>super</code>既可以引用父类实例的属性和方法，也可以引用父类的静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">  get m() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._p * <span class=\"keyword\">super</span>._p;</div><div class=\"line\">  &#125;</div><div class=\"line\">  set m() &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'该属性只读'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，子类通过<code>super</code>关键字，调用父类实例的<code>_p</code>属性。</p>\n<p>由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">  toString() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"MyObject: \"</span> + <span class=\"keyword\">super</span>.toString();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">obj.toString(); <span class=\"comment\">// MyObject: [object Object]</span></div></pre></td></tr></table></figure>\n<h2 id=\"Class的取值函数（getter）和存值函数（setter）\"><a href=\"#Class的取值函数（getter）和存值函数（setter）\" class=\"headerlink\" title=\"Class的取值函数（getter）和存值函数（setter）\"></a>Class的取值函数（getter）和存值函数（setter）</h2><p>与ES5一样，在Class内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  get prop() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  set prop(value) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setter: '</span>+value);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> inst = <span class=\"keyword\">new</span> MyClass();</div><div class=\"line\"></div><div class=\"line\">inst.prop = <span class=\"number\">123</span>;</div><div class=\"line\"><span class=\"comment\">// setter: 123</span></div><div class=\"line\"></div><div class=\"line\">inst.prop</div><div class=\"line\"><span class=\"comment\">// 'getter'</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>\n<p>存值函数和取值函数是设置在属性的descriptor对象上的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomHTMLElement</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(element) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.element = element;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  get html() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.element.innerHTML;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  set html(value) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.element.innerHTML = value;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(</div><div class=\"line\">  CustomHTMLElement.prototype, <span class=\"string\">\"html\"</span>);</div><div class=\"line\"><span class=\"string\">\"get\"</span> <span class=\"keyword\">in</span> descriptor  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"string\">\"set\"</span> <span class=\"keyword\">in</span> descriptor  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与ES5完全一致。</p>\n<h2 id=\"Class的静态方法\"><a href=\"#Class的静态方法\" class=\"headerlink\" title=\"Class的静态方法\"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示<strong>该方法不会被实例继承，而是直接通过类来调用</strong>，这就称为“静态方法”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Foo.classMethod() <span class=\"comment\">// 'hello'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</div><div class=\"line\">foo.classMethod()</div><div class=\"line\"><span class=\"comment\">// TypeError: foo.classMethod is not a function</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>\n<p>父类的静态方法，可以被子类继承。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Bar.classMethod(); <span class=\"comment\">// 'hello'</span></div></pre></td></tr></table></figure>\n<p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p>\n<p>静态方法也是可以从<code>super</code>对象上调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.classMethod() + <span class=\"string\">', too'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Bar.classMethod();</div></pre></td></tr></table></figure>\n<h2 id=\"Class的静态属性和实例属性\"><a href=\"#Class的静态属性和实例属性\" class=\"headerlink\" title=\"Class的静态属性和实例属性\"></a>Class的静态属性和实例属性</h2><p>静态属性指的是Class本身的属性，即<code>Class.propname</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Foo.prop = <span class=\"number\">1</span>;</div><div class=\"line\">Foo.prop <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p>\n<p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 以下两种写法都无效</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 写法一</span></div><div class=\"line\">  prop: <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 写法二</span></div><div class=\"line\">  <span class=\"keyword\">static</span> prop: <span class=\"number\">2</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Foo.prop <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<hr>\n<p>ES7有一个静态属性的<a href=\"https://github.com/jeffmo/es-class-properties\" target=\"_blank\" rel=\"external\">提案</a>，目前Babel转码器支持。</p>\n<p>这个提案对实例属性和静态属性，都规定了新的写法。</p>\n<p>（1）类的实例属性</p>\n<p>类的实例属性可以用等式，写入类的定义之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</div><div class=\"line\">  myProp = <span class=\"number\">42</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.myProp); <span class=\"comment\">// 42</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>myProp</code>就是<code>MyClass</code>的实例属性。在<code>MyClass</code>的实例上，可以读取这个属性。</p>\n<p>以前，我们定义实例属性，只能写在类的<code>constructor</code>方法里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，构造方法<code>constructor</code>里面，定义了<code>this.state</code>属性。</p>\n<p>有了新的写法以后，可以不在<code>constructor</code>方法里面定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  state = &#123;</div><div class=\"line\">    <span class=\"attr\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种写法比以前更清晰。</p>\n<p>为了可读性的目的，对于那些在<code>constructor</code>里面已经定义的实例属性，新写法允许直接列出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactCounter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(props);</div><div class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</div><div class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  state;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>（2）类的静态属性</p>\n<p>类的静态属性只要在上面的实例属性写法前面，加上<code>static</code>关键字就可以了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> myStaticProp = <span class=\"number\">42</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(MyClass.myProp); <span class=\"comment\">// 42</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，这个新写法大大方便了静态属性的表达。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 老写法</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Foo.prop = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 新写法</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> prop = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>\n<h2 id=\"new-target属性\"><a href=\"#new-target属性\" class=\"headerlink\" title=\"new.target属性\"></a>new.target属性</h2><p><code>new</code>是从构造函数生成实例的命令。ES6为<code>new</code>命令引入了一个<code>new.target</code>属性，（在构造函数中）返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>.target !== <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'必须使用new生成实例'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 另一种写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>.target === Person) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'必须使用new生成实例'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'张三'</span>); <span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">var</span> notAPerson = Person.call(person, <span class=\"string\">'张三'</span>);  <span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p>\n<p>Class内部调用<code>new.target</code>，返回当前Class。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(length, width) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span>.target === Rectangle);</div><div class=\"line\">    <span class=\"keyword\">this</span>.length = length;</div><div class=\"line\">    <span class=\"keyword\">this</span>.width = width;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>); <span class=\"comment\">// 输出 true</span></div></pre></td></tr></table></figure>\n<p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(length, width) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span>.target === Rectangle);</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Rectangle</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(length) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>(length, length);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Square(<span class=\"number\">3</span>); <span class=\"comment\">// 输出 false</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>new.target</code>会返回子类。</p>\n<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">new</span>.target === Shape) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'本类不能实例化'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(length, width) &#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>();</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> Shape();  <span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">3</span>, <span class=\"number\">4</span>);  <span class=\"comment\">// 正确</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>Shape</code>类不能被实例化，只能用于继承。</p>\n<p>注意，在函数外部，使用<code>new.target</code>会报错。</p>"},{"title":"ES2015之let 和 const","date":"2016-10-29T03:45:52.000Z","_content":"## let命令\n\n### 基本用法\n\nES6新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。\n\n```javascript\n{\n  let a = 10;\n  var b = 1;\n}\n\na // ReferenceError: a is not defined.\nb // 1\n```\n\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\n\n`for`循环的计数器，就很合适使用`let`命令。\n\n```javascript\nfor (let i = 0; i < 10; i++) {}\n\nconsole.log(i);\n//ReferenceError: i is not defined\n```\n\n上面代码中，计数器`i`只在`for`循环体内有效，在循环体外引用就会报错。\n\n下面的代码如果使用`var`，最后输出的是10。\n\n```javascript\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n```\n\n上面代码中，变量`i`是`var`声明的，在全局范围内都有效。所以每一次循环，新的`i`值都会覆盖旧值，导致最后输出的是最后一轮的`i`的值。\n\n如果使用`let`，声明的变量仅在块级作用域内有效，最后输出的是6。\n\n```javascript\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n```\n\n上面代码中，变量`i`是`let`声明的，当前的`i`只在本轮循环有效，所以每一次循环的`i`其实都是一个新的变量，所以最后输出的是6。\n\n### 不存在变量提升\n\n`let`不像`var`那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。\n\n```javascript\nconsole.log(foo); // 输出undefined\nconsole.log(bar); // 报错ReferenceError\n\nvar foo = 2;\nlet bar = 2;\n```\n\n上面代码中，变量`foo`用`var`命令声明，会发生变量提升，即脚本开始运行时，变量`foo`已经存在了，但是没有值，所以会输出`undefined`。变量`bar`用`let`命令声明，不会发生变量提升。这表示在声明它之前，变量`bar`是不存在的，这时如果用到它，就会抛出一个错误。\n<!--more-->\n### 暂时性死区\n\n只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n\n```javascript\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // ReferenceError\n  let tmp;\n}\n```\n\n上面代码中，存在全局变量`tmp`，但是块级作用域内`let`又声明了一个局部变量`tmp`，导致后者绑定这个块级作用域，所以在`let`声明变量前，对`tmp`赋值会报错。\n\nES6明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。\n\n```javascript\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n```\n\n上面代码中，在`let`命令声明变量`tmp`之前，都属于变量`tmp`的“死区”。\n\n“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。\n\n```javascript\ntypeof x; // ReferenceError\nlet x;\n```\n\n上面代码中，变量`x`使用`let`命令声明，所以在声明之前，都属于`x`的“死区”，只要用到该变量就会报错。因此，`typeof`运行时就会抛出一个`ReferenceError`。\n\n作为比较，如果一个变量根本没有被声明，使用`typeof`反而不会报错。\n\n```javascript\ntypeof undeclared_variable // \"undefined\"\n```\n\n上面代码中，`undeclared_variable`是一个不存在的变量名，结果返回“undefined”。所以，在没有`let`之前，`typeof`运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。\n\n有些“死区”比较隐蔽，不太容易发现。\n\n```javascript\nfunction bar(x = y, y = 2) {\n  return [x, y];\n}\n\nbar(); // 报错\n```\n\n上面代码中，调用`bar`函数之所以报错（某些实现可能不报错），是因为参数`x`默认值等于另一个参数`y`，而此时`y`还没有声明，属于”死区“。如果`y`的默认值是`x`，就不会报错，因为此时`x`已经声明了。\n\n```javascript\nfunction bar(x = 2, y = x) {\n  return [x, y];\n}\nbar(); // [2, 2]\n```\n\nES6规定暂时性死区和`let`、`const`语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。\n\n总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\n### 不允许重复声明\n\nlet不允许在相同作用域内，重复声明同一个变量。\n\n```javascript\n// 报错\nfunction () {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction () {\n  let a = 10;\n  let a = 1;\n}\n```\n\n因此，不能在函数内部重新声明参数。\n\n```javascript\nfunction func(arg) {\n  let arg; // 报错\n}\n\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}\n```\n\n## 块级作用域\n\n### 为什么需要块级作用域？\n\nES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。\n\n第一种场景，内层变量可能会覆盖外层变量。\n\n```javascript\nvar tmp = new Date();\n\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = \"hello world\";\n  }\n}\n\nf(); // undefined\n```\n\n上面代码中，函数f执行后，输出结果为`undefined`，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。\n\n第二种场景，用来计数的循环变量泄露为全局变量。\n\n```javascript\nvar s = 'hello';\n\nfor (var i = 0; i < s.length; i++) {\n  console.log(s[i]);\n}\n\nconsole.log(i); // 5\n```\n\n上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。\n\n### ES6的块级作用域\n\n`let`实际上为JavaScript新增了块级作用域。\n\n```javascript\nfunction f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n```\n\n上面的函数有两个代码块，都声明了变量`n`，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用`var`定义变量`n`，最后输出的值就是10。\n\nES6允许块级作用域的任意嵌套。\n\n```javascript\n{{{{{let insane = 'Hello World'}}}}};\n```\n\n上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。\n\n```javascript\n{{{{\n  {let insane = 'Hello World'}\n  console.log(insane); // 报错\n}}}};\n```\n\n内层作用域可以定义外层作用域的同名变量。\n\n```javascript\n{{{{\n  let insane = 'Hello World';\n  {let insane = 'Hello World'}\n}}}};\n```\n\n块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。\n\n```javascript\n// IIFE写法\n(function () {\n  var tmp = ...;\n  ...\n}());\n\n// 块级作用域写法\n{\n  let tmp = ...;\n  ...\n}\n```\n\n### 块级作用域与函数声明\n\n函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。\n\nES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。\n\n```javascript\n// 情况一\nif (true) {\n  function f() {}\n}\n\n// 情况二\ntry {\n  function f() {}\n} catch(e) {\n}\n```\n\n上面代码的两种函数声明，根据ES5的规定都是非法的。\n\n但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。\n\n```javascript\n// ES5严格模式\n'use strict';\nif (true) {\n  function f() {}\n}\n// 报错\n```\n\nES6引入了块级作用域，明确允许在块级作用域之中声明函数。\n\n```javascript\n// ES6严格模式\n'use strict';\nif (true) {\n  function f() {}\n}\n// 不报错\n```\n\n并且ES6规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。\n\n```javascript\nfunction f() { console.log('I am outside!'); }\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n```\n\n上面代码在ES5中运行，会得到“I am inside!”，因为在`if`内声明的函数`f`会被提升到函数头部，实际运行的代码如下。\n\n```javascript\n// ES5版本\nfunction f() { console.log('I am outside!'); }\n(function () {\n  function f() { console.log('I am inside!'); }\n  if (false) {\n  }\n  f();\n}());\n```\n\nES6的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于`let`，对作用域之外没有影响，实际运行的代码如下。\n\n```javascript\n// ES6版本\nfunction f() { console.log('I am outside!'); }\n(function () {\n  f();\n}());\n```\n\n很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在[附录B](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics)里面规定，浏览器的实现可以不遵守上面的规定，有自己的[行为方式](http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6)。\n\n- 允许在块级作用域内声明函数。\n- 函数声明类似于`var`，即会提升到全局作用域或函数作用域的头部。\n- 同时，函数声明还会提升到所在的块级作用域的头部。\n\n注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作`let`处理。\n\n前面那段代码，在Chrome环境下运行会报错。\n\n```javascript\n// ES6的浏览器环境\nfunction f() { console.log('I am outside!'); }\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n// Uncaught TypeError: f is not a function\n```\n\n上面的代码报错，是因为实际运行的是下面的代码。\n\n```javascript\n// ES6的浏览器环境\nfunction f() { console.log('I am outside!'); }\n(function () {\n  var f = undefined;\n  if (false) {\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n// Uncaught TypeError: f is not a function\n```\n\n考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。\n\n```javascript\n// 函数声明语句\n{\n  let a = 'secret';\n  function f() {\n    return a;\n  }\n}\n\n// 函数表达式\n{\n  let a = 'secret';\n  let f = function () {\n    return a;\n  };\n}\n```\n\n另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。\n\n```javascript\n// 不报错\n'use strict';\nif (true) {\n  function f() {}\n}\n\n// 报错\n'use strict';\nif (true)\n  function f() {}\n```\n\n## const命令\n\n`const`声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n```javascript\nconst PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: Assignment to constant variable.\n```\n\n上面代码表明改变常量的值会报错。\n\n`const`声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。\n\n```javascript\nconst foo;\n// SyntaxError: Missing initializer in const declaration\n```\n\n上面代码表示，对于`const`来说，只声明不赋值，就会报错。\n\n`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。\n\n```javascript\nif (true) {\n  const MAX = 5;\n}\n\nMAX // Uncaught ReferenceError: MAX is not defined\n```\n\n`const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。\n\n```javascript\nif (true) {\n  console.log(MAX); // ReferenceError\n  const MAX = 5;\n}\n```\n\n上面代码在常量`MAX`声明之前就调用，结果报错。\n\n`const`声明的常量，也与`let`一样不可重复声明。\n\n```javascript\nvar message = \"Hello!\";\nlet age = 25;\n\n// 以下两行都会报错\nconst message = \"Goodbye!\";\nconst age = 30;\n```\n\n对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。`const`命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。\n\n```javascript\nconst foo = {};\nfoo.prop = 123;\n\nfoo.prop\n// 123\n\nfoo = {}; // TypeError: \"foo\" is read-only\n```\n\n上面代码中，常量`foo`储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把`foo`指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\n\n下面是另一个例子。\n\n```js\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报错\n```\n\n上面代码中，常量`a`是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给`a`，就会报错。\n\n如果真的想将对象冻结，应该使用`Object.freeze`方法。\n\n```javascript\nconst foo = Object.freeze({});\n\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n```\n\n上面代码中，常量`foo`指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。\n\n除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。\n\n```javascript\nvar constantize = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach( (key, value) => {\n    if ( typeof obj[key] === 'object' ) {\n      constantize( obj[key] );\n    }\n  });\n};\n```\n\nES5只有两种声明变量的方法：`var`命令和`function`命令。ES6除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令。所以，ES6一共有6种声明变量的方法。\n\n## 顶层对象的属性\n\n顶层对象，在浏览器环境指的是`window`对象，在Node指的是`global`对象。ES5之中，顶层对象的属性与全局变量是等价的。\n\n```javascript\nwindow.a = 1;\na // 1\n\na = 2;\nwindow.a // 2\n```\n\n上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。\n\n顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，`window`对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。\n\nES6为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。\n\n```javascript\nvar a = 1;\n// 如果在Node的REPL环境，可以写成global.a\n// 或者采用通用方法，写成this.a\nwindow.a // 1\n\nlet b = 1;\nwindow.b // undefined\n```\n\n上面代码中，全局变量`a`由`var`命令声明，所以它是顶层对象的属性；全局变量`b`由`let`命令声明，所以它不是顶层对象的属性，返回`undefined`。\n\n## 顶层对象\n\nES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。\n\n- 浏览器里面，顶层对象是`window`，但Node和Web Worker没有`window`。\n- 浏览器和Web Worker里面，`self`也指向顶层对象，但是Node没有`self`。\n- Node里面，顶层对象是`global`，但其他环境都不支持。\n\n同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用`this`变量，但是有局限性。\n\n- 全局环境中，`this`会返回顶层对象。但是，Node模块和ES6模块中，`this`返回的是当前模块。\n- 函数里面的`this`，如果函数不是作为对象的方法运行，而是单纯作为函数运行，`this`会指向顶层对象。但是，严格模式下，这时`this`会返回`undefined`。\n- 不管是严格模式，还是普通模式，`new Function('return this')()`，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么`eval`、`new Function`这些方法都可能无法使用。\n\n综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。\n\n```javascript\n// 方法一\n(typeof window !== 'undefined'\n   ? window\n   : (typeof process === 'object' &&\n      typeof require === 'function' &&\n      typeof global === 'object')\n     ? global\n     : this);\n\n// 方法二\nvar getGlobal = function () {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n```\n\n现在有一个[提案](https://github.com/tc39/proposal-global)，在语言标准的层面，引入`global`作为顶层对象。也就是说，在所有环境下，`global`都是存在的，都可以从它拿到顶层对象。\n\n垫片库[`system.global`](https://github.com/ljharb/System.global)模拟了这个提案，可以在所有环境拿到`global`。\n\n```javascript\n// CommonJS的写法\nrequire('system.global/shim')();\n\n// ES6模块的写法\nimport shim from 'system.global/shim'; shim();\n```\n\n上面代码可以保证各种环境里面，`global`对象都是存在的。\n\n```javascript\n// CommonJS的写法\nvar global = require('system.global')();\n\n// ES6模块的写法\nimport getGlobal from 'system.global';\nconst global = getGlobal();\n```\n\n上面代码将顶层对象放入变量`global`。\n\n\n\n","source":"_posts/ES2015之let-和-const.md","raw":"---\ntitle: ES2015之let 和 const\ndate: 2016-10-29 11:45:52\ntags: ES2015\n---\n## let命令\n\n### 基本用法\n\nES6新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。\n\n```javascript\n{\n  let a = 10;\n  var b = 1;\n}\n\na // ReferenceError: a is not defined.\nb // 1\n```\n\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\n\n`for`循环的计数器，就很合适使用`let`命令。\n\n```javascript\nfor (let i = 0; i < 10; i++) {}\n\nconsole.log(i);\n//ReferenceError: i is not defined\n```\n\n上面代码中，计数器`i`只在`for`循环体内有效，在循环体外引用就会报错。\n\n下面的代码如果使用`var`，最后输出的是10。\n\n```javascript\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n```\n\n上面代码中，变量`i`是`var`声明的，在全局范围内都有效。所以每一次循环，新的`i`值都会覆盖旧值，导致最后输出的是最后一轮的`i`的值。\n\n如果使用`let`，声明的变量仅在块级作用域内有效，最后输出的是6。\n\n```javascript\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n```\n\n上面代码中，变量`i`是`let`声明的，当前的`i`只在本轮循环有效，所以每一次循环的`i`其实都是一个新的变量，所以最后输出的是6。\n\n### 不存在变量提升\n\n`let`不像`var`那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。\n\n```javascript\nconsole.log(foo); // 输出undefined\nconsole.log(bar); // 报错ReferenceError\n\nvar foo = 2;\nlet bar = 2;\n```\n\n上面代码中，变量`foo`用`var`命令声明，会发生变量提升，即脚本开始运行时，变量`foo`已经存在了，但是没有值，所以会输出`undefined`。变量`bar`用`let`命令声明，不会发生变量提升。这表示在声明它之前，变量`bar`是不存在的，这时如果用到它，就会抛出一个错误。\n<!--more-->\n### 暂时性死区\n\n只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n\n```javascript\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // ReferenceError\n  let tmp;\n}\n```\n\n上面代码中，存在全局变量`tmp`，但是块级作用域内`let`又声明了一个局部变量`tmp`，导致后者绑定这个块级作用域，所以在`let`声明变量前，对`tmp`赋值会报错。\n\nES6明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。\n\n```javascript\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n```\n\n上面代码中，在`let`命令声明变量`tmp`之前，都属于变量`tmp`的“死区”。\n\n“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。\n\n```javascript\ntypeof x; // ReferenceError\nlet x;\n```\n\n上面代码中，变量`x`使用`let`命令声明，所以在声明之前，都属于`x`的“死区”，只要用到该变量就会报错。因此，`typeof`运行时就会抛出一个`ReferenceError`。\n\n作为比较，如果一个变量根本没有被声明，使用`typeof`反而不会报错。\n\n```javascript\ntypeof undeclared_variable // \"undefined\"\n```\n\n上面代码中，`undeclared_variable`是一个不存在的变量名，结果返回“undefined”。所以，在没有`let`之前，`typeof`运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。\n\n有些“死区”比较隐蔽，不太容易发现。\n\n```javascript\nfunction bar(x = y, y = 2) {\n  return [x, y];\n}\n\nbar(); // 报错\n```\n\n上面代码中，调用`bar`函数之所以报错（某些实现可能不报错），是因为参数`x`默认值等于另一个参数`y`，而此时`y`还没有声明，属于”死区“。如果`y`的默认值是`x`，就不会报错，因为此时`x`已经声明了。\n\n```javascript\nfunction bar(x = 2, y = x) {\n  return [x, y];\n}\nbar(); // [2, 2]\n```\n\nES6规定暂时性死区和`let`、`const`语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。\n\n总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\n### 不允许重复声明\n\nlet不允许在相同作用域内，重复声明同一个变量。\n\n```javascript\n// 报错\nfunction () {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction () {\n  let a = 10;\n  let a = 1;\n}\n```\n\n因此，不能在函数内部重新声明参数。\n\n```javascript\nfunction func(arg) {\n  let arg; // 报错\n}\n\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}\n```\n\n## 块级作用域\n\n### 为什么需要块级作用域？\n\nES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。\n\n第一种场景，内层变量可能会覆盖外层变量。\n\n```javascript\nvar tmp = new Date();\n\nfunction f() {\n  console.log(tmp);\n  if (false) {\n    var tmp = \"hello world\";\n  }\n}\n\nf(); // undefined\n```\n\n上面代码中，函数f执行后，输出结果为`undefined`，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。\n\n第二种场景，用来计数的循环变量泄露为全局变量。\n\n```javascript\nvar s = 'hello';\n\nfor (var i = 0; i < s.length; i++) {\n  console.log(s[i]);\n}\n\nconsole.log(i); // 5\n```\n\n上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。\n\n### ES6的块级作用域\n\n`let`实际上为JavaScript新增了块级作用域。\n\n```javascript\nfunction f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n```\n\n上面的函数有两个代码块，都声明了变量`n`，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用`var`定义变量`n`，最后输出的值就是10。\n\nES6允许块级作用域的任意嵌套。\n\n```javascript\n{{{{{let insane = 'Hello World'}}}}};\n```\n\n上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。\n\n```javascript\n{{{{\n  {let insane = 'Hello World'}\n  console.log(insane); // 报错\n}}}};\n```\n\n内层作用域可以定义外层作用域的同名变量。\n\n```javascript\n{{{{\n  let insane = 'Hello World';\n  {let insane = 'Hello World'}\n}}}};\n```\n\n块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。\n\n```javascript\n// IIFE写法\n(function () {\n  var tmp = ...;\n  ...\n}());\n\n// 块级作用域写法\n{\n  let tmp = ...;\n  ...\n}\n```\n\n### 块级作用域与函数声明\n\n函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。\n\nES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。\n\n```javascript\n// 情况一\nif (true) {\n  function f() {}\n}\n\n// 情况二\ntry {\n  function f() {}\n} catch(e) {\n}\n```\n\n上面代码的两种函数声明，根据ES5的规定都是非法的。\n\n但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。\n\n```javascript\n// ES5严格模式\n'use strict';\nif (true) {\n  function f() {}\n}\n// 报错\n```\n\nES6引入了块级作用域，明确允许在块级作用域之中声明函数。\n\n```javascript\n// ES6严格模式\n'use strict';\nif (true) {\n  function f() {}\n}\n// 不报错\n```\n\n并且ES6规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。\n\n```javascript\nfunction f() { console.log('I am outside!'); }\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n```\n\n上面代码在ES5中运行，会得到“I am inside!”，因为在`if`内声明的函数`f`会被提升到函数头部，实际运行的代码如下。\n\n```javascript\n// ES5版本\nfunction f() { console.log('I am outside!'); }\n(function () {\n  function f() { console.log('I am inside!'); }\n  if (false) {\n  }\n  f();\n}());\n```\n\nES6的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于`let`，对作用域之外没有影响，实际运行的代码如下。\n\n```javascript\n// ES6版本\nfunction f() { console.log('I am outside!'); }\n(function () {\n  f();\n}());\n```\n\n很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在[附录B](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics)里面规定，浏览器的实现可以不遵守上面的规定，有自己的[行为方式](http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6)。\n\n- 允许在块级作用域内声明函数。\n- 函数声明类似于`var`，即会提升到全局作用域或函数作用域的头部。\n- 同时，函数声明还会提升到所在的块级作用域的头部。\n\n注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作`let`处理。\n\n前面那段代码，在Chrome环境下运行会报错。\n\n```javascript\n// ES6的浏览器环境\nfunction f() { console.log('I am outside!'); }\n(function () {\n  if (false) {\n    // 重复声明一次函数f\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n// Uncaught TypeError: f is not a function\n```\n\n上面的代码报错，是因为实际运行的是下面的代码。\n\n```javascript\n// ES6的浏览器环境\nfunction f() { console.log('I am outside!'); }\n(function () {\n  var f = undefined;\n  if (false) {\n    function f() { console.log('I am inside!'); }\n  }\n\n  f();\n}());\n// Uncaught TypeError: f is not a function\n```\n\n考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。\n\n```javascript\n// 函数声明语句\n{\n  let a = 'secret';\n  function f() {\n    return a;\n  }\n}\n\n// 函数表达式\n{\n  let a = 'secret';\n  let f = function () {\n    return a;\n  };\n}\n```\n\n另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。\n\n```javascript\n// 不报错\n'use strict';\nif (true) {\n  function f() {}\n}\n\n// 报错\n'use strict';\nif (true)\n  function f() {}\n```\n\n## const命令\n\n`const`声明一个只读的常量。一旦声明，常量的值就不能改变。\n\n```javascript\nconst PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: Assignment to constant variable.\n```\n\n上面代码表明改变常量的值会报错。\n\n`const`声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。\n\n```javascript\nconst foo;\n// SyntaxError: Missing initializer in const declaration\n```\n\n上面代码表示，对于`const`来说，只声明不赋值，就会报错。\n\n`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。\n\n```javascript\nif (true) {\n  const MAX = 5;\n}\n\nMAX // Uncaught ReferenceError: MAX is not defined\n```\n\n`const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。\n\n```javascript\nif (true) {\n  console.log(MAX); // ReferenceError\n  const MAX = 5;\n}\n```\n\n上面代码在常量`MAX`声明之前就调用，结果报错。\n\n`const`声明的常量，也与`let`一样不可重复声明。\n\n```javascript\nvar message = \"Hello!\";\nlet age = 25;\n\n// 以下两行都会报错\nconst message = \"Goodbye!\";\nconst age = 30;\n```\n\n对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。`const`命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。\n\n```javascript\nconst foo = {};\nfoo.prop = 123;\n\nfoo.prop\n// 123\n\nfoo = {}; // TypeError: \"foo\" is read-only\n```\n\n上面代码中，常量`foo`储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把`foo`指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\n\n下面是另一个例子。\n\n```js\nconst a = [];\na.push('Hello'); // 可执行\na.length = 0;    // 可执行\na = ['Dave'];    // 报错\n```\n\n上面代码中，常量`a`是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给`a`，就会报错。\n\n如果真的想将对象冻结，应该使用`Object.freeze`方法。\n\n```javascript\nconst foo = Object.freeze({});\n\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n```\n\n上面代码中，常量`foo`指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。\n\n除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。\n\n```javascript\nvar constantize = (obj) => {\n  Object.freeze(obj);\n  Object.keys(obj).forEach( (key, value) => {\n    if ( typeof obj[key] === 'object' ) {\n      constantize( obj[key] );\n    }\n  });\n};\n```\n\nES5只有两种声明变量的方法：`var`命令和`function`命令。ES6除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令。所以，ES6一共有6种声明变量的方法。\n\n## 顶层对象的属性\n\n顶层对象，在浏览器环境指的是`window`对象，在Node指的是`global`对象。ES5之中，顶层对象的属性与全局变量是等价的。\n\n```javascript\nwindow.a = 1;\na // 1\n\na = 2;\nwindow.a // 2\n```\n\n上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。\n\n顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，`window`对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。\n\nES6为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。\n\n```javascript\nvar a = 1;\n// 如果在Node的REPL环境，可以写成global.a\n// 或者采用通用方法，写成this.a\nwindow.a // 1\n\nlet b = 1;\nwindow.b // undefined\n```\n\n上面代码中，全局变量`a`由`var`命令声明，所以它是顶层对象的属性；全局变量`b`由`let`命令声明，所以它不是顶层对象的属性，返回`undefined`。\n\n## 顶层对象\n\nES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。\n\n- 浏览器里面，顶层对象是`window`，但Node和Web Worker没有`window`。\n- 浏览器和Web Worker里面，`self`也指向顶层对象，但是Node没有`self`。\n- Node里面，顶层对象是`global`，但其他环境都不支持。\n\n同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用`this`变量，但是有局限性。\n\n- 全局环境中，`this`会返回顶层对象。但是，Node模块和ES6模块中，`this`返回的是当前模块。\n- 函数里面的`this`，如果函数不是作为对象的方法运行，而是单纯作为函数运行，`this`会指向顶层对象。但是，严格模式下，这时`this`会返回`undefined`。\n- 不管是严格模式，还是普通模式，`new Function('return this')()`，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么`eval`、`new Function`这些方法都可能无法使用。\n\n综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。\n\n```javascript\n// 方法一\n(typeof window !== 'undefined'\n   ? window\n   : (typeof process === 'object' &&\n      typeof require === 'function' &&\n      typeof global === 'object')\n     ? global\n     : this);\n\n// 方法二\nvar getGlobal = function () {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n```\n\n现在有一个[提案](https://github.com/tc39/proposal-global)，在语言标准的层面，引入`global`作为顶层对象。也就是说，在所有环境下，`global`都是存在的，都可以从它拿到顶层对象。\n\n垫片库[`system.global`](https://github.com/ljharb/System.global)模拟了这个提案，可以在所有环境拿到`global`。\n\n```javascript\n// CommonJS的写法\nrequire('system.global/shim')();\n\n// ES6模块的写法\nimport shim from 'system.global/shim'; shim();\n```\n\n上面代码可以保证各种环境里面，`global`对象都是存在的。\n\n```javascript\n// CommonJS的写法\nvar global = require('system.global')();\n\n// ES6模块的写法\nimport getGlobal from 'system.global';\nconst global = getGlobal();\n```\n\n上面代码将顶层对象放入变量`global`。\n\n\n\n","slug":"ES2015之let-和-const","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfbo0005zk4oilf5m9wf","content":"<h2 id=\"let命令\"><a href=\"#let命令\" class=\"headerlink\" title=\"let命令\"></a>let命令</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">a <span class=\"comment\">// ReferenceError: a is not defined.</span></div><div class=\"line\">b <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p>\n<p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(i);</div><div class=\"line\"><span class=\"comment\">//ReferenceError: i is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p>\n<p>下面的代码如果使用<code>var</code>，最后输出的是10。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(i);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>i</code>是<code>var</code>声明的，在全局范围内都有效。所以每一次循环，新的<code>i</code>值都会覆盖旧值，导致最后输出的是最后一轮的<code>i</code>的值。</p>\n<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是6。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(i);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是6。</p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p><code>let</code>不像<code>var</code>那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。<br><a id=\"more\"></a></p>\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"keyword\">let</span> tmp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>\n<p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>\n<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// TDZ开始</span></div><div class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> tmp; <span class=\"comment\">// TDZ结束</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\">  tmp = <span class=\"number\">123</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// 123</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p>\n<p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\"><span class=\"keyword\">let</span> x;</div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p>\n<p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typeof</span> undeclared_variable <span class=\"comment\">// \"undefined\"</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“undefined”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>\n<p>有些“死区”比较隐蔽，不太容易发现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x = y, y = <span class=\"number\">2</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar(); <span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于”死区“。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x = <span class=\"number\">2</span>, y = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\">bar(); <span class=\"comment\">// [2, 2]</span></div></pre></td></tr></table></figure>\n<p>ES6规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>\n<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>\n<h3 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因此，不能在函数内部重新声明参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 报错</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 不报错</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><h3 id=\"为什么需要块级作用域？\"><a href=\"#为什么需要块级作用域？\" class=\"headerlink\" title=\"为什么需要块级作用域？\"></a>为什么需要块级作用域？</h3><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>\n<p>第一种场景，内层变量可能会覆盖外层变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f(); <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数f执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>\n<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.length; i++) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(s[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>\n<h3 id=\"ES6的块级作用域\"><a href=\"#ES6的块级作用域\" class=\"headerlink\" title=\"ES6的块级作用域\"></a>ES6的块级作用域</h3><p><code>let</code>实际上为JavaScript新增了块级作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">5</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> n = <span class=\"number\">10</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 5</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用<code>var</code>定义变量<code>n</code>，最后输出的值就是10。</p>\n<p>ES6允许块级作用域的任意嵌套。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;&#123;&#123;&#123;<span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;&#123;&#123;</div><div class=\"line\">  &#123;<span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>&#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(insane); <span class=\"comment\">// 报错</span></div><div class=\"line\">&#125;&#125;&#125;&#125;;</div></pre></td></tr></table></figure>\n<p>内层作用域可以定义外层作用域的同名变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;&#123;&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>;</div><div class=\"line\">  &#123;<span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>&#125;</div><div class=\"line\">&#125;&#125;&#125;&#125;;</div></pre></td></tr></table></figure>\n<p>块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// IIFE写法</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> tmp = ...;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 块级作用域写法</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> tmp = ...;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"块级作用域与函数声明\"><a href=\"#块级作用域与函数声明\" class=\"headerlink\" title=\"块级作用域与函数声明\"></a>块级作用域与函数声明</h3><p>函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。</p>\n<p>ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 情况一</span></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 情况二</span></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码的两种函数声明，根据ES5的规定都是非法的。</p>\n<p>但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5严格模式</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>ES6引入了块级作用域，明确允许在块级作用域之中声明函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6严格模式</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 不报错</span></div></pre></td></tr></table></figure>\n<p>并且ES6规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 重复声明一次函数f</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n<p>上面代码在ES5中运行，会得到“I am inside!”，因为在<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5版本</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n<p>ES6的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响，实际运行的代码如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6版本</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n<p>很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在<a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics\" target=\"_blank\" rel=\"external\">附录B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href=\"http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6\" target=\"_blank\" rel=\"external\">行为方式</a>。</p>\n<ul>\n<li>允许在块级作用域内声明函数。</li>\n<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>\n<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>\n</ul>\n<p>注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p>\n<p>前面那段代码，在Chrome环境下运行会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6的浏览器环境</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 重复声明一次函数f</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div><div class=\"line\"><span class=\"comment\">// Uncaught TypeError: f is not a function</span></div></pre></td></tr></table></figure>\n<p>上面的代码报错，是因为实际运行的是下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6的浏览器环境</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"literal\">undefined</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div><div class=\"line\"><span class=\"comment\">// Uncaught TypeError: f is not a function</span></div></pre></td></tr></table></figure>\n<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数声明语句</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"string\">'secret'</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 函数表达式</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"string\">'secret'</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 不报错</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"const命令\"><a href=\"#const命令\" class=\"headerlink\" title=\"const命令\"></a>const命令</h2><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.1415</span>;</div><div class=\"line\">PI <span class=\"comment\">// 3.1415</span></div><div class=\"line\"></div><div class=\"line\">PI = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"comment\">// TypeError: Assignment to constant variable.</span></div></pre></td></tr></table></figure>\n<p>上面代码表明改变常量的值会报错。</p>\n<p><code>const</code>声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foo;</div><div class=\"line\"><span class=\"comment\">// SyntaxError: Missing initializer in const declaration</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p>\n<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> MAX = <span class=\"number\">5</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MAX <span class=\"comment\">// Uncaught ReferenceError: MAX is not defined</span></div></pre></td></tr></table></figure>\n<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(MAX); <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"keyword\">const</span> MAX = <span class=\"number\">5</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p>\n<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">\"Hello!\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">25</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 以下两行都会报错</span></div><div class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">\"Goodbye!\"</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">30</span>;</div></pre></td></tr></table></figure>\n<p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。<code>const</code>命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foo = &#123;&#125;;</div><div class=\"line\">foo.prop = <span class=\"number\">123</span>;</div><div class=\"line\"></div><div class=\"line\">foo.prop</div><div class=\"line\"><span class=\"comment\">// 123</span></div><div class=\"line\"></div><div class=\"line\">foo = &#123;&#125;; <span class=\"comment\">// TypeError: \"foo\" is read-only</span></div></pre></td></tr></table></figure>\n<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>\n<p>下面是另一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> a = [];</div><div class=\"line\">a.push(<span class=\"string\">'Hello'</span>); <span class=\"comment\">// 可执行</span></div><div class=\"line\">a.length = <span class=\"number\">0</span>;    <span class=\"comment\">// 可执行</span></div><div class=\"line\">a = [<span class=\"string\">'Dave'</span>];    <span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>\n<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 常规模式时，下面一行不起作用；</span></div><div class=\"line\"><span class=\"comment\">// 严格模式时，该行会报错</span></div><div class=\"line\">foo.prop = <span class=\"number\">123</span>;</div></pre></td></tr></table></figure>\n<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>\n<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> constantize = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.freeze(obj);</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach( <span class=\"function\">(<span class=\"params\">key, value</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'object'</span> ) &#123;</div><div class=\"line\">      constantize( obj[key] );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>ES5只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6一共有6种声明变量的方法。</p>\n<h2 id=\"顶层对象的属性\"><a href=\"#顶层对象的属性\" class=\"headerlink\" title=\"顶层对象的属性\"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。ES5之中，顶层对象的属性与全局变量是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.a = <span class=\"number\">1</span>;</div><div class=\"line\">a <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\">a = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"built_in\">window</span>.a <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>\n<p>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>\n<p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"comment\">// 如果在Node的REPL环境，可以写成global.a</span></div><div class=\"line\"><span class=\"comment\">// 或者采用通用方法，写成this.a</span></div><div class=\"line\"><span class=\"built_in\">window</span>.a <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"built_in\">window</span>.b <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>\n<h2 id=\"顶层对象\"><a href=\"#顶层对象\" class=\"headerlink\" title=\"顶层对象\"></a>顶层对象</h2><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p>\n<ul>\n<li>浏览器里面，顶层对象是<code>window</code>，但Node和Web Worker没有<code>window</code>。</li>\n<li>浏览器和Web Worker里面，<code>self</code>也指向顶层对象，但是Node没有<code>self</code>。</li>\n<li>Node里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>\n</ul>\n<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。</p>\n<ul>\n<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node模块和ES6模块中，<code>this</code>返回的是当前模块。</li>\n<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>\n<li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>\n</ul>\n<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 方法一</span></div><div class=\"line\">(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span></div><div class=\"line\">   ? <span class=\"built_in\">window</span></div><div class=\"line\">   : (<span class=\"keyword\">typeof</span> process === <span class=\"string\">'object'</span> &amp;&amp;</div><div class=\"line\">      <span class=\"keyword\">typeof</span> <span class=\"built_in\">require</span> === <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">      <span class=\"keyword\">typeof</span> global === <span class=\"string\">'object'</span>)</div><div class=\"line\">     ? global</div><div class=\"line\">     : <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 方法二</span></div><div class=\"line\"><span class=\"keyword\">var</span> getGlobal = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> self !== <span class=\"string\">'undefined'</span>) &#123; <span class=\"keyword\">return</span> self; &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span>) &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>; &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> global !== <span class=\"string\">'undefined'</span>) &#123; <span class=\"keyword\">return</span> global; &#125;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'unable to locate global object'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>现在有一个<a href=\"https://github.com/tc39/proposal-global\" target=\"_blank\" rel=\"external\">提案</a>，在语言标准的层面，引入<code>global</code>作为顶层对象。也就是说，在所有环境下，<code>global</code>都是存在的，都可以从它拿到顶层对象。</p>\n<p>垫片库<a href=\"https://github.com/ljharb/System.global\" target=\"_blank\" rel=\"external\"><code>system.global</code></a>模拟了这个提案，可以在所有环境拿到<code>global</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CommonJS的写法</span></div><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'system.global/shim'</span>)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6模块的写法</span></div><div class=\"line\"><span class=\"keyword\">import</span> shim <span class=\"keyword\">from</span> <span class=\"string\">'system.global/shim'</span>; shim();</div></pre></td></tr></table></figure>\n<p>上面代码可以保证各种环境里面，<code>global</code>对象都是存在的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CommonJS的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> global = <span class=\"built_in\">require</span>(<span class=\"string\">'system.global'</span>)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6模块的写法</span></div><div class=\"line\"><span class=\"keyword\">import</span> getGlobal <span class=\"keyword\">from</span> <span class=\"string\">'system.global'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> global = getGlobal();</div></pre></td></tr></table></figure>\n<p>上面代码将顶层对象放入变量<code>global</code>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"let命令\"><a href=\"#let命令\" class=\"headerlink\" title=\"let命令\"></a>let命令</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">a <span class=\"comment\">// ReferenceError: a is not defined.</span></div><div class=\"line\">b <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p>\n<p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(i);</div><div class=\"line\"><span class=\"comment\">//ReferenceError: i is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p>\n<p>下面的代码如果使用<code>var</code>，最后输出的是10。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(i);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>i</code>是<code>var</code>声明的，在全局范围内都有效。所以每一次循环，新的<code>i</code>值都会覆盖旧值，导致最后输出的是最后一轮的<code>i</code>的值。</p>\n<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是6。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</div><div class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(i);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是6。</p>\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p><code>let</code>不像<code>var</code>那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。<br>","more":"</p>\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"keyword\">let</span> tmp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>\n<p>ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>\n<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"comment\">// TDZ开始</span></div><div class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">let</span> tmp; <span class=\"comment\">// TDZ结束</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\">  tmp = <span class=\"number\">123</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// 123</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p>\n<p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></div><div class=\"line\"><span class=\"keyword\">let</span> x;</div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p>\n<p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typeof</span> undeclared_variable <span class=\"comment\">// \"undefined\"</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“undefined”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>\n<p>有些“死区”比较隐蔽，不太容易发现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x = y, y = <span class=\"number\">2</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar(); <span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于”死区“。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x = <span class=\"number\">2</span>, y = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\">bar(); <span class=\"comment\">// [2, 2]</span></div></pre></td></tr></table></figure>\n<p>ES6规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>\n<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>\n<h3 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h3><p>let不允许在相同作用域内，重复声明同一个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因此，不能在函数内部重新声明参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 报错</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</div><div class=\"line\">  &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 不报错</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><h3 id=\"为什么需要块级作用域？\"><a href=\"#为什么需要块级作用域？\" class=\"headerlink\" title=\"为什么需要块级作用域？\"></a>为什么需要块级作用域？</h3><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>\n<p>第一种场景，内层变量可能会覆盖外层变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(tmp);</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f(); <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数f执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>\n<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.length; i++) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(s[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>\n<h3 id=\"ES6的块级作用域\"><a href=\"#ES6的块级作用域\" class=\"headerlink\" title=\"ES6的块级作用域\"></a>ES6的块级作用域</h3><p><code>let</code>实际上为JavaScript新增了块级作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">5</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> n = <span class=\"number\">10</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 5</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用<code>var</code>定义变量<code>n</code>，最后输出的值就是10。</p>\n<p>ES6允许块级作用域的任意嵌套。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;&#123;&#123;&#123;<span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;&#123;&#123;</div><div class=\"line\">  &#123;<span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>&#125;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(insane); <span class=\"comment\">// 报错</span></div><div class=\"line\">&#125;&#125;&#125;&#125;;</div></pre></td></tr></table></figure>\n<p>内层作用域可以定义外层作用域的同名变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;&#123;&#123;&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>;</div><div class=\"line\">  &#123;<span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>&#125;</div><div class=\"line\">&#125;&#125;&#125;&#125;;</div></pre></td></tr></table></figure>\n<p>块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// IIFE写法</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> tmp = ...;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 块级作用域写法</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> tmp = ...;</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"块级作用域与函数声明\"><a href=\"#块级作用域与函数声明\" class=\"headerlink\" title=\"块级作用域与函数声明\"></a>块级作用域与函数声明</h3><p>函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。</p>\n<p>ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 情况一</span></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 情况二</span></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码的两种函数声明，根据ES5的规定都是非法的。</p>\n<p>但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5严格模式</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>ES6引入了块级作用域，明确允许在块级作用域之中声明函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6严格模式</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 不报错</span></div></pre></td></tr></table></figure>\n<p>并且ES6规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 重复声明一次函数f</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n<p>上面代码在ES5中运行，会得到“I am inside!”，因为在<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5版本</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">  &#125;</div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n<p>ES6的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响，实际运行的代码如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6版本</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n<p>很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在<a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics\" target=\"_blank\" rel=\"external\">附录B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href=\"http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6\" target=\"_blank\" rel=\"external\">行为方式</a>。</p>\n<ul>\n<li>允许在块级作用域内声明函数。</li>\n<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>\n<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>\n</ul>\n<p>注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p>\n<p>前面那段代码，在Chrome环境下运行会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6的浏览器环境</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// 重复声明一次函数f</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div><div class=\"line\"><span class=\"comment\">// Uncaught TypeError: f is not a function</span></div></pre></td></tr></table></figure>\n<p>上面的代码报错，是因为实际运行的是下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6的浏览器环境</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"literal\">undefined</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  f();</div><div class=\"line\">&#125;());</div><div class=\"line\"><span class=\"comment\">// Uncaught TypeError: f is not a function</span></div></pre></td></tr></table></figure>\n<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数声明语句</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"string\">'secret'</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 函数表达式</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"string\">'secret'</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 不报错</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>)</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"const命令\"><a href=\"#const命令\" class=\"headerlink\" title=\"const命令\"></a>const命令</h2><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.1415</span>;</div><div class=\"line\">PI <span class=\"comment\">// 3.1415</span></div><div class=\"line\"></div><div class=\"line\">PI = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"comment\">// TypeError: Assignment to constant variable.</span></div></pre></td></tr></table></figure>\n<p>上面代码表明改变常量的值会报错。</p>\n<p><code>const</code>声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foo;</div><div class=\"line\"><span class=\"comment\">// SyntaxError: Missing initializer in const declaration</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p>\n<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> MAX = <span class=\"number\">5</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">MAX <span class=\"comment\">// Uncaught ReferenceError: MAX is not defined</span></div></pre></td></tr></table></figure>\n<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(MAX); <span class=\"comment\">// ReferenceError</span></div><div class=\"line\">  <span class=\"keyword\">const</span> MAX = <span class=\"number\">5</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p>\n<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">\"Hello!\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">25</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 以下两行都会报错</span></div><div class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">\"Goodbye!\"</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">30</span>;</div></pre></td></tr></table></figure>\n<p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。<code>const</code>命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foo = &#123;&#125;;</div><div class=\"line\">foo.prop = <span class=\"number\">123</span>;</div><div class=\"line\"></div><div class=\"line\">foo.prop</div><div class=\"line\"><span class=\"comment\">// 123</span></div><div class=\"line\"></div><div class=\"line\">foo = &#123;&#125;; <span class=\"comment\">// TypeError: \"foo\" is read-only</span></div></pre></td></tr></table></figure>\n<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>\n<p>下面是另一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> a = [];</div><div class=\"line\">a.push(<span class=\"string\">'Hello'</span>); <span class=\"comment\">// 可执行</span></div><div class=\"line\">a.length = <span class=\"number\">0</span>;    <span class=\"comment\">// 可执行</span></div><div class=\"line\">a = [<span class=\"string\">'Dave'</span>];    <span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>\n<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 常规模式时，下面一行不起作用；</span></div><div class=\"line\"><span class=\"comment\">// 严格模式时，该行会报错</span></div><div class=\"line\">foo.prop = <span class=\"number\">123</span>;</div></pre></td></tr></table></figure>\n<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>\n<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> constantize = <span class=\"function\">(<span class=\"params\">obj</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.freeze(obj);</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach( <span class=\"function\">(<span class=\"params\">key, value</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'object'</span> ) &#123;</div><div class=\"line\">      constantize( obj[key] );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>ES5只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6一共有6种声明变量的方法。</p>\n<h2 id=\"顶层对象的属性\"><a href=\"#顶层对象的属性\" class=\"headerlink\" title=\"顶层对象的属性\"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。ES5之中，顶层对象的属性与全局变量是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.a = <span class=\"number\">1</span>;</div><div class=\"line\">a <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\">a = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"built_in\">window</span>.a <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>\n<p>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>\n<p>ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"comment\">// 如果在Node的REPL环境，可以写成global.a</span></div><div class=\"line\"><span class=\"comment\">// 或者采用通用方法，写成this.a</span></div><div class=\"line\"><span class=\"built_in\">window</span>.a <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"built_in\">window</span>.b <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>\n<h2 id=\"顶层对象\"><a href=\"#顶层对象\" class=\"headerlink\" title=\"顶层对象\"></a>顶层对象</h2><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p>\n<ul>\n<li>浏览器里面，顶层对象是<code>window</code>，但Node和Web Worker没有<code>window</code>。</li>\n<li>浏览器和Web Worker里面，<code>self</code>也指向顶层对象，但是Node没有<code>self</code>。</li>\n<li>Node里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>\n</ul>\n<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。</p>\n<ul>\n<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node模块和ES6模块中，<code>this</code>返回的是当前模块。</li>\n<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>\n<li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>\n</ul>\n<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 方法一</span></div><div class=\"line\">(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span></div><div class=\"line\">   ? <span class=\"built_in\">window</span></div><div class=\"line\">   : (<span class=\"keyword\">typeof</span> process === <span class=\"string\">'object'</span> &amp;&amp;</div><div class=\"line\">      <span class=\"keyword\">typeof</span> <span class=\"built_in\">require</span> === <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">      <span class=\"keyword\">typeof</span> global === <span class=\"string\">'object'</span>)</div><div class=\"line\">     ? global</div><div class=\"line\">     : <span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 方法二</span></div><div class=\"line\"><span class=\"keyword\">var</span> getGlobal = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> self !== <span class=\"string\">'undefined'</span>) &#123; <span class=\"keyword\">return</span> self; &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span>) &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>; &#125;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> global !== <span class=\"string\">'undefined'</span>) &#123; <span class=\"keyword\">return</span> global; &#125;</div><div class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'unable to locate global object'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>现在有一个<a href=\"https://github.com/tc39/proposal-global\" target=\"_blank\" rel=\"external\">提案</a>，在语言标准的层面，引入<code>global</code>作为顶层对象。也就是说，在所有环境下，<code>global</code>都是存在的，都可以从它拿到顶层对象。</p>\n<p>垫片库<a href=\"https://github.com/ljharb/System.global\" target=\"_blank\" rel=\"external\"><code>system.global</code></a>模拟了这个提案，可以在所有环境拿到<code>global</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CommonJS的写法</span></div><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'system.global/shim'</span>)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6模块的写法</span></div><div class=\"line\"><span class=\"keyword\">import</span> shim <span class=\"keyword\">from</span> <span class=\"string\">'system.global/shim'</span>; shim();</div></pre></td></tr></table></figure>\n<p>上面代码可以保证各种环境里面，<code>global</code>对象都是存在的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CommonJS的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> global = <span class=\"built_in\">require</span>(<span class=\"string\">'system.global'</span>)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6模块的写法</span></div><div class=\"line\"><span class=\"keyword\">import</span> getGlobal <span class=\"keyword\">from</span> <span class=\"string\">'system.global'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> global = getGlobal();</div></pre></td></tr></table></figure>\n<p>上面代码将顶层对象放入变量<code>global</code>。</p>"},{"title":"ES2015函数默认值,rest参数及扩展运算符","date":"2016-11-01T08:22:10.000Z","_content":"## 函数参数的默认值\n\n### 基本用法\n\n在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\n\n```javascript\nfunction log(x, y) {\n  y = y || 'World';\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello World\n```\n\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布尔值为`false`，则该赋值不起作用。就像上面代码的最后一行，参数`y`等于空字符，结果被改为默认值。\n\n为了避免这个问题，通常需要先判断一下参数`y`是否被赋值，如果没有，再等于默认值。\n\n```javascript\nif (typeof y === 'undefined') {\n  y = 'World';\n}\n```\n\nES6允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\n```javascript\nfunction log(x, y = 'World') {\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n\n可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。\n\n```javascript\nfunction Point(x = 0, y = 0) {\n  this.x = x;\n  this.y = y;\n}\n\nvar p = new Point();\np // { x: 0, y: 0 }\n```\n\n除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。\n\n参数变量是默认声明的，所以不能用`let`或`const`再次声明。\n\n```javascript\nfunction foo(x = 5) {\n  let x = 1; // error\n  const x = 2; // error\n}\n```\n\n上面代码中，参数变量`x`是默认声明的，在函数体中，不能用`let`或`const`再次声明，否则会报错。\n<!--more-->\n### 与解构赋值默认值结合使用\n\n参数默认值可以与解构赋值的默认值，结合起来使用。\n\n```javascript\nfunction foo({x, y = 5}) {\n  console.log(x, y);\n}\n\nfoo({}) // undefined, 5\nfoo({x: 1}) // 1, 5\nfoo({x: 1, y: 2}) // 1, 2\nfoo() // TypeError: Cannot read property 'x' of undefined\n```\n\n上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数`foo`的参数是一个对象时，变量`x`和`y`才会通过解构赋值而生成。如果函数`foo`调用时参数不是对象，变量`x`和`y`就不会生成，从而报错。如果参数对象没有`y`属性，`y`的默认值5才会生效。\n\n下面是另一个对象的解构赋值默认值的例子。\n\n```javascript\nfunction fetch(url, { body = '', method = 'GET', headers = {} }) {\n  console.log(method);\n}\n\nfetch('http://example.com', {})\n// \"GET\"\n\nfetch('http://example.com')\n// 报错\n```\n\n上面代码中，如果函数`fetch`的第二个参数是一个对象，就可以为它的三个属性设置默认值。\n\n上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。\n\n```javascript\nfunction fetch(url, { method = 'GET' } = {}) {\n  console.log(method);\n}\n\nfetch('http://example.com')\n// \"GET\"\n```\n\n上面代码中，函数`fetch`没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量`method`才会取到默认值`GET`。\n\n再请问下面两种写法有什么差别？\n\n```javascript\n// 写法一\nfunction m1({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\n// 写法二\nfunction m2({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n```\n\n上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。\n\n```javascript\n// 函数没有参数的情况\nm1() // [0, 0]\nm2() // [0, 0]\n\n// x和y都有值的情况\nm1({x: 3, y: 8}) // [3, 8]\nm2({x: 3, y: 8}) // [3, 8]\n\n// x有值，y无值的情况\nm1({x: 3}) // [3, 0]\nm2({x: 3}) // [3, undefined]\n\n// x和y都无值的情况\nm1({}) // [0, 0];\nm2({}) // [undefined, undefined]\n\nm1({z: 3}) // [0, 0]\nm2({z: 3}) // [undefined, undefined]\n```\n\n### 参数默认值的位置\n>  尽量放在**参数最后**\n通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果~~非尾部的参数设置默认值~~，实际上这个参数是没法省略的。\n\n```javascript\n// 例一\nfunction f(x = 1, y) {\n  return [x, y];\n}\n\nf() // [1, undefined]\nf(2) // [2, undefined])\nf(, 1) // 报错\nf(undefined, 1) // [1, 1]\n\n// 例二\nfunction f(x, y = 5, z) {\n  return [x, y, z];\n}\n\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // 报错\nf(1, undefined, 2) // [1, 5, 2]\n```\n\n上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入`undefined`。\n\n如果传入`undefined`，将触发该参数等于默认值，`null`则没有这个效果。\n\n```javascript\nfunction foo(x = 5, y = 6) {\n  console.log(x, y);\n}\n\nfoo(undefined, null)\n// 5 null\n```\n\n上面代码中，`x`参数对应`undefined`，结果触发了默认值，`y`参数等于`null`，就没有触发默认值。\n\n### 函数的length属性\n\n指定了默认值以后，函数的`length`属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，`length`属性将失真。\n\n```javascript\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n```\n\n上面代码中，`length`属性的返回值，**等于函数的参数个数减去指定了默认值的参数个数**。比如，上面最后一个函数，定义了3个参数，其中有一个参数`c`指定了默认值，因此`length`属性等于`3`减去`1`，最后得到`2`。\n\n这是因为`length`属性的含义是，该函数预期传入的参数个数。**某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入`length`属性**。\n\n```javascript\n(function(...args) {}).length // 0\n```\n\n如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了。\n\n```javascript\n(function (a = 0, b, c) {}).length // 0\n(function (a, b = 1, c) {}).length // 1\n```\n\n### 作用域\n\n一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。\n\n```javascript\nvar x = 1;\n\nfunction f(x, y = x) {\n  console.log(y);\n}\n\nf(2) // 2\n```\n\n上面代码中，参数`y`的默认值等于`x`。调用时，由于函数作用域内部的变量`x`已经生成，所以`y`等于参数`x`，而不是全局变量`x`。\n\n如果调用时，函数作用域内部的变量`x`没有生成，结果就会不一样。\n\n```javascript\nlet x = 1;\n\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // 1\n```\n\n上面代码中，函数调用时，`y`的默认值变量`x`尚未在函数内部生成，所以`x`指向全局变量。\n\n如果此时，全局变量`x`不存在，就会报错。\n\n```javascript\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // ReferenceError: x is not defined\n```\n\n下面这样写，也会报错。\n\n```javascript\nvar x = 1;\n\nfunction foo(x = x) {\n  // ...\n}\n\nfoo() // ReferenceError: x is not defined\n```\n\n上面代码中，函数`foo`的参数`x`的默认值也是`x`。这时，默认值`x`的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量`x`，但是默认值在`x`赋值之前先执行了，所以这时属于暂时性死区（参见《let和const命令》一章），任何对`x`的操作都会报错。\n\n如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。\n\n```javascript\nlet foo = 'outer';\n\nfunction bar(func = x => foo) {\n  let foo = 'inner';\n  console.log(func()); // outer\n}\n\nbar();\n```\n\n上面代码中，函数`bar`的参数`func`的默认值是一个匿名函数，返回值为变量`foo`。这个匿名函数声明时，`bar`函数的作用域还没有形成，所以匿名函数里面的`foo`指向外层作用域的`foo`，输出`outer`。\n\n如果写成下面这样，就会报错。\n\n```javascript\nfunction bar(func = () => foo) {\n  let foo = 'inner';\n  console.log(func());\n}\n\nbar() // ReferenceError: foo is not defined\n```\n\n上面代码中，匿名函数里面的`foo`指向函数外层，但是函数外层并没有声明`foo`，所以就报错了。\n\n## rest参数\n\nES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\n```javascript\nfunction add(...values) {\n  let sum = 0;\n\n  for (var val of values) {\n    sum += val;\n  }\n\n  return sum;\n}\n\nadd(2, 5, 3) // 10\n```\n\n上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数。\n\n下面是一个rest参数代替arguments变量的例子。\n\n```javascript\n// arguments变量的写法\nfunction sortNumbers() {\n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// rest参数的写法\nconst sortNumbers = (...numbers) => numbers.sort();\n```\n\n上面代码的两种写法，比较后可以发现，rest参数的写法更自然也更简洁。\n\nrest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push方法的例子。\n\n```javascript\nfunction push(array, ...items) {\n  items.forEach(function(item) {\n    array.push(item);\n    console.log(item);\n  });\n}\n\nvar a = [];\npush(a, 1, 2, 3)\n```\n\n注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\n\n```javascript\n// 报错\nfunction f(a, ...b, c) {\n  // ...\n}\n```\n\n函数的length属性，不包括rest参数。\n\n```javascript\n(function(a) {}).length  // 1\n(function(...a) {}).length  // 0\n(function(a, ...b) {}).length  // 1\n```\n\n## 扩展运算符\n\n### 含义\n\n扩展运算符（spread）是三个点（`...`）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\n```javascript\nconsole.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n[...document.querySelectorAll('div')]\n// [<div>, <div>, <div>]\n```\n\n该运算符主要用于函数调用。\n\n```javascript\nfunction push(array, ...items) {\n  array.push(...items);\n}\n\nfunction add(x, y) {\n  return x + y;\n}\n\nvar numbers = [4, 38];\nadd(...numbers) // 42\n```\n\n上面代码中，`array.push(...items)`和`add(...numbers)`这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。\n\n扩展运算符与正常的函数参数可以结合使用，非常灵活。\n\n```javascript\nfunction f(v, w, x, y, z) { }\nvar args = [0, 1];\nf(-1, ...args, 2, ...[3]);\n```\n\n### 替代数组的apply方法\n\n由于扩展运算符可以展开数组，所以不再需要`apply`方法，将数组转为函数的参数了。\n\n```javascript\n// ES5的写法\nfunction f(x, y, z) {\n  // ...\n}\nvar args = [0, 1, 2];\nf.apply(null, args);\n\n// ES6的写法\nfunction f(x, y, z) {\n  // ...\n}\nvar args = [0, 1, 2];\nf(...args);\n```\n\n下面是扩展运算符取代`apply`方法的一个实际的例子，应用`Math.max`方法，简化求出一个数组最大元素的写法。\n\n```javascript\n// ES5的写法\nMath.max.apply(null, [14, 3, 77])\n\n// ES6的写法\nMath.max(...[14, 3, 77])\n\n// 等同于\nMath.max(14, 3, 77);\n```\n\n上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用`Math.max`函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用`Math.max`了。\n\n另一个例子是通过`push`函数，将一个数组添加到另一个数组的尾部。\n\n```javascript\n// ES5的写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nArray.prototype.push.apply(arr1, arr2);\n\n// ES6的写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1.push(...arr2);\n```\n\n上面代码的ES5写法中，`push`方法的参数不能是数组，所以只好通过`apply`方法变通使用`push`方法。有了扩展运算符，就可以直接将数组传入`push`方法。\n\n下面是另外一个例子。\n\n```javascript\n// ES5\nnew (Date.bind.apply(Date, [null, 2015, 1, 1]))\n// ES6\nnew Date(...[2015, 1, 1]);\n```\n\n### 扩展运算符的应用\n\n**（1）合并数组**\n\n扩展运算符提供了数组合并的新写法。\n\n```javascript\n// ES5\n[1, 2].concat(more)\n// ES6\n[1, 2, ...more]\n\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['d', 'e'];\n\n// ES5的合并数组\narr1.concat(arr2, arr3);\n// [ 'a', 'b', 'c', 'd', 'e' ]\n\n// ES6的合并数组\n[...arr1, ...arr2, ...arr3]\n// [ 'a', 'b', 'c', 'd', 'e' ]\n```\n\n**（2）与解构赋值结合**\n\n扩展运算符可以与解构赋值结合起来，用于生成数组。\n\n```javascript\n// ES5\na = list[0], rest = list.slice(1)\n// ES6\n[a, ...rest] = list\n```\n\n下面是另外一些例子。\n\n```javascript\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []:\n\nconst [first, ...rest] = [\"foo\"];\nfirst  // \"foo\"\nrest   // []\n```\n\n如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n\n```javascript\nconst [...butLast, last] = [1, 2, 3, 4, 5];\n// 报错\n\nconst [first, ...middle, last] = [1, 2, 3, 4, 5];\n// 报错\n```\n\n**（3）函数的返回值**\n\nJavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。\n\n```javascript\nvar dateFields = readDateFields(database);\nvar d = new Date(...dateFields);\n```\n\n上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数`Date`。\n\n**（4）字符串**\n\n扩展运算符还可以将字符串转为真正的数组。\n\n```javascript\n[...'hello']\n// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n```\n\n**（5）实现了Iterator接口的对象**\n\n任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。\n\n```javascript\nvar nodeList = document.querySelectorAll('div');\nvar array = [...nodeList];\n```\n\n上面代码中，`querySelectorAll`方法返回的是一个`nodeList`对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于`NodeList`对象实现了Iterator接口。\n\n对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。\n\n```javascript\nlet arrayLike = {\n  '0': 'a',\n  '1': 'b',\n  '2': 'c',\n  length: 3\n};\n\n// TypeError: Cannot spread non-iterable object.\nlet arr = [...arrayLike];\n```\n\n上面代码中，`arrayLike`是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用`Array.from`方法将`arrayLike`转为真正的数组。\n\n**（6）Map和Set结构，Generator函数**\n\n扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。\n\n```javascript\nlet map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nlet arr = [...map.keys()]; // [1, 2, 3]\n```\n\n如果对没有`iterator`接口的对象，使用扩展运算符，将会报错。\n\n```javascript\nvar obj = {a: 1, b: 2};\nlet arr = [...obj]; // TypeError: Cannot spread non-iterable object\n```\n\n## 严格模式\n\n从ES5开始，函数内部可以设定为严格模式。\n\n```javascript\nfunction doSomething(a, b) {\n  'use strict';\n  // code\n}\n```\n\n《ECMAScript 2016标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n\n```javascript\n// 报错\nfunction doSomething(a, b = a) {\n  'use strict';\n  // code\n}\n\n// 报错\nconst doSomething = function ({a, b}) {\n  'use strict';\n  // code\n};\n\n// 报错\nconst doSomething = (...a) => {\n  'use strict';\n  // code\n};\n\nconst obj = {\n  // 报错\n  doSomething({a, b}) {\n    'use strict';\n    // code\n  }\n};\n```\n\n这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。\n\n```javascript\n// 报错\nfunction doSomething(value = 070) {\n  'use strict';\n  return value;\n}\n```\n\n上面代码中，参数`value`的默认值是八进制数`070`，但是严格模式下不能用前缀`0`表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行`value = 070`，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。\n\n虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。\n\n两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。\n\n```javascript\n'use strict';\n\nfunction doSomething(a, b = a) {\n  // code\n}\n```\n\n第二种是把函数包在一个无参数的立即执行函数里面。\n\n```javascript\nconst doSomething = (function () {\n  'use strict';\n  return function(value = 42) {\n    return value;\n  };\n}());\n```\n\n","source":"_posts/ES2015函数默认值,rest参数及扩展运算符.md","raw":"---\ntitle: ES2015函数默认值,rest参数及扩展运算符\ndate: 2016-11-01 16:22:10\ntags: ES2015\n---\n## 函数参数的默认值\n\n### 基本用法\n\n在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\n\n```javascript\nfunction log(x, y) {\n  y = y || 'World';\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello World\n```\n\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布尔值为`false`，则该赋值不起作用。就像上面代码的最后一行，参数`y`等于空字符，结果被改为默认值。\n\n为了避免这个问题，通常需要先判断一下参数`y`是否被赋值，如果没有，再等于默认值。\n\n```javascript\nif (typeof y === 'undefined') {\n  y = 'World';\n}\n```\n\nES6允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\n```javascript\nfunction log(x, y = 'World') {\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n\n可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。\n\n```javascript\nfunction Point(x = 0, y = 0) {\n  this.x = x;\n  this.y = y;\n}\n\nvar p = new Point();\np // { x: 0, y: 0 }\n```\n\n除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。\n\n参数变量是默认声明的，所以不能用`let`或`const`再次声明。\n\n```javascript\nfunction foo(x = 5) {\n  let x = 1; // error\n  const x = 2; // error\n}\n```\n\n上面代码中，参数变量`x`是默认声明的，在函数体中，不能用`let`或`const`再次声明，否则会报错。\n<!--more-->\n### 与解构赋值默认值结合使用\n\n参数默认值可以与解构赋值的默认值，结合起来使用。\n\n```javascript\nfunction foo({x, y = 5}) {\n  console.log(x, y);\n}\n\nfoo({}) // undefined, 5\nfoo({x: 1}) // 1, 5\nfoo({x: 1, y: 2}) // 1, 2\nfoo() // TypeError: Cannot read property 'x' of undefined\n```\n\n上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数`foo`的参数是一个对象时，变量`x`和`y`才会通过解构赋值而生成。如果函数`foo`调用时参数不是对象，变量`x`和`y`就不会生成，从而报错。如果参数对象没有`y`属性，`y`的默认值5才会生效。\n\n下面是另一个对象的解构赋值默认值的例子。\n\n```javascript\nfunction fetch(url, { body = '', method = 'GET', headers = {} }) {\n  console.log(method);\n}\n\nfetch('http://example.com', {})\n// \"GET\"\n\nfetch('http://example.com')\n// 报错\n```\n\n上面代码中，如果函数`fetch`的第二个参数是一个对象，就可以为它的三个属性设置默认值。\n\n上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。\n\n```javascript\nfunction fetch(url, { method = 'GET' } = {}) {\n  console.log(method);\n}\n\nfetch('http://example.com')\n// \"GET\"\n```\n\n上面代码中，函数`fetch`没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量`method`才会取到默认值`GET`。\n\n再请问下面两种写法有什么差别？\n\n```javascript\n// 写法一\nfunction m1({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\n// 写法二\nfunction m2({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n```\n\n上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。\n\n```javascript\n// 函数没有参数的情况\nm1() // [0, 0]\nm2() // [0, 0]\n\n// x和y都有值的情况\nm1({x: 3, y: 8}) // [3, 8]\nm2({x: 3, y: 8}) // [3, 8]\n\n// x有值，y无值的情况\nm1({x: 3}) // [3, 0]\nm2({x: 3}) // [3, undefined]\n\n// x和y都无值的情况\nm1({}) // [0, 0];\nm2({}) // [undefined, undefined]\n\nm1({z: 3}) // [0, 0]\nm2({z: 3}) // [undefined, undefined]\n```\n\n### 参数默认值的位置\n>  尽量放在**参数最后**\n通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果~~非尾部的参数设置默认值~~，实际上这个参数是没法省略的。\n\n```javascript\n// 例一\nfunction f(x = 1, y) {\n  return [x, y];\n}\n\nf() // [1, undefined]\nf(2) // [2, undefined])\nf(, 1) // 报错\nf(undefined, 1) // [1, 1]\n\n// 例二\nfunction f(x, y = 5, z) {\n  return [x, y, z];\n}\n\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // 报错\nf(1, undefined, 2) // [1, 5, 2]\n```\n\n上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入`undefined`。\n\n如果传入`undefined`，将触发该参数等于默认值，`null`则没有这个效果。\n\n```javascript\nfunction foo(x = 5, y = 6) {\n  console.log(x, y);\n}\n\nfoo(undefined, null)\n// 5 null\n```\n\n上面代码中，`x`参数对应`undefined`，结果触发了默认值，`y`参数等于`null`，就没有触发默认值。\n\n### 函数的length属性\n\n指定了默认值以后，函数的`length`属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，`length`属性将失真。\n\n```javascript\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n```\n\n上面代码中，`length`属性的返回值，**等于函数的参数个数减去指定了默认值的参数个数**。比如，上面最后一个函数，定义了3个参数，其中有一个参数`c`指定了默认值，因此`length`属性等于`3`减去`1`，最后得到`2`。\n\n这是因为`length`属性的含义是，该函数预期传入的参数个数。**某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入`length`属性**。\n\n```javascript\n(function(...args) {}).length // 0\n```\n\n如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了。\n\n```javascript\n(function (a = 0, b, c) {}).length // 0\n(function (a, b = 1, c) {}).length // 1\n```\n\n### 作用域\n\n一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。\n\n```javascript\nvar x = 1;\n\nfunction f(x, y = x) {\n  console.log(y);\n}\n\nf(2) // 2\n```\n\n上面代码中，参数`y`的默认值等于`x`。调用时，由于函数作用域内部的变量`x`已经生成，所以`y`等于参数`x`，而不是全局变量`x`。\n\n如果调用时，函数作用域内部的变量`x`没有生成，结果就会不一样。\n\n```javascript\nlet x = 1;\n\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // 1\n```\n\n上面代码中，函数调用时，`y`的默认值变量`x`尚未在函数内部生成，所以`x`指向全局变量。\n\n如果此时，全局变量`x`不存在，就会报错。\n\n```javascript\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // ReferenceError: x is not defined\n```\n\n下面这样写，也会报错。\n\n```javascript\nvar x = 1;\n\nfunction foo(x = x) {\n  // ...\n}\n\nfoo() // ReferenceError: x is not defined\n```\n\n上面代码中，函数`foo`的参数`x`的默认值也是`x`。这时，默认值`x`的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量`x`，但是默认值在`x`赋值之前先执行了，所以这时属于暂时性死区（参见《let和const命令》一章），任何对`x`的操作都会报错。\n\n如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。\n\n```javascript\nlet foo = 'outer';\n\nfunction bar(func = x => foo) {\n  let foo = 'inner';\n  console.log(func()); // outer\n}\n\nbar();\n```\n\n上面代码中，函数`bar`的参数`func`的默认值是一个匿名函数，返回值为变量`foo`。这个匿名函数声明时，`bar`函数的作用域还没有形成，所以匿名函数里面的`foo`指向外层作用域的`foo`，输出`outer`。\n\n如果写成下面这样，就会报错。\n\n```javascript\nfunction bar(func = () => foo) {\n  let foo = 'inner';\n  console.log(func());\n}\n\nbar() // ReferenceError: foo is not defined\n```\n\n上面代码中，匿名函数里面的`foo`指向函数外层，但是函数外层并没有声明`foo`，所以就报错了。\n\n## rest参数\n\nES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\n```javascript\nfunction add(...values) {\n  let sum = 0;\n\n  for (var val of values) {\n    sum += val;\n  }\n\n  return sum;\n}\n\nadd(2, 5, 3) // 10\n```\n\n上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数。\n\n下面是一个rest参数代替arguments变量的例子。\n\n```javascript\n// arguments变量的写法\nfunction sortNumbers() {\n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// rest参数的写法\nconst sortNumbers = (...numbers) => numbers.sort();\n```\n\n上面代码的两种写法，比较后可以发现，rest参数的写法更自然也更简洁。\n\nrest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push方法的例子。\n\n```javascript\nfunction push(array, ...items) {\n  items.forEach(function(item) {\n    array.push(item);\n    console.log(item);\n  });\n}\n\nvar a = [];\npush(a, 1, 2, 3)\n```\n\n注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\n\n```javascript\n// 报错\nfunction f(a, ...b, c) {\n  // ...\n}\n```\n\n函数的length属性，不包括rest参数。\n\n```javascript\n(function(a) {}).length  // 1\n(function(...a) {}).length  // 0\n(function(a, ...b) {}).length  // 1\n```\n\n## 扩展运算符\n\n### 含义\n\n扩展运算符（spread）是三个点（`...`）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\n```javascript\nconsole.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n[...document.querySelectorAll('div')]\n// [<div>, <div>, <div>]\n```\n\n该运算符主要用于函数调用。\n\n```javascript\nfunction push(array, ...items) {\n  array.push(...items);\n}\n\nfunction add(x, y) {\n  return x + y;\n}\n\nvar numbers = [4, 38];\nadd(...numbers) // 42\n```\n\n上面代码中，`array.push(...items)`和`add(...numbers)`这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。\n\n扩展运算符与正常的函数参数可以结合使用，非常灵活。\n\n```javascript\nfunction f(v, w, x, y, z) { }\nvar args = [0, 1];\nf(-1, ...args, 2, ...[3]);\n```\n\n### 替代数组的apply方法\n\n由于扩展运算符可以展开数组，所以不再需要`apply`方法，将数组转为函数的参数了。\n\n```javascript\n// ES5的写法\nfunction f(x, y, z) {\n  // ...\n}\nvar args = [0, 1, 2];\nf.apply(null, args);\n\n// ES6的写法\nfunction f(x, y, z) {\n  // ...\n}\nvar args = [0, 1, 2];\nf(...args);\n```\n\n下面是扩展运算符取代`apply`方法的一个实际的例子，应用`Math.max`方法，简化求出一个数组最大元素的写法。\n\n```javascript\n// ES5的写法\nMath.max.apply(null, [14, 3, 77])\n\n// ES6的写法\nMath.max(...[14, 3, 77])\n\n// 等同于\nMath.max(14, 3, 77);\n```\n\n上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用`Math.max`函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用`Math.max`了。\n\n另一个例子是通过`push`函数，将一个数组添加到另一个数组的尾部。\n\n```javascript\n// ES5的写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nArray.prototype.push.apply(arr1, arr2);\n\n// ES6的写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1.push(...arr2);\n```\n\n上面代码的ES5写法中，`push`方法的参数不能是数组，所以只好通过`apply`方法变通使用`push`方法。有了扩展运算符，就可以直接将数组传入`push`方法。\n\n下面是另外一个例子。\n\n```javascript\n// ES5\nnew (Date.bind.apply(Date, [null, 2015, 1, 1]))\n// ES6\nnew Date(...[2015, 1, 1]);\n```\n\n### 扩展运算符的应用\n\n**（1）合并数组**\n\n扩展运算符提供了数组合并的新写法。\n\n```javascript\n// ES5\n[1, 2].concat(more)\n// ES6\n[1, 2, ...more]\n\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['d', 'e'];\n\n// ES5的合并数组\narr1.concat(arr2, arr3);\n// [ 'a', 'b', 'c', 'd', 'e' ]\n\n// ES6的合并数组\n[...arr1, ...arr2, ...arr3]\n// [ 'a', 'b', 'c', 'd', 'e' ]\n```\n\n**（2）与解构赋值结合**\n\n扩展运算符可以与解构赋值结合起来，用于生成数组。\n\n```javascript\n// ES5\na = list[0], rest = list.slice(1)\n// ES6\n[a, ...rest] = list\n```\n\n下面是另外一些例子。\n\n```javascript\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []:\n\nconst [first, ...rest] = [\"foo\"];\nfirst  // \"foo\"\nrest   // []\n```\n\n如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\n\n```javascript\nconst [...butLast, last] = [1, 2, 3, 4, 5];\n// 报错\n\nconst [first, ...middle, last] = [1, 2, 3, 4, 5];\n// 报错\n```\n\n**（3）函数的返回值**\n\nJavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。\n\n```javascript\nvar dateFields = readDateFields(database);\nvar d = new Date(...dateFields);\n```\n\n上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数`Date`。\n\n**（4）字符串**\n\n扩展运算符还可以将字符串转为真正的数组。\n\n```javascript\n[...'hello']\n// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n```\n\n**（5）实现了Iterator接口的对象**\n\n任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。\n\n```javascript\nvar nodeList = document.querySelectorAll('div');\nvar array = [...nodeList];\n```\n\n上面代码中，`querySelectorAll`方法返回的是一个`nodeList`对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于`NodeList`对象实现了Iterator接口。\n\n对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。\n\n```javascript\nlet arrayLike = {\n  '0': 'a',\n  '1': 'b',\n  '2': 'c',\n  length: 3\n};\n\n// TypeError: Cannot spread non-iterable object.\nlet arr = [...arrayLike];\n```\n\n上面代码中，`arrayLike`是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用`Array.from`方法将`arrayLike`转为真正的数组。\n\n**（6）Map和Set结构，Generator函数**\n\n扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。\n\n```javascript\nlet map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nlet arr = [...map.keys()]; // [1, 2, 3]\n```\n\n如果对没有`iterator`接口的对象，使用扩展运算符，将会报错。\n\n```javascript\nvar obj = {a: 1, b: 2};\nlet arr = [...obj]; // TypeError: Cannot spread non-iterable object\n```\n\n## 严格模式\n\n从ES5开始，函数内部可以设定为严格模式。\n\n```javascript\nfunction doSomething(a, b) {\n  'use strict';\n  // code\n}\n```\n\n《ECMAScript 2016标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n\n```javascript\n// 报错\nfunction doSomething(a, b = a) {\n  'use strict';\n  // code\n}\n\n// 报错\nconst doSomething = function ({a, b}) {\n  'use strict';\n  // code\n};\n\n// 报错\nconst doSomething = (...a) => {\n  'use strict';\n  // code\n};\n\nconst obj = {\n  // 报错\n  doSomething({a, b}) {\n    'use strict';\n    // code\n  }\n};\n```\n\n这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。\n\n```javascript\n// 报错\nfunction doSomething(value = 070) {\n  'use strict';\n  return value;\n}\n```\n\n上面代码中，参数`value`的默认值是八进制数`070`，但是严格模式下不能用前缀`0`表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行`value = 070`，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。\n\n虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。\n\n两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。\n\n```javascript\n'use strict';\n\nfunction doSomething(a, b = a) {\n  // code\n}\n```\n\n第二种是把函数包在一个无参数的立即执行函数里面。\n\n```javascript\nconst doSomething = (function () {\n  'use strict';\n  return function(value = 42) {\n    return value;\n  };\n}());\n```\n\n","slug":"ES2015函数默认值,rest参数及扩展运算符","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfbr0008zk4owdii00ay","content":"<h2 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  y = y || <span class=\"string\">'World'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// Hello World</span></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">'China'</span>) <span class=\"comment\">// Hello China</span></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">''</span>) <span class=\"comment\">// Hello World</span></div></pre></td></tr></table></figure>\n<p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p>\n<p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> y === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">  y = <span class=\"string\">'World'</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">x, y = <span class=\"string\">'World'</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// Hello World</span></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">'China'</span>) <span class=\"comment\">// Hello China</span></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">''</span>) <span class=\"comment\">// Hello</span></div></pre></td></tr></table></figure>\n<p>可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">  <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point();</div><div class=\"line\">p <span class=\"comment\">// &#123; x: 0, y: 0 &#125;</span></div></pre></td></tr></table></figure>\n<p>除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>\n<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = <span class=\"number\">5</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">1</span>; <span class=\"comment\">// error</span></div><div class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">2</span>; <span class=\"comment\">// error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，参数变量<code>x</code>是默认声明的，在函数体中，不能用<code>let</code>或<code>const</code>再次声明，否则会报错。<br><a id=\"more\"></a></p>\n<h3 id=\"与解构赋值默认值结合使用\"><a href=\"#与解构赋值默认值结合使用\" class=\"headerlink\" title=\"与解构赋值默认值结合使用\"></a>与解构赋值默认值结合使用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">&#123;x, y = <span class=\"number\">5</span>&#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(&#123;&#125;) <span class=\"comment\">// undefined, 5</span></div><div class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;) <span class=\"comment\">// 1, 5</span></div><div class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;) <span class=\"comment\">// 1, 2</span></div><div class=\"line\">foo() <span class=\"comment\">// TypeError: Cannot read property 'x' of undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值而生成。如果函数<code>foo</code>调用时参数不是对象，变量<code>x</code>和<code>y</code>就不会生成，从而报错。如果参数对象没有<code>y</code>属性，<code>y</code>的默认值5才会生效。</p>\n<p>下面是另一个对象的解构赋值默认值的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetch</span>(<span class=\"params\">url, &#123; body = <span class=\"string\">''</span>, method = <span class=\"string\">'GET'</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(method);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fetch(<span class=\"string\">'http://example.com'</span>, &#123;&#125;)</div><div class=\"line\"><span class=\"comment\">// \"GET\"</span></div><div class=\"line\"></div><div class=\"line\">fetch(<span class=\"string\">'http://example.com'</span>)</div><div class=\"line\"><span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。</p>\n<p>上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetch</span>(<span class=\"params\">url, &#123; method = <span class=\"string\">'GET'</span> &#125; = &#123;&#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(method);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fetch(<span class=\"string\">'http://example.com'</span>)</div><div class=\"line\"><span class=\"comment\">// \"GET\"</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</p>\n<p>再请问下面两种写法有什么差别？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写法一</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">&#123;x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写法二</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">&#123;x, y&#125; = &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数没有参数的情况</span></div><div class=\"line\">m1() <span class=\"comment\">// [0, 0]</span></div><div class=\"line\">m2() <span class=\"comment\">// [0, 0]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// x和y都有值的情况</span></div><div class=\"line\">m1(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">8</span>&#125;) <span class=\"comment\">// [3, 8]</span></div><div class=\"line\">m2(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">8</span>&#125;) <span class=\"comment\">// [3, 8]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// x有值，y无值的情况</span></div><div class=\"line\">m1(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// [3, 0]</span></div><div class=\"line\">m2(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// [3, undefined]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// x和y都无值的情况</span></div><div class=\"line\">m1(&#123;&#125;) <span class=\"comment\">// [0, 0];</span></div><div class=\"line\">m2(&#123;&#125;) <span class=\"comment\">// [undefined, undefined]</span></div><div class=\"line\"></div><div class=\"line\">m1(&#123;<span class=\"attr\">z</span>: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// [0, 0]</span></div><div class=\"line\">m2(&#123;<span class=\"attr\">z</span>: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// [undefined, undefined]</span></div></pre></td></tr></table></figure>\n<h3 id=\"参数默认值的位置\"><a href=\"#参数默认值的位置\" class=\"headerlink\" title=\"参数默认值的位置\"></a>参数默认值的位置</h3><blockquote>\n<p> 尽量放在<strong>参数最后</strong><br>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果<del>非尾部的参数设置默认值</del>，实际上这个参数是没法省略的。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 例一</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x = <span class=\"number\">1</span>, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f() <span class=\"comment\">// [1, undefined]</span></div><div class=\"line\">f(<span class=\"number\">2</span>) <span class=\"comment\">// [2, undefined])</span></div><div class=\"line\">f(, <span class=\"number\">1</span>) <span class=\"comment\">// 报错</span></div><div class=\"line\">f(<span class=\"literal\">undefined</span>, <span class=\"number\">1</span>) <span class=\"comment\">// [1, 1]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 例二</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y = <span class=\"number\">5</span>, z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y, z];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f() <span class=\"comment\">// [undefined, 5, undefined]</span></div><div class=\"line\">f(<span class=\"number\">1</span>) <span class=\"comment\">// [1, 5, undefined]</span></div><div class=\"line\">f(<span class=\"number\">1</span>, ,<span class=\"number\">2</span>) <span class=\"comment\">// 报错</span></div><div class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>, <span class=\"number\">2</span>) <span class=\"comment\">// [1, 5, 2]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入<code>undefined</code>。</p>\n<p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = <span class=\"number\">5</span>, y = <span class=\"number\">6</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"literal\">undefined</span>, <span class=\"literal\">null</span>)</div><div class=\"line\"><span class=\"comment\">// 5 null</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>x</code>参数对应<code>undefined</code>，结果触发了默认值，<code>y</code>参数等于<code>null</code>，就没有触发默认值。</p>\n<h3 id=\"函数的length属性\"><a href=\"#函数的length属性\" class=\"headerlink\" title=\"函数的length属性\"></a>函数的length属性</h3><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123;&#125;).length <span class=\"comment\">// 1</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a = <span class=\"number\">5</span></span>) </span>&#123;&#125;).length <span class=\"comment\">// 0</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b, c = <span class=\"number\">5</span></span>) </span>&#123;&#125;).length <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>length</code>属性的返回值，<strong>等于函数的参数个数减去指定了默认值的参数个数</strong>。比如，上面最后一个函数，定义了3个参数，其中有一个参数<code>c</code>指定了默认值，因此<code>length</code>属性等于<code>3</code>减去<code>1</code>，最后得到<code>2</code>。</p>\n<p>这是因为<code>length</code>属性的含义是，该函数预期传入的参数个数。<strong>某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入<code>length</code>属性</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;&#125;).length <span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a = <span class=\"number\">0</span>, b, c</span>) </span>&#123;&#125;).length <span class=\"comment\">// 0</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b = <span class=\"number\">1</span>, c</span>) </span>&#123;&#125;).length <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f(<span class=\"number\">2</span>) <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面代码中，参数<code>y</code>的默认值等于<code>x</code>。调用时，由于函数作用域内部的变量<code>x</code>已经生成，所以<code>y</code>等于参数<code>x</code>，而不是全局变量<code>x</code>。</p>\n<p>如果调用时，函数作用域内部的变量<code>x</code>没有生成，结果就会不一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">y = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f() <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数调用时，<code>y</code>的默认值变量<code>x</code>尚未在函数内部生成，所以<code>x</code>指向全局变量。</p>\n<p>如果此时，全局变量<code>x</code>不存在，就会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">y = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f() <span class=\"comment\">// ReferenceError: x is not defined</span></div></pre></td></tr></table></figure>\n<p>下面这样写，也会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo() <span class=\"comment\">// ReferenceError: x is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>foo</code>的参数<code>x</code>的默认值也是<code>x</code>。这时，默认值<code>x</code>的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量<code>x</code>，但是默认值在<code>x</code>赋值之前先执行了，所以这时属于暂时性死区（参见《let和const命令》一章），任何对<code>x</code>的操作都会报错。</p>\n<p>如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"string\">'outer'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">func = x =&gt; foo</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> foo = <span class=\"string\">'inner'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(func()); <span class=\"comment\">// outer</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar();</div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。这个匿名函数声明时，<code>bar</code>函数的作用域还没有形成，所以匿名函数里面的<code>foo</code>指向外层作用域的<code>foo</code>，输出<code>outer</code>。</p>\n<p>如果写成下面这样，就会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">func = (</span>) =&gt; <span class=\"title\">foo</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> foo = <span class=\"string\">'inner'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(func());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar() <span class=\"comment\">// ReferenceError: foo is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，匿名函数里面的<code>foo</code>指向函数外层，但是函数外层并没有声明<code>foo</code>，所以就报错了。</p>\n<h2 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h2><p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">...values</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> val <span class=\"keyword\">of</span> values) &#123;</div><div class=\"line\">    sum += val;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">add(<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure>\n<p>上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数。</p>\n<p>下面是一个rest参数代替arguments变量的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// arguments变量的写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortNumbers</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>).sort();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// rest参数的写法</span></div><div class=\"line\"><span class=\"keyword\">const</span> sortNumbers = <span class=\"function\">(<span class=\"params\">...numbers</span>) =&gt;</span> numbers.sort();</div></pre></td></tr></table></figure>\n<p>上面代码的两种写法，比较后可以发现，rest参数的写法更自然也更简洁。</p>\n<p>rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push方法的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">array, ...items</span>) </span>&#123;</div><div class=\"line\">  items.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">    array.push(item);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(item);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = [];</div><div class=\"line\">push(a, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</div></pre></td></tr></table></figure>\n<p>注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a, ...b, c</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数的length属性，不包括rest参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;&#125;).length  <span class=\"comment\">// 1</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...a</span>) </span>&#123;&#125;).length  <span class=\"comment\">// 0</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, ...b</span>) </span>&#123;&#125;).length  <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(...[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"comment\">// 1 2 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, ...[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// 1 2 3 4 5</span></div><div class=\"line\"></div><div class=\"line\">[...document.querySelectorAll(<span class=\"string\">'div'</span>)]</div><div class=\"line\"><span class=\"comment\">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></div></pre></td></tr></table></figure>\n<p>该运算符主要用于函数调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">array, ...items</span>) </span>&#123;</div><div class=\"line\">  array.push(...items);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">4</span>, <span class=\"number\">38</span>];</div><div class=\"line\">add(...numbers) <span class=\"comment\">// 42</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>\n<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">v, w, x, y, z</span>) </span>&#123; &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>];</div><div class=\"line\">f(<span class=\"number\">-1</span>, ...args, <span class=\"number\">2</span>, ...[<span class=\"number\">3</span>]);</div></pre></td></tr></table></figure>\n<h3 id=\"替代数组的apply方法\"><a href=\"#替代数组的apply方法\" class=\"headerlink\" title=\"替代数组的apply方法\"></a>替代数组的apply方法</h3><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">f.apply(<span class=\"literal\">null</span>, args);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">f(...args);</div></pre></td></tr></table></figure>\n<p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">14</span>, <span class=\"number\">3</span>, <span class=\"number\">77</span>])</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max(...[<span class=\"number\">14</span>, <span class=\"number\">3</span>, <span class=\"number\">77</span>])</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max(<span class=\"number\">14</span>, <span class=\"number\">3</span>, <span class=\"number\">77</span>);</div></pre></td></tr></table></figure>\n<p>上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。</p>\n<p>另一个例子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(arr1, arr2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\">arr1.push(...arr2);</div></pre></td></tr></table></figure>\n<p>上面代码的ES5写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。</p>\n<p>下面是另外一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\"><span class=\"keyword\">new</span> (<span class=\"built_in\">Date</span>.bind.apply(<span class=\"built_in\">Date</span>, [<span class=\"literal\">null</span>, <span class=\"number\">2015</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]))</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(...[<span class=\"number\">2015</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]);</div></pre></td></tr></table></figure>\n<h3 id=\"扩展运算符的应用\"><a href=\"#扩展运算符的应用\" class=\"headerlink\" title=\"扩展运算符的应用\"></a>扩展运算符的应用</h3><p><strong>（1）合并数组</strong></p>\n<p>扩展运算符提供了数组合并的新写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>].concat(more)</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, ...more]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">'c'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> arr3 = [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES5的合并数组</span></div><div class=\"line\">arr1.concat(arr2, arr3);</div><div class=\"line\"><span class=\"comment\">// [ 'a', 'b', 'c', 'd', 'e' ]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的合并数组</span></div><div class=\"line\">[...arr1, ...arr2, ...arr3]</div><div class=\"line\"><span class=\"comment\">// [ 'a', 'b', 'c', 'd', 'e' ]</span></div></pre></td></tr></table></figure>\n<p><strong>（2）与解构赋值结合</strong></p>\n<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\">a = list[<span class=\"number\">0</span>], rest = list.slice(<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\">[a, ...rest] = list</div></pre></td></tr></table></figure>\n<p>下面是另外一些例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\">first <span class=\"comment\">// 1</span></div><div class=\"line\">rest  <span class=\"comment\">// [2, 3, 4, 5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [];</div><div class=\"line\">first <span class=\"comment\">// undefined</span></div><div class=\"line\">rest  <span class=\"comment\">// []:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"string\">\"foo\"</span>];</div><div class=\"line\">first  <span class=\"comment\">// \"foo\"</span></div><div class=\"line\">rest   <span class=\"comment\">// []</span></div></pre></td></tr></table></figure>\n<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> [...butLast, last] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> [first, ...middle, last] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p><strong>（3）函数的返回值</strong></p>\n<p>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> dateFields = readDateFields(database);</div><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(...dateFields);</div></pre></td></tr></table></figure>\n<p>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数<code>Date</code>。</p>\n<p><strong>（4）字符串</strong></p>\n<p>扩展运算符还可以将字符串转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...<span class=\"string\">'hello'</span>]</div><div class=\"line\"><span class=\"comment\">// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]</span></div></pre></td></tr></table></figure>\n<p><strong>（5）实现了Iterator接口的对象</strong></p>\n<p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> nodeList = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'div'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> array = [...nodeList];</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>nodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了Iterator接口。</p>\n<p>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</div><div class=\"line\">  <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</div><div class=\"line\">  <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</div><div class=\"line\">  <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</div><div class=\"line\">  <span class=\"attr\">length</span>: <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// TypeError: Cannot spread non-iterable object.</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [...arrayLike];</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</p>\n<p><strong>（6）Map和Set结构，Generator函数</strong></p>\n<p>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>],</div><div class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'two'</span>],</div><div class=\"line\">  [<span class=\"number\">3</span>, <span class=\"string\">'three'</span>],</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [...map.keys()]; <span class=\"comment\">// [1, 2, 3]</span></div></pre></td></tr></table></figure>\n<p>如果对没有<code>iterator</code>接口的对象，使用扩展运算符，将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> arr = [...obj]; <span class=\"comment\">// TypeError: Cannot spread non-iterable object</span></div></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>从ES5开始，函数内部可以设定为严格模式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>《ECMAScript 2016标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a, b = a</span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">&#123;a, b&#125;</span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\">(<span class=\"params\">...a</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"string\">'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">  <span class=\"comment\">// 报错</span></div><div class=\"line\">  doSomething(&#123;a, b&#125;) &#123;</div><div class=\"line\">    <span class=\"string\">'use strict'</span>;</div><div class=\"line\">    <span class=\"comment\">// code</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">value = <span class=\"number\">070</span></span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，参数<code>value</code>的默认值是八进制数<code>070</code>，但是严格模式下不能用前缀<code>0</code>表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行<code>value = 070</code>，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>\n<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>\n<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a, b = a</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二种是把函数包在一个无参数的立即执行函数里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> doSomething = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value = <span class=\"number\">42</span></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  y = y || <span class=\"string\">'World'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// Hello World</span></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">'China'</span>) <span class=\"comment\">// Hello China</span></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">''</span>) <span class=\"comment\">// Hello World</span></div></pre></td></tr></table></figure>\n<p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p>\n<p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> y === <span class=\"string\">'undefined'</span>) &#123;</div><div class=\"line\">  y = <span class=\"string\">'World'</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">x, y = <span class=\"string\">'World'</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// Hello World</span></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">'China'</span>) <span class=\"comment\">// Hello China</span></div><div class=\"line\">log(<span class=\"string\">'Hello'</span>, <span class=\"string\">''</span>) <span class=\"comment\">// Hello</span></div></pre></td></tr></table></figure>\n<p>可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.x = x;</div><div class=\"line\">  <span class=\"keyword\">this</span>.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Point();</div><div class=\"line\">p <span class=\"comment\">// &#123; x: 0, y: 0 &#125;</span></div></pre></td></tr></table></figure>\n<p>除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>\n<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = <span class=\"number\">5</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">1</span>; <span class=\"comment\">// error</span></div><div class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">2</span>; <span class=\"comment\">// error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，参数变量<code>x</code>是默认声明的，在函数体中，不能用<code>let</code>或<code>const</code>再次声明，否则会报错。<br>","more":"</p>\n<h3 id=\"与解构赋值默认值结合使用\"><a href=\"#与解构赋值默认值结合使用\" class=\"headerlink\" title=\"与解构赋值默认值结合使用\"></a>与解构赋值默认值结合使用</h3><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">&#123;x, y = <span class=\"number\">5</span>&#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(&#123;&#125;) <span class=\"comment\">// undefined, 5</span></div><div class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;) <span class=\"comment\">// 1, 5</span></div><div class=\"line\">foo(&#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;) <span class=\"comment\">// 1, 2</span></div><div class=\"line\">foo() <span class=\"comment\">// TypeError: Cannot read property 'x' of undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值而生成。如果函数<code>foo</code>调用时参数不是对象，变量<code>x</code>和<code>y</code>就不会生成，从而报错。如果参数对象没有<code>y</code>属性，<code>y</code>的默认值5才会生效。</p>\n<p>下面是另一个对象的解构赋值默认值的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetch</span>(<span class=\"params\">url, &#123; body = <span class=\"string\">''</span>, method = <span class=\"string\">'GET'</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(method);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fetch(<span class=\"string\">'http://example.com'</span>, &#123;&#125;)</div><div class=\"line\"><span class=\"comment\">// \"GET\"</span></div><div class=\"line\"></div><div class=\"line\">fetch(<span class=\"string\">'http://example.com'</span>)</div><div class=\"line\"><span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。</p>\n<p>上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetch</span>(<span class=\"params\">url, &#123; method = <span class=\"string\">'GET'</span> &#125; = &#123;&#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(method);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fetch(<span class=\"string\">'http://example.com'</span>)</div><div class=\"line\"><span class=\"comment\">// \"GET\"</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</p>\n<p>再请问下面两种写法有什么差别？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写法一</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m1</span>(<span class=\"params\">&#123;x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写法二</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">m2</span>(<span class=\"params\">&#123;x, y&#125; = &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125;</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 函数没有参数的情况</span></div><div class=\"line\">m1() <span class=\"comment\">// [0, 0]</span></div><div class=\"line\">m2() <span class=\"comment\">// [0, 0]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// x和y都有值的情况</span></div><div class=\"line\">m1(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">8</span>&#125;) <span class=\"comment\">// [3, 8]</span></div><div class=\"line\">m2(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>, <span class=\"attr\">y</span>: <span class=\"number\">8</span>&#125;) <span class=\"comment\">// [3, 8]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// x有值，y无值的情况</span></div><div class=\"line\">m1(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// [3, 0]</span></div><div class=\"line\">m2(&#123;<span class=\"attr\">x</span>: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// [3, undefined]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// x和y都无值的情况</span></div><div class=\"line\">m1(&#123;&#125;) <span class=\"comment\">// [0, 0];</span></div><div class=\"line\">m2(&#123;&#125;) <span class=\"comment\">// [undefined, undefined]</span></div><div class=\"line\"></div><div class=\"line\">m1(&#123;<span class=\"attr\">z</span>: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// [0, 0]</span></div><div class=\"line\">m2(&#123;<span class=\"attr\">z</span>: <span class=\"number\">3</span>&#125;) <span class=\"comment\">// [undefined, undefined]</span></div></pre></td></tr></table></figure>\n<h3 id=\"参数默认值的位置\"><a href=\"#参数默认值的位置\" class=\"headerlink\" title=\"参数默认值的位置\"></a>参数默认值的位置</h3><blockquote>\n<p> 尽量放在<strong>参数最后</strong><br>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果<del>非尾部的参数设置默认值</del>，实际上这个参数是没法省略的。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 例一</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x = <span class=\"number\">1</span>, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f() <span class=\"comment\">// [1, undefined]</span></div><div class=\"line\">f(<span class=\"number\">2</span>) <span class=\"comment\">// [2, undefined])</span></div><div class=\"line\">f(, <span class=\"number\">1</span>) <span class=\"comment\">// 报错</span></div><div class=\"line\">f(<span class=\"literal\">undefined</span>, <span class=\"number\">1</span>) <span class=\"comment\">// [1, 1]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 例二</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y = <span class=\"number\">5</span>, z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [x, y, z];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f() <span class=\"comment\">// [undefined, 5, undefined]</span></div><div class=\"line\">f(<span class=\"number\">1</span>) <span class=\"comment\">// [1, 5, undefined]</span></div><div class=\"line\">f(<span class=\"number\">1</span>, ,<span class=\"number\">2</span>) <span class=\"comment\">// 报错</span></div><div class=\"line\">f(<span class=\"number\">1</span>, <span class=\"literal\">undefined</span>, <span class=\"number\">2</span>) <span class=\"comment\">// [1, 5, 2]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入<code>undefined</code>。</p>\n<p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = <span class=\"number\">5</span>, y = <span class=\"number\">6</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x, y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo(<span class=\"literal\">undefined</span>, <span class=\"literal\">null</span>)</div><div class=\"line\"><span class=\"comment\">// 5 null</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>x</code>参数对应<code>undefined</code>，结果触发了默认值，<code>y</code>参数等于<code>null</code>，就没有触发默认值。</p>\n<h3 id=\"函数的length属性\"><a href=\"#函数的length属性\" class=\"headerlink\" title=\"函数的length属性\"></a>函数的length属性</h3><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>) </span>&#123;&#125;).length <span class=\"comment\">// 1</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a = <span class=\"number\">5</span></span>) </span>&#123;&#125;).length <span class=\"comment\">// 0</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b, c = <span class=\"number\">5</span></span>) </span>&#123;&#125;).length <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>length</code>属性的返回值，<strong>等于函数的参数个数减去指定了默认值的参数个数</strong>。比如，上面最后一个函数，定义了3个参数，其中有一个参数<code>c</code>指定了默认值，因此<code>length</code>属性等于<code>3</code>减去<code>1</code>，最后得到<code>2</code>。</p>\n<p>这是因为<code>length</code>属性的含义是，该函数预期传入的参数个数。<strong>某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入<code>length</code>属性</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;&#125;).length <span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a = <span class=\"number\">0</span>, b, c</span>) </span>&#123;&#125;).length <span class=\"comment\">// 0</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a, b = <span class=\"number\">1</span>, c</span>) </span>&#123;&#125;).length <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f(<span class=\"number\">2</span>) <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面代码中，参数<code>y</code>的默认值等于<code>x</code>。调用时，由于函数作用域内部的变量<code>x</code>已经生成，所以<code>y</code>等于参数<code>x</code>，而不是全局变量<code>x</code>。</p>\n<p>如果调用时，函数作用域内部的变量<code>x</code>没有生成，结果就会不一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">y = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f() <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数调用时，<code>y</code>的默认值变量<code>x</code>尚未在函数内部生成，所以<code>x</code>指向全局变量。</p>\n<p>如果此时，全局变量<code>x</code>不存在，就会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">y = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f() <span class=\"comment\">// ReferenceError: x is not defined</span></div></pre></td></tr></table></figure>\n<p>下面这样写，也会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x = x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">foo() <span class=\"comment\">// ReferenceError: x is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>foo</code>的参数<code>x</code>的默认值也是<code>x</code>。这时，默认值<code>x</code>的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量<code>x</code>，但是默认值在<code>x</code>赋值之前先执行了，所以这时属于暂时性死区（参见《let和const命令》一章），任何对<code>x</code>的操作都会报错。</p>\n<p>如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"string\">'outer'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">func = x =&gt; foo</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> foo = <span class=\"string\">'inner'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(func()); <span class=\"comment\">// outer</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar();</div></pre></td></tr></table></figure>\n<p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。这个匿名函数声明时，<code>bar</code>函数的作用域还没有形成，所以匿名函数里面的<code>foo</code>指向外层作用域的<code>foo</code>，输出<code>outer</code>。</p>\n<p>如果写成下面这样，就会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">func = (</span>) =&gt; <span class=\"title\">foo</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> foo = <span class=\"string\">'inner'</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(func());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar() <span class=\"comment\">// ReferenceError: foo is not defined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，匿名函数里面的<code>foo</code>指向函数外层，但是函数外层并没有声明<code>foo</code>，所以就报错了。</p>\n<h2 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h2><p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">...values</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> val <span class=\"keyword\">of</span> values) &#123;</div><div class=\"line\">    sum += val;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">add(<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure>\n<p>上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数。</p>\n<p>下面是一个rest参数代替arguments变量的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// arguments变量的写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortNumbers</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>).sort();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// rest参数的写法</span></div><div class=\"line\"><span class=\"keyword\">const</span> sortNumbers = <span class=\"function\">(<span class=\"params\">...numbers</span>) =&gt;</span> numbers.sort();</div></pre></td></tr></table></figure>\n<p>上面代码的两种写法，比较后可以发现，rest参数的写法更自然也更简洁。</p>\n<p>rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push方法的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">array, ...items</span>) </span>&#123;</div><div class=\"line\">  items.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</div><div class=\"line\">    array.push(item);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(item);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = [];</div><div class=\"line\">push(a, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</div></pre></td></tr></table></figure>\n<p>注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a, ...b, c</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数的length属性，不包括rest参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;&#125;).length  <span class=\"comment\">// 1</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...a</span>) </span>&#123;&#125;).length  <span class=\"comment\">// 0</span></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, ...b</span>) </span>&#123;&#125;).length  <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<h2 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h2><h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(...[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</div><div class=\"line\"><span class=\"comment\">// 1 2 3</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>, ...[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// 1 2 3 4 5</span></div><div class=\"line\"></div><div class=\"line\">[...document.querySelectorAll(<span class=\"string\">'div'</span>)]</div><div class=\"line\"><span class=\"comment\">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></div></pre></td></tr></table></figure>\n<p>该运算符主要用于函数调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">push</span>(<span class=\"params\">array, ...items</span>) </span>&#123;</div><div class=\"line\">  array.push(...items);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">4</span>, <span class=\"number\">38</span>];</div><div class=\"line\">add(...numbers) <span class=\"comment\">// 42</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>\n<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">v, w, x, y, z</span>) </span>&#123; &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>];</div><div class=\"line\">f(<span class=\"number\">-1</span>, ...args, <span class=\"number\">2</span>, ...[<span class=\"number\">3</span>]);</div></pre></td></tr></table></figure>\n<h3 id=\"替代数组的apply方法\"><a href=\"#替代数组的apply方法\" class=\"headerlink\" title=\"替代数组的apply方法\"></a>替代数组的apply方法</h3><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">f.apply(<span class=\"literal\">null</span>, args);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\">f(...args);</div></pre></td></tr></table></figure>\n<p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">14</span>, <span class=\"number\">3</span>, <span class=\"number\">77</span>])</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max(...[<span class=\"number\">14</span>, <span class=\"number\">3</span>, <span class=\"number\">77</span>])</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.max(<span class=\"number\">14</span>, <span class=\"number\">3</span>, <span class=\"number\">77</span>);</div></pre></td></tr></table></figure>\n<p>上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。</p>\n<p>另一个例子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(arr1, arr2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\">arr1.push(...arr2);</div></pre></td></tr></table></figure>\n<p>上面代码的ES5写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。</p>\n<p>下面是另外一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\"><span class=\"keyword\">new</span> (<span class=\"built_in\">Date</span>.bind.apply(<span class=\"built_in\">Date</span>, [<span class=\"literal\">null</span>, <span class=\"number\">2015</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]))</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(...[<span class=\"number\">2015</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]);</div></pre></td></tr></table></figure>\n<h3 id=\"扩展运算符的应用\"><a href=\"#扩展运算符的应用\" class=\"headerlink\" title=\"扩展运算符的应用\"></a>扩展运算符的应用</h3><p><strong>（1）合并数组</strong></p>\n<p>扩展运算符提供了数组合并的新写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>].concat(more)</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, ...more]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">'c'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> arr3 = [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES5的合并数组</span></div><div class=\"line\">arr1.concat(arr2, arr3);</div><div class=\"line\"><span class=\"comment\">// [ 'a', 'b', 'c', 'd', 'e' ]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的合并数组</span></div><div class=\"line\">[...arr1, ...arr2, ...arr3]</div><div class=\"line\"><span class=\"comment\">// [ 'a', 'b', 'c', 'd', 'e' ]</span></div></pre></td></tr></table></figure>\n<p><strong>（2）与解构赋值结合</strong></p>\n<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5</span></div><div class=\"line\">a = list[<span class=\"number\">0</span>], rest = list.slice(<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\">[a, ...rest] = list</div></pre></td></tr></table></figure>\n<p>下面是另外一些例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\">first <span class=\"comment\">// 1</span></div><div class=\"line\">rest  <span class=\"comment\">// [2, 3, 4, 5]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [];</div><div class=\"line\">first <span class=\"comment\">// undefined</span></div><div class=\"line\">rest  <span class=\"comment\">// []:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> [first, ...rest] = [<span class=\"string\">\"foo\"</span>];</div><div class=\"line\">first  <span class=\"comment\">// \"foo\"</span></div><div class=\"line\">rest   <span class=\"comment\">// []</span></div></pre></td></tr></table></figure>\n<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> [...butLast, last] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> [first, ...middle, last] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p><strong>（3）函数的返回值</strong></p>\n<p>JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> dateFields = readDateFields(database);</div><div class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(...dateFields);</div></pre></td></tr></table></figure>\n<p>上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数<code>Date</code>。</p>\n<p><strong>（4）字符串</strong></p>\n<p>扩展运算符还可以将字符串转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[...<span class=\"string\">'hello'</span>]</div><div class=\"line\"><span class=\"comment\">// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]</span></div></pre></td></tr></table></figure>\n<p><strong>（5）实现了Iterator接口的对象</strong></p>\n<p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> nodeList = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'div'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> array = [...nodeList];</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>nodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了Iterator接口。</p>\n<p>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</div><div class=\"line\">  <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</div><div class=\"line\">  <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</div><div class=\"line\">  <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</div><div class=\"line\">  <span class=\"attr\">length</span>: <span class=\"number\">3</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// TypeError: Cannot spread non-iterable object.</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [...arrayLike];</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</p>\n<p><strong>（6）Map和Set结构，Generator函数</strong></p>\n<p>扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>],</div><div class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'two'</span>],</div><div class=\"line\">  [<span class=\"number\">3</span>, <span class=\"string\">'three'</span>],</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [...map.keys()]; <span class=\"comment\">// [1, 2, 3]</span></div></pre></td></tr></table></figure>\n<p>如果对没有<code>iterator</code>接口的对象，使用扩展运算符，将会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> arr = [...obj]; <span class=\"comment\">// TypeError: Cannot spread non-iterable object</span></div></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>从ES5开始，函数内部可以设定为严格模式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>《ECMAScript 2016标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a, b = a</span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">&#123;a, b&#125;</span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\">(<span class=\"params\">...a</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"string\">'use strict'</span>;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">  <span class=\"comment\">// 报错</span></div><div class=\"line\">  doSomething(&#123;a, b&#125;) &#123;</div><div class=\"line\">    <span class=\"string\">'use strict'</span>;</div><div class=\"line\">    <span class=\"comment\">// code</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">value = <span class=\"number\">070</span></span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，参数<code>value</code>的默认值是八进制数<code>070</code>，但是严格模式下不能用前缀<code>0</code>表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行<code>value = 070</code>，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>\n<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>\n<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a, b = a</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// code</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第二种是把函数包在一个无参数的立即执行函数里面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> doSomething = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  'use strict'</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value = <span class=\"number\">42</span></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> value;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>"},{"title":"Es2015字符串扩展","date":"2016-10-31T07:00:05.000Z","_content":"## includes(), startsWith(), endsWith()\n\n传统上，JavaScript只有`indexOf`方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。\n\n- **includes()**：返回布尔值，表示是否找到了参数字符串。\n- **startsWith()**：返回布尔值，表示参数字符串是否在源字符串的头部。\n- **endsWith()**：返回布尔值，表示参数字符串是否在源字符串的尾部。\n\n```javascript\nvar s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n```\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n\n```javascript\nvar s = 'Hello world!';\n\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n```\n\n上面代码表示，使用第二个参数`n`时，`endsWith`的行为与其他两个方法有所不同。它针对前`n`个字符，而其他两个方法针对从第`n`个位置直到字符串结束。\n\n## repeat()\n\n`repeat`方法返回一个新字符串，表示将原字符串重复`n`次。\n\n```javascript\n'x'.repeat(3) // \"xxx\"\n'hello'.repeat(2) // \"hellohello\"\n'na'.repeat(0) // \"\"\n```\n\n参数如果是小数，会被取整。\n\n```javascript\n'na'.repeat(2.9) // \"nana\"\n```\n\n如果`repeat`的参数是负数或者`Infinity`，会报错。\n\n```javascript\n'na'.repeat(Infinity)\n// RangeError\n'na'.repeat(-1)\n// RangeError\n```\n\n但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于`-0`，`repeat`视同为0。\n\n```javascript\n'na'.repeat(-0.9) // \"\"\n```\n\n参数`NaN`等同于0。\n\n```javascript\n'na'.repeat(NaN) // \"\"\n```\n\n如果`repeat`的参数是字符串，则会先转换成数字。\n\n```javascript\n'na'.repeat('na') // \"\"\n'na'.repeat('3') // \"nanana\"\n```\n<!--more-->\n\n## 模板字符串\n\n传统的JavaScript语言，输出模板通常是这样写的。\n\n```javascript\n$('#result').append(\n  'There are <b>' + basket.count + '</b> ' +\n  'items in your basket, ' +\n  '<em>' + basket.onSale +\n  '</em> are on sale!'\n);\n```\n\n上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。\n\n```javascript\n$('#result').append(`\n  There are <b>${basket.count}</b> items\n   in your basket, <em>${basket.onSale}</em>\n  are on sale!\n`);\n```\n\n模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n\n```javascript\n// 普通字符串\n`In JavaScript '\\n' is a line-feed.`\n\n// 多行字符串\n`In JavaScript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n\n// 字符串中嵌入变量\nvar name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n```\n\n上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n\n```javascript\nvar greeting = `\\`Yo\\` World!`;\n```\n\n如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。\n\n```javascript\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`);\n```\n\n上面代码中，所有模板字符串的空格和换行，都是被保留的，比如`<ul>`标签前面会有一个换行。如果你不想要这个换行，可以使用`trim`方法消除它。\n\n\n```javascript\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`.trim());\n```\n\n模板字符串中嵌入变量，需要将变量名写在`${}`之中。\n\n```javascript\nfunction authorize(user, action) {\n  if (!user.hasPrivilege(action)) {\n    throw new Error(\n      // 传统写法为\n      // 'User '\n      // + user.name\n      // + ' is not authorized to do '\n      // + action\n      // + '.'\n      `User ${user.name} is not authorized to do ${action}.`);\n  }\n}\n```\n\n大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。\n\n```javascript\nvar x = 1;\nvar y = 2;\n\n`${x} + ${y} = ${x + y}`\n// \"1 + 2 = 3\"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// \"1 + 4 = 5\"\n\nvar obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n// 3\n```\n\n模板字符串之中还能调用函数。\n\n```javascript\nfunction fn() {\n  return \"Hello World\";\n}\n\n`foo ${fn()} bar`\n// foo Hello World bar\n```\n\n如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的`toString`方法。\n\n如果模板字符串中的变量没有声明，将报错。\n\n```javascript\n// 变量place没有声明\nvar msg = `Hello, ${place}`;\n// 报错\n```\n\n由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。\n\n```javascript\n`Hello ${'World'}`\n// \"Hello World\"\n```\n\n模板字符串甚至还能嵌套。\n\n```javascript\nconst tmpl = addrs => `\n  <table>\n  ${addrs.map(addr => `\n    <tr><td>${addr.first}</td></tr>\n    <tr><td>${addr.last}</td></tr>\n  `).join('')}\n  </table>\n`;\n```\n\n上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。\n\n```javascript\nconst data = [\n    { first: '<Jane>', last: 'Bond' },\n    { first: 'Lars', last: '<Croft>' },\n];\n\nconsole.log(tmpl(data));\n// <table>\n//\n//   <tr><td><Jane></td></tr>\n//   <tr><td>Bond</td></tr>\n//\n//   <tr><td>Lars</td></tr>\n//   <tr><td><Croft></td></tr>\n//\n// </table>\n```\n\n如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。\n\n```javascript\n// 写法一\nlet str = 'return ' + '`Hello ${name}!`';\nlet func = new Function('name', str);\nfunc('Jack') // \"Hello Jack!\"\n\n// 写法二\nlet str = '(name) => `Hello ${name}!`';\nlet func = eval.call(null, str);\nfunc('Jack') // \"Hello Jack!\"\n```\n\n\n## String.raw()\n\nES6还为原生的String对象，提供了一个`raw`方法。\n\n`String.raw`方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。\n\n```javascript\nString.raw`Hi\\n${2+3}!`;\n// \"Hi\\\\n5!\"\n\nString.raw`Hi\\u000A!`;\n// 'Hi\\\\u000A!'\n```\n\n如果原字符串的斜杠已经转义，那么`String.raw`不会做任何处理。\n\n```javascript\nString.raw`Hi\\\\n`\n// \"Hi\\\\n\"\n```\n\n`String.raw`的代码基本如下。\n\n```javascript\nString.raw = function (strings, ...values) {\n  var output = \"\";\n  for (var index = 0; index < values.length; index++) {\n    output += strings.raw[index] + values[index];\n  }\n\n  output += strings.raw[index]\n  return output;\n}\n```\n\n`String.raw`方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。\n\n`String.raw`方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有`raw`属性的对象，且`raw`属性的值应该是一个数组。\n\n```javascript\nString.raw({ raw: 'test' }, 0, 1, 2);\n// 't0e1s2t'\n\n// 等同于\nString.raw({ raw: ['t','e','s','t'] }, 0, 1, 2);\n```\n","source":"_posts/ES2015字符串扩展.md","raw":"---\ntitle: Es2015字符串扩展\ndate: 2016-10-31 15:00:05\ntags: ES2015\n---\n## includes(), startsWith(), endsWith()\n\n传统上，JavaScript只有`indexOf`方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。\n\n- **includes()**：返回布尔值，表示是否找到了参数字符串。\n- **startsWith()**：返回布尔值，表示参数字符串是否在源字符串的头部。\n- **endsWith()**：返回布尔值，表示参数字符串是否在源字符串的尾部。\n\n```javascript\nvar s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n```\n\n这三个方法都支持第二个参数，表示开始搜索的位置。\n\n```javascript\nvar s = 'Hello world!';\n\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n```\n\n上面代码表示，使用第二个参数`n`时，`endsWith`的行为与其他两个方法有所不同。它针对前`n`个字符，而其他两个方法针对从第`n`个位置直到字符串结束。\n\n## repeat()\n\n`repeat`方法返回一个新字符串，表示将原字符串重复`n`次。\n\n```javascript\n'x'.repeat(3) // \"xxx\"\n'hello'.repeat(2) // \"hellohello\"\n'na'.repeat(0) // \"\"\n```\n\n参数如果是小数，会被取整。\n\n```javascript\n'na'.repeat(2.9) // \"nana\"\n```\n\n如果`repeat`的参数是负数或者`Infinity`，会报错。\n\n```javascript\n'na'.repeat(Infinity)\n// RangeError\n'na'.repeat(-1)\n// RangeError\n```\n\n但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于`-0`，`repeat`视同为0。\n\n```javascript\n'na'.repeat(-0.9) // \"\"\n```\n\n参数`NaN`等同于0。\n\n```javascript\n'na'.repeat(NaN) // \"\"\n```\n\n如果`repeat`的参数是字符串，则会先转换成数字。\n\n```javascript\n'na'.repeat('na') // \"\"\n'na'.repeat('3') // \"nanana\"\n```\n<!--more-->\n\n## 模板字符串\n\n传统的JavaScript语言，输出模板通常是这样写的。\n\n```javascript\n$('#result').append(\n  'There are <b>' + basket.count + '</b> ' +\n  'items in your basket, ' +\n  '<em>' + basket.onSale +\n  '</em> are on sale!'\n);\n```\n\n上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。\n\n```javascript\n$('#result').append(`\n  There are <b>${basket.count}</b> items\n   in your basket, <em>${basket.onSale}</em>\n  are on sale!\n`);\n```\n\n模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n\n```javascript\n// 普通字符串\n`In JavaScript '\\n' is a line-feed.`\n\n// 多行字符串\n`In JavaScript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n\n// 字符串中嵌入变量\nvar name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n```\n\n上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。\n\n```javascript\nvar greeting = `\\`Yo\\` World!`;\n```\n\n如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。\n\n```javascript\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`);\n```\n\n上面代码中，所有模板字符串的空格和换行，都是被保留的，比如`<ul>`标签前面会有一个换行。如果你不想要这个换行，可以使用`trim`方法消除它。\n\n\n```javascript\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`.trim());\n```\n\n模板字符串中嵌入变量，需要将变量名写在`${}`之中。\n\n```javascript\nfunction authorize(user, action) {\n  if (!user.hasPrivilege(action)) {\n    throw new Error(\n      // 传统写法为\n      // 'User '\n      // + user.name\n      // + ' is not authorized to do '\n      // + action\n      // + '.'\n      `User ${user.name} is not authorized to do ${action}.`);\n  }\n}\n```\n\n大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。\n\n```javascript\nvar x = 1;\nvar y = 2;\n\n`${x} + ${y} = ${x + y}`\n// \"1 + 2 = 3\"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// \"1 + 4 = 5\"\n\nvar obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n// 3\n```\n\n模板字符串之中还能调用函数。\n\n```javascript\nfunction fn() {\n  return \"Hello World\";\n}\n\n`foo ${fn()} bar`\n// foo Hello World bar\n```\n\n如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的`toString`方法。\n\n如果模板字符串中的变量没有声明，将报错。\n\n```javascript\n// 变量place没有声明\nvar msg = `Hello, ${place}`;\n// 报错\n```\n\n由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。\n\n```javascript\n`Hello ${'World'}`\n// \"Hello World\"\n```\n\n模板字符串甚至还能嵌套。\n\n```javascript\nconst tmpl = addrs => `\n  <table>\n  ${addrs.map(addr => `\n    <tr><td>${addr.first}</td></tr>\n    <tr><td>${addr.last}</td></tr>\n  `).join('')}\n  </table>\n`;\n```\n\n上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。\n\n```javascript\nconst data = [\n    { first: '<Jane>', last: 'Bond' },\n    { first: 'Lars', last: '<Croft>' },\n];\n\nconsole.log(tmpl(data));\n// <table>\n//\n//   <tr><td><Jane></td></tr>\n//   <tr><td>Bond</td></tr>\n//\n//   <tr><td>Lars</td></tr>\n//   <tr><td><Croft></td></tr>\n//\n// </table>\n```\n\n如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。\n\n```javascript\n// 写法一\nlet str = 'return ' + '`Hello ${name}!`';\nlet func = new Function('name', str);\nfunc('Jack') // \"Hello Jack!\"\n\n// 写法二\nlet str = '(name) => `Hello ${name}!`';\nlet func = eval.call(null, str);\nfunc('Jack') // \"Hello Jack!\"\n```\n\n\n## String.raw()\n\nES6还为原生的String对象，提供了一个`raw`方法。\n\n`String.raw`方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。\n\n```javascript\nString.raw`Hi\\n${2+3}!`;\n// \"Hi\\\\n5!\"\n\nString.raw`Hi\\u000A!`;\n// 'Hi\\\\u000A!'\n```\n\n如果原字符串的斜杠已经转义，那么`String.raw`不会做任何处理。\n\n```javascript\nString.raw`Hi\\\\n`\n// \"Hi\\\\n\"\n```\n\n`String.raw`的代码基本如下。\n\n```javascript\nString.raw = function (strings, ...values) {\n  var output = \"\";\n  for (var index = 0; index < values.length; index++) {\n    output += strings.raw[index] + values[index];\n  }\n\n  output += strings.raw[index]\n  return output;\n}\n```\n\n`String.raw`方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。\n\n`String.raw`方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有`raw`属性的对象，且`raw`属性的值应该是一个数组。\n\n```javascript\nString.raw({ raw: 'test' }, 0, 1, 2);\n// 't0e1s2t'\n\n// 等同于\nString.raw({ raw: ['t','e','s','t'] }, 0, 1, 2);\n```\n","slug":"ES2015字符串扩展","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfbt000azk4ot8r186i5","content":"<h2 id=\"includes-startsWith-endsWith\"><a href=\"#includes-startsWith-endsWith\" class=\"headerlink\" title=\"includes(), startsWith(), endsWith()\"></a>includes(), startsWith(), endsWith()</h2><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>\n<ul>\n<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>\n<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>\n<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello world!'</span>;</div><div class=\"line\"></div><div class=\"line\">s.startsWith(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.endsWith(<span class=\"string\">'!'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.includes(<span class=\"string\">'o'</span>) <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello world!'</span>;</div><div class=\"line\"></div><div class=\"line\">s.startsWith(<span class=\"string\">'world'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.endsWith(<span class=\"string\">'Hello'</span>, <span class=\"number\">5</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.includes(<span class=\"string\">'Hello'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>\n<h2 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h2><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'x'</span>.repeat(<span class=\"number\">3</span>) <span class=\"comment\">// \"xxx\"</span></div><div class=\"line\"><span class=\"string\">'hello'</span>.repeat(<span class=\"number\">2</span>) <span class=\"comment\">// \"hellohello\"</span></div><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">0</span>) <span class=\"comment\">// \"\"</span></div></pre></td></tr></table></figure>\n<p>参数如果是小数，会被取整。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">2.9</span>) <span class=\"comment\">// \"nana\"</span></div></pre></td></tr></table></figure>\n<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"literal\">Infinity</span>)</div><div class=\"line\"><span class=\"comment\">// RangeError</span></div><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">-1</span>)</div><div class=\"line\"><span class=\"comment\">// RangeError</span></div></pre></td></tr></table></figure>\n<p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为0。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">-0.9</span>) <span class=\"comment\">// \"\"</span></div></pre></td></tr></table></figure>\n<p>参数<code>NaN</code>等同于0。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"literal\">NaN</span>) <span class=\"comment\">// \"\"</span></div></pre></td></tr></table></figure>\n<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"string\">'na'</span>) <span class=\"comment\">// \"\"</span></div><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"string\">'3'</span>) <span class=\"comment\">// \"nanana\"</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>传统的JavaScript语言，输出模板通常是这样写的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#result'</span>).append(</div><div class=\"line\">  <span class=\"string\">'There are &lt;b&gt;'</span> + basket.count + <span class=\"string\">'&lt;/b&gt; '</span> +</div><div class=\"line\">  <span class=\"string\">'items in your basket, '</span> +</div><div class=\"line\">  <span class=\"string\">'&lt;em&gt;'</span> + basket.onSale +</div><div class=\"line\">  <span class=\"string\">'&lt;/em&gt; are on sale!'</span></div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#result'</span>).append(<span class=\"string\">`</span></div><div class=\"line\">  There are &lt;b&gt;<span class=\"subst\">$&#123;basket.count&#125;</span>&lt;/b&gt; items</div><div class=\"line\">   in your basket, &lt;em&gt;<span class=\"subst\">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</div><div class=\"line\">  are on sale!</div><div class=\"line\">`);</div></pre></td></tr></table></figure>\n<p>模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 普通字符串</span></div><div class=\"line\"><span class=\"string\">`In JavaScript '\\n' is a line-feed.`</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 多行字符串</span></div><div class=\"line\"><span class=\"string\">`In JavaScript this is</span></div><div class=\"line\"> not legal.`</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`string text line 1</span></div><div class=\"line\">string text line 2`);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 字符串中嵌入变量</span></div><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"Bob\"</span>, time = <span class=\"string\">\"today\"</span>;</div><div class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>, how are you <span class=\"subst\">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure>\n<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> greeting = <span class=\"string\">`\\`Yo\\` World!`</span>;</div></pre></td></tr></table></figure>\n<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#list'</span>).html(<span class=\"string\">`</span></div><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">  &lt;li&gt;first&lt;/li&gt;</div><div class=\"line\">  &lt;li&gt;second&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">`);</div></pre></td></tr></table></figure>\n<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#list'</span>).html(<span class=\"string\">`</span></div><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">  &lt;li&gt;first&lt;/li&gt;</div><div class=\"line\">  &lt;li&gt;second&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">`.trim());</div></pre></td></tr></table></figure>\n<p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">authorize</span>(<span class=\"params\">user, action</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!user.hasPrivilege(action)) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</div><div class=\"line\">      <span class=\"comment\">// 传统写法为</span></div><div class=\"line\">      <span class=\"comment\">// 'User '</span></div><div class=\"line\">      <span class=\"comment\">// + user.name</span></div><div class=\"line\">      <span class=\"comment\">// + ' is not authorized to do '</span></div><div class=\"line\">      <span class=\"comment\">// + action</span></div><div class=\"line\">      <span class=\"comment\">// + '.'</span></div><div class=\"line\">      <span class=\"string\">`User <span class=\"subst\">$&#123;user.name&#125;</span> is not authorized to do <span class=\"subst\">$&#123;action&#125;</span>.`</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span> + <span class=\"subst\">$&#123;y&#125;</span> = <span class=\"subst\">$&#123;x + y&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// \"1 + 2 = 3\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span> + <span class=\"subst\">$&#123;y * <span class=\"number\">2</span>&#125;</span> = <span class=\"subst\">$&#123;x + y * <span class=\"number\">2</span>&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// \"1 + 4 = 5\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;;</div><div class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;obj.x + obj.y&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>模板字符串之中还能调用函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">`foo <span class=\"subst\">$&#123;fn()&#125;</span> bar`</span></div><div class=\"line\"><span class=\"comment\">// foo Hello World bar</span></div></pre></td></tr></table></figure>\n<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p>\n<p>如果模板字符串中的变量没有声明，将报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 变量place没有声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"string\">`Hello, <span class=\"subst\">$&#123;place&#125;</span>`</span>;</div><div class=\"line\"><span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;<span class=\"string\">'World'</span>&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// \"Hello World\"</span></div></pre></td></tr></table></figure>\n<p>模板字符串甚至还能嵌套。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> tmpl = <span class=\"function\"><span class=\"params\">addrs</span> =&gt;</span> <span class=\"string\">`</span></div><div class=\"line\">  &lt;table&gt;</div><div class=\"line\">  <span class=\"subst\">$&#123;addrs.map(addr =&gt; <span class=\"string\">`</span></span></div><div class=\"line\">    &lt;tr&gt;&lt;td&gt;<span class=\"subst\">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class=\"line\">    &lt;tr&gt;&lt;td&gt;<span class=\"subst\">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class=\"line\">  `).join(<span class=\"string\">''</span>)&#125;</div><div class=\"line\">  &lt;/table&gt;</div><div class=\"line\">`;</div></pre></td></tr></table></figure>\n<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> data = [</div><div class=\"line\">    &#123; <span class=\"attr\">first</span>: <span class=\"string\">'&lt;Jane&gt;'</span>, <span class=\"attr\">last</span>: <span class=\"string\">'Bond'</span> &#125;,</div><div class=\"line\">    &#123; <span class=\"attr\">first</span>: <span class=\"string\">'Lars'</span>, <span class=\"attr\">last</span>: <span class=\"string\">'&lt;Croft&gt;'</span> &#125;,</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(tmpl(data));</div><div class=\"line\"><span class=\"comment\">// &lt;table&gt;</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class=\"line\"><span class=\"comment\">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></div><div class=\"line\"><span class=\"comment\">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// &lt;/table&gt;</span></div></pre></td></tr></table></figure>\n<p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写法一</span></div><div class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'return '</span> + <span class=\"string\">'`Hello $&#123;name&#125;!`'</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> func = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'name'</span>, str);</div><div class=\"line\">func(<span class=\"string\">'Jack'</span>) <span class=\"comment\">// \"Hello Jack!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写法二</span></div><div class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> func = <span class=\"built_in\">eval</span>.call(<span class=\"literal\">null</span>, str);</div><div class=\"line\">func(<span class=\"string\">'Jack'</span>) <span class=\"comment\">// \"Hello Jack!\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"String-raw\"><a href=\"#String-raw\" class=\"headerlink\" title=\"String.raw()\"></a>String.raw()</h2><p>ES6还为原生的String对象，提供了一个<code>raw</code>方法。</p>\n<p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\n<span class=\"subst\">$&#123;<span class=\"number\">2</span>+<span class=\"number\">3</span>&#125;</span>!`</span>;</div><div class=\"line\"><span class=\"comment\">// \"Hi\\\\n5!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\u000A!`</span>;</div><div class=\"line\"><span class=\"comment\">// 'Hi\\\\u000A!'</span></div></pre></td></tr></table></figure>\n<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>不会做任何处理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\\\n`</span></div><div class=\"line\"><span class=\"comment\">// \"Hi\\\\n\"</span></div></pre></td></tr></table></figure>\n<p><code>String.raw</code>的代码基本如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.raw = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">strings, ...values</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> output = <span class=\"string\">\"\"</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; values.length; index++) &#123;</div><div class=\"line\">    output += strings.raw[index] + values[index];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  output += strings.raw[index]</div><div class=\"line\">  <span class=\"keyword\">return</span> output;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>\n<p><code>String.raw</code>方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.raw(&#123; <span class=\"attr\">raw</span>: <span class=\"string\">'test'</span> &#125;, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">// 't0e1s2t'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"built_in\">String</span>.raw(&#123; <span class=\"attr\">raw</span>: [<span class=\"string\">'t'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'s'</span>,<span class=\"string\">'t'</span>] &#125;, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"includes-startsWith-endsWith\"><a href=\"#includes-startsWith-endsWith\" class=\"headerlink\" title=\"includes(), startsWith(), endsWith()\"></a>includes(), startsWith(), endsWith()</h2><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>\n<ul>\n<li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li>\n<li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>\n<li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello world!'</span>;</div><div class=\"line\"></div><div class=\"line\">s.startsWith(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.endsWith(<span class=\"string\">'!'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.includes(<span class=\"string\">'o'</span>) <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'Hello world!'</span>;</div><div class=\"line\"></div><div class=\"line\">s.startsWith(<span class=\"string\">'world'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.endsWith(<span class=\"string\">'Hello'</span>, <span class=\"number\">5</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.includes(<span class=\"string\">'Hello'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>\n<h2 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h2><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'x'</span>.repeat(<span class=\"number\">3</span>) <span class=\"comment\">// \"xxx\"</span></div><div class=\"line\"><span class=\"string\">'hello'</span>.repeat(<span class=\"number\">2</span>) <span class=\"comment\">// \"hellohello\"</span></div><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">0</span>) <span class=\"comment\">// \"\"</span></div></pre></td></tr></table></figure>\n<p>参数如果是小数，会被取整。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">2.9</span>) <span class=\"comment\">// \"nana\"</span></div></pre></td></tr></table></figure>\n<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"literal\">Infinity</span>)</div><div class=\"line\"><span class=\"comment\">// RangeError</span></div><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">-1</span>)</div><div class=\"line\"><span class=\"comment\">// RangeError</span></div></pre></td></tr></table></figure>\n<p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为0。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"number\">-0.9</span>) <span class=\"comment\">// \"\"</span></div></pre></td></tr></table></figure>\n<p>参数<code>NaN</code>等同于0。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"literal\">NaN</span>) <span class=\"comment\">// \"\"</span></div></pre></td></tr></table></figure>\n<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"string\">'na'</span>) <span class=\"comment\">// \"\"</span></div><div class=\"line\"><span class=\"string\">'na'</span>.repeat(<span class=\"string\">'3'</span>) <span class=\"comment\">// \"nanana\"</span></div></pre></td></tr></table></figure>","more":"<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><p>传统的JavaScript语言，输出模板通常是这样写的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#result'</span>).append(</div><div class=\"line\">  <span class=\"string\">'There are &lt;b&gt;'</span> + basket.count + <span class=\"string\">'&lt;/b&gt; '</span> +</div><div class=\"line\">  <span class=\"string\">'items in your basket, '</span> +</div><div class=\"line\">  <span class=\"string\">'&lt;em&gt;'</span> + basket.onSale +</div><div class=\"line\">  <span class=\"string\">'&lt;/em&gt; are on sale!'</span></div><div class=\"line\">);</div></pre></td></tr></table></figure>\n<p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#result'</span>).append(<span class=\"string\">`</span></div><div class=\"line\">  There are &lt;b&gt;<span class=\"subst\">$&#123;basket.count&#125;</span>&lt;/b&gt; items</div><div class=\"line\">   in your basket, &lt;em&gt;<span class=\"subst\">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</div><div class=\"line\">  are on sale!</div><div class=\"line\">`);</div></pre></td></tr></table></figure>\n<p>模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 普通字符串</span></div><div class=\"line\"><span class=\"string\">`In JavaScript '\\n' is a line-feed.`</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 多行字符串</span></div><div class=\"line\"><span class=\"string\">`In JavaScript this is</span></div><div class=\"line\"> not legal.`</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`string text line 1</span></div><div class=\"line\">string text line 2`);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 字符串中嵌入变量</span></div><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"Bob\"</span>, time = <span class=\"string\">\"today\"</span>;</div><div class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>, how are you <span class=\"subst\">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure>\n<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> greeting = <span class=\"string\">`\\`Yo\\` World!`</span>;</div></pre></td></tr></table></figure>\n<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#list'</span>).html(<span class=\"string\">`</span></div><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">  &lt;li&gt;first&lt;/li&gt;</div><div class=\"line\">  &lt;li&gt;second&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">`);</div></pre></td></tr></table></figure>\n<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(<span class=\"string\">'#list'</span>).html(<span class=\"string\">`</span></div><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">  &lt;li&gt;first&lt;/li&gt;</div><div class=\"line\">  &lt;li&gt;second&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div><div class=\"line\">`.trim());</div></pre></td></tr></table></figure>\n<p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">authorize</span>(<span class=\"params\">user, action</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!user.hasPrivilege(action)) &#123;</div><div class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</div><div class=\"line\">      <span class=\"comment\">// 传统写法为</span></div><div class=\"line\">      <span class=\"comment\">// 'User '</span></div><div class=\"line\">      <span class=\"comment\">// + user.name</span></div><div class=\"line\">      <span class=\"comment\">// + ' is not authorized to do '</span></div><div class=\"line\">      <span class=\"comment\">// + action</span></div><div class=\"line\">      <span class=\"comment\">// + '.'</span></div><div class=\"line\">      <span class=\"string\">`User <span class=\"subst\">$&#123;user.name&#125;</span> is not authorized to do <span class=\"subst\">$&#123;action&#125;</span>.`</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span> + <span class=\"subst\">$&#123;y&#125;</span> = <span class=\"subst\">$&#123;x + y&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// \"1 + 2 = 3\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span> + <span class=\"subst\">$&#123;y * <span class=\"number\">2</span>&#125;</span> = <span class=\"subst\">$&#123;x + y * <span class=\"number\">2</span>&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// \"1 + 4 = 5\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>&#125;;</div><div class=\"line\"><span class=\"string\">`<span class=\"subst\">$&#123;obj.x + obj.y&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>模板字符串之中还能调用函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Hello World\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"string\">`foo <span class=\"subst\">$&#123;fn()&#125;</span> bar`</span></div><div class=\"line\"><span class=\"comment\">// foo Hello World bar</span></div></pre></td></tr></table></figure>\n<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p>\n<p>如果模板字符串中的变量没有声明，将报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 变量place没有声明</span></div><div class=\"line\"><span class=\"keyword\">var</span> msg = <span class=\"string\">`Hello, <span class=\"subst\">$&#123;place&#125;</span>`</span>;</div><div class=\"line\"><span class=\"comment\">// 报错</span></div></pre></td></tr></table></figure>\n<p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">`Hello <span class=\"subst\">$&#123;<span class=\"string\">'World'</span>&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// \"Hello World\"</span></div></pre></td></tr></table></figure>\n<p>模板字符串甚至还能嵌套。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> tmpl = <span class=\"function\"><span class=\"params\">addrs</span> =&gt;</span> <span class=\"string\">`</span></div><div class=\"line\">  &lt;table&gt;</div><div class=\"line\">  <span class=\"subst\">$&#123;addrs.map(addr =&gt; <span class=\"string\">`</span></span></div><div class=\"line\">    &lt;tr&gt;&lt;td&gt;<span class=\"subst\">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class=\"line\">    &lt;tr&gt;&lt;td&gt;<span class=\"subst\">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class=\"line\">  `).join(<span class=\"string\">''</span>)&#125;</div><div class=\"line\">  &lt;/table&gt;</div><div class=\"line\">`;</div></pre></td></tr></table></figure>\n<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> data = [</div><div class=\"line\">    &#123; <span class=\"attr\">first</span>: <span class=\"string\">'&lt;Jane&gt;'</span>, <span class=\"attr\">last</span>: <span class=\"string\">'Bond'</span> &#125;,</div><div class=\"line\">    &#123; <span class=\"attr\">first</span>: <span class=\"string\">'Lars'</span>, <span class=\"attr\">last</span>: <span class=\"string\">'&lt;Croft&gt;'</span> &#125;,</div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(tmpl(data));</div><div class=\"line\"><span class=\"comment\">// &lt;table&gt;</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class=\"line\"><span class=\"comment\">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></div><div class=\"line\"><span class=\"comment\">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class=\"line\"><span class=\"comment\">//</span></div><div class=\"line\"><span class=\"comment\">// &lt;/table&gt;</span></div></pre></td></tr></table></figure>\n<p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写法一</span></div><div class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'return '</span> + <span class=\"string\">'`Hello $&#123;name&#125;!`'</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> func = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'name'</span>, str);</div><div class=\"line\">func(<span class=\"string\">'Jack'</span>) <span class=\"comment\">// \"Hello Jack!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写法二</span></div><div class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> func = <span class=\"built_in\">eval</span>.call(<span class=\"literal\">null</span>, str);</div><div class=\"line\">func(<span class=\"string\">'Jack'</span>) <span class=\"comment\">// \"Hello Jack!\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"String-raw\"><a href=\"#String-raw\" class=\"headerlink\" title=\"String.raw()\"></a>String.raw()</h2><p>ES6还为原生的String对象，提供了一个<code>raw</code>方法。</p>\n<p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\n<span class=\"subst\">$&#123;<span class=\"number\">2</span>+<span class=\"number\">3</span>&#125;</span>!`</span>;</div><div class=\"line\"><span class=\"comment\">// \"Hi\\\\n5!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\u000A!`</span>;</div><div class=\"line\"><span class=\"comment\">// 'Hi\\\\u000A!'</span></div></pre></td></tr></table></figure>\n<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>不会做任何处理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\\\n`</span></div><div class=\"line\"><span class=\"comment\">// \"Hi\\\\n\"</span></div></pre></td></tr></table></figure>\n<p><code>String.raw</code>的代码基本如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.raw = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">strings, ...values</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> output = <span class=\"string\">\"\"</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; values.length; index++) &#123;</div><div class=\"line\">    output += strings.raw[index] + values[index];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  output += strings.raw[index]</div><div class=\"line\">  <span class=\"keyword\">return</span> output;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>\n<p><code>String.raw</code>方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.raw(&#123; <span class=\"attr\">raw</span>: <span class=\"string\">'test'</span> &#125;, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">// 't0e1s2t'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"built_in\">String</span>.raw(&#123; <span class=\"attr\">raw</span>: [<span class=\"string\">'t'</span>,<span class=\"string\">'e'</span>,<span class=\"string\">'s'</span>,<span class=\"string\">'t'</span>] &#125;, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>);</div></pre></td></tr></table></figure>"},{"title":"Es2015的数值扩展","date":"2016-10-31T15:10:03.000Z","_content":"# 数值的扩展\n\n## Number.isFinite(), Number.isNaN()\n\nES6在Number对象上，新提供了`Number.isFinite()`和`Number.isNaN()`两个方法。\n\n`Number.isFinite()`用来检查一个数值是否为有限的（finite）。\n\n```javascript\nNumber.isFinite(15); // true\nNumber.isFinite(0.8); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\nNumber.isFinite('foo'); // false\nNumber.isFinite('15'); // false\nNumber.isFinite(true); // false\n```\n\nES5可以通过下面的代码，部署`Number.isFinite`方法。\n\n```javascript\n(function (global) {\n  var global_isFinite = global.isFinite;\n\n  Object.defineProperty(Number, 'isFinite', {\n    value: function isFinite(value) {\n      return typeof value === 'number' && global_isFinite(value);\n    },\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n})(this);\n```\n\n`Number.isNaN()`用来检查一个值是否为`NaN`。\n\n```javascript\nNumber.isNaN(NaN) // true\nNumber.isNaN(15) // false\nNumber.isNaN('15') // false\nNumber.isNaN(true) // false\nNumber.isNaN(9/NaN) // true\nNumber.isNaN('true'/0) // true\nNumber.isNaN('true'/'true') // true\n```\n\nES5通过下面的代码，部署`Number.isNaN()`。\n\n```javascript\n(function (global) {\n  var global_isNaN = global.isNaN;\n\n  Object.defineProperty(Number, 'isNaN', {\n    value: function isNaN(value) {\n      return typeof value === 'number' && global_isNaN(value);\n    },\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n})(this);\n```\n\n它们与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回`false`。\n\n```javascript\nisFinite(25) // true\nisFinite(\"25\") // true\nNumber.isFinite(25) // true\nNumber.isFinite(\"25\") // false\n\nisNaN(NaN) // true\nisNaN(\"NaN\") // true\nNumber.isNaN(NaN) // true\nNumber.isNaN(\"NaN\") // false\n```\n\n## Number.parseInt(), Number.parseFloat()\n\nES6将全局方法`parseInt()`和`parseFloat()`，移植到Number对象上面，行为完全保持不变。\n\n```javascript\n// ES5的写法\nparseInt('12.34') // 12\nparseFloat('123.45#') // 123.45\n\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\n```\n\n这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。\n\n```javascript\nNumber.parseInt === parseInt // true\nNumber.parseFloat === parseFloat // true\n```\n<!--more-->\n## Number.isInteger()\n\n`Number.isInteger()`用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。\n\n```javascript\nNumber.isInteger(25) // true\nNumber.isInteger(25.0) // true\nNumber.isInteger(25.1) // false\nNumber.isInteger(\"15\") // false\nNumber.isInteger(true) // false\n```\n\n\n## Number.EPSILON\n\nES6在Number对象上面，新增一个极小的常量`Number.EPSILON`。\n\n```javascript\nNumber.EPSILON\n// 2.220446049250313e-16\nNumber.EPSILON.toFixed(20)\n// '0.00000000000000022204'\n```\n\n引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。\n\n```javascript\n0.1 + 0.2\n// 0.30000000000000004\n\n0.1 + 0.2 - 0.3\n// 5.551115123125783e-17\n\n5.551115123125783e-17.toFixed(20)\n// '0.00000000000000005551'\n```\n\n但是如果这个误差能够小于`Number.EPSILON`，我们就可以认为得到了正确结果。\n\n```javascript\n5.551115123125783e-17 < Number.EPSILON\n// true\n```\n\n因此，`Number.EPSILON`的实质是一个可以接受的误差范围。\n\n```javascript\nfunction withinErrorMargin (left, right) {\n  return Math.abs(left - right) < Number.EPSILON;\n}\nwithinErrorMargin(0.1 + 0.2, 0.3)\n// true\nwithinErrorMargin(0.2 + 0.2, 0.3)\n// false\n```\n\n上面的代码为浮点数运算，部署了一个误差检查函数。\n\n## 安全整数和Number.isSafeInteger()\n\nJavaScript能够准确表示的整数范围在`-2^53`到`2^53`之间（不含两个端点），超过这个范围，无法精确表示这个值。\n\n```javascript\nMath.pow(2, 53) // 9007199254740992\n\n9007199254740992  // 9007199254740992\n9007199254740993  // 9007199254740992\n\nMath.pow(2, 53) === Math.pow(2, 53) + 1\n// true\n```\n\n上面代码中，超出2的53次方之后，一个数就不精确了。\n\nES6引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`这两个常量，用来表示这个范围的上下限。\n\n```javascript\nNumber.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1\n// true\nNumber.MAX_SAFE_INTEGER === 9007199254740991\n// true\n\nNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER\n// true\nNumber.MIN_SAFE_INTEGER === -9007199254740991\n// true\n```\n\n上面代码中，可以看到JavaScript能够精确表示的极限。\n\n`Number.isSafeInteger()`则是用来判断一个整数是否落在这个范围之内。\n\n```javascript\nNumber.isSafeInteger('a') // false\nNumber.isSafeInteger(null) // false\nNumber.isSafeInteger(NaN) // false\nNumber.isSafeInteger(Infinity) // false\nNumber.isSafeInteger(-Infinity) // false\n\nNumber.isSafeInteger(3) // true\nNumber.isSafeInteger(1.2) // false\nNumber.isSafeInteger(9007199254740990) // true\nNumber.isSafeInteger(9007199254740992) // false\n\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false\n```\n\n这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。\n\n```javascript\nNumber.isSafeInteger = function (n) {\n  return (typeof n === 'number' &&\n    Math.round(n) === n &&\n    Number.MIN_SAFE_INTEGER <= n &&\n    n <= Number.MAX_SAFE_INTEGER);\n}\n```\n\n实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。\n如果只验证运算结果是否为安全整数，很可能得到错误结果。\n\n## 指数运算符\n\nES7新增了一个指数运算符（`**`），目前Babel转码器已经支持。\n\n```javascript\n2 ** 2 // 4\n2 ** 3 // 8\n```\n\n指数运算符可以与等号结合，形成一个新的赋值运算符（`**=`）。\n\n```javascript\nlet a = 2;\na **= 2;\n// 等同于 a = a * a;\n\nlet b = 3;\nb **= 3;\n// 等同于 b = b * b * b;\n```\n## Math对象的扩展\n\nES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。\n\n### Math.trunc()\n\n`Math.trunc`方法用于去除一个数的小数部分，返回整数部分。\n\n```javascript\nMath.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\n```\n\n对于非数值，`Math.trunc`内部使用`Number`方法将其先转为数值。\n\n```javascript\nMath.trunc('123.456')\n// 123\n```\n\n对于空值和无法截取整数的值，返回NaN。\n\n```javascript\nMath.trunc(NaN);      // NaN\nMath.trunc('foo');    // NaN\nMath.trunc();         // NaN\n```\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\n```javascript\nMath.trunc = Math.trunc || function(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n};\n```\n\n### Math.sign()\n\n`Math.sign`方法用来判断一个数到底是正数、负数、还是零。\n\n它会返回五种值。\n\n- 参数为正数，返回+1；\n- 参数为负数，返回-1；\n- 参数为0，返回0；\n- 参数为-0，返回-0;\n- 其他值，返回NaN。\n\n```javascript\nMath.sign(-5) // -1\nMath.sign(5) // +1\nMath.sign(0) // +0\nMath.sign(-0) // -0\nMath.sign(NaN) // NaN\nMath.sign('foo'); // NaN\nMath.sign();      // NaN\n```\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\n```javascript\nMath.sign = Math.sign || function(x) {\n  x = +x; // convert to a number\n  if (x === 0 || isNaN(x)) {\n    return x;\n  }\n  return x > 0 ? 1 : -1;\n};\n```\n\n### Math.cbrt()\n\n`Math.cbrt`方法用于计算一个数的立方根。\n\n```javascript\nMath.cbrt(-1) // -1\nMath.cbrt(0)  // 0\nMath.cbrt(1)  // 1\nMath.cbrt(2)  // 1.2599210498948734\n```\n\n对于非数值，`Math.cbrt`方法内部也是先使用`Number`方法将其转为数值。\n\n```javascript\nMath.cbrt('8') // 2\nMath.cbrt('hello') // NaN\n```\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\n```javascript\nMath.cbrt = Math.cbrt || function(x) {\n  var y = Math.pow(Math.abs(x), 1/3);\n  return x < 0 ? -y : y;\n};\n```\n\n### Math.hypot()\n\n`Math.hypot`方法返回所有参数的平方和的平方根。\n\n```javascript\nMath.hypot(3, 4);        // 5\nMath.hypot(3, 4, 5);     // 7.0710678118654755\nMath.hypot();            // 0\nMath.hypot(NaN);         // NaN\nMath.hypot(3, 4, 'foo'); // NaN\nMath.hypot(3, 4, '5');   // 7.0710678118654755\nMath.hypot(-3);          // 3\n```\n\n上面代码中，3的平方加上4的平方，等于5的平方。\n\n如果参数不是数值，`Math.hypot`方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。\n\n### 三角函数方法\n\nES6新增了6个三角函数方法。\n\n- `Math.sinh(x)` 返回`x`的双曲正弦（hyperbolic sine）\n- `Math.cosh(x)` 返回`x`的双曲余弦（hyperbolic cosine）\n- `Math.tanh(x)` 返回`x`的双曲正切（hyperbolic tangent）\n- `Math.asinh(x)` 返回`x`的反双曲正弦（inverse hyperbolic sine）\n- `Math.acosh(x)` 返回`x`的反双曲余弦（inverse hyperbolic cosine）\n- `Math.atanh(x)` 返回`x`的反双曲正切（inverse hyperbolic tangent）\n\n\n","source":"_posts/ES2015的数值扩展.md","raw":"---\ntitle: Es2015的数值扩展\ndate: 2016-10-31 23:10:03\ntags: ES2015\n---\n# 数值的扩展\n\n## Number.isFinite(), Number.isNaN()\n\nES6在Number对象上，新提供了`Number.isFinite()`和`Number.isNaN()`两个方法。\n\n`Number.isFinite()`用来检查一个数值是否为有限的（finite）。\n\n```javascript\nNumber.isFinite(15); // true\nNumber.isFinite(0.8); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\nNumber.isFinite('foo'); // false\nNumber.isFinite('15'); // false\nNumber.isFinite(true); // false\n```\n\nES5可以通过下面的代码，部署`Number.isFinite`方法。\n\n```javascript\n(function (global) {\n  var global_isFinite = global.isFinite;\n\n  Object.defineProperty(Number, 'isFinite', {\n    value: function isFinite(value) {\n      return typeof value === 'number' && global_isFinite(value);\n    },\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n})(this);\n```\n\n`Number.isNaN()`用来检查一个值是否为`NaN`。\n\n```javascript\nNumber.isNaN(NaN) // true\nNumber.isNaN(15) // false\nNumber.isNaN('15') // false\nNumber.isNaN(true) // false\nNumber.isNaN(9/NaN) // true\nNumber.isNaN('true'/0) // true\nNumber.isNaN('true'/'true') // true\n```\n\nES5通过下面的代码，部署`Number.isNaN()`。\n\n```javascript\n(function (global) {\n  var global_isNaN = global.isNaN;\n\n  Object.defineProperty(Number, 'isNaN', {\n    value: function isNaN(value) {\n      return typeof value === 'number' && global_isNaN(value);\n    },\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n})(this);\n```\n\n它们与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回`false`。\n\n```javascript\nisFinite(25) // true\nisFinite(\"25\") // true\nNumber.isFinite(25) // true\nNumber.isFinite(\"25\") // false\n\nisNaN(NaN) // true\nisNaN(\"NaN\") // true\nNumber.isNaN(NaN) // true\nNumber.isNaN(\"NaN\") // false\n```\n\n## Number.parseInt(), Number.parseFloat()\n\nES6将全局方法`parseInt()`和`parseFloat()`，移植到Number对象上面，行为完全保持不变。\n\n```javascript\n// ES5的写法\nparseInt('12.34') // 12\nparseFloat('123.45#') // 123.45\n\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\n```\n\n这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。\n\n```javascript\nNumber.parseInt === parseInt // true\nNumber.parseFloat === parseFloat // true\n```\n<!--more-->\n## Number.isInteger()\n\n`Number.isInteger()`用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。\n\n```javascript\nNumber.isInteger(25) // true\nNumber.isInteger(25.0) // true\nNumber.isInteger(25.1) // false\nNumber.isInteger(\"15\") // false\nNumber.isInteger(true) // false\n```\n\n\n## Number.EPSILON\n\nES6在Number对象上面，新增一个极小的常量`Number.EPSILON`。\n\n```javascript\nNumber.EPSILON\n// 2.220446049250313e-16\nNumber.EPSILON.toFixed(20)\n// '0.00000000000000022204'\n```\n\n引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。\n\n```javascript\n0.1 + 0.2\n// 0.30000000000000004\n\n0.1 + 0.2 - 0.3\n// 5.551115123125783e-17\n\n5.551115123125783e-17.toFixed(20)\n// '0.00000000000000005551'\n```\n\n但是如果这个误差能够小于`Number.EPSILON`，我们就可以认为得到了正确结果。\n\n```javascript\n5.551115123125783e-17 < Number.EPSILON\n// true\n```\n\n因此，`Number.EPSILON`的实质是一个可以接受的误差范围。\n\n```javascript\nfunction withinErrorMargin (left, right) {\n  return Math.abs(left - right) < Number.EPSILON;\n}\nwithinErrorMargin(0.1 + 0.2, 0.3)\n// true\nwithinErrorMargin(0.2 + 0.2, 0.3)\n// false\n```\n\n上面的代码为浮点数运算，部署了一个误差检查函数。\n\n## 安全整数和Number.isSafeInteger()\n\nJavaScript能够准确表示的整数范围在`-2^53`到`2^53`之间（不含两个端点），超过这个范围，无法精确表示这个值。\n\n```javascript\nMath.pow(2, 53) // 9007199254740992\n\n9007199254740992  // 9007199254740992\n9007199254740993  // 9007199254740992\n\nMath.pow(2, 53) === Math.pow(2, 53) + 1\n// true\n```\n\n上面代码中，超出2的53次方之后，一个数就不精确了。\n\nES6引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`这两个常量，用来表示这个范围的上下限。\n\n```javascript\nNumber.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1\n// true\nNumber.MAX_SAFE_INTEGER === 9007199254740991\n// true\n\nNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER\n// true\nNumber.MIN_SAFE_INTEGER === -9007199254740991\n// true\n```\n\n上面代码中，可以看到JavaScript能够精确表示的极限。\n\n`Number.isSafeInteger()`则是用来判断一个整数是否落在这个范围之内。\n\n```javascript\nNumber.isSafeInteger('a') // false\nNumber.isSafeInteger(null) // false\nNumber.isSafeInteger(NaN) // false\nNumber.isSafeInteger(Infinity) // false\nNumber.isSafeInteger(-Infinity) // false\n\nNumber.isSafeInteger(3) // true\nNumber.isSafeInteger(1.2) // false\nNumber.isSafeInteger(9007199254740990) // true\nNumber.isSafeInteger(9007199254740992) // false\n\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false\n```\n\n这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。\n\n```javascript\nNumber.isSafeInteger = function (n) {\n  return (typeof n === 'number' &&\n    Math.round(n) === n &&\n    Number.MIN_SAFE_INTEGER <= n &&\n    n <= Number.MAX_SAFE_INTEGER);\n}\n```\n\n实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。\n如果只验证运算结果是否为安全整数，很可能得到错误结果。\n\n## 指数运算符\n\nES7新增了一个指数运算符（`**`），目前Babel转码器已经支持。\n\n```javascript\n2 ** 2 // 4\n2 ** 3 // 8\n```\n\n指数运算符可以与等号结合，形成一个新的赋值运算符（`**=`）。\n\n```javascript\nlet a = 2;\na **= 2;\n// 等同于 a = a * a;\n\nlet b = 3;\nb **= 3;\n// 等同于 b = b * b * b;\n```\n## Math对象的扩展\n\nES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。\n\n### Math.trunc()\n\n`Math.trunc`方法用于去除一个数的小数部分，返回整数部分。\n\n```javascript\nMath.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\n```\n\n对于非数值，`Math.trunc`内部使用`Number`方法将其先转为数值。\n\n```javascript\nMath.trunc('123.456')\n// 123\n```\n\n对于空值和无法截取整数的值，返回NaN。\n\n```javascript\nMath.trunc(NaN);      // NaN\nMath.trunc('foo');    // NaN\nMath.trunc();         // NaN\n```\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\n```javascript\nMath.trunc = Math.trunc || function(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n};\n```\n\n### Math.sign()\n\n`Math.sign`方法用来判断一个数到底是正数、负数、还是零。\n\n它会返回五种值。\n\n- 参数为正数，返回+1；\n- 参数为负数，返回-1；\n- 参数为0，返回0；\n- 参数为-0，返回-0;\n- 其他值，返回NaN。\n\n```javascript\nMath.sign(-5) // -1\nMath.sign(5) // +1\nMath.sign(0) // +0\nMath.sign(-0) // -0\nMath.sign(NaN) // NaN\nMath.sign('foo'); // NaN\nMath.sign();      // NaN\n```\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\n```javascript\nMath.sign = Math.sign || function(x) {\n  x = +x; // convert to a number\n  if (x === 0 || isNaN(x)) {\n    return x;\n  }\n  return x > 0 ? 1 : -1;\n};\n```\n\n### Math.cbrt()\n\n`Math.cbrt`方法用于计算一个数的立方根。\n\n```javascript\nMath.cbrt(-1) // -1\nMath.cbrt(0)  // 0\nMath.cbrt(1)  // 1\nMath.cbrt(2)  // 1.2599210498948734\n```\n\n对于非数值，`Math.cbrt`方法内部也是先使用`Number`方法将其转为数值。\n\n```javascript\nMath.cbrt('8') // 2\nMath.cbrt('hello') // NaN\n```\n\n对于没有部署这个方法的环境，可以用下面的代码模拟。\n\n```javascript\nMath.cbrt = Math.cbrt || function(x) {\n  var y = Math.pow(Math.abs(x), 1/3);\n  return x < 0 ? -y : y;\n};\n```\n\n### Math.hypot()\n\n`Math.hypot`方法返回所有参数的平方和的平方根。\n\n```javascript\nMath.hypot(3, 4);        // 5\nMath.hypot(3, 4, 5);     // 7.0710678118654755\nMath.hypot();            // 0\nMath.hypot(NaN);         // NaN\nMath.hypot(3, 4, 'foo'); // NaN\nMath.hypot(3, 4, '5');   // 7.0710678118654755\nMath.hypot(-3);          // 3\n```\n\n上面代码中，3的平方加上4的平方，等于5的平方。\n\n如果参数不是数值，`Math.hypot`方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。\n\n### 三角函数方法\n\nES6新增了6个三角函数方法。\n\n- `Math.sinh(x)` 返回`x`的双曲正弦（hyperbolic sine）\n- `Math.cosh(x)` 返回`x`的双曲余弦（hyperbolic cosine）\n- `Math.tanh(x)` 返回`x`的双曲正切（hyperbolic tangent）\n- `Math.asinh(x)` 返回`x`的反双曲正弦（inverse hyperbolic sine）\n- `Math.acosh(x)` 返回`x`的反双曲余弦（inverse hyperbolic cosine）\n- `Math.atanh(x)` 返回`x`的反双曲正切（inverse hyperbolic tangent）\n\n\n","slug":"ES2015的数值扩展","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfbw000dzk4opx3bzg1d","content":"<h1 id=\"数值的扩展\"><a href=\"#数值的扩展\" class=\"headerlink\" title=\"数值的扩展\"></a>数值的扩展</h1><h2 id=\"Number-isFinite-Number-isNaN\"><a href=\"#Number-isFinite-Number-isNaN\" class=\"headerlink\" title=\"Number.isFinite(), Number.isNaN()\"></a>Number.isFinite(), Number.isNaN()</h2><p>ES6在Number对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>\n<p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">15</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">0.8</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">NaN</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">Infinity</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(-<span class=\"literal\">Infinity</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'foo'</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'15'</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">true</span>); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>ES5可以通过下面的代码，部署<code>Number.isFinite</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">global</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> global_isFinite = global.isFinite;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">Number</span>, <span class=\"string\">'isFinite'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFinite</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'number'</span> &amp;&amp; global_isFinite(value);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;)(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">15</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">'15'</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">true</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">9</span>/<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">'true'</span>/<span class=\"number\">0</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">'true'</span>/<span class=\"string\">'true'</span>) <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>ES5通过下面的代码，部署<code>Number.isNaN()</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">global</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> global_isNaN = global.isNaN;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">Number</span>, <span class=\"string\">'isNaN'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNaN</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'number'</span> &amp;&amp; global_isNaN(value);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;)(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回<code>false</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<h2 id=\"Number-parseInt-Number-parseFloat\"><a href=\"#Number-parseInt-Number-parseFloat\" class=\"headerlink\" title=\"Number.parseInt(), Number.parseFloat()\"></a>Number.parseInt(), Number.parseFloat()</h2><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'12.34'</span>) <span class=\"comment\">// 12</span></div><div class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">'123.45#'</span>) <span class=\"comment\">// 123.45</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.parseInt(<span class=\"string\">'12.34'</span>) <span class=\"comment\">// 12</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.parseFloat(<span class=\"string\">'123.45#'</span>) <span class=\"comment\">// 123.45</span></div></pre></td></tr></table></figure>\n<p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.parseInt === <span class=\"built_in\">parseInt</span> <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.parseFloat === <span class=\"built_in\">parseFloat</span> <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"Number-isInteger\"><a href=\"#Number-isInteger\" class=\"headerlink\" title=\"Number.isInteger()\"></a>Number.isInteger()</h2><p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">25.0</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">25.1</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"string\">\"15\"</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"literal\">true</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<h2 id=\"Number-EPSILON\"><a href=\"#Number-EPSILON\" class=\"headerlink\" title=\"Number.EPSILON\"></a>Number.EPSILON</h2><p>ES6在Number对象上面，新增一个极小的常量<code>Number.EPSILON</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.EPSILON</div><div class=\"line\"><span class=\"comment\">// 2.220446049250313e-16</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.EPSILON.toFixed(<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">// '0.00000000000000022204'</span></div></pre></td></tr></table></figure>\n<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span></div><div class=\"line\"><span class=\"comment\">// 0.30000000000000004</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span></div><div class=\"line\"><span class=\"comment\">// 5.551115123125783e-17</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5.551115123125783e-17</span>.toFixed(<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">// '0.00000000000000005551'</span></div></pre></td></tr></table></figure>\n<p>但是如果这个误差能够小于<code>Number.EPSILON</code>，我们就可以认为得到了正确结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">5.551115123125783e-17</span> &lt; <span class=\"built_in\">Number</span>.EPSILON</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的误差范围。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withinErrorMargin</span> (<span class=\"params\">left, right</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.abs(left - right) &lt; <span class=\"built_in\">Number</span>.EPSILON;</div><div class=\"line\">&#125;</div><div class=\"line\">withinErrorMargin(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>, <span class=\"number\">0.3</span>)</div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\">withinErrorMargin(<span class=\"number\">0.2</span> + <span class=\"number\">0.2</span>, <span class=\"number\">0.3</span>)</div><div class=\"line\"><span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>\n<h2 id=\"安全整数和Number-isSafeInteger\"><a href=\"#安全整数和Number-isSafeInteger\" class=\"headerlink\" title=\"安全整数和Number.isSafeInteger()\"></a>安全整数和Number.isSafeInteger()</h2><p>JavaScript能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) <span class=\"comment\">// 9007199254740992</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">9007199254740992</span>  <span class=\"comment\">// 9007199254740992</span></div><div class=\"line\"><span class=\"number\">9007199254740993</span>  <span class=\"comment\">// 9007199254740992</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) === <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) + <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，超出2的53次方之后，一个数就不精确了。</p>\n<p>ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER === <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) - <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER === <span class=\"number\">9007199254740991</span></div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER === -<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER</div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER === <span class=\"number\">-9007199254740991</span></div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，可以看到JavaScript能够精确表示的极限。</p>\n<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"string\">'a'</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"literal\">null</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"literal\">NaN</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(-<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">3</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">1.2</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">9007199254740990</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">9007199254740992</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER - <span class=\"number\">1</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER + <span class=\"number\">1</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">typeof</span> n === <span class=\"string\">'number'</span> &amp;&amp;</div><div class=\"line\">    <span class=\"built_in\">Math</span>.round(n) === n &amp;&amp;</div><div class=\"line\">    <span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</div><div class=\"line\">    n &lt;= <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。<br>如果只验证运算结果是否为安全整数，很可能得到错误结果。</p>\n<h2 id=\"指数运算符\"><a href=\"#指数运算符\" class=\"headerlink\" title=\"指数运算符\"></a>指数运算符</h2><p>ES7新增了一个指数运算符（<code>**</code>），目前Babel转码器已经支持。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span> <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">3</span> <span class=\"comment\">// 8</span></div></pre></td></tr></table></figure>\n<p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">a **= <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"comment\">// 等同于 a = a * a;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">3</span>;</div><div class=\"line\">b **= <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"comment\">// 等同于 b = b * b * b;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Math对象的扩展\"><a href=\"#Math对象的扩展\" class=\"headerlink\" title=\"Math对象的扩展\"></a>Math对象的扩展</h2><p>ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。</p>\n<h3 id=\"Math-trunc\"><a href=\"#Math-trunc\" class=\"headerlink\" title=\"Math.trunc()\"></a>Math.trunc()</h3><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">4.1</span>) <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">4.9</span>) <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">-4.1</span>) <span class=\"comment\">// -4</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">-4.9</span>) <span class=\"comment\">// -4</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">-0.1234</span>) <span class=\"comment\">// -0</span></div></pre></td></tr></table></figure>\n<p>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"string\">'123.456'</span>)</div><div class=\"line\"><span class=\"comment\">// 123</span></div></pre></td></tr></table></figure>\n<p>对于空值和无法截取整数的值，返回NaN。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"literal\">NaN</span>);      <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"string\">'foo'</span>);    <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc();         <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.trunc = <span class=\"built_in\">Math</span>.trunc || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">0</span> ? <span class=\"built_in\">Math</span>.ceil(x) : <span class=\"built_in\">Math</span>.floor(x);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"Math-sign\"><a href=\"#Math-sign\" class=\"headerlink\" title=\"Math.sign()\"></a>Math.sign()</h3><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。</p>\n<p>它会返回五种值。</p>\n<ul>\n<li>参数为正数，返回+1；</li>\n<li>参数为负数，返回-1；</li>\n<li>参数为0，返回0；</li>\n<li>参数为-0，返回-0;</li>\n<li>其他值，返回NaN。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"number\">-5</span>) <span class=\"comment\">// -1</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"number\">5</span>) <span class=\"comment\">// +1</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"number\">0</span>) <span class=\"comment\">// +0</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"number\">-0</span>) <span class=\"comment\">// -0</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"literal\">NaN</span>) <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"string\">'foo'</span>); <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign();      <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.sign = <span class=\"built_in\">Math</span>.sign || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  x = +x; <span class=\"comment\">// convert to a number</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (x === <span class=\"number\">0</span> || <span class=\"built_in\">isNaN</span>(x)) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> x &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"Math-cbrt\"><a href=\"#Math-cbrt\" class=\"headerlink\" title=\"Math.cbrt()\"></a>Math.cbrt()</h3><p><code>Math.cbrt</code>方法用于计算一个数的立方根。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">-1</span>) <span class=\"comment\">// -1</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">0</span>)  <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">1</span>)  <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">2</span>)  <span class=\"comment\">// 1.2599210498948734</span></div></pre></td></tr></table></figure>\n<p>对于非数值，<code>Math.cbrt</code>方法内部也是先使用<code>Number</code>方法将其转为数值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"string\">'8'</span>) <span class=\"comment\">// 2</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"string\">'hello'</span>) <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt = <span class=\"built_in\">Math</span>.cbrt || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"built_in\">Math</span>.pow(<span class=\"built_in\">Math</span>.abs(x), <span class=\"number\">1</span>/<span class=\"number\">3</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">0</span> ? -y : y;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"Math-hypot\"><a href=\"#Math-hypot\" class=\"headerlink\" title=\"Math.hypot()\"></a>Math.hypot()</h3><p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>);        <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);     <span class=\"comment\">// 7.0710678118654755</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot();            <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"literal\">NaN</span>);         <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">'foo'</span>); <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">'5'</span>);   <span class=\"comment\">// 7.0710678118654755</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">-3</span>);          <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>上面代码中，3的平方加上4的平方，等于5的平方。</p>\n<p>如果参数不是数值，<code>Math.hypot</code>方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。</p>\n<h3 id=\"三角函数方法\"><a href=\"#三角函数方法\" class=\"headerlink\" title=\"三角函数方法\"></a>三角函数方法</h3><p>ES6新增了6个三角函数方法。</p>\n<ul>\n<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>\n<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>\n<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>\n<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>\n<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>\n<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"数值的扩展\"><a href=\"#数值的扩展\" class=\"headerlink\" title=\"数值的扩展\"></a>数值的扩展</h1><h2 id=\"Number-isFinite-Number-isNaN\"><a href=\"#Number-isFinite-Number-isNaN\" class=\"headerlink\" title=\"Number.isFinite(), Number.isNaN()\"></a>Number.isFinite(), Number.isNaN()</h2><p>ES6在Number对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>\n<p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">15</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">0.8</span>); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">NaN</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">Infinity</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(-<span class=\"literal\">Infinity</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'foo'</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">'15'</span>); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"literal\">true</span>); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>ES5可以通过下面的代码，部署<code>Number.isFinite</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">global</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> global_isFinite = global.isFinite;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">Number</span>, <span class=\"string\">'isFinite'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFinite</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'number'</span> &amp;&amp; global_isFinite(value);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;)(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">15</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">'15'</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">true</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"number\">9</span>/<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">'true'</span>/<span class=\"number\">0</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">'true'</span>/<span class=\"string\">'true'</span>) <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>ES5通过下面的代码，部署<code>Number.isNaN()</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">global</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> global_isNaN = global.isNaN;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(<span class=\"built_in\">Number</span>, <span class=\"string\">'isNaN'</span>, &#123;</div><div class=\"line\">    <span class=\"attr\">value</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNaN</span>(<span class=\"params\">value</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'number'</span> &amp;&amp; global_isNaN(value);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">true</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;)(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回<code>false</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">isFinite</span>(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isFinite(<span class=\"string\">\"25\"</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"literal\">NaN</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isNaN(<span class=\"string\">\"NaN\"</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<h2 id=\"Number-parseInt-Number-parseFloat\"><a href=\"#Number-parseInt-Number-parseFloat\" class=\"headerlink\" title=\"Number.parseInt(), Number.parseFloat()\"></a>Number.parseInt(), Number.parseFloat()</h2><p>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES5的写法</span></div><div class=\"line\"><span class=\"built_in\">parseInt</span>(<span class=\"string\">'12.34'</span>) <span class=\"comment\">// 12</span></div><div class=\"line\"><span class=\"built_in\">parseFloat</span>(<span class=\"string\">'123.45#'</span>) <span class=\"comment\">// 123.45</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6的写法</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.parseInt(<span class=\"string\">'12.34'</span>) <span class=\"comment\">// 12</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.parseFloat(<span class=\"string\">'123.45#'</span>) <span class=\"comment\">// 123.45</span></div></pre></td></tr></table></figure>\n<p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.parseInt === <span class=\"built_in\">parseInt</span> <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.parseFloat === <span class=\"built_in\">parseFloat</span> <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>","more":"<h2 id=\"Number-isInteger\"><a href=\"#Number-isInteger\" class=\"headerlink\" title=\"Number.isInteger()\"></a>Number.isInteger()</h2><p><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">25</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">25.0</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"number\">25.1</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"string\">\"15\"</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isInteger(<span class=\"literal\">true</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<h2 id=\"Number-EPSILON\"><a href=\"#Number-EPSILON\" class=\"headerlink\" title=\"Number.EPSILON\"></a>Number.EPSILON</h2><p>ES6在Number对象上面，新增一个极小的常量<code>Number.EPSILON</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.EPSILON</div><div class=\"line\"><span class=\"comment\">// 2.220446049250313e-16</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.EPSILON.toFixed(<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">// '0.00000000000000022204'</span></div></pre></td></tr></table></figure>\n<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span></div><div class=\"line\"><span class=\"comment\">// 0.30000000000000004</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> - <span class=\"number\">0.3</span></div><div class=\"line\"><span class=\"comment\">// 5.551115123125783e-17</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">5.551115123125783e-17</span>.toFixed(<span class=\"number\">20</span>)</div><div class=\"line\"><span class=\"comment\">// '0.00000000000000005551'</span></div></pre></td></tr></table></figure>\n<p>但是如果这个误差能够小于<code>Number.EPSILON</code>，我们就可以认为得到了正确结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">5.551115123125783e-17</span> &lt; <span class=\"built_in\">Number</span>.EPSILON</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的误差范围。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withinErrorMargin</span> (<span class=\"params\">left, right</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.abs(left - right) &lt; <span class=\"built_in\">Number</span>.EPSILON;</div><div class=\"line\">&#125;</div><div class=\"line\">withinErrorMargin(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>, <span class=\"number\">0.3</span>)</div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\">withinErrorMargin(<span class=\"number\">0.2</span> + <span class=\"number\">0.2</span>, <span class=\"number\">0.3</span>)</div><div class=\"line\"><span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>\n<h2 id=\"安全整数和Number-isSafeInteger\"><a href=\"#安全整数和Number-isSafeInteger\" class=\"headerlink\" title=\"安全整数和Number.isSafeInteger()\"></a>安全整数和Number.isSafeInteger()</h2><p>JavaScript能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) <span class=\"comment\">// 9007199254740992</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"number\">9007199254740992</span>  <span class=\"comment\">// 9007199254740992</span></div><div class=\"line\"><span class=\"number\">9007199254740993</span>  <span class=\"comment\">// 9007199254740992</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) === <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) + <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，超出2的53次方之后，一个数就不精确了。</p>\n<p>ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER === <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) - <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER === <span class=\"number\">9007199254740991</span></div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER === -<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER</div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER === <span class=\"number\">-9007199254740991</span></div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>上面代码中，可以看到JavaScript能够精确表示的极限。</p>\n<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"string\">'a'</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"literal\">null</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"literal\">NaN</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(-<span class=\"literal\">Infinity</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">3</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">1.2</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">9007199254740990</span>) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"number\">9007199254740992</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER - <span class=\"number\">1</span>) <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER) <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger(<span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER + <span class=\"number\">1</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Number</span>.isSafeInteger = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">typeof</span> n === <span class=\"string\">'number'</span> &amp;&amp;</div><div class=\"line\">    <span class=\"built_in\">Math</span>.round(n) === n &amp;&amp;</div><div class=\"line\">    <span class=\"built_in\">Number</span>.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</div><div class=\"line\">    n &lt;= <span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。<br>如果只验证运算结果是否为安全整数，很可能得到错误结果。</p>\n<h2 id=\"指数运算符\"><a href=\"#指数运算符\" class=\"headerlink\" title=\"指数运算符\"></a>指数运算符</h2><p>ES7新增了一个指数运算符（<code>**</code>），目前Babel转码器已经支持。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span> <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">3</span> <span class=\"comment\">// 8</span></div></pre></td></tr></table></figure>\n<p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</div><div class=\"line\">a **= <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"comment\">// 等同于 a = a * a;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">3</span>;</div><div class=\"line\">b **= <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"comment\">// 等同于 b = b * b * b;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Math对象的扩展\"><a href=\"#Math对象的扩展\" class=\"headerlink\" title=\"Math对象的扩展\"></a>Math对象的扩展</h2><p>ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。</p>\n<h3 id=\"Math-trunc\"><a href=\"#Math-trunc\" class=\"headerlink\" title=\"Math.trunc()\"></a>Math.trunc()</h3><p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">4.1</span>) <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">4.9</span>) <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">-4.1</span>) <span class=\"comment\">// -4</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">-4.9</span>) <span class=\"comment\">// -4</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"number\">-0.1234</span>) <span class=\"comment\">// -0</span></div></pre></td></tr></table></figure>\n<p>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"string\">'123.456'</span>)</div><div class=\"line\"><span class=\"comment\">// 123</span></div></pre></td></tr></table></figure>\n<p>对于空值和无法截取整数的值，返回NaN。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"literal\">NaN</span>);      <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc(<span class=\"string\">'foo'</span>);    <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.trunc();         <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.trunc = <span class=\"built_in\">Math</span>.trunc || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">0</span> ? <span class=\"built_in\">Math</span>.ceil(x) : <span class=\"built_in\">Math</span>.floor(x);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"Math-sign\"><a href=\"#Math-sign\" class=\"headerlink\" title=\"Math.sign()\"></a>Math.sign()</h3><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。</p>\n<p>它会返回五种值。</p>\n<ul>\n<li>参数为正数，返回+1；</li>\n<li>参数为负数，返回-1；</li>\n<li>参数为0，返回0；</li>\n<li>参数为-0，返回-0;</li>\n<li>其他值，返回NaN。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"number\">-5</span>) <span class=\"comment\">// -1</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"number\">5</span>) <span class=\"comment\">// +1</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"number\">0</span>) <span class=\"comment\">// +0</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"number\">-0</span>) <span class=\"comment\">// -0</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"literal\">NaN</span>) <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign(<span class=\"string\">'foo'</span>); <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.sign();      <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.sign = <span class=\"built_in\">Math</span>.sign || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  x = +x; <span class=\"comment\">// convert to a number</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (x === <span class=\"number\">0</span> || <span class=\"built_in\">isNaN</span>(x)) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> x &gt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">-1</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"Math-cbrt\"><a href=\"#Math-cbrt\" class=\"headerlink\" title=\"Math.cbrt()\"></a>Math.cbrt()</h3><p><code>Math.cbrt</code>方法用于计算一个数的立方根。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">-1</span>) <span class=\"comment\">// -1</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">0</span>)  <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">1</span>)  <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"number\">2</span>)  <span class=\"comment\">// 1.2599210498948734</span></div></pre></td></tr></table></figure>\n<p>对于非数值，<code>Math.cbrt</code>方法内部也是先使用<code>Number</code>方法将其转为数值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"string\">'8'</span>) <span class=\"comment\">// 2</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt(<span class=\"string\">'hello'</span>) <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.cbrt = <span class=\"built_in\">Math</span>.cbrt || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"built_in\">Math</span>.pow(<span class=\"built_in\">Math</span>.abs(x), <span class=\"number\">1</span>/<span class=\"number\">3</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">0</span> ? -y : y;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"Math-hypot\"><a href=\"#Math-hypot\" class=\"headerlink\" title=\"Math.hypot()\"></a>Math.hypot()</h3><p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>);        <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);     <span class=\"comment\">// 7.0710678118654755</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot();            <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"literal\">NaN</span>);         <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">'foo'</span>); <span class=\"comment\">// NaN</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">'5'</span>);   <span class=\"comment\">// 7.0710678118654755</span></div><div class=\"line\"><span class=\"built_in\">Math</span>.hypot(<span class=\"number\">-3</span>);          <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>上面代码中，3的平方加上4的平方，等于5的平方。</p>\n<p>如果参数不是数值，<code>Math.hypot</code>方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。</p>\n<h3 id=\"三角函数方法\"><a href=\"#三角函数方法\" class=\"headerlink\" title=\"三角函数方法\"></a>三角函数方法</h3><p>ES6新增了6个三角函数方法。</p>\n<ul>\n<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>\n<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>\n<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>\n<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>\n<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>\n<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>\n</ul>"},{"title":"ES2015新的数据结构Set和Map","date":"2016-11-02T08:38:05.000Z","_content":"## Set\n\n### 基本用法\n\nES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nSet本身是一个构造函数，用来生成Set数据结构。\n\n```javascript\nvar s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n上面代码通过`add`方法向Set结构加入成员，结果表明Set结构不会添加重复的值。\n\nSet函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。\n\n```javascript\n// 例一\nvar set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nvar items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nfunction divs () {\n  return [...document.querySelectorAll('div')];\n}\n\nvar set = new Set(divs());\nset.size // 56\n\n// 类似于\ndivs().forEach(div => set.add(div));\nset.size // 56\n```\n\n上面代码中，例一和例二都是`Set`函数接受数组作为参数，例三是接受类似数组的对象作为参数。\n\n上面代码中，也展示了一种去除数组重复成员的方法。\n\n```javascript\n// 去除数组的重复成员\n[...new Set(array)]\n```\n\n向Set加入值的时候，不会发生类型转换，所以`5`和`\"5\"`是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（`===`），主要的区别是`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。\n\n```javascript\nlet set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set {NaN}\n```\n\n上面代码向Set实例添加了两个`NaN`，但是只能加入一个。这表明，在Set内部，两个`NaN`是相等。\n\n另外，两个对象总是不相等的。\n\n```javascript\nlet set = new Set();\n\nset.add({});\nset.size // 1\n\nset.add({});\nset.size // 2\n```\n\n上面代码表示，由于两个空对象不相等，所以它们被视为两个值。\n\n### Set实例的属性和方法\n\nSet结构的实例有以下属性。\n\n- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。\n- `Set.prototype.size`：返回`Set`实例的成员总数。\n\nSet实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n\n- `add(value)`：添加某个值，返回Set结构本身。\n- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。\n- `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。\n- `clear()`：清除所有成员，没有返回值。\n<!--more-->\n上面这些属性和方法的实例如下。\n\n```javascript\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n```\n\n下面是一个对比，看看在判断是否包括一个键上面，`Object`结构和`Set`结构的写法不同。\n\n```javascript\n// 对象的写法\nvar properties = {\n  'width': 1,\n  'height': 1\n};\n\nif (properties[someName]) {\n  // do something\n}\n\n// Set的写法\nvar properties = new Set();\n\nproperties.add('width');\nproperties.add('height');\n\nif (properties.has(someName)) {\n  // do something\n}\n```\n\n`Array.from`方法可以将Set结构转为数组。\n\n```javascript\nvar items = new Set([1, 2, 3, 4, 5]);\nvar array = Array.from(items);\n```\n\n这就提供了去除数组重复成员的另一种方法。\n\n```javascript\nfunction dedupe(array) {\n  return Array.from(new Set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n```\n\n### 遍历操作\n\nSet结构的实例有四个遍历方法，可以用于遍历成员。\n\n- `keys()`：返回键名的遍历器\n- `values()`：返回键值的遍历器\n- `entries()`：返回键值对的遍历器\n- `forEach()`：使用回调函数遍历每个成员\n\n需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。\n\n**（1）`keys()`，`values()`，`entries()`**\n\n`key`方法、`value`方法、`entries`方法返回的都是遍历器对象（详见《Iterator对象》一章）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以`key`方法和`value`方法的行为完全一致。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// [\"red\", \"red\"]\n// [\"green\", \"green\"]\n// [\"blue\", \"blue\"]\n```\n\n上面代码中，`entries`方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n\nSet结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法。\n\n```javascript\nSet.prototype[Symbol.iterator] === Set.prototype.values\n// true\n```\n\n这意味着，可以省略`values`方法，直接用`for...of`循环遍历Set。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let x of set) {\n  console.log(x);\n}\n// red\n// green\n// blue\n```\n\n**（2）`forEach()`**\n\nSet结构的实例的`forEach`方法，用于对每个成员执行某种操作，没有返回值。\n\n```javascript\nlet set = new Set([1, 2, 3]);\nset.forEach((value, key) => console.log(value * 2) )\n// 2\n// 4\n// 6\n```\n\n上面代码说明，`forEach`方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，`forEach`方法还可以有第二个参数，表示绑定的this对象。\n\n**（3）遍历的应用**\n\n扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于Set结构。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\n```\n\n扩展运算符和Set结构相结合，就可以去除数组的重复成员。\n\n```javascript\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n```\n\n而且，数组的`map`和`filter`方法也可以用于Set了。\n\n```javascript\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => (x % 2) == 0));\n// 返回Set结构：{2, 4}\n```\n\n因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。\n\n```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n\n如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用`Array.from`方法。\n\n```javascript\n// 方法一\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(val => val * 2));\n// set的值是2, 4, 6\n\n// 方法二\nlet set = new Set([1, 2, 3]);\nset = new Set(Array.from(set, val => val * 2));\n// set的值是2, 4, 6\n```\n\n上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。\n\n## WeakSet\n\nWeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。\n\n首先，**WeakSet的成员只能是对象**，而不能是其他类型的值。\n\n其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。\n\n```javascript\nvar ws = new WeakSet();\nws.add(1)\n// TypeError: Invalid value used in weak set\nws.add(Symbol())\n// TypeError: invalid value used in weak set\n```\n\n上面代码试图向WeakSet添加一个数值和`Symbol`值，结果报错，因为WeakSet只能放置对象。\n\nWeakSet是一个构造函数，可以使用`new`命令，创建WeakSet数据结构。\n\n```javascript\nvar ws = new WeakSet();\n```\n\n作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。\n\n```javascript\nvar a = [[1,2], [3,4]];\nvar ws = new WeakSet(a);\n```\n\n上面代码中，`a`是一个数组，它有两个成员，也都是数组。将`a`作为WeakSet构造函数的参数，`a`的成员会自动成为WeakSet的成员。\n\n注意，是`a`数组的成员成为WeakSet的成员，而不是`a`数组本身。这意味着，数组的成员只能是对象。\n\n```javascript\nvar b = [3, 4];\nvar ws = new WeakSet(b);\n// Uncaught TypeError: Invalid value used in weak set(…)\n```\n\n上面代码中，数组`b`的成员不是对象，加入WeaKSet就会报错。\n\nWeakSet结构有以下三个方法。\n\n- **WeakSet.prototype.add(value)**：向WeakSet实例添加一个新成员。\n- **WeakSet.prototype.delete(value)**：清除WeakSet实例的指定成员。\n- **WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在WeakSet实例之中。\n\n下面是一个例子。\n\n```javascript\nvar ws = new WeakSet();\nvar obj = {};\nvar foo = {};\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo);    // false\n\nws.delete(window);\nws.has(window);    // false\n```\n\nWeakSet没有`size`属性，没有办法遍历它的成员。\n\n```javascript\nws.size // undefined\nws.forEach // undefined\n\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n// TypeError: undefined is not a function\n```\n\n上面代码试图获取`size`和`forEach`属性，结果都不能成功。\n\nWeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n下面是WeakSet的另一个例子。\n\n```javascript\nconst foos = new WeakSet()\nclass Foo {\n  constructor() {\n    foos.add(this)\n  }\n  method () {\n    if (!foos.has(this)) {\n      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');\n    }\n  }\n}\n```\n\n上面代码保证了`Foo`的实例方法，只能在`Foo`的实例上调用。这里使用WeakSet的好处是，`foos`对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑`foos`，也不会出现内存泄漏。\n\n## Map\n\n### Map结构的目的和基本用法\n\nJavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\n```javascript\nvar data = {};\nvar element = document.getElementById('myDiv');\n\ndata[element] = 'metadata';\ndata['[object HTMLDivElement]'] // \"metadata\"\n```\n\n上面代码原意是将一个DOM节点作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`element`被自动转为字符串`[object HTMLDivElement]`。\n\n为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。\n\n```javascript\nvar m = new Map();\nvar o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n```\n\n上面代码使用`set`方法，将对象`o`当作`m`的一个键，然后又使用`get`方法读取这个键，接着使用`delete`方法删除了这个键。\n\n作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\n```javascript\nvar map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"\n```\n\n上面代码在新建Map实例时，就指定了两个键`name`和`title`。\n\nMap构造函数接受数组作为参数，实际上执行的是下面的算法。\n\n```javascript\nvar items = [\n  ['name', '张三'],\n  ['title', 'Author']\n];\nvar map = new Map();\nitems.forEach(([key, value]) => map.set(key, value));\n```\n\n下面的例子中，字符串`true`和布尔值`true`是两个不同的键。\n\n```javascript\nvar m = new Map([\n  [true, 'foo'],\n  ['true', 'bar']\n]);\n\nm.get(true) // 'foo'\nm.get('true') // 'bar'\n```\n\n如果对同一个键多次赋值，后面的值将覆盖前面的值。\n\n```javascript\nlet map = new Map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n```\n\n上面代码对键`1`连续赋值两次，后一次的值覆盖前一次的值。\n\n如果读取一个未知的键，则返回`undefined`。\n\n```javascript\nnew Map().get('asfddfsasadf')\n// undefined\n```\n\n注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。\n\n```javascript\nvar map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n```\n\n上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。\n\n同理，同样的值的两个实例，在Map结构中被视为两个键。\n\n```javascript\nvar map = new Map();\n\nvar k1 = ['a'];\nvar k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n```\n\n上面代码中，变量`k1`和`k2`的值是一样的，但是它们在Map结构中被视为两个键。\n\n由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。\n\n如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括`0`和`-0`。另外，虽然`NaN`不严格相等于自身，但Map将其视为同一个键。\n\n```javascript\nlet map = new Map();\n\nmap.set(NaN, 123);\nmap.get(NaN) // 123\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n```\n\n### 实例的属性和操作方法\n\nMap结构的实例有以下属性和操作方法。\n\n**（1）size属性**\n\n`size`属性返回Map结构的成员总数。\n\n```javascript\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n```\n\n**（2）set(key, value)**\n\n`set`方法设置`key`所对应的键值，然后返回整个Map结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。\n\n```javascript\nvar m = new Map();\n\nm.set(\"edition\", 6)        // 键是字符串\nm.set(262, \"standard\")     // 键是数值\nm.set(undefined, \"nah\")    // 键是undefined\n```\n\n`set`方法返回的是Map本身，因此可以采用链式写法。\n\n```javascript\nlet map = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n```\n\n**（3）get(key)**\n\n`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。\n\n```javascript\nvar m = new Map();\n\nvar hello = function() {console.log(\"hello\");}\nm.set(hello, \"Hello ES6!\") // 键是函数\n\nm.get(hello)  // Hello ES6!\n```\n\n**（4）has(key)**\n\n`has`方法返回一个布尔值，表示某个键是否在Map数据结构中。\n\n```javascript\nvar m = new Map();\n\nm.set(\"edition\", 6);\nm.set(262, \"standard\");\nm.set(undefined, \"nah\");\n\nm.has(\"edition\")     // true\nm.has(\"years\")       // false\nm.has(262)           // true\nm.has(undefined)     // true\n```\n\n**（5）delete(key)**\n\n`delete`方法删除某个键，返回true。如果删除失败，返回false。\n\n```javascript\nvar m = new Map();\nm.set(undefined, \"nah\");\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n```\n**（6）clear()**\n\n`clear`方法清除所有成员，没有返回值。\n\n```javascript\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n```\n\n### 遍历方法\n\nMap原生提供三个遍历器生成函数和一个遍历方法。\n\n- `keys()`：返回键名的遍历器。\n- `values()`：返回键值的遍历器。\n- `entries()`：返回所有成员的遍历器。\n- `forEach()`：遍历Map的所有成员。\n\n需要特别注意的是，Map的遍历顺序就是插入顺序。\n\n下面是使用实例。\n\n```javascript\nlet map = new Map([\n  ['F', 'no'],\n  ['T',  'yes'],\n]);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// \"F\"\n// \"T\"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// \"no\"\n// \"yes\"\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n```\n\n上面代码最后的那个例子，表示Map结构的默认遍历器接口（`Symbol.iterator`属性），就是`entries`方法。\n\n```javascript\nmap[Symbol.iterator] === map.entries\n// true\n```\n\nMap结构转为数组结构，比较快速的方法是结合使用扩展运算符（`...`）。\n\n```javascript\nlet map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n```\n\n结合数组的`map`方法、`filter`方法，可以实现Map的遍历和过滤（Map本身没有`map`和`filter`方法）。\n\n```javascript\nlet map0 = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\nlet map1 = new Map(\n  [...map0].filter(([k, v]) => k < 3)\n);\n// 产生Map结构 {1 => 'a', 2 => 'b'}\n\nlet map2 = new Map(\n  [...map0].map(([k, v]) => [k * 2, '_' + v])\n    );\n// 产生Map结构 {2 => '_a', 4 => '_b', 6 => '_c'}\n```\n\n此外，Map还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历。\n\n```javascript\nmap.forEach(function(value, key, map) {\n  console.log(\"Key: %s, Value: %s\", key, value);\n});\n```\n\n`forEach`方法还可以接受第二个参数，用来绑定`this`。\n\n```javascript\nvar reporter = {\n  report: function(key, value) {\n    console.log(\"Key: %s, Value: %s\", key, value);\n  }\n};\n\nmap.forEach(function(value, key, map) {\n  this.report(key, value);\n}, reporter);\n```\n\n上面代码中，`forEach`方法的回调函数的`this`，就指向`reporter`。\n\n### 与其他数据结构的互相转换\n\n**（1）Map转为数组**\n\n前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（...）。\n\n```javascript\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\n[...myMap]\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n```\n\n**（2）数组转为Map**\n\n将数组转入Map构造函数，就可以转为Map。\n\n```javascript\nnew Map([[true, 7], [{foo: 3}, ['abc']]])\n// Map {true => 7, Object {foo: 3} => ['abc']}\n```\n\n**（3）Map转为对象**\n\n如果所有Map的键都是字符串，它可以转为对象。\n\n```javascript\nfunction strMapToObj(strMap) {\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToObj(myMap)\n// { yes: true, no: false }\n```\n\n**（4）对象转为Map**\n\n```javascript\nfunction objToStrMap(obj) {\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n// [ [ 'yes', true ], [ 'no', false ] ]\n```\n\n## WeakMap\n\n`WeakMap`结构与`Map`结构基本类似，唯一的区别是它只接受对象作为键名（`null`除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。\n\n```javascript\nvar map = new WeakMap()\nmap.set(1, 2)\n// TypeError: 1 is not an object!\nmap.set(Symbol(), 2)\n// TypeError: Invalid value used as weak map key\n```\n\n上面代码中，如果将`1`和`Symbol`作为WeakMap的键名，都会报错。\n\n`WeakMap`的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，`WeakMap`自动移除对应的键值对。典型应用是，一个对应DOM元素的`WeakMap`结构，当某个DOM元素被清除，其所对应的`WeakMap`记录就会自动被移除。基本上，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。\n\n下面是`WeakMap`结构的一个例子，可以看到用法上与`Map`几乎一样。\n\n```javascript\nvar wm = new WeakMap();\nvar element = document.querySelector(\".element\");\n\nwm.set(element, \"Original\");\nwm.get(element) // \"Original\"\n\nelement.parentNode.removeChild(element);\nelement = null;\nwm.get(element) // undefined\n```\n\n上面代码中，变量`wm`是一个`WeakMap`实例，我们将一个`DOM`节点`element`作为键名，然后销毁这个节点，`element`对应的键就自动消失了，再引用这个键名就返回`undefined`。\n\nWeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有`key()`、`values()`和`entries()`方法），也没有`size`属性；二是无法清空，即不支持`clear`方法。这与`WeakMap`的键不被计入引用、被垃圾回收机制忽略有关。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`。\n\n```javascript\nvar wm = new WeakMap();\n\nwm.size\n// undefined\n\nwm.forEach\n// undefined\n```\n\n前文说过，WeakMap应用的典型场合就是DOM节点作为键名。下面是一个例子。\n\n```javascript\nlet myElement = document.getElementById('logo');\nlet myWeakmap = new WeakMap();\n\nmyWeakmap.set(myElement, {timesClicked: 0});\n\nmyElement.addEventListener('click', function() {\n  let logoData = myWeakmap.get(myElement);\n  logoData.timesClicked++;\n  myWeakmap.set(myElement, logoData);\n}, false);\n```\n\n上面代码中，`myElement`是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是`myElement`。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。\n\nWeakMap的另一个用处是部署私有属性。\n\n```javascript\nlet _counter = new WeakMap();\nlet _action = new WeakMap();\n\nclass Countdown {\n  constructor(counter, action) {\n    _counter.set(this, counter);\n    _action.set(this, action);\n  }\n  dec() {\n    let counter = _counter.get(this);\n    if (counter < 1) return;\n    counter--;\n    _counter.set(this, counter);\n    if (counter === 0) {\n      _action.get(this)();\n    }\n  }\n}\n\nlet c = new Countdown(2, () => console.log('DONE'));\n\nc.dec()\nc.dec()\n// DONE\n```\n\n上面代码中，Countdown类的两个内部属性`_counter`和`_action`，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。\n","source":"_posts/ES2015新的数据结构Set和Map.md","raw":"---\ntitle: ES2015新的数据结构Set和Map\ndate: 2016-11-02 16:38:05\ntags: ES2015\n---\n## Set\n\n### 基本用法\n\nES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\nSet本身是一个构造函数，用来生成Set数据结构。\n\n```javascript\nvar s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].map(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n上面代码通过`add`方法向Set结构加入成员，结果表明Set结构不会添加重复的值。\n\nSet函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。\n\n```javascript\n// 例一\nvar set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nvar items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nfunction divs () {\n  return [...document.querySelectorAll('div')];\n}\n\nvar set = new Set(divs());\nset.size // 56\n\n// 类似于\ndivs().forEach(div => set.add(div));\nset.size // 56\n```\n\n上面代码中，例一和例二都是`Set`函数接受数组作为参数，例三是接受类似数组的对象作为参数。\n\n上面代码中，也展示了一种去除数组重复成员的方法。\n\n```javascript\n// 去除数组的重复成员\n[...new Set(array)]\n```\n\n向Set加入值的时候，不会发生类型转换，所以`5`和`\"5\"`是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（`===`），主要的区别是`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。\n\n```javascript\nlet set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set {NaN}\n```\n\n上面代码向Set实例添加了两个`NaN`，但是只能加入一个。这表明，在Set内部，两个`NaN`是相等。\n\n另外，两个对象总是不相等的。\n\n```javascript\nlet set = new Set();\n\nset.add({});\nset.size // 1\n\nset.add({});\nset.size // 2\n```\n\n上面代码表示，由于两个空对象不相等，所以它们被视为两个值。\n\n### Set实例的属性和方法\n\nSet结构的实例有以下属性。\n\n- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。\n- `Set.prototype.size`：返回`Set`实例的成员总数。\n\nSet实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。\n\n- `add(value)`：添加某个值，返回Set结构本身。\n- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。\n- `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。\n- `clear()`：清除所有成员，没有返回值。\n<!--more-->\n上面这些属性和方法的实例如下。\n\n```javascript\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n```\n\n下面是一个对比，看看在判断是否包括一个键上面，`Object`结构和`Set`结构的写法不同。\n\n```javascript\n// 对象的写法\nvar properties = {\n  'width': 1,\n  'height': 1\n};\n\nif (properties[someName]) {\n  // do something\n}\n\n// Set的写法\nvar properties = new Set();\n\nproperties.add('width');\nproperties.add('height');\n\nif (properties.has(someName)) {\n  // do something\n}\n```\n\n`Array.from`方法可以将Set结构转为数组。\n\n```javascript\nvar items = new Set([1, 2, 3, 4, 5]);\nvar array = Array.from(items);\n```\n\n这就提供了去除数组重复成员的另一种方法。\n\n```javascript\nfunction dedupe(array) {\n  return Array.from(new Set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n```\n\n### 遍历操作\n\nSet结构的实例有四个遍历方法，可以用于遍历成员。\n\n- `keys()`：返回键名的遍历器\n- `values()`：返回键值的遍历器\n- `entries()`：返回键值对的遍历器\n- `forEach()`：使用回调函数遍历每个成员\n\n需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。\n\n**（1）`keys()`，`values()`，`entries()`**\n\n`key`方法、`value`方法、`entries`方法返回的都是遍历器对象（详见《Iterator对象》一章）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以`key`方法和`value`方法的行为完全一致。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// [\"red\", \"red\"]\n// [\"green\", \"green\"]\n// [\"blue\", \"blue\"]\n```\n\n上面代码中，`entries`方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n\nSet结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法。\n\n```javascript\nSet.prototype[Symbol.iterator] === Set.prototype.values\n// true\n```\n\n这意味着，可以省略`values`方法，直接用`for...of`循环遍历Set。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\n\nfor (let x of set) {\n  console.log(x);\n}\n// red\n// green\n// blue\n```\n\n**（2）`forEach()`**\n\nSet结构的实例的`forEach`方法，用于对每个成员执行某种操作，没有返回值。\n\n```javascript\nlet set = new Set([1, 2, 3]);\nset.forEach((value, key) => console.log(value * 2) )\n// 2\n// 4\n// 6\n```\n\n上面代码说明，`forEach`方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，`forEach`方法还可以有第二个参数，表示绑定的this对象。\n\n**（3）遍历的应用**\n\n扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于Set结构。\n\n```javascript\nlet set = new Set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\n```\n\n扩展运算符和Set结构相结合，就可以去除数组的重复成员。\n\n```javascript\nlet arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n```\n\n而且，数组的`map`和`filter`方法也可以用于Set了。\n\n```javascript\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => (x % 2) == 0));\n// 返回Set结构：{2, 4}\n```\n\n因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。\n\n```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n\n如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用`Array.from`方法。\n\n```javascript\n// 方法一\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(val => val * 2));\n// set的值是2, 4, 6\n\n// 方法二\nlet set = new Set([1, 2, 3]);\nset = new Set(Array.from(set, val => val * 2));\n// set的值是2, 4, 6\n```\n\n上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。\n\n## WeakSet\n\nWeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。\n\n首先，**WeakSet的成员只能是对象**，而不能是其他类型的值。\n\n其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。\n\n```javascript\nvar ws = new WeakSet();\nws.add(1)\n// TypeError: Invalid value used in weak set\nws.add(Symbol())\n// TypeError: invalid value used in weak set\n```\n\n上面代码试图向WeakSet添加一个数值和`Symbol`值，结果报错，因为WeakSet只能放置对象。\n\nWeakSet是一个构造函数，可以使用`new`命令，创建WeakSet数据结构。\n\n```javascript\nvar ws = new WeakSet();\n```\n\n作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。\n\n```javascript\nvar a = [[1,2], [3,4]];\nvar ws = new WeakSet(a);\n```\n\n上面代码中，`a`是一个数组，它有两个成员，也都是数组。将`a`作为WeakSet构造函数的参数，`a`的成员会自动成为WeakSet的成员。\n\n注意，是`a`数组的成员成为WeakSet的成员，而不是`a`数组本身。这意味着，数组的成员只能是对象。\n\n```javascript\nvar b = [3, 4];\nvar ws = new WeakSet(b);\n// Uncaught TypeError: Invalid value used in weak set(…)\n```\n\n上面代码中，数组`b`的成员不是对象，加入WeaKSet就会报错。\n\nWeakSet结构有以下三个方法。\n\n- **WeakSet.prototype.add(value)**：向WeakSet实例添加一个新成员。\n- **WeakSet.prototype.delete(value)**：清除WeakSet实例的指定成员。\n- **WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在WeakSet实例之中。\n\n下面是一个例子。\n\n```javascript\nvar ws = new WeakSet();\nvar obj = {};\nvar foo = {};\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo);    // false\n\nws.delete(window);\nws.has(window);    // false\n```\n\nWeakSet没有`size`属性，没有办法遍历它的成员。\n\n```javascript\nws.size // undefined\nws.forEach // undefined\n\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n// TypeError: undefined is not a function\n```\n\n上面代码试图获取`size`和`forEach`属性，结果都不能成功。\n\nWeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n下面是WeakSet的另一个例子。\n\n```javascript\nconst foos = new WeakSet()\nclass Foo {\n  constructor() {\n    foos.add(this)\n  }\n  method () {\n    if (!foos.has(this)) {\n      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');\n    }\n  }\n}\n```\n\n上面代码保证了`Foo`的实例方法，只能在`Foo`的实例上调用。这里使用WeakSet的好处是，`foos`对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑`foos`，也不会出现内存泄漏。\n\n## Map\n\n### Map结构的目的和基本用法\n\nJavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。\n\n```javascript\nvar data = {};\nvar element = document.getElementById('myDiv');\n\ndata[element] = 'metadata';\ndata['[object HTMLDivElement]'] // \"metadata\"\n```\n\n上面代码原意是将一个DOM节点作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`element`被自动转为字符串`[object HTMLDivElement]`。\n\n为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。\n\n```javascript\nvar m = new Map();\nvar o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n```\n\n上面代码使用`set`方法，将对象`o`当作`m`的一个键，然后又使用`get`方法读取这个键，接着使用`delete`方法删除了这个键。\n\n作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。\n\n```javascript\nvar map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"\n```\n\n上面代码在新建Map实例时，就指定了两个键`name`和`title`。\n\nMap构造函数接受数组作为参数，实际上执行的是下面的算法。\n\n```javascript\nvar items = [\n  ['name', '张三'],\n  ['title', 'Author']\n];\nvar map = new Map();\nitems.forEach(([key, value]) => map.set(key, value));\n```\n\n下面的例子中，字符串`true`和布尔值`true`是两个不同的键。\n\n```javascript\nvar m = new Map([\n  [true, 'foo'],\n  ['true', 'bar']\n]);\n\nm.get(true) // 'foo'\nm.get('true') // 'bar'\n```\n\n如果对同一个键多次赋值，后面的值将覆盖前面的值。\n\n```javascript\nlet map = new Map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n```\n\n上面代码对键`1`连续赋值两次，后一次的值覆盖前一次的值。\n\n如果读取一个未知的键，则返回`undefined`。\n\n```javascript\nnew Map().get('asfddfsasadf')\n// undefined\n```\n\n注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。\n\n```javascript\nvar map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n```\n\n上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。\n\n同理，同样的值的两个实例，在Map结构中被视为两个键。\n\n```javascript\nvar map = new Map();\n\nvar k1 = ['a'];\nvar k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n```\n\n上面代码中，变量`k1`和`k2`的值是一样的，但是它们在Map结构中被视为两个键。\n\n由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。\n\n如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括`0`和`-0`。另外，虽然`NaN`不严格相等于自身，但Map将其视为同一个键。\n\n```javascript\nlet map = new Map();\n\nmap.set(NaN, 123);\nmap.get(NaN) // 123\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n```\n\n### 实例的属性和操作方法\n\nMap结构的实例有以下属性和操作方法。\n\n**（1）size属性**\n\n`size`属性返回Map结构的成员总数。\n\n```javascript\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n```\n\n**（2）set(key, value)**\n\n`set`方法设置`key`所对应的键值，然后返回整个Map结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。\n\n```javascript\nvar m = new Map();\n\nm.set(\"edition\", 6)        // 键是字符串\nm.set(262, \"standard\")     // 键是数值\nm.set(undefined, \"nah\")    // 键是undefined\n```\n\n`set`方法返回的是Map本身，因此可以采用链式写法。\n\n```javascript\nlet map = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n```\n\n**（3）get(key)**\n\n`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。\n\n```javascript\nvar m = new Map();\n\nvar hello = function() {console.log(\"hello\");}\nm.set(hello, \"Hello ES6!\") // 键是函数\n\nm.get(hello)  // Hello ES6!\n```\n\n**（4）has(key)**\n\n`has`方法返回一个布尔值，表示某个键是否在Map数据结构中。\n\n```javascript\nvar m = new Map();\n\nm.set(\"edition\", 6);\nm.set(262, \"standard\");\nm.set(undefined, \"nah\");\n\nm.has(\"edition\")     // true\nm.has(\"years\")       // false\nm.has(262)           // true\nm.has(undefined)     // true\n```\n\n**（5）delete(key)**\n\n`delete`方法删除某个键，返回true。如果删除失败，返回false。\n\n```javascript\nvar m = new Map();\nm.set(undefined, \"nah\");\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n```\n**（6）clear()**\n\n`clear`方法清除所有成员，没有返回值。\n\n```javascript\nlet map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n```\n\n### 遍历方法\n\nMap原生提供三个遍历器生成函数和一个遍历方法。\n\n- `keys()`：返回键名的遍历器。\n- `values()`：返回键值的遍历器。\n- `entries()`：返回所有成员的遍历器。\n- `forEach()`：遍历Map的所有成员。\n\n需要特别注意的是，Map的遍历顺序就是插入顺序。\n\n下面是使用实例。\n\n```javascript\nlet map = new Map([\n  ['F', 'no'],\n  ['T',  'yes'],\n]);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// \"F\"\n// \"T\"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// \"no\"\n// \"yes\"\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// \"F\" \"no\"\n// \"T\" \"yes\"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n```\n\n上面代码最后的那个例子，表示Map结构的默认遍历器接口（`Symbol.iterator`属性），就是`entries`方法。\n\n```javascript\nmap[Symbol.iterator] === map.entries\n// true\n```\n\nMap结构转为数组结构，比较快速的方法是结合使用扩展运算符（`...`）。\n\n```javascript\nlet map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n```\n\n结合数组的`map`方法、`filter`方法，可以实现Map的遍历和过滤（Map本身没有`map`和`filter`方法）。\n\n```javascript\nlet map0 = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\nlet map1 = new Map(\n  [...map0].filter(([k, v]) => k < 3)\n);\n// 产生Map结构 {1 => 'a', 2 => 'b'}\n\nlet map2 = new Map(\n  [...map0].map(([k, v]) => [k * 2, '_' + v])\n    );\n// 产生Map结构 {2 => '_a', 4 => '_b', 6 => '_c'}\n```\n\n此外，Map还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历。\n\n```javascript\nmap.forEach(function(value, key, map) {\n  console.log(\"Key: %s, Value: %s\", key, value);\n});\n```\n\n`forEach`方法还可以接受第二个参数，用来绑定`this`。\n\n```javascript\nvar reporter = {\n  report: function(key, value) {\n    console.log(\"Key: %s, Value: %s\", key, value);\n  }\n};\n\nmap.forEach(function(value, key, map) {\n  this.report(key, value);\n}, reporter);\n```\n\n上面代码中，`forEach`方法的回调函数的`this`，就指向`reporter`。\n\n### 与其他数据结构的互相转换\n\n**（1）Map转为数组**\n\n前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（...）。\n\n```javascript\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\n[...myMap]\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n```\n\n**（2）数组转为Map**\n\n将数组转入Map构造函数，就可以转为Map。\n\n```javascript\nnew Map([[true, 7], [{foo: 3}, ['abc']]])\n// Map {true => 7, Object {foo: 3} => ['abc']}\n```\n\n**（3）Map转为对象**\n\n如果所有Map的键都是字符串，它可以转为对象。\n\n```javascript\nfunction strMapToObj(strMap) {\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToObj(myMap)\n// { yes: true, no: false }\n```\n\n**（4）对象转为Map**\n\n```javascript\nfunction objToStrMap(obj) {\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n// [ [ 'yes', true ], [ 'no', false ] ]\n```\n\n## WeakMap\n\n`WeakMap`结构与`Map`结构基本类似，唯一的区别是它只接受对象作为键名（`null`除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。\n\n```javascript\nvar map = new WeakMap()\nmap.set(1, 2)\n// TypeError: 1 is not an object!\nmap.set(Symbol(), 2)\n// TypeError: Invalid value used as weak map key\n```\n\n上面代码中，如果将`1`和`Symbol`作为WeakMap的键名，都会报错。\n\n`WeakMap`的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，`WeakMap`自动移除对应的键值对。典型应用是，一个对应DOM元素的`WeakMap`结构，当某个DOM元素被清除，其所对应的`WeakMap`记录就会自动被移除。基本上，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。\n\n下面是`WeakMap`结构的一个例子，可以看到用法上与`Map`几乎一样。\n\n```javascript\nvar wm = new WeakMap();\nvar element = document.querySelector(\".element\");\n\nwm.set(element, \"Original\");\nwm.get(element) // \"Original\"\n\nelement.parentNode.removeChild(element);\nelement = null;\nwm.get(element) // undefined\n```\n\n上面代码中，变量`wm`是一个`WeakMap`实例，我们将一个`DOM`节点`element`作为键名，然后销毁这个节点，`element`对应的键就自动消失了，再引用这个键名就返回`undefined`。\n\nWeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有`key()`、`values()`和`entries()`方法），也没有`size`属性；二是无法清空，即不支持`clear`方法。这与`WeakMap`的键不被计入引用、被垃圾回收机制忽略有关。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`。\n\n```javascript\nvar wm = new WeakMap();\n\nwm.size\n// undefined\n\nwm.forEach\n// undefined\n```\n\n前文说过，WeakMap应用的典型场合就是DOM节点作为键名。下面是一个例子。\n\n```javascript\nlet myElement = document.getElementById('logo');\nlet myWeakmap = new WeakMap();\n\nmyWeakmap.set(myElement, {timesClicked: 0});\n\nmyElement.addEventListener('click', function() {\n  let logoData = myWeakmap.get(myElement);\n  logoData.timesClicked++;\n  myWeakmap.set(myElement, logoData);\n}, false);\n```\n\n上面代码中，`myElement`是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是`myElement`。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。\n\nWeakMap的另一个用处是部署私有属性。\n\n```javascript\nlet _counter = new WeakMap();\nlet _action = new WeakMap();\n\nclass Countdown {\n  constructor(counter, action) {\n    _counter.set(this, counter);\n    _action.set(this, action);\n  }\n  dec() {\n    let counter = _counter.get(this);\n    if (counter < 1) return;\n    counter--;\n    _counter.set(this, counter);\n    if (counter === 0) {\n      _action.get(this)();\n    }\n  }\n}\n\nlet c = new Countdown(2, () => console.log('DONE'));\n\nc.dec()\nc.dec()\n// DONE\n```\n\n上面代码中，Countdown类的两个内部属性`_counter`和`_action`，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。\n","slug":"ES2015新的数据结构Set和Map","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfcd000jzk4o1zuzztjm","content":"<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p>Set本身是一个构造函数，用来生成Set数据结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> s.add(x));</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(i);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 2 3 5 4</span></div></pre></td></tr></table></figure>\n<p>上面代码通过<code>add</code>方法向Set结构加入成员，结果表明Set结构不会添加重复的值。</p>\n<p>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 例一</span></div><div class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</div><div class=\"line\">[...set]</div><div class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 例二</span></div><div class=\"line\"><span class=\"keyword\">var</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>]);</div><div class=\"line\">items.size <span class=\"comment\">// 5</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 例三</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">divs</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [...document.querySelectorAll(<span class=\"string\">'div'</span>)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(divs());</div><div class=\"line\">set.size <span class=\"comment\">// 56</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 类似于</span></div><div class=\"line\">divs().forEach(<span class=\"function\"><span class=\"params\">div</span> =&gt;</span> set.add(div));</div><div class=\"line\">set.size <span class=\"comment\">// 56</span></div></pre></td></tr></table></figure>\n<p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>\n<p>上面代码中，也展示了一种去除数组重复成员的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 去除数组的重复成员</span></div><div class=\"line\">[...new <span class=\"built_in\">Set</span>(array)]</div></pre></td></tr></table></figure>\n<p>向Set加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"literal\">NaN</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"literal\">NaN</span>;</div><div class=\"line\">set.add(a);</div><div class=\"line\">set.add(b);</div><div class=\"line\">set <span class=\"comment\">// Set &#123;NaN&#125;</span></div></pre></td></tr></table></figure>\n<p>上面代码向Set实例添加了两个<code>NaN</code>，但是只能加入一个。这表明，在Set内部，两个<code>NaN</code>是相等。</p>\n<p>另外，两个对象总是不相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">set.add(&#123;&#125;);</div><div class=\"line\">set.size <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\">set.add(&#123;&#125;);</div><div class=\"line\">set.size <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>\n<h3 id=\"Set实例的属性和方法\"><a href=\"#Set实例的属性和方法\" class=\"headerlink\" title=\"Set实例的属性和方法\"></a>Set实例的属性和方法</h3><p>Set结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>\n<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>\n</ul>\n<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>\n<ul>\n<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>\n<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>\n<li><code>clear()</code>：清除所有成员，没有返回值。<a id=\"more\"></a>\n上面这些属性和方法的实例如下。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">s.add(<span class=\"number\">1</span>).add(<span class=\"number\">2</span>).add(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">// 注意2被加入了两次</span></div><div class=\"line\"></div><div class=\"line\">s.size <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\">s.has(<span class=\"number\">1</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.has(<span class=\"number\">3</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\">s.delete(<span class=\"number\">2</span>);</div><div class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 对象的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> properties = &#123;</div><div class=\"line\">  <span class=\"string\">'width'</span>: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"string\">'height'</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (properties[someName]) &#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> properties = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">properties.add(<span class=\"string\">'width'</span>);</div><div class=\"line\">properties.add(<span class=\"string\">'height'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (properties.has(someName)) &#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Array.from</code>方法可以将Set结构转为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</div><div class=\"line\"><span class=\"keyword\">var</span> array = <span class=\"built_in\">Array</span>.from(items);</div></pre></td></tr></table></figure>\n<p>这就提供了去除数组重复成员的另一种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dedupe</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(array));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dedupe([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) <span class=\"comment\">// [1, 2, 3]</span></div></pre></td></tr></table></figure>\n<h3 id=\"遍历操作\"><a href=\"#遍历操作\" class=\"headerlink\" title=\"遍历操作\"></a>遍历操作</h3><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器</li>\n<li><code>values()</code>：返回键值的遍历器</li>\n<li><code>entries()</code>：返回键值对的遍历器</li>\n<li><code>forEach()</code>：使用回调函数遍历每个成员</li>\n</ul>\n<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>\n<p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p>\n<p><code>key</code>方法、<code>value</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator对象》一章）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>key</code>方法和<code>value</code>方法的行为完全一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.keys()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(item);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// red</span></div><div class=\"line\"><span class=\"comment\">// green</span></div><div class=\"line\"><span class=\"comment\">// blue</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.values()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(item);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// red</span></div><div class=\"line\"><span class=\"comment\">// green</span></div><div class=\"line\"><span class=\"comment\">// blue</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.entries()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(item);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// [\"red\", \"red\"]</span></div><div class=\"line\"><span class=\"comment\">// [\"green\", \"green\"]</span></div><div class=\"line\"><span class=\"comment\">// [\"blue\", \"blue\"]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<p>Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Set</span>.prototype[<span class=\"built_in\">Symbol</span>.iterator] === <span class=\"built_in\">Set</span>.prototype.values</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历Set。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> set) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// red</span></div><div class=\"line\"><span class=\"comment\">// green</span></div><div class=\"line\"><span class=\"comment\">// blue</span></div></pre></td></tr></table></figure>\n<p><strong>（2）<code>forEach()</code></strong></p>\n<p>Set结构的实例的<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">set.forEach(<span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(value * <span class=\"number\">2</span>) )</div><div class=\"line\"><span class=\"comment\">// 2</span></div><div class=\"line\"><span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，<code>forEach</code>方法还可以有第二个参数，表示绑定的this对象。</p>\n<p><strong>（3）遍历的应用</strong></p>\n<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于Set结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</div><div class=\"line\"><span class=\"keyword\">let</span> arr = [...set];</div><div class=\"line\"><span class=\"comment\">// ['red', 'green', 'blue']</span></div></pre></td></tr></table></figure>\n<p>扩展运算符和Set结构相结合，就可以去除数组的重复成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> unique = [...new <span class=\"built_in\">Set</span>(arr)];</div><div class=\"line\"><span class=\"comment\">// [3, 5, 2]</span></div></pre></td></tr></table></figure>\n<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以用于Set了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>));</div><div class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4, 6&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</div><div class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (x % <span class=\"number\">2</span>) == <span class=\"number\">0</span>));</div><div class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4&#125;</span></div></pre></td></tr></table></figure>\n<p>因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 并集</span></div><div class=\"line\"><span class=\"keyword\">let</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a, ...b]);</div><div class=\"line\"><span class=\"comment\">// Set &#123;1, 2, 3, 4&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 交集</span></div><div class=\"line\"><span class=\"keyword\">let</span> intersect = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.has(x)));</div><div class=\"line\"><span class=\"comment\">// set &#123;2, 3&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 差集</span></div><div class=\"line\"><span class=\"keyword\">let</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !b.has(x)));</div><div class=\"line\"><span class=\"comment\">// Set &#123;1&#125;</span></div></pre></td></tr></table></figure>\n<p>如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用<code>Array.from</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 方法一</span></div><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> val * <span class=\"number\">2</span>));</div><div class=\"line\"><span class=\"comment\">// set的值是2, 4, 6</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 方法二</span></div><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">Array</span>.from(set, val =&gt; val * <span class=\"number\">2</span>));</div><div class=\"line\"><span class=\"comment\">// set的值是2, 4, 6</span></div></pre></td></tr></table></figure>\n<p>上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。</p>\n<h2 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h2><p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p>\n<p>首先，<strong>WeakSet的成员只能是对象</strong>，而不能是其他类型的值。</p>\n<p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</div><div class=\"line\">ws.add(<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"comment\">// TypeError: Invalid value used in weak set</span></div><div class=\"line\">ws.add(<span class=\"built_in\">Symbol</span>())</div><div class=\"line\"><span class=\"comment\">// TypeError: invalid value used in weak set</span></div></pre></td></tr></table></figure>\n<p>上面代码试图向WeakSet添加一个数值和<code>Symbol</code>值，结果报错，因为WeakSet只能放置对象。</p>\n<p>WeakSet是一个构造函数，可以使用<code>new</code>命令，创建WeakSet数据结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</div></pre></td></tr></table></figure>\n<p>作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>], [<span class=\"number\">3</span>,<span class=\"number\">4</span>]];</div><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>(a);</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为WeakSet构造函数的参数，<code>a</code>的成员会自动成为WeakSet的成员。</p>\n<p>注意，是<code>a</code>数组的成员成为WeakSet的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>(b);</div><div class=\"line\"><span class=\"comment\">// Uncaught TypeError: Invalid value used in weak set(…)</span></div></pre></td></tr></table></figure>\n<p>上面代码中，数组<code>b</code>的成员不是对象，加入WeaKSet就会报错。</p>\n<p>WeakSet结构有以下三个方法。</p>\n<ul>\n<li><strong>WeakSet.prototype.add(value)</strong>：向WeakSet实例添加一个新成员。</li>\n<li><strong>WeakSet.prototype.delete(value)</strong>：清除WeakSet实例的指定成员。</li>\n<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在WeakSet实例之中。</li>\n</ul>\n<p>下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> foo = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.add(<span class=\"built_in\">window</span>);</div><div class=\"line\">ws.add(obj);</div><div class=\"line\"></div><div class=\"line\">ws.has(<span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></div><div class=\"line\">ws.has(foo);    <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\">ws.delete(<span class=\"built_in\">window</span>);</div><div class=\"line\">ws.has(<span class=\"built_in\">window</span>);    <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>WeakSet没有<code>size</code>属性，没有办法遍历它的成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ws.size <span class=\"comment\">// undefined</span></div><div class=\"line\">ws.forEach <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\">ws.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'WeakSet has '</span> + item)&#125;)</div><div class=\"line\"><span class=\"comment\">// TypeError: undefined is not a function</span></div></pre></td></tr></table></figure>\n<p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p>\n<p>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<p>下面是WeakSet的另一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foos = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>()</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    foos.add(<span class=\"keyword\">this</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  method () &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!foos.has(<span class=\"keyword\">this</span>)) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用WeakSet的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"Map结构的目的和基本用法\"><a href=\"#Map结构的目的和基本用法\" class=\"headerlink\" title=\"Map结构的目的和基本用法\"></a>Map结构的目的和基本用法</h3><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myDiv'</span>);</div><div class=\"line\"></div><div class=\"line\">data[element] = <span class=\"string\">'metadata'</span>;</div><div class=\"line\">data[<span class=\"string\">'[object HTMLDivElement]'</span>] <span class=\"comment\">// \"metadata\"</span></div></pre></td></tr></table></figure>\n<p>上面代码原意是将一个DOM节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>\n<p>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">p</span>: <span class=\"string\">'Hello World'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">m.set(o, <span class=\"string\">'content'</span>)</div><div class=\"line\">m.get(o) <span class=\"comment\">// \"content\"</span></div><div class=\"line\"></div><div class=\"line\">m.has(o) <span class=\"comment\">// true</span></div><div class=\"line\">m.delete(o) <span class=\"comment\">// true</span></div><div class=\"line\">m.has(o) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面代码使用<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>\n<p>作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"string\">'name'</span>, <span class=\"string\">'张三'</span>],</div><div class=\"line\">  [<span class=\"string\">'title'</span>, <span class=\"string\">'Author'</span>]</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\">map.size <span class=\"comment\">// 2</span></div><div class=\"line\">map.has(<span class=\"string\">'name'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">'name'</span>) <span class=\"comment\">// \"张三\"</span></div><div class=\"line\">map.has(<span class=\"string\">'title'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">'title'</span>) <span class=\"comment\">// \"Author\"</span></div></pre></td></tr></table></figure>\n<p>上面代码在新建Map实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>\n<p>Map构造函数接受数组作为参数，实际上执行的是下面的算法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> items = [</div><div class=\"line\">  [<span class=\"string\">'name'</span>, <span class=\"string\">'张三'</span>],</div><div class=\"line\">  [<span class=\"string\">'title'</span>, <span class=\"string\">'Author'</span>]</div><div class=\"line\">];</div><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">items.forEach(<span class=\"function\">(<span class=\"params\">[key, value]</span>) =&gt;</span> map.set(key, value));</div></pre></td></tr></table></figure>\n<p>下面的例子中，字符串<code>true</code>和布尔值<code>true</code>是两个不同的键。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"literal\">true</span>, <span class=\"string\">'foo'</span>],</div><div class=\"line\">  [<span class=\"string\">'true'</span>, <span class=\"string\">'bar'</span>]</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\">m.get(<span class=\"literal\">true</span>) <span class=\"comment\">// 'foo'</span></div><div class=\"line\">m.get(<span class=\"string\">'true'</span>) <span class=\"comment\">// 'bar'</span></div></pre></td></tr></table></figure>\n<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">map</div><div class=\"line\">.set(<span class=\"number\">1</span>, <span class=\"string\">'aaa'</span>)</div><div class=\"line\">.set(<span class=\"number\">1</span>, <span class=\"string\">'bbb'</span>);</div><div class=\"line\"></div><div class=\"line\">map.get(<span class=\"number\">1</span>) <span class=\"comment\">// \"bbb\"</span></div></pre></td></tr></table></figure>\n<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>\n<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().get(<span class=\"string\">'asfddfsasadf'</span>)</div><div class=\"line\"><span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">map.set([<span class=\"string\">'a'</span>], <span class=\"number\">555</span>);</div><div class=\"line\">map.get([<span class=\"string\">'a'</span>]) <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>\n<p>同理，同样的值的两个实例，在Map结构中被视为两个键。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> k1 = [<span class=\"string\">'a'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> k2 = [<span class=\"string\">'a'</span>];</div><div class=\"line\"></div><div class=\"line\">map</div><div class=\"line\">.set(k1, <span class=\"number\">111</span>)</div><div class=\"line\">.set(k2, <span class=\"number\">222</span>);</div><div class=\"line\"></div><div class=\"line\">map.get(k1) <span class=\"comment\">// 111</span></div><div class=\"line\">map.get(k2) <span class=\"comment\">// 222</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在Map结构中被视为两个键。</p>\n<p>由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>\n<p>如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括<code>0</code>和<code>-0</code>。另外，虽然<code>NaN</code>不严格相等于自身，但Map将其视为同一个键。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">map.set(<span class=\"literal\">NaN</span>, <span class=\"number\">123</span>);</div><div class=\"line\">map.get(<span class=\"literal\">NaN</span>) <span class=\"comment\">// 123</span></div><div class=\"line\"></div><div class=\"line\">map.set(<span class=\"number\">-0</span>, <span class=\"number\">123</span>);</div><div class=\"line\">map.get(+<span class=\"number\">0</span>) <span class=\"comment\">// 123</span></div></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和操作方法\"><a href=\"#实例的属性和操作方法\" class=\"headerlink\" title=\"实例的属性和操作方法\"></a>实例的属性和操作方法</h3><p>Map结构的实例有以下属性和操作方法。</p>\n<p><strong>（1）size属性</strong></p>\n<p><code>size</code>属性返回Map结构的成员总数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">map.set(<span class=\"string\">'foo'</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">map.set(<span class=\"string\">'bar'</span>, <span class=\"literal\">false</span>);</div><div class=\"line\"></div><div class=\"line\">map.size <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p><strong>（2）set(key, value)</strong></p>\n<p><code>set</code>方法设置<code>key</code>所对应的键值，然后返回整个Map结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">m.set(<span class=\"string\">\"edition\"</span>, <span class=\"number\">6</span>)        <span class=\"comment\">// 键是字符串</span></div><div class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">\"standard\"</span>)     <span class=\"comment\">// 键是数值</span></div><div class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">\"nah\"</span>)    <span class=\"comment\">// 键是undefined</span></div></pre></td></tr></table></figure>\n<p><code>set</code>方法返回的是Map本身，因此可以采用链式写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</div><div class=\"line\">  .set(<span class=\"number\">1</span>, <span class=\"string\">'a'</span>)</div><div class=\"line\">  .set(<span class=\"number\">2</span>, <span class=\"string\">'b'</span>)</div><div class=\"line\">  .set(<span class=\"number\">3</span>, <span class=\"string\">'c'</span>);</div></pre></td></tr></table></figure>\n<p><strong>（3）get(key)</strong></p>\n<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> hello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);&#125;</div><div class=\"line\">m.set(hello, <span class=\"string\">\"Hello ES6!\"</span>) <span class=\"comment\">// 键是函数</span></div><div class=\"line\"></div><div class=\"line\">m.get(hello)  <span class=\"comment\">// Hello ES6!</span></div></pre></td></tr></table></figure>\n<p><strong>（4）has(key)</strong></p>\n<p><code>has</code>方法返回一个布尔值，表示某个键是否在Map数据结构中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">m.set(<span class=\"string\">\"edition\"</span>, <span class=\"number\">6</span>);</div><div class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">\"standard\"</span>);</div><div class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">\"nah\"</span>);</div><div class=\"line\"></div><div class=\"line\">m.has(<span class=\"string\">\"edition\"</span>)     <span class=\"comment\">// true</span></div><div class=\"line\">m.has(<span class=\"string\">\"years\"</span>)       <span class=\"comment\">// false</span></div><div class=\"line\">m.has(<span class=\"number\">262</span>)           <span class=\"comment\">// true</span></div><div class=\"line\">m.has(<span class=\"literal\">undefined</span>)     <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><strong>（5）delete(key)</strong></p>\n<p><code>delete</code>方法删除某个键，返回true。如果删除失败，返回false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">\"nah\"</span>);</div><div class=\"line\">m.has(<span class=\"literal\">undefined</span>)     <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\">m.delete(<span class=\"literal\">undefined</span>)</div><div class=\"line\">m.has(<span class=\"literal\">undefined</span>)       <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p><strong>（6）clear()</strong></p>\n<p><code>clear</code>方法清除所有成员，没有返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">map.set(<span class=\"string\">'foo'</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">map.set(<span class=\"string\">'bar'</span>, <span class=\"literal\">false</span>);</div><div class=\"line\"></div><div class=\"line\">map.size <span class=\"comment\">// 2</span></div><div class=\"line\">map.clear()</div><div class=\"line\">map.size <span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。</li>\n<li><code>entries()</code>：返回所有成员的遍历器。</li>\n<li><code>forEach()</code>：遍历Map的所有成员。</li>\n</ul>\n<p>需要特别注意的是，Map的遍历顺序就是插入顺序。</p>\n<p>下面是使用实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"string\">'F'</span>, <span class=\"string\">'no'</span>],</div><div class=\"line\">  [<span class=\"string\">'T'</span>,  <span class=\"string\">'yes'</span>],</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">of</span> map.keys()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(key);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// \"F\"</span></div><div class=\"line\"><span class=\"comment\">// \"T\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> map.values()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(value);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// \"no\"</span></div><div class=\"line\"><span class=\"comment\">// \"yes\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> map.entries()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(item[<span class=\"number\">0</span>], item[<span class=\"number\">1</span>]);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// \"F\" \"no\"</span></div><div class=\"line\"><span class=\"comment\">// \"T\" \"yes\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或者</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map.entries()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于使用map.entries()</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码最后的那个例子，表示Map结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">map[<span class=\"built_in\">Symbol</span>.iterator] === map.entries</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（<code>...</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>],</div><div class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'two'</span>],</div><div class=\"line\">  [<span class=\"number\">3</span>, <span class=\"string\">'three'</span>],</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\">[...map.keys()]</div><div class=\"line\"><span class=\"comment\">// [1, 2, 3]</span></div><div class=\"line\"></div><div class=\"line\">[...map.values()]</div><div class=\"line\"><span class=\"comment\">// ['one', 'two', 'three']</span></div><div class=\"line\"></div><div class=\"line\">[...map.entries()]</div><div class=\"line\"><span class=\"comment\">// [[1,'one'], [2, 'two'], [3, 'three']]</span></div><div class=\"line\"></div><div class=\"line\">[...map]</div><div class=\"line\"><span class=\"comment\">// [[1,'one'], [2, 'two'], [3, 'three']]</span></div></pre></td></tr></table></figure>\n<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现Map的遍历和过滤（Map本身没有<code>map</code>和<code>filter</code>方法）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map0 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</div><div class=\"line\">  .set(<span class=\"number\">1</span>, <span class=\"string\">'a'</span>)</div><div class=\"line\">  .set(<span class=\"number\">2</span>, <span class=\"string\">'b'</span>)</div><div class=\"line\">  .set(<span class=\"number\">3</span>, <span class=\"string\">'c'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> map1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(</div><div class=\"line\">  [...map0].filter(<span class=\"function\">(<span class=\"params\">[k, v]</span>) =&gt;</span> k &lt; <span class=\"number\">3</span>)</div><div class=\"line\">);</div><div class=\"line\"><span class=\"comment\">// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> map2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(</div><div class=\"line\">  [...map0].map(<span class=\"function\">(<span class=\"params\">[k, v]</span>) =&gt;</span> [k * <span class=\"number\">2</span>, <span class=\"string\">'_'</span> + v])</div><div class=\"line\">    );</div><div class=\"line\"><span class=\"comment\">// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></div></pre></td></tr></table></figure>\n<p>此外，Map还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">map.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, key, map</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Key: %s, Value: %s\"</span>, key, value);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reporter = &#123;</div><div class=\"line\">  <span class=\"attr\">report</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Key: %s, Value: %s\"</span>, key, value);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">map.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, key, map</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.report(key, value);</div><div class=\"line\">&#125;, reporter);</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>\n<h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map转为数组</strong></p>\n<p>前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"literal\">true</span>, <span class=\"number\">7</span>).set(&#123;<span class=\"attr\">foo</span>: <span class=\"number\">3</span>&#125;, [<span class=\"string\">'abc'</span>]);</div><div class=\"line\">[...myMap]</div><div class=\"line\"><span class=\"comment\">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span></div></pre></td></tr></table></figure>\n<p><strong>（2）数组转为Map</strong></p>\n<p>将数组转入Map构造函数，就可以转为Map。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"literal\">true</span>, <span class=\"number\">7</span>], [&#123;<span class=\"attr\">foo</span>: <span class=\"number\">3</span>&#125;, [<span class=\"string\">'abc'</span>]]])</div><div class=\"line\"><span class=\"comment\">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125;</span></div></pre></td></tr></table></figure>\n<p><strong>（3）Map转为对象</strong></p>\n<p>如果所有Map的键都是字符串，它可以转为对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strMapToObj</span>(<span class=\"params\">strMap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [k,v] <span class=\"keyword\">of</span> strMap) &#123;</div><div class=\"line\">    obj[k] = v;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"string\">'yes'</span>, <span class=\"literal\">true</span>).set(<span class=\"string\">'no'</span>, <span class=\"literal\">false</span>);</div><div class=\"line\">strMapToObj(myMap)</div><div class=\"line\"><span class=\"comment\">// &#123; yes: true, no: false &#125;</span></div></pre></td></tr></table></figure>\n<p><strong>（4）对象转为Map</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">objToStrMap</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> strMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.keys(obj)) &#123;</div><div class=\"line\">    strMap.set(k, obj[k]);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> strMap;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">objToStrMap(&#123;<span class=\"attr\">yes</span>: <span class=\"literal\">true</span>, <span class=\"attr\">no</span>: <span class=\"literal\">false</span>&#125;)</div><div class=\"line\"><span class=\"comment\">// [ [ 'yes', true ], [ 'no', false ] ]</span></div></pre></td></tr></table></figure>\n<h2 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h2><p><code>WeakMap</code>结构与<code>Map</code>结构基本类似，唯一的区别是它只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</div><div class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">// TypeError: 1 is not an object!</span></div><div class=\"line\">map.set(<span class=\"built_in\">Symbol</span>(), <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">// TypeError: Invalid value used as weak map key</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果将<code>1</code>和<code>Symbol</code>作为WeakMap的键名，都会报错。</p>\n<p><code>WeakMap</code>的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，<code>WeakMap</code>自动移除对应的键值对。典型应用是，一个对应DOM元素的<code>WeakMap</code>结构，当某个DOM元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。基本上，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>\n<p>下面是<code>WeakMap</code>结构的一个例子，可以看到用法上与<code>Map</code>几乎一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".element\"</span>);</div><div class=\"line\"></div><div class=\"line\">wm.set(element, <span class=\"string\">\"Original\"</span>);</div><div class=\"line\">wm.get(element) <span class=\"comment\">// \"Original\"</span></div><div class=\"line\"></div><div class=\"line\">element.parentNode.removeChild(element);</div><div class=\"line\">element = <span class=\"literal\">null</span>;</div><div class=\"line\">wm.get(element) <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>wm</code>是一个<code>WeakMap</code>实例，我们将一个<code>DOM</code>节点<code>element</code>作为键名，然后销毁这个节点，<code>element</code>对应的键就自动消失了，再引用这个键名就返回<code>undefined</code>。</p>\n<p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有<code>key()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性；二是无法清空，即不支持<code>clear</code>方法。这与<code>WeakMap</code>的键不被计入引用、被垃圾回收机制忽略有关。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"></div><div class=\"line\">wm.size</div><div class=\"line\"><span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\">wm.forEach</div><div class=\"line\"><span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>前文说过，WeakMap应用的典型场合就是DOM节点作为键名。下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> myElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'logo'</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> myWeakmap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"></div><div class=\"line\">myWeakmap.set(myElement, &#123;<span class=\"attr\">timesClicked</span>: <span class=\"number\">0</span>&#125;);</div><div class=\"line\"></div><div class=\"line\">myElement.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> logoData = myWeakmap.get(myElement);</div><div class=\"line\">  logoData.timesClicked++;</div><div class=\"line\">  myWeakmap.set(myElement, logoData);</div><div class=\"line\">&#125;, <span class=\"literal\">false</span>);</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>myElement</code>是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是<code>myElement</code>。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>\n<p>WeakMap的另一个用处是部署私有属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> _counter = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"><span class=\"keyword\">let</span> _action = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Countdown</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(counter, action) &#123;</div><div class=\"line\">    _counter.set(<span class=\"keyword\">this</span>, counter);</div><div class=\"line\">    _action.set(<span class=\"keyword\">this</span>, action);</div><div class=\"line\">  &#125;</div><div class=\"line\">  dec() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> counter = _counter.get(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (counter &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    counter--;</div><div class=\"line\">    _counter.set(<span class=\"keyword\">this</span>, counter);</div><div class=\"line\">    <span class=\"keyword\">if</span> (counter === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      _action.get(<span class=\"keyword\">this</span>)();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> Countdown(<span class=\"number\">2</span>, () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'DONE'</span>));</div><div class=\"line\"></div><div class=\"line\">c.dec()</div><div class=\"line\">c.dec()</div><div class=\"line\"><span class=\"comment\">// DONE</span></div></pre></td></tr></table></figure>\n<p>上面代码中，Countdown类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n<p>Set本身是一个构造函数，用来生成Set数据结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> s.add(x));</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> s) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(i);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 2 3 5 4</span></div></pre></td></tr></table></figure>\n<p>上面代码通过<code>add</code>方法向Set结构加入成员，结果表明Set结构不会添加重复的值。</p>\n<p>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 例一</span></div><div class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</div><div class=\"line\">[...set]</div><div class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 例二</span></div><div class=\"line\"><span class=\"keyword\">var</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>]);</div><div class=\"line\">items.size <span class=\"comment\">// 5</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 例三</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">divs</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [...document.querySelectorAll(<span class=\"string\">'div'</span>)];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(divs());</div><div class=\"line\">set.size <span class=\"comment\">// 56</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 类似于</span></div><div class=\"line\">divs().forEach(<span class=\"function\"><span class=\"params\">div</span> =&gt;</span> set.add(div));</div><div class=\"line\">set.size <span class=\"comment\">// 56</span></div></pre></td></tr></table></figure>\n<p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>\n<p>上面代码中，也展示了一种去除数组重复成员的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 去除数组的重复成员</span></div><div class=\"line\">[...new <span class=\"built_in\">Set</span>(array)]</div></pre></td></tr></table></figure>\n<p>向Set加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"literal\">NaN</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"literal\">NaN</span>;</div><div class=\"line\">set.add(a);</div><div class=\"line\">set.add(b);</div><div class=\"line\">set <span class=\"comment\">// Set &#123;NaN&#125;</span></div></pre></td></tr></table></figure>\n<p>上面代码向Set实例添加了两个<code>NaN</code>，但是只能加入一个。这表明，在Set内部，两个<code>NaN</code>是相等。</p>\n<p>另外，两个对象总是不相等的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">set.add(&#123;&#125;);</div><div class=\"line\">set.size <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\">set.add(&#123;&#125;);</div><div class=\"line\">set.size <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>\n<h3 id=\"Set实例的属性和方法\"><a href=\"#Set实例的属性和方法\" class=\"headerlink\" title=\"Set实例的属性和方法\"></a>Set实例的属性和方法</h3><p>Set结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>\n<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>\n</ul>\n<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>\n<ul>\n<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>\n<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>\n<li><code>clear()</code>：清除所有成员，没有返回值。","more":"上面这些属性和方法的实例如下。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">s.add(<span class=\"number\">1</span>).add(<span class=\"number\">2</span>).add(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"comment\">// 注意2被加入了两次</span></div><div class=\"line\"></div><div class=\"line\">s.size <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\">s.has(<span class=\"number\">1</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// true</span></div><div class=\"line\">s.has(<span class=\"number\">3</span>) <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\">s.delete(<span class=\"number\">2</span>);</div><div class=\"line\">s.has(<span class=\"number\">2</span>) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 对象的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> properties = &#123;</div><div class=\"line\">  <span class=\"string\">'width'</span>: <span class=\"number\">1</span>,</div><div class=\"line\">  <span class=\"string\">'height'</span>: <span class=\"number\">1</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (properties[someName]) &#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set的写法</span></div><div class=\"line\"><span class=\"keyword\">var</span> properties = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\">properties.add(<span class=\"string\">'width'</span>);</div><div class=\"line\">properties.add(<span class=\"string\">'height'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (properties.has(someName)) &#123;</div><div class=\"line\">  <span class=\"comment\">// do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Array.from</code>方法可以将Set结构转为数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</div><div class=\"line\"><span class=\"keyword\">var</span> array = <span class=\"built_in\">Array</span>.from(items);</div></pre></td></tr></table></figure>\n<p>这就提供了去除数组重复成员的另一种方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dedupe</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(array));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">dedupe([<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) <span class=\"comment\">// [1, 2, 3]</span></div></pre></td></tr></table></figure>\n<h3 id=\"遍历操作\"><a href=\"#遍历操作\" class=\"headerlink\" title=\"遍历操作\"></a>遍历操作</h3><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器</li>\n<li><code>values()</code>：返回键值的遍历器</li>\n<li><code>entries()</code>：返回键值对的遍历器</li>\n<li><code>forEach()</code>：使用回调函数遍历每个成员</li>\n</ul>\n<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>\n<p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p>\n<p><code>key</code>方法、<code>value</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator对象》一章）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>key</code>方法和<code>value</code>方法的行为完全一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.keys()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(item);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// red</span></div><div class=\"line\"><span class=\"comment\">// green</span></div><div class=\"line\"><span class=\"comment\">// blue</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.values()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(item);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// red</span></div><div class=\"line\"><span class=\"comment\">// green</span></div><div class=\"line\"><span class=\"comment\">// blue</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.entries()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(item);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// [\"red\", \"red\"]</span></div><div class=\"line\"><span class=\"comment\">// [\"green\", \"green\"]</span></div><div class=\"line\"><span class=\"comment\">// [\"blue\", \"blue\"]</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<p>Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Set</span>.prototype[<span class=\"built_in\">Symbol</span>.iterator] === <span class=\"built_in\">Set</span>.prototype.values</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历Set。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> set) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// red</span></div><div class=\"line\"><span class=\"comment\">// green</span></div><div class=\"line\"><span class=\"comment\">// blue</span></div></pre></td></tr></table></figure>\n<p><strong>（2）<code>forEach()</code></strong></p>\n<p>Set结构的实例的<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">set.forEach(<span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(value * <span class=\"number\">2</span>) )</div><div class=\"line\"><span class=\"comment\">// 2</span></div><div class=\"line\"><span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"comment\">// 6</span></div></pre></td></tr></table></figure>\n<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，<code>forEach</code>方法还可以有第二个参数，表示绑定的this对象。</p>\n<p><strong>（3）遍历的应用</strong></p>\n<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于Set结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'red'</span>, <span class=\"string\">'green'</span>, <span class=\"string\">'blue'</span>]);</div><div class=\"line\"><span class=\"keyword\">let</span> arr = [...set];</div><div class=\"line\"><span class=\"comment\">// ['red', 'green', 'blue']</span></div></pre></td></tr></table></figure>\n<p>扩展运算符和Set结构相结合，就可以去除数组的重复成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> unique = [...new <span class=\"built_in\">Set</span>(arr)];</div><div class=\"line\"><span class=\"comment\">// [3, 5, 2]</span></div></pre></td></tr></table></figure>\n<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以用于Set了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>));</div><div class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4, 6&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</div><div class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> (x % <span class=\"number\">2</span>) == <span class=\"number\">0</span>));</div><div class=\"line\"><span class=\"comment\">// 返回Set结构：&#123;2, 4&#125;</span></div></pre></td></tr></table></figure>\n<p>因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 并集</span></div><div class=\"line\"><span class=\"keyword\">let</span> union = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a, ...b]);</div><div class=\"line\"><span class=\"comment\">// Set &#123;1, 2, 3, 4&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 交集</span></div><div class=\"line\"><span class=\"keyword\">let</span> intersect = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> b.has(x)));</div><div class=\"line\"><span class=\"comment\">// set &#123;2, 3&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 差集</span></div><div class=\"line\"><span class=\"keyword\">let</span> difference = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...a].filter(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !b.has(x)));</div><div class=\"line\"><span class=\"comment\">// Set &#123;1&#125;</span></div></pre></td></tr></table></figure>\n<p>如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用<code>Array.from</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 方法一</span></div><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([...set].map(<span class=\"function\"><span class=\"params\">val</span> =&gt;</span> val * <span class=\"number\">2</span>));</div><div class=\"line\"><span class=\"comment\">// set的值是2, 4, 6</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 方法二</span></div><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</div><div class=\"line\">set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(<span class=\"built_in\">Array</span>.from(set, val =&gt; val * <span class=\"number\">2</span>));</div><div class=\"line\"><span class=\"comment\">// set的值是2, 4, 6</span></div></pre></td></tr></table></figure>\n<p>上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。</p>\n<h2 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h2><p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p>\n<p>首先，<strong>WeakSet的成员只能是对象</strong>，而不能是其他类型的值。</p>\n<p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</div><div class=\"line\">ws.add(<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"comment\">// TypeError: Invalid value used in weak set</span></div><div class=\"line\">ws.add(<span class=\"built_in\">Symbol</span>())</div><div class=\"line\"><span class=\"comment\">// TypeError: invalid value used in weak set</span></div></pre></td></tr></table></figure>\n<p>上面代码试图向WeakSet添加一个数值和<code>Symbol</code>值，结果报错，因为WeakSet只能放置对象。</p>\n<p>WeakSet是一个构造函数，可以使用<code>new</code>命令，创建WeakSet数据结构。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</div></pre></td></tr></table></figure>\n<p>作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>], [<span class=\"number\">3</span>,<span class=\"number\">4</span>]];</div><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>(a);</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为WeakSet构造函数的参数，<code>a</code>的成员会自动成为WeakSet的成员。</p>\n<p>注意，是<code>a</code>数组的成员成为WeakSet的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>(b);</div><div class=\"line\"><span class=\"comment\">// Uncaught TypeError: Invalid value used in weak set(…)</span></div></pre></td></tr></table></figure>\n<p>上面代码中，数组<code>b</code>的成员不是对象，加入WeaKSet就会报错。</p>\n<p>WeakSet结构有以下三个方法。</p>\n<ul>\n<li><strong>WeakSet.prototype.add(value)</strong>：向WeakSet实例添加一个新成员。</li>\n<li><strong>WeakSet.prototype.delete(value)</strong>：清除WeakSet实例的指定成员。</li>\n<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在WeakSet实例之中。</li>\n</ul>\n<p>下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> foo = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.add(<span class=\"built_in\">window</span>);</div><div class=\"line\">ws.add(obj);</div><div class=\"line\"></div><div class=\"line\">ws.has(<span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></div><div class=\"line\">ws.has(foo);    <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\">ws.delete(<span class=\"built_in\">window</span>);</div><div class=\"line\">ws.has(<span class=\"built_in\">window</span>);    <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>WeakSet没有<code>size</code>属性，没有办法遍历它的成员。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ws.size <span class=\"comment\">// undefined</span></div><div class=\"line\">ws.forEach <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\">ws.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'WeakSet has '</span> + item)&#125;)</div><div class=\"line\"><span class=\"comment\">// TypeError: undefined is not a function</span></div></pre></td></tr></table></figure>\n<p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p>\n<p>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<p>下面是WeakSet的另一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> foos = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>()</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    foos.add(<span class=\"keyword\">this</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  method () &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!foos.has(<span class=\"keyword\">this</span>)) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用WeakSet的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"Map结构的目的和基本用法\"><a href=\"#Map结构的目的和基本用法\" class=\"headerlink\" title=\"Map结构的目的和基本用法\"></a>Map结构的目的和基本用法</h3><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> data = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myDiv'</span>);</div><div class=\"line\"></div><div class=\"line\">data[element] = <span class=\"string\">'metadata'</span>;</div><div class=\"line\">data[<span class=\"string\">'[object HTMLDivElement]'</span>] <span class=\"comment\">// \"metadata\"</span></div></pre></td></tr></table></figure>\n<p>上面代码原意是将一个DOM节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>\n<p>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> o = &#123;<span class=\"attr\">p</span>: <span class=\"string\">'Hello World'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">m.set(o, <span class=\"string\">'content'</span>)</div><div class=\"line\">m.get(o) <span class=\"comment\">// \"content\"</span></div><div class=\"line\"></div><div class=\"line\">m.has(o) <span class=\"comment\">// true</span></div><div class=\"line\">m.delete(o) <span class=\"comment\">// true</span></div><div class=\"line\">m.has(o) <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>上面代码使用<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>\n<p>作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"string\">'name'</span>, <span class=\"string\">'张三'</span>],</div><div class=\"line\">  [<span class=\"string\">'title'</span>, <span class=\"string\">'Author'</span>]</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\">map.size <span class=\"comment\">// 2</span></div><div class=\"line\">map.has(<span class=\"string\">'name'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">'name'</span>) <span class=\"comment\">// \"张三\"</span></div><div class=\"line\">map.has(<span class=\"string\">'title'</span>) <span class=\"comment\">// true</span></div><div class=\"line\">map.get(<span class=\"string\">'title'</span>) <span class=\"comment\">// \"Author\"</span></div></pre></td></tr></table></figure>\n<p>上面代码在新建Map实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>\n<p>Map构造函数接受数组作为参数，实际上执行的是下面的算法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> items = [</div><div class=\"line\">  [<span class=\"string\">'name'</span>, <span class=\"string\">'张三'</span>],</div><div class=\"line\">  [<span class=\"string\">'title'</span>, <span class=\"string\">'Author'</span>]</div><div class=\"line\">];</div><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">items.forEach(<span class=\"function\">(<span class=\"params\">[key, value]</span>) =&gt;</span> map.set(key, value));</div></pre></td></tr></table></figure>\n<p>下面的例子中，字符串<code>true</code>和布尔值<code>true</code>是两个不同的键。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"literal\">true</span>, <span class=\"string\">'foo'</span>],</div><div class=\"line\">  [<span class=\"string\">'true'</span>, <span class=\"string\">'bar'</span>]</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\">m.get(<span class=\"literal\">true</span>) <span class=\"comment\">// 'foo'</span></div><div class=\"line\">m.get(<span class=\"string\">'true'</span>) <span class=\"comment\">// 'bar'</span></div></pre></td></tr></table></figure>\n<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">map</div><div class=\"line\">.set(<span class=\"number\">1</span>, <span class=\"string\">'aaa'</span>)</div><div class=\"line\">.set(<span class=\"number\">1</span>, <span class=\"string\">'bbb'</span>);</div><div class=\"line\"></div><div class=\"line\">map.get(<span class=\"number\">1</span>) <span class=\"comment\">// \"bbb\"</span></div></pre></td></tr></table></figure>\n<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>\n<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().get(<span class=\"string\">'asfddfsasadf'</span>)</div><div class=\"line\"><span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">map.set([<span class=\"string\">'a'</span>], <span class=\"number\">555</span>);</div><div class=\"line\">map.get([<span class=\"string\">'a'</span>]) <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>\n<p>同理，同样的值的两个实例，在Map结构中被视为两个键。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> k1 = [<span class=\"string\">'a'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> k2 = [<span class=\"string\">'a'</span>];</div><div class=\"line\"></div><div class=\"line\">map</div><div class=\"line\">.set(k1, <span class=\"number\">111</span>)</div><div class=\"line\">.set(k2, <span class=\"number\">222</span>);</div><div class=\"line\"></div><div class=\"line\">map.get(k1) <span class=\"comment\">// 111</span></div><div class=\"line\">map.get(k2) <span class=\"comment\">// 222</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在Map结构中被视为两个键。</p>\n<p>由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>\n<p>如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括<code>0</code>和<code>-0</code>。另外，虽然<code>NaN</code>不严格相等于自身，但Map将其视为同一个键。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">map.set(<span class=\"literal\">NaN</span>, <span class=\"number\">123</span>);</div><div class=\"line\">map.get(<span class=\"literal\">NaN</span>) <span class=\"comment\">// 123</span></div><div class=\"line\"></div><div class=\"line\">map.set(<span class=\"number\">-0</span>, <span class=\"number\">123</span>);</div><div class=\"line\">map.get(+<span class=\"number\">0</span>) <span class=\"comment\">// 123</span></div></pre></td></tr></table></figure>\n<h3 id=\"实例的属性和操作方法\"><a href=\"#实例的属性和操作方法\" class=\"headerlink\" title=\"实例的属性和操作方法\"></a>实例的属性和操作方法</h3><p>Map结构的实例有以下属性和操作方法。</p>\n<p><strong>（1）size属性</strong></p>\n<p><code>size</code>属性返回Map结构的成员总数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">map.set(<span class=\"string\">'foo'</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">map.set(<span class=\"string\">'bar'</span>, <span class=\"literal\">false</span>);</div><div class=\"line\"></div><div class=\"line\">map.size <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p><strong>（2）set(key, value)</strong></p>\n<p><code>set</code>方法设置<code>key</code>所对应的键值，然后返回整个Map结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">m.set(<span class=\"string\">\"edition\"</span>, <span class=\"number\">6</span>)        <span class=\"comment\">// 键是字符串</span></div><div class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">\"standard\"</span>)     <span class=\"comment\">// 键是数值</span></div><div class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">\"nah\"</span>)    <span class=\"comment\">// 键是undefined</span></div></pre></td></tr></table></figure>\n<p><code>set</code>方法返回的是Map本身，因此可以采用链式写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</div><div class=\"line\">  .set(<span class=\"number\">1</span>, <span class=\"string\">'a'</span>)</div><div class=\"line\">  .set(<span class=\"number\">2</span>, <span class=\"string\">'b'</span>)</div><div class=\"line\">  .set(<span class=\"number\">3</span>, <span class=\"string\">'c'</span>);</div></pre></td></tr></table></figure>\n<p><strong>（3）get(key)</strong></p>\n<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> hello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);&#125;</div><div class=\"line\">m.set(hello, <span class=\"string\">\"Hello ES6!\"</span>) <span class=\"comment\">// 键是函数</span></div><div class=\"line\"></div><div class=\"line\">m.get(hello)  <span class=\"comment\">// Hello ES6!</span></div></pre></td></tr></table></figure>\n<p><strong>（4）has(key)</strong></p>\n<p><code>has</code>方法返回一个布尔值，表示某个键是否在Map数据结构中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\">m.set(<span class=\"string\">\"edition\"</span>, <span class=\"number\">6</span>);</div><div class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">\"standard\"</span>);</div><div class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">\"nah\"</span>);</div><div class=\"line\"></div><div class=\"line\">m.has(<span class=\"string\">\"edition\"</span>)     <span class=\"comment\">// true</span></div><div class=\"line\">m.has(<span class=\"string\">\"years\"</span>)       <span class=\"comment\">// false</span></div><div class=\"line\">m.has(<span class=\"number\">262</span>)           <span class=\"comment\">// true</span></div><div class=\"line\">m.has(<span class=\"literal\">undefined</span>)     <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p><strong>（5）delete(key)</strong></p>\n<p><code>delete</code>方法删除某个键，返回true。如果删除失败，返回false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">\"nah\"</span>);</div><div class=\"line\">m.has(<span class=\"literal\">undefined</span>)     <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\">m.delete(<span class=\"literal\">undefined</span>)</div><div class=\"line\">m.has(<span class=\"literal\">undefined</span>)       <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p><strong>（6）clear()</strong></p>\n<p><code>clear</code>方法清除所有成员，没有返回值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">map.set(<span class=\"string\">'foo'</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">map.set(<span class=\"string\">'bar'</span>, <span class=\"literal\">false</span>);</div><div class=\"line\"></div><div class=\"line\">map.size <span class=\"comment\">// 2</span></div><div class=\"line\">map.clear()</div><div class=\"line\">map.size <span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>\n<ul>\n<li><code>keys()</code>：返回键名的遍历器。</li>\n<li><code>values()</code>：返回键值的遍历器。</li>\n<li><code>entries()</code>：返回所有成员的遍历器。</li>\n<li><code>forEach()</code>：遍历Map的所有成员。</li>\n</ul>\n<p>需要特别注意的是，Map的遍历顺序就是插入顺序。</p>\n<p>下面是使用实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"string\">'F'</span>, <span class=\"string\">'no'</span>],</div><div class=\"line\">  [<span class=\"string\">'T'</span>,  <span class=\"string\">'yes'</span>],</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">of</span> map.keys()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(key);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// \"F\"</span></div><div class=\"line\"><span class=\"comment\">// \"T\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> map.values()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(value);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// \"no\"</span></div><div class=\"line\"><span class=\"comment\">// \"yes\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> map.entries()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(item[<span class=\"number\">0</span>], item[<span class=\"number\">1</span>]);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// \"F\" \"no\"</span></div><div class=\"line\"><span class=\"comment\">// \"T\" \"yes\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或者</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map.entries()) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于使用map.entries()</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码最后的那个例子，表示Map结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">map[<span class=\"built_in\">Symbol</span>.iterator] === map.entries</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（<code>...</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</div><div class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>],</div><div class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'two'</span>],</div><div class=\"line\">  [<span class=\"number\">3</span>, <span class=\"string\">'three'</span>],</div><div class=\"line\">]);</div><div class=\"line\"></div><div class=\"line\">[...map.keys()]</div><div class=\"line\"><span class=\"comment\">// [1, 2, 3]</span></div><div class=\"line\"></div><div class=\"line\">[...map.values()]</div><div class=\"line\"><span class=\"comment\">// ['one', 'two', 'three']</span></div><div class=\"line\"></div><div class=\"line\">[...map.entries()]</div><div class=\"line\"><span class=\"comment\">// [[1,'one'], [2, 'two'], [3, 'three']]</span></div><div class=\"line\"></div><div class=\"line\">[...map]</div><div class=\"line\"><span class=\"comment\">// [[1,'one'], [2, 'two'], [3, 'three']]</span></div></pre></td></tr></table></figure>\n<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现Map的遍历和过滤（Map本身没有<code>map</code>和<code>filter</code>方法）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> map0 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</div><div class=\"line\">  .set(<span class=\"number\">1</span>, <span class=\"string\">'a'</span>)</div><div class=\"line\">  .set(<span class=\"number\">2</span>, <span class=\"string\">'b'</span>)</div><div class=\"line\">  .set(<span class=\"number\">3</span>, <span class=\"string\">'c'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> map1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(</div><div class=\"line\">  [...map0].filter(<span class=\"function\">(<span class=\"params\">[k, v]</span>) =&gt;</span> k &lt; <span class=\"number\">3</span>)</div><div class=\"line\">);</div><div class=\"line\"><span class=\"comment\">// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> map2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(</div><div class=\"line\">  [...map0].map(<span class=\"function\">(<span class=\"params\">[k, v]</span>) =&gt;</span> [k * <span class=\"number\">2</span>, <span class=\"string\">'_'</span> + v])</div><div class=\"line\">    );</div><div class=\"line\"><span class=\"comment\">// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125;</span></div></pre></td></tr></table></figure>\n<p>此外，Map还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">map.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, key, map</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Key: %s, Value: %s\"</span>, key, value);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reporter = &#123;</div><div class=\"line\">  <span class=\"attr\">report</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Key: %s, Value: %s\"</span>, key, value);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">map.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, key, map</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.report(key, value);</div><div class=\"line\">&#125;, reporter);</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>\n<h3 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map转为数组</strong></p>\n<p>前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"literal\">true</span>, <span class=\"number\">7</span>).set(&#123;<span class=\"attr\">foo</span>: <span class=\"number\">3</span>&#125;, [<span class=\"string\">'abc'</span>]);</div><div class=\"line\">[...myMap]</div><div class=\"line\"><span class=\"comment\">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ]</span></div></pre></td></tr></table></figure>\n<p><strong>（2）数组转为Map</strong></p>\n<p>将数组转入Map构造函数，就可以转为Map。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"literal\">true</span>, <span class=\"number\">7</span>], [&#123;<span class=\"attr\">foo</span>: <span class=\"number\">3</span>&#125;, [<span class=\"string\">'abc'</span>]]])</div><div class=\"line\"><span class=\"comment\">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125;</span></div></pre></td></tr></table></figure>\n<p><strong>（3）Map转为对象</strong></p>\n<p>如果所有Map的键都是字符串，它可以转为对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strMapToObj</span>(<span class=\"params\">strMap</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [k,v] <span class=\"keyword\">of</span> strMap) &#123;</div><div class=\"line\">    obj[k] = v;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>().set(<span class=\"string\">'yes'</span>, <span class=\"literal\">true</span>).set(<span class=\"string\">'no'</span>, <span class=\"literal\">false</span>);</div><div class=\"line\">strMapToObj(myMap)</div><div class=\"line\"><span class=\"comment\">// &#123; yes: true, no: false &#125;</span></div></pre></td></tr></table></figure>\n<p><strong>（4）对象转为Map</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">objToStrMap</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> strMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.keys(obj)) &#123;</div><div class=\"line\">    strMap.set(k, obj[k]);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> strMap;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">objToStrMap(&#123;<span class=\"attr\">yes</span>: <span class=\"literal\">true</span>, <span class=\"attr\">no</span>: <span class=\"literal\">false</span>&#125;)</div><div class=\"line\"><span class=\"comment\">// [ [ 'yes', true ], [ 'no', false ] ]</span></div></pre></td></tr></table></figure>\n<h2 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h2><p><code>WeakMap</code>结构与<code>Map</code>结构基本类似，唯一的区别是它只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</div><div class=\"line\">map.set(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">// TypeError: 1 is not an object!</span></div><div class=\"line\">map.set(<span class=\"built_in\">Symbol</span>(), <span class=\"number\">2</span>)</div><div class=\"line\"><span class=\"comment\">// TypeError: Invalid value used as weak map key</span></div></pre></td></tr></table></figure>\n<p>上面代码中，如果将<code>1</code>和<code>Symbol</code>作为WeakMap的键名，都会报错。</p>\n<p><code>WeakMap</code>的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，<code>WeakMap</code>自动移除对应的键值对。典型应用是，一个对应DOM元素的<code>WeakMap</code>结构，当某个DOM元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。基本上，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>\n<p>下面是<code>WeakMap</code>结构的一个例子，可以看到用法上与<code>Map</code>几乎一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"><span class=\"keyword\">var</span> element = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\".element\"</span>);</div><div class=\"line\"></div><div class=\"line\">wm.set(element, <span class=\"string\">\"Original\"</span>);</div><div class=\"line\">wm.get(element) <span class=\"comment\">// \"Original\"</span></div><div class=\"line\"></div><div class=\"line\">element.parentNode.removeChild(element);</div><div class=\"line\">element = <span class=\"literal\">null</span>;</div><div class=\"line\">wm.get(element) <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>上面代码中，变量<code>wm</code>是一个<code>WeakMap</code>实例，我们将一个<code>DOM</code>节点<code>element</code>作为键名，然后销毁这个节点，<code>element</code>对应的键就自动消失了，再引用这个键名就返回<code>undefined</code>。</p>\n<p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有<code>key()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性；二是无法清空，即不支持<code>clear</code>方法。这与<code>WeakMap</code>的键不被计入引用、被垃圾回收机制忽略有关。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> wm = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"></div><div class=\"line\">wm.size</div><div class=\"line\"><span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\">wm.forEach</div><div class=\"line\"><span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>前文说过，WeakMap应用的典型场合就是DOM节点作为键名。下面是一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> myElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'logo'</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> myWeakmap = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"></div><div class=\"line\">myWeakmap.set(myElement, &#123;<span class=\"attr\">timesClicked</span>: <span class=\"number\">0</span>&#125;);</div><div class=\"line\"></div><div class=\"line\">myElement.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> logoData = myWeakmap.get(myElement);</div><div class=\"line\">  logoData.timesClicked++;</div><div class=\"line\">  myWeakmap.set(myElement, logoData);</div><div class=\"line\">&#125;, <span class=\"literal\">false</span>);</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>myElement</code>是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是<code>myElement</code>。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。</p>\n<p>WeakMap的另一个用处是部署私有属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> _counter = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"><span class=\"keyword\">let</span> _action = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Countdown</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(counter, action) &#123;</div><div class=\"line\">    _counter.set(<span class=\"keyword\">this</span>, counter);</div><div class=\"line\">    _action.set(<span class=\"keyword\">this</span>, action);</div><div class=\"line\">  &#125;</div><div class=\"line\">  dec() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> counter = _counter.get(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (counter &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</div><div class=\"line\">    counter--;</div><div class=\"line\">    _counter.set(<span class=\"keyword\">this</span>, counter);</div><div class=\"line\">    <span class=\"keyword\">if</span> (counter === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      _action.get(<span class=\"keyword\">this</span>)();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> Countdown(<span class=\"number\">2</span>, () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'DONE'</span>));</div><div class=\"line\"></div><div class=\"line\">c.dec()</div><div class=\"line\">c.dec()</div><div class=\"line\"><span class=\"comment\">// DONE</span></div></pre></td></tr></table></figure>\n<p>上面代码中，Countdown类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>"},{"title":"ES2015的尾调用优化","date":"2016-11-01T08:56:50.000Z","_content":"\n## 尾调用优化\n\n### 什么是尾调用？\n\n尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\n```javascript\nfunction f(x){\n  return g(x);\n}\n```\n\n上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。\n\n以下三种情况，都不属于尾调用。\n\n```javascript\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n```\n\n上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。\n\n```javascript\nfunction f(x){\n  g(x);\n  return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n\n```javascript\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n\n上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。\n<!--more-->\n### 尾调用优化\n\n尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n\n我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\n```javascript\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n```\n\n上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。\n\n这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n\n```javascript\nfunction addOne(a){\n  var one = 1;\n  function inner(b){\n    return b + one;\n  }\n  return inner(a);\n}\n```\n\n上面的函数不会进行尾调用优化，因为内层函数`inner`用到了外层函数`addOne`的内部变量`one`。\n\n### 尾递归\n\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n```javascript\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n```\n\n上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n\n```javascript\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1) // 120\n```\n\n还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性\n\n如果是非尾递归的fibonacci 递归方法\n\n```javascript\nfunction Fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nFibonacci(10); // 89\n// Fibonacci(100)\n// Fibonacci(500)\n// 堆栈溢出了\n```\n\n如果我们使用尾递归优化过的fibonacci 递归算法\n\n```javascript\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n <= 1 ) {return ac2};\n\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n}\n\nFibonacci2(100) // 573147844013817200000\nFibonacci2(1000) // 7.0330367711422765e+208\nFibonacci2(10000) // Infinity\n```\n\n由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。\n\n### 递归函数的改写\n\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？\n\n两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。\n\n```javascript\nfunction tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nfunction factorial(n) {\n  return tailFactorial(n, 1);\n}\n\nfactorial(5) // 120\n```\n\n上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。\n\n函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。\n\n```javascript\nfunction currying(fn, n) {\n  return function (m) {\n    return fn.call(this, m, n);\n  };\n}\n\nfunction tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nconst factorial = currying(tailFactorial, 1);\n\nfactorial(5) // 120\n```\n\n上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。\n\n第二种方法就简单多了，就是采用ES6的函数默认值。\n\n```javascript\nfunction factorial(n, total = 1) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n```\n\n上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。\n\n总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。\n\n### 严格模式\n\nES6的尾调用优化只在严格模式下开启，正常模式是无效的。\n\n这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。\n\n- `func.arguments`：返回调用时函数的参数。\n- `func.caller`：返回调用当前函数的那个函数。\n\n尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。\n\n```javascript\nfunction restricted() {\n  \"use strict\";\n  restricted.caller;    // 报错\n  restricted.arguments; // 报错\n}\nrestricted();\n```\n\n### 尾递归优化的实现\n\n尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。\n\n它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。\n\n下面是一个正常的递归函数。\n\n```javascript\nfunction sum(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n\nsum(1, 100000)\n// Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n上面代码中，`sum`是一个递归函数，参数`x`是需要累加的值，参数`y`控制递归次数。一旦指定`sum`递归100000次，就会报错，提示超出调用栈的最大次数。\n\n蹦床函数（trampoline）可以将递归执行转为循环执行。\n\n```javascript\nfunction trampoline(f) {\n  while (f && f instanceof Function) {\n    f = f();\n  }\n  return f;\n}\n```\n\n上面就是蹦床函数的一个实现，它接受一个函数`f`作为参数。只要`f`执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。\n\n然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。\n\n```javascript\nfunction sum(x, y) {\n  if (y > 0) {\n    return sum.bind(null, x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n```\n\n上面代码中，`sum`函数的每次执行，都会返回自身的另一个版本。\n\n现在，使用蹦床函数执行`sum`，就不会发生调用栈溢出。\n\n```javascript\ntrampoline(sum(1, 100000))\n// 100001\n```\n\n蹦床函数并不是真正的尾递归优化，下面的实现才是。\n\n```javascript\nfunction tco(f) {\n  var value;\n  var active = false;\n  var accumulated = [];\n\n  return function accumulator() {\n    accumulated.push(arguments);\n    if (!active) {\n      active = true;\n      while (accumulated.length) {\n        value = f.apply(this, accumulated.shift());\n      }\n      active = false;\n      return value;\n    }\n  };\n}\n\nvar sum = tco(function(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1)\n  }\n  else {\n    return x\n  }\n});\n\nsum(1, 100000)\n// 100001\n```\n\n上面代码中，`tco`函数是尾递归优化的实现，它的奥妙就在于状态变量`active`。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归`sum`返回的都是`undefined`，所以就避免了递归执行；而`accumulated`数组存放每一轮`sum`执行的参数，总是有值的，这就保证了`accumulator`函数内部的`while`循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。\n\n","source":"_posts/ES2015的尾调用优化.md","raw":"---\ntitle: ES2015的尾调用优化\ndate: 2016-11-01 16:56:50\ntags: ES2015\n---\n\n## 尾调用优化\n\n### 什么是尾调用？\n\n尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n\n```javascript\nfunction f(x){\n  return g(x);\n}\n```\n\n上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。\n\n以下三种情况，都不属于尾调用。\n\n```javascript\n// 情况一\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三\nfunction f(x){\n  g(x);\n}\n```\n\n上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。\n\n```javascript\nfunction f(x){\n  g(x);\n  return undefined;\n}\n```\n\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n\n```javascript\nfunction f(x) {\n  if (x > 0) {\n    return m(x)\n  }\n  return n(x);\n}\n```\n\n上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。\n<!--more-->\n### 尾调用优化\n\n尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n\n我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\n```javascript\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n```\n\n上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。\n\n这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。\n\n注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。\n\n```javascript\nfunction addOne(a){\n  var one = 1;\n  function inner(b){\n    return b + one;\n  }\n  return inner(a);\n}\n```\n\n上面的函数不会进行尾调用优化，因为内层函数`inner`用到了外层函数`addOne`的内部变量`one`。\n\n### 尾递归\n\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n```javascript\nfunction factorial(n) {\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfactorial(5) // 120\n```\n\n上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n\n```javascript\nfunction factorial(n, total) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5, 1) // 120\n```\n\n还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性\n\n如果是非尾递归的fibonacci 递归方法\n\n```javascript\nfunction Fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nFibonacci(10); // 89\n// Fibonacci(100)\n// Fibonacci(500)\n// 堆栈溢出了\n```\n\n如果我们使用尾递归优化过的fibonacci 递归算法\n\n```javascript\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n <= 1 ) {return ac2};\n\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n}\n\nFibonacci2(100) // 573147844013817200000\nFibonacci2(1000) // 7.0330367711422765e+208\nFibonacci2(10000) // Infinity\n```\n\n由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。\n\n### 递归函数的改写\n\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？\n\n两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。\n\n```javascript\nfunction tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nfunction factorial(n) {\n  return tailFactorial(n, 1);\n}\n\nfactorial(5) // 120\n```\n\n上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。\n\n函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。\n\n```javascript\nfunction currying(fn, n) {\n  return function (m) {\n    return fn.call(this, m, n);\n  };\n}\n\nfunction tailFactorial(n, total) {\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n}\n\nconst factorial = currying(tailFactorial, 1);\n\nfactorial(5) // 120\n```\n\n上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。\n\n第二种方法就简单多了，就是采用ES6的函数默认值。\n\n```javascript\nfunction factorial(n, total = 1) {\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n}\n\nfactorial(5) // 120\n```\n\n上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。\n\n总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。\n\n### 严格模式\n\nES6的尾调用优化只在严格模式下开启，正常模式是无效的。\n\n这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。\n\n- `func.arguments`：返回调用时函数的参数。\n- `func.caller`：返回调用当前函数的那个函数。\n\n尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。\n\n```javascript\nfunction restricted() {\n  \"use strict\";\n  restricted.caller;    // 报错\n  restricted.arguments; // 报错\n}\nrestricted();\n```\n\n### 尾递归优化的实现\n\n尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。\n\n它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。\n\n下面是一个正常的递归函数。\n\n```javascript\nfunction sum(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n\nsum(1, 100000)\n// Uncaught RangeError: Maximum call stack size exceeded(…)\n```\n\n上面代码中，`sum`是一个递归函数，参数`x`是需要累加的值，参数`y`控制递归次数。一旦指定`sum`递归100000次，就会报错，提示超出调用栈的最大次数。\n\n蹦床函数（trampoline）可以将递归执行转为循环执行。\n\n```javascript\nfunction trampoline(f) {\n  while (f && f instanceof Function) {\n    f = f();\n  }\n  return f;\n}\n```\n\n上面就是蹦床函数的一个实现，它接受一个函数`f`作为参数。只要`f`执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。\n\n然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。\n\n```javascript\nfunction sum(x, y) {\n  if (y > 0) {\n    return sum.bind(null, x + 1, y - 1);\n  } else {\n    return x;\n  }\n}\n```\n\n上面代码中，`sum`函数的每次执行，都会返回自身的另一个版本。\n\n现在，使用蹦床函数执行`sum`，就不会发生调用栈溢出。\n\n```javascript\ntrampoline(sum(1, 100000))\n// 100001\n```\n\n蹦床函数并不是真正的尾递归优化，下面的实现才是。\n\n```javascript\nfunction tco(f) {\n  var value;\n  var active = false;\n  var accumulated = [];\n\n  return function accumulator() {\n    accumulated.push(arguments);\n    if (!active) {\n      active = true;\n      while (accumulated.length) {\n        value = f.apply(this, accumulated.shift());\n      }\n      active = false;\n      return value;\n    }\n  };\n}\n\nvar sum = tco(function(x, y) {\n  if (y > 0) {\n    return sum(x + 1, y - 1)\n  }\n  else {\n    return x\n  }\n});\n\nsum(1, 100000)\n// 100001\n```\n\n上面代码中，`tco`函数是尾递归优化的实现，它的奥妙就在于状态变量`active`。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归`sum`返回的都是`undefined`，所以就避免了递归执行；而`accumulated`数组存放每一轮`sum`执行的参数，总是有值的，这就保证了`accumulator`函数内部的`while`循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。\n\n","slug":"ES2015的尾调用优化","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfce000kzk4obsbifanh","content":"<h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><h3 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h3><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> g(x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</p>\n<p>以下三种情况，都不属于尾调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 情况一</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> y = g(x);</div><div class=\"line\">  <span class=\"keyword\">return</span> y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 情况二</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> g(x) + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 情况三</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  g(x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  g(x);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> m(x)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> n(x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。<br><a id=\"more\"></a></p>\n<h3 id=\"尾调用优化-1\"><a href=\"#尾调用优化-1\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h3><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>\n<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>\n<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> g(m + n);</div><div class=\"line\">&#125;</div><div class=\"line\">f();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> g(<span class=\"number\">3</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">f();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\">g(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p>\n<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>\n<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addOne</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> one = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\">b</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> b + one;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> inner(a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>\n<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>, <span class=\"number\">1</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性</p>\n<p>如果是非尾递归的fibonacci 递归方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci</span> (<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> ( n &lt;= <span class=\"number\">1</span> ) &#123;<span class=\"keyword\">return</span> <span class=\"number\">1</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> Fibonacci(n - <span class=\"number\">1</span>) + Fibonacci(n - <span class=\"number\">2</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Fibonacci(<span class=\"number\">10</span>); <span class=\"comment\">// 89</span></div><div class=\"line\"><span class=\"comment\">// Fibonacci(100)</span></div><div class=\"line\"><span class=\"comment\">// Fibonacci(500)</span></div><div class=\"line\"><span class=\"comment\">// 堆栈溢出了</span></div></pre></td></tr></table></figure>\n<p>如果我们使用尾递归优化过的fibonacci 递归算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci2</span> (<span class=\"params\">n , ac1 = <span class=\"number\">1</span> , ac2 = <span class=\"number\">1</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>( n &lt;= <span class=\"number\">1</span> ) &#123;<span class=\"keyword\">return</span> ac2&#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> Fibonacci2 (n - <span class=\"number\">1</span>, ac2, ac1 + ac2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Fibonacci2(<span class=\"number\">100</span>) <span class=\"comment\">// 573147844013817200000</span></div><div class=\"line\">Fibonacci2(<span class=\"number\">1000</span>) <span class=\"comment\">// 7.0330367711422765e+208</span></div><div class=\"line\">Fibonacci2(<span class=\"number\">10000</span>) <span class=\"comment\">// Infinity</span></div></pre></td></tr></table></figure>\n<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n<h3 id=\"递归函数的改写\"><a href=\"#递归函数的改写\" class=\"headerlink\" title=\"递归函数的改写\"></a>递归函数的改写</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>\n<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailFactorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n, <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。</p>\n<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn, n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fn.call(<span class=\"keyword\">this</span>, m, n);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailFactorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> factorial = currying(tailFactorial, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。</p>\n<p>第二种方法就简单多了，就是采用ES6的函数默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total = <span class=\"number\">1</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。</p>\n<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>\n<h3 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h3><p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p>\n<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>\n<ul>\n<li><code>func.arguments</code>：返回调用时函数的参数。</li>\n<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>\n</ul>\n<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">restricted</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</div><div class=\"line\">  restricted.caller;    <span class=\"comment\">// 报错</span></div><div class=\"line\">  restricted.arguments; <span class=\"comment\">// 报错</span></div><div class=\"line\">&#125;</div><div class=\"line\">restricted();</div></pre></td></tr></table></figure>\n<h3 id=\"尾递归优化的实现\"><a href=\"#尾递归优化的实现\" class=\"headerlink\" title=\"尾递归优化的实现\"></a>尾递归优化的实现</h3><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>\n<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>\n<p>下面是一个正常的递归函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (y &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum(x + <span class=\"number\">1</span>, y - <span class=\"number\">1</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">100000</span>)</div><div class=\"line\"><span class=\"comment\">// Uncaught RangeError: Maximum call stack size exceeded(…)</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归100000次，就会报错，提示超出调用栈的最大次数。</p>\n<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trampoline</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">while</span> (f &amp;&amp; f <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>) &#123;</div><div class=\"line\">    f = f();</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> f;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>\n<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (y &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum.bind(<span class=\"literal\">null</span>, x + <span class=\"number\">1</span>, y - <span class=\"number\">1</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>\n<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">trampoline(sum(<span class=\"number\">1</span>, <span class=\"number\">100000</span>))</div><div class=\"line\"><span class=\"comment\">// 100001</span></div></pre></td></tr></table></figure>\n<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tco</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> value;</div><div class=\"line\">  <span class=\"keyword\">var</span> active = <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> accumulated = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">accumulator</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    accumulated.push(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!active) &#123;</div><div class=\"line\">      active = <span class=\"literal\">true</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span> (accumulated.length) &#123;</div><div class=\"line\">        value = f.apply(<span class=\"keyword\">this</span>, accumulated.shift());</div><div class=\"line\">      &#125;</div><div class=\"line\">      active = <span class=\"literal\">false</span>;</div><div class=\"line\">      <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum = tco(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (y &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum(x + <span class=\"number\">1</span>, y - <span class=\"number\">1</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">100000</span>)</div><div class=\"line\"><span class=\"comment\">// 100001</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><h3 id=\"什么是尾调用？\"><a href=\"#什么是尾调用？\" class=\"headerlink\" title=\"什么是尾调用？\"></a>什么是尾调用？</h3><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> g(x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</p>\n<p>以下三种情况，都不属于尾调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 情况一</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> y = g(x);</div><div class=\"line\">  <span class=\"keyword\">return</span> y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 情况二</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> g(x) + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 情况三</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  g(x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">  g(x);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> m(x)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> n(x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。<br>","more":"</p>\n<h3 id=\"尾调用优化-1\"><a href=\"#尾调用优化-1\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h3><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>\n<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>\n<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> g(m + n);</div><div class=\"line\">&#125;</div><div class=\"line\">f();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> g(<span class=\"number\">3</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">f();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\">g(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure>\n<p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p>\n<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>\n<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addOne</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> one = <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span>(<span class=\"params\">b</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> b + one;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> inner(a);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>\n<h3 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>\n<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>, <span class=\"number\">1</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性</p>\n<p>如果是非尾递归的fibonacci 递归方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci</span> (<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> ( n &lt;= <span class=\"number\">1</span> ) &#123;<span class=\"keyword\">return</span> <span class=\"number\">1</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> Fibonacci(n - <span class=\"number\">1</span>) + Fibonacci(n - <span class=\"number\">2</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Fibonacci(<span class=\"number\">10</span>); <span class=\"comment\">// 89</span></div><div class=\"line\"><span class=\"comment\">// Fibonacci(100)</span></div><div class=\"line\"><span class=\"comment\">// Fibonacci(500)</span></div><div class=\"line\"><span class=\"comment\">// 堆栈溢出了</span></div></pre></td></tr></table></figure>\n<p>如果我们使用尾递归优化过的fibonacci 递归算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fibonacci2</span> (<span class=\"params\">n , ac1 = <span class=\"number\">1</span> , ac2 = <span class=\"number\">1</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>( n &lt;= <span class=\"number\">1</span> ) &#123;<span class=\"keyword\">return</span> ac2&#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> Fibonacci2 (n - <span class=\"number\">1</span>, ac2, ac1 + ac2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Fibonacci2(<span class=\"number\">100</span>) <span class=\"comment\">// 573147844013817200000</span></div><div class=\"line\">Fibonacci2(<span class=\"number\">1000</span>) <span class=\"comment\">// 7.0330367711422765e+208</span></div><div class=\"line\">Fibonacci2(<span class=\"number\">10000</span>) <span class=\"comment\">// Infinity</span></div></pre></td></tr></table></figure>\n<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n<h3 id=\"递归函数的改写\"><a href=\"#递归函数的改写\" class=\"headerlink\" title=\"递归函数的改写\"></a>递归函数的改写</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>\n<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailFactorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n, <span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。</p>\n<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn, n</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">m</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fn.call(<span class=\"keyword\">this</span>, m, n);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailFactorial</span>(<span class=\"params\">n, total</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> factorial = currying(tailFactorial, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。</p>\n<p>第二种方法就简单多了，就是采用ES6的函数默认值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total = <span class=\"number\">1</span></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">// 120</span></div></pre></td></tr></table></figure>\n<p>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。</p>\n<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>\n<h3 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h3><p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。</p>\n<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>\n<ul>\n<li><code>func.arguments</code>：返回调用时函数的参数。</li>\n<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>\n</ul>\n<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">restricted</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">  \"use strict\"</span>;</div><div class=\"line\">  restricted.caller;    <span class=\"comment\">// 报错</span></div><div class=\"line\">  restricted.arguments; <span class=\"comment\">// 报错</span></div><div class=\"line\">&#125;</div><div class=\"line\">restricted();</div></pre></td></tr></table></figure>\n<h3 id=\"尾递归优化的实现\"><a href=\"#尾递归优化的实现\" class=\"headerlink\" title=\"尾递归优化的实现\"></a>尾递归优化的实现</h3><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>\n<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>\n<p>下面是一个正常的递归函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (y &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum(x + <span class=\"number\">1</span>, y - <span class=\"number\">1</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">100000</span>)</div><div class=\"line\"><span class=\"comment\">// Uncaught RangeError: Maximum call stack size exceeded(…)</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归100000次，就会报错，提示超出调用栈的最大次数。</p>\n<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trampoline</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">while</span> (f &amp;&amp; f <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>) &#123;</div><div class=\"line\">    f = f();</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> f;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>\n<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (y &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum.bind(<span class=\"literal\">null</span>, x + <span class=\"number\">1</span>, y - <span class=\"number\">1</span>);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>\n<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">trampoline(sum(<span class=\"number\">1</span>, <span class=\"number\">100000</span>))</div><div class=\"line\"><span class=\"comment\">// 100001</span></div></pre></td></tr></table></figure>\n<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tco</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> value;</div><div class=\"line\">  <span class=\"keyword\">var</span> active = <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> accumulated = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">accumulator</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    accumulated.push(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!active) &#123;</div><div class=\"line\">      active = <span class=\"literal\">true</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span> (accumulated.length) &#123;</div><div class=\"line\">        value = f.apply(<span class=\"keyword\">this</span>, accumulated.shift());</div><div class=\"line\">      &#125;</div><div class=\"line\">      active = <span class=\"literal\">false</span>;</div><div class=\"line\">      <span class=\"keyword\">return</span> value;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> sum = tco(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (y &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum(x + <span class=\"number\">1</span>, y - <span class=\"number\">1</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">sum(<span class=\"number\">1</span>, <span class=\"number\">100000</span>)</div><div class=\"line\"><span class=\"comment\">// 100001</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>"},{"title":"ES2015的模块化","date":"2016-11-09T02:26:59.000Z","_content":"\n# Module\n\nES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。\n\n历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的`require`、Python的`import`，甚至就连CSS都有`@import`，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\n\n在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。\n\nES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。\n\n```javascript\n// CommonJS模块\nlet { stat, exists, readFile } = require('fs');\n\n// 等同于\nlet _fs = require('fs');\nlet stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;\n```\n\n上面代码的实质是整体加载`fs`模块（即加载`fs`的所有方法），生成一个对象（`_fs`），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\n\nES6模块不是对象，而是通过`export`命令显式指定输出的代码，输入时也采用静态命令的形式。\n\n```javascript\n// ES6模块\nimport { stat, exists, readFile } from 'fs';\n```\n\n上面代码的实质是从`fs`模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。\n\n由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。\n\n除了静态加载带来的各种好处，ES6模块还有以下好处。\n\n- 不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。\n- 将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者`navigator`对象的属性。\n- 不再需要对象作为命名空间（比如`Math`对象），未来这些功能可以通过模块提供。\n\n浏览器使用ES6模块的语法如下。\n\n```html\n<script type=\"module\" src=\"foo.js\"></script>\n```\n\n上面代码在网页中插入一个模块`foo.js`，由于`type`属性设为`module`，所以浏览器知道这是一个ES6模块。\n\nNode的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。\n\nES6的模块自动采用严格模式，不管你有没有在模块头部加上`\"use strict\";`。\n<!--more-->\n\n## export命令\n\n模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。下面是一个JS文件，里面使用`export`命令输出变量。\n\n```javascript\n// profile.js\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n```\n\n上面代码是`profile.js`文件，保存了用户信息。ES6将其视为一个模块，里面用`export`命令对外部输出了三个变量。\n\n`export`的写法，除了像上面这样，还有另外一种。\n\n```javascript\n// profile.js\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n```\n\n上面代码在`export`命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在`var`语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。\n\nexport命令除了输出变量，还可以输出函数或类（class）。\n\n```javascript\nexport function multiply(x, y) {\n  return x * y;\n};\n```\n\n上面代码对外输出一个函数`multiply`。\n\n通常情况下，`export`输出的变量就是本来的名字，但是可以使用`as`关键字重命名。\n\n```javascript\nfunction v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n```\n\n上面代码使用`as`关键字，重命名了函数`v1`和`v2`的对外接口。重命名后，`v2`可以用不同的名字输出两次。\n\n需要特别注意的是，`export`命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\n\n```javascript\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n```\n\n上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量`m`，还是直接输出1。`1`只是一个值，不是接口。正确的写法是下面这样。\n\n```javascript\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n```\n\n上面三种写法都是正确的，规定了对外的接口`m`。其他脚本可以通过这个接口，取到值`1`。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。\n\n同样的，`function`和`class`的输出，也必须遵守这样的写法。\n\n```javascript\n// 报错\nfunction f() {}\nexport f;\n\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n```\n\n另外，`export`语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。\n\n```javascript\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n```\n\n上面代码输出变量`foo`，值为`bar`，500毫秒之后变成`baz`。\n\n这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。\n\n最后，`export`命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的`import`命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。\n\n```javascript\nfunction foo() {\n  export default 'bar' // SyntaxError\n}\nfoo()\n```\n\n上面代码中，`export`语句放在函数之中，结果报错。\n\n## import命令\n\n使用`export`命令定义了模块的对外接口以后，其他JS文件就可以通过`import`命令加载这个模块（文件）。\n\n```javascript\n// main.js\n\nimport {firstName, lastName, year} from './profile';\n\nfunction setName(element) {\n  element.textContent = firstName + ' ' + lastName;\n}\n```\n\n上面代码的`import`命令，就用于加载`profile.js`文件，并从中输入变量。`import`命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（`profile.js`）对外接口的名称相同。\n\n如果想为输入的变量重新取一个名字，import命令要使用`as`关键字，将输入的变量重命名。\n\n```javascript\nimport { lastName as surname } from './profile';\n```\n\n注意，`import`命令具有提升效果，会提升到整个模块的头部，首先执行。\n\n```javascript\nfoo();\n\nimport { foo } from 'my_module';\n```\n\n上面的代码不会报错，因为`import`的执行早于`foo`的调用。\n\n如果在一个模块之中，先输入后输出同一个模块，`import`语句可以与`export`语句写在一起。\n\n```javascript\nexport { es6 as default } from './someModule';\n\n// 等同于\nimport { es6 } from './someModule';\nexport default es6;\n```\n\n上面代码中，`export`和`import`语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，而应该采用标准写法。\n\n另外，ES7有一个[提案](https://github.com/leebyron/ecmascript-more-export-from)，简化先输入后输出的写法，拿掉输出时的大括号。\n\n```javascript\n// 提案的写法\nexport v from 'mod';\n\n// 现行的写法\nexport {v} from 'mod';\n```\n\n`import`语句会执行所加载的模块，因此可以有下面的写法。\n\n```javascript\nimport 'lodash';\n```\n\n上面代码仅仅执行`lodash`模块，但是不输入任何值。\n\n## 模块的整体加载\n\n除了指定加载某个输出值，还可以使用整体加载，即用星号（`*`）指定一个对象，所有输出值都加载在这个对象上面。\n\n下面是一个`circle.js`文件，它输出两个方法`area`和`circumference`。\n\n```javascript\n// circle.js\n\nexport function area(radius) {\n  return Math.PI * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * Math.PI * radius;\n}\n```\n\n现在，加载这个模块。\n\n```javascript\n// main.js\n\nimport { area, circumference } from './circle';\n\nconsole.log('圆面积：' + area(4));\nconsole.log('圆周长：' + circumference(14));\n```\n\n上面写法是逐一指定要加载的方法，整体加载的写法如下。\n\n```javascript\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n```\n\n## export default命令\n\n从前面的例子可以看出，使用`import`命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。\n\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到`export default`命令，为模块指定默认输出。\n\n```javascript\n// export-default.js\nexport default function () {\n  console.log('foo');\n}\n```\n\n上面代码是一个模块文件`export-default.js`，它的默认输出是一个函数。\n\n其他模块加载该模块时，`import`命令可以为该匿名函数指定任意名字。\n\n```javascript\n// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n```\n\n上面代码的`import`命令，可以用任意名称指向`export-default.js`输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时`import`命令后面，不使用大括号。\n\n`export default`命令用在非匿名函数前，也是可以的。\n\n```javascript\n// export-default.js\nexport default function foo() {\n  console.log('foo');\n}\n\n// 或者写成\n\nfunction foo() {\n  console.log('foo');\n}\n\nexport default foo;\n```\n\n上面代码中，`foo`函数的函数名`foo`，在模块外部是无效的。加载的时候，视同匿名函数加载。\n\n下面比较一下默认输出和正常输出。\n\n```javascript\n// 输出\nexport default function crc32() {\n  // ...\n}\n// 输入\nimport crc32 from 'crc32';\n\n// 输出\nexport function crc32() {\n  // ...\n};\n// 输入\nimport {crc32} from 'crc32';\n```\n\n上面代码的两组写法，第一组是使用`export default`时，对应的`import`语句不需要使用大括号；第二组是不使用`export default`时，对应的`import`语句需要使用大括号。\n\n`export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export deault`命令只能使用一次。所以，`import`命令后面才不用加大括号，因为只可能对应一个方法。\n\n本质上，`export default`就是输出一个叫做`default`的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。\n\n```javascript\n// modules.js\nfunction add(x, y) {\n  return x * y;\n}\nexport {add as default};\n// 等同于\n// export default add;\n\n// app.js\nimport { default as xxx } from 'modules';\n// 等同于\n// import xxx from 'modules';\n```\n\n正是因为`export default`命令其实只是输出一个叫做`default`的变量，所以它后面不能跟变量声明语句。\n\n```javascript\n// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n\n// 错误\nexport default var a = 1;\n```\n\n上面代码中，`export default a`的含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。\n\n有了`export default`命令，输入模块时就非常直观了，以输入jQuery模块为例。\n\n```javascript\nimport $ from 'jquery';\n```\n\n如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。\n\n```javascript\nimport customName, { otherMethod } from './export-default';\n```\n\n如果要输出默认的值，只需将值跟在`export default`之后即可。\n\n```javascript\nexport default 42;\n```\n\n`export default`也可以用来输出类。\n\n```javascript\n// MyClass.js\nexport default class { ... }\n\n// main.js\nimport MyClass from 'MyClass';\nlet o = new MyClass();\n```\n\n## 模块的继承\n\n模块之间也可以继承。\n\n假设有一个`circleplus`模块，继承了`circle`模块。\n\n```javascript\n// circleplus.js\n\nexport * from 'circle';\nexport var e = 2.71828182846;\nexport default function(x) {\n  return Math.exp(x);\n}\n```\n\n上面代码中的`export *`，表示再输出`circle`模块的所有属性和方法。注意，`export *`命令会忽略`circle`模块的`default`方法。然后，上面代码又输出了自定义的`e`变量和默认方法。\n\n这时，也可以将`circle`的属性或方法，改名后再输出。\n\n```javascript\n// circleplus.js\n\nexport { area as circleArea } from 'circle';\n```\n\n上面代码表示，只输出`circle`模块的`area`方法，且将其改名为`circleArea`。\n\n加载上面模块的写法如下。\n\n```javascript\n// main.js\n\nimport * as math from 'circleplus';\nimport exp from 'circleplus';\nconsole.log(exp(math.e));\n```\n\n上面代码中的`import exp`表示，将`circleplus`模块的默认方法加载为`exp`方法。\n\n## ES6模块加载的实质\n\nES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。\n\nCommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件`lib.js`的例子。\n\n```javascript\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n```\n\n上面代码输出内部变量`counter`和改写这个变量的内部方法`incCounter`。然后，在`main.js`里面加载这个模块。\n\n```javascript\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n```\n\n上面代码说明，`lib.js`模块加载以后，它的内部变化就影响不到输出的`mod.counter`了。这是因为`mod.counter`是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。\n\n```javascript\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  get counter() {\n    return counter\n  },\n  incCounter: incCounter,\n};\n```\n\n上面代码中，输出的`counter`属性实际上是一个取值器函数。现在再执行`main.js`，就可以正确读取内部变量`counter`的变动了。\n\n```bash\n$ node main.js\n3\n4\n```\n\nES6模块的运行机制与CommonJS不一样，它遇到模块加载命令`import`时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，`import`输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n还是举上面的例子。\n\n```javascript\n// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n\n// main.js\nimport { counter, incCounter } from './lib';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n```\n\n上面代码说明，ES6模块输入的变量`counter`是活的，完全反应其所在模块`lib.js`内部的变化。\n\n再举一个出现在`export`一节中的例子。\n\n```javascript\n// m1.js\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n\n// m2.js\nimport {foo} from './m1.js';\nconsole.log(foo);\nsetTimeout(() => console.log(foo), 500);\n```\n\n上面代码中，`m1.js`的变量`foo`，在刚加载时等于`bar`，过了500毫秒，又变为等于`baz`。\n\n让我们看看，`m2.js`能否正确读取这个变化。\n\n```bash\n$ babel-node m2.js\n\nbar\nbaz\n```\n\n上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。\n\n由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。\n\n```javascript\n// lib.js\nexport let obj = {};\n\n// main.js\nimport { obj } from './lib';\n\nobj.prop = 123; // OK\nobj = {}; // TypeError\n```\n\n上面代码中，`main.js`从`lib.js`输入变量`obj`，可以对`obj`添加属性，但是重新赋值就会报错。因为变量`obj`指向的地址是只读的，不能重新赋值，这就好比`main.js`创造了一个名为`obj`的const变量。\n\n最后，`export`通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。\n\n```javascript\n// mod.js\nfunction C() {\n  this.sum = 0;\n  this.add = function () {\n    this.sum += 1;\n  };\n  this.show = function () {\n    console.log(this.sum);\n  };\n}\n\nexport let c = new C();\n```\n\n上面的脚本`mod.js`，输出的是一个`C`的实例。不同的脚本加载这个模块，得到的都是同一个实例。\n\n```javascript\n// x.js\nimport {c} from './mod';\nc.add();\n\n// y.js\nimport {c} from './mod';\nc.show();\n\n// main.js\nimport './x';\nimport './y';\n```\n\n现在执行`main.js`，输出的是1。\n\n```bash\n$ babel-node main.js\n1\n```\n\n这就证明了`x.js`和`y.js`加载的都是`C`的同一个实例。\n","source":"_posts/ES2015的模块化.md","raw":"---\ntitle: ES2015的模块化\ndate: 2016-11-09 10:26:59\ntags: ES2015\n---\n\n# Module\n\nES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。\n\n历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的`require`、Python的`import`，甚至就连CSS都有`@import`，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\n\n在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。\n\nES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。\n\n```javascript\n// CommonJS模块\nlet { stat, exists, readFile } = require('fs');\n\n// 等同于\nlet _fs = require('fs');\nlet stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;\n```\n\n上面代码的实质是整体加载`fs`模块（即加载`fs`的所有方法），生成一个对象（`_fs`），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。\n\nES6模块不是对象，而是通过`export`命令显式指定输出的代码，输入时也采用静态命令的形式。\n\n```javascript\n// ES6模块\nimport { stat, exists, readFile } from 'fs';\n```\n\n上面代码的实质是从`fs`模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。\n\n由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。\n\n除了静态加载带来的各种好处，ES6模块还有以下好处。\n\n- 不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。\n- 将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者`navigator`对象的属性。\n- 不再需要对象作为命名空间（比如`Math`对象），未来这些功能可以通过模块提供。\n\n浏览器使用ES6模块的语法如下。\n\n```html\n<script type=\"module\" src=\"foo.js\"></script>\n```\n\n上面代码在网页中插入一个模块`foo.js`，由于`type`属性设为`module`，所以浏览器知道这是一个ES6模块。\n\nNode的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。\n\nES6的模块自动采用严格模式，不管你有没有在模块头部加上`\"use strict\";`。\n<!--more-->\n\n## export命令\n\n模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。下面是一个JS文件，里面使用`export`命令输出变量。\n\n```javascript\n// profile.js\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n```\n\n上面代码是`profile.js`文件，保存了用户信息。ES6将其视为一个模块，里面用`export`命令对外部输出了三个变量。\n\n`export`的写法，除了像上面这样，还有另外一种。\n\n```javascript\n// profile.js\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n```\n\n上面代码在`export`命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在`var`语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。\n\nexport命令除了输出变量，还可以输出函数或类（class）。\n\n```javascript\nexport function multiply(x, y) {\n  return x * y;\n};\n```\n\n上面代码对外输出一个函数`multiply`。\n\n通常情况下，`export`输出的变量就是本来的名字，但是可以使用`as`关键字重命名。\n\n```javascript\nfunction v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n```\n\n上面代码使用`as`关键字，重命名了函数`v1`和`v2`的对外接口。重命名后，`v2`可以用不同的名字输出两次。\n\n需要特别注意的是，`export`命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。\n\n```javascript\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n```\n\n上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量`m`，还是直接输出1。`1`只是一个值，不是接口。正确的写法是下面这样。\n\n```javascript\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n```\n\n上面三种写法都是正确的，规定了对外的接口`m`。其他脚本可以通过这个接口，取到值`1`。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。\n\n同样的，`function`和`class`的输出，也必须遵守这样的写法。\n\n```javascript\n// 报错\nfunction f() {}\nexport f;\n\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n```\n\n另外，`export`语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。\n\n```javascript\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n```\n\n上面代码输出变量`foo`，值为`bar`，500毫秒之后变成`baz`。\n\n这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。\n\n最后，`export`命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的`import`命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。\n\n```javascript\nfunction foo() {\n  export default 'bar' // SyntaxError\n}\nfoo()\n```\n\n上面代码中，`export`语句放在函数之中，结果报错。\n\n## import命令\n\n使用`export`命令定义了模块的对外接口以后，其他JS文件就可以通过`import`命令加载这个模块（文件）。\n\n```javascript\n// main.js\n\nimport {firstName, lastName, year} from './profile';\n\nfunction setName(element) {\n  element.textContent = firstName + ' ' + lastName;\n}\n```\n\n上面代码的`import`命令，就用于加载`profile.js`文件，并从中输入变量。`import`命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（`profile.js`）对外接口的名称相同。\n\n如果想为输入的变量重新取一个名字，import命令要使用`as`关键字，将输入的变量重命名。\n\n```javascript\nimport { lastName as surname } from './profile';\n```\n\n注意，`import`命令具有提升效果，会提升到整个模块的头部，首先执行。\n\n```javascript\nfoo();\n\nimport { foo } from 'my_module';\n```\n\n上面的代码不会报错，因为`import`的执行早于`foo`的调用。\n\n如果在一个模块之中，先输入后输出同一个模块，`import`语句可以与`export`语句写在一起。\n\n```javascript\nexport { es6 as default } from './someModule';\n\n// 等同于\nimport { es6 } from './someModule';\nexport default es6;\n```\n\n上面代码中，`export`和`import`语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，而应该采用标准写法。\n\n另外，ES7有一个[提案](https://github.com/leebyron/ecmascript-more-export-from)，简化先输入后输出的写法，拿掉输出时的大括号。\n\n```javascript\n// 提案的写法\nexport v from 'mod';\n\n// 现行的写法\nexport {v} from 'mod';\n```\n\n`import`语句会执行所加载的模块，因此可以有下面的写法。\n\n```javascript\nimport 'lodash';\n```\n\n上面代码仅仅执行`lodash`模块，但是不输入任何值。\n\n## 模块的整体加载\n\n除了指定加载某个输出值，还可以使用整体加载，即用星号（`*`）指定一个对象，所有输出值都加载在这个对象上面。\n\n下面是一个`circle.js`文件，它输出两个方法`area`和`circumference`。\n\n```javascript\n// circle.js\n\nexport function area(radius) {\n  return Math.PI * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * Math.PI * radius;\n}\n```\n\n现在，加载这个模块。\n\n```javascript\n// main.js\n\nimport { area, circumference } from './circle';\n\nconsole.log('圆面积：' + area(4));\nconsole.log('圆周长：' + circumference(14));\n```\n\n上面写法是逐一指定要加载的方法，整体加载的写法如下。\n\n```javascript\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n```\n\n## export default命令\n\n从前面的例子可以看出，使用`import`命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。\n\n为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到`export default`命令，为模块指定默认输出。\n\n```javascript\n// export-default.js\nexport default function () {\n  console.log('foo');\n}\n```\n\n上面代码是一个模块文件`export-default.js`，它的默认输出是一个函数。\n\n其他模块加载该模块时，`import`命令可以为该匿名函数指定任意名字。\n\n```javascript\n// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n```\n\n上面代码的`import`命令，可以用任意名称指向`export-default.js`输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时`import`命令后面，不使用大括号。\n\n`export default`命令用在非匿名函数前，也是可以的。\n\n```javascript\n// export-default.js\nexport default function foo() {\n  console.log('foo');\n}\n\n// 或者写成\n\nfunction foo() {\n  console.log('foo');\n}\n\nexport default foo;\n```\n\n上面代码中，`foo`函数的函数名`foo`，在模块外部是无效的。加载的时候，视同匿名函数加载。\n\n下面比较一下默认输出和正常输出。\n\n```javascript\n// 输出\nexport default function crc32() {\n  // ...\n}\n// 输入\nimport crc32 from 'crc32';\n\n// 输出\nexport function crc32() {\n  // ...\n};\n// 输入\nimport {crc32} from 'crc32';\n```\n\n上面代码的两组写法，第一组是使用`export default`时，对应的`import`语句不需要使用大括号；第二组是不使用`export default`时，对应的`import`语句需要使用大括号。\n\n`export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export deault`命令只能使用一次。所以，`import`命令后面才不用加大括号，因为只可能对应一个方法。\n\n本质上，`export default`就是输出一个叫做`default`的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。\n\n```javascript\n// modules.js\nfunction add(x, y) {\n  return x * y;\n}\nexport {add as default};\n// 等同于\n// export default add;\n\n// app.js\nimport { default as xxx } from 'modules';\n// 等同于\n// import xxx from 'modules';\n```\n\n正是因为`export default`命令其实只是输出一个叫做`default`的变量，所以它后面不能跟变量声明语句。\n\n```javascript\n// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n\n// 错误\nexport default var a = 1;\n```\n\n上面代码中，`export default a`的含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。\n\n有了`export default`命令，输入模块时就非常直观了，以输入jQuery模块为例。\n\n```javascript\nimport $ from 'jquery';\n```\n\n如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。\n\n```javascript\nimport customName, { otherMethod } from './export-default';\n```\n\n如果要输出默认的值，只需将值跟在`export default`之后即可。\n\n```javascript\nexport default 42;\n```\n\n`export default`也可以用来输出类。\n\n```javascript\n// MyClass.js\nexport default class { ... }\n\n// main.js\nimport MyClass from 'MyClass';\nlet o = new MyClass();\n```\n\n## 模块的继承\n\n模块之间也可以继承。\n\n假设有一个`circleplus`模块，继承了`circle`模块。\n\n```javascript\n// circleplus.js\n\nexport * from 'circle';\nexport var e = 2.71828182846;\nexport default function(x) {\n  return Math.exp(x);\n}\n```\n\n上面代码中的`export *`，表示再输出`circle`模块的所有属性和方法。注意，`export *`命令会忽略`circle`模块的`default`方法。然后，上面代码又输出了自定义的`e`变量和默认方法。\n\n这时，也可以将`circle`的属性或方法，改名后再输出。\n\n```javascript\n// circleplus.js\n\nexport { area as circleArea } from 'circle';\n```\n\n上面代码表示，只输出`circle`模块的`area`方法，且将其改名为`circleArea`。\n\n加载上面模块的写法如下。\n\n```javascript\n// main.js\n\nimport * as math from 'circleplus';\nimport exp from 'circleplus';\nconsole.log(exp(math.e));\n```\n\n上面代码中的`import exp`表示，将`circleplus`模块的默认方法加载为`exp`方法。\n\n## ES6模块加载的实质\n\nES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。\n\nCommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件`lib.js`的例子。\n\n```javascript\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n```\n\n上面代码输出内部变量`counter`和改写这个变量的内部方法`incCounter`。然后，在`main.js`里面加载这个模块。\n\n```javascript\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n```\n\n上面代码说明，`lib.js`模块加载以后，它的内部变化就影响不到输出的`mod.counter`了。这是因为`mod.counter`是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。\n\n```javascript\n// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  get counter() {\n    return counter\n  },\n  incCounter: incCounter,\n};\n```\n\n上面代码中，输出的`counter`属性实际上是一个取值器函数。现在再执行`main.js`，就可以正确读取内部变量`counter`的变动了。\n\n```bash\n$ node main.js\n3\n4\n```\n\nES6模块的运行机制与CommonJS不一样，它遇到模块加载命令`import`时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，`import`输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n还是举上面的例子。\n\n```javascript\n// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n\n// main.js\nimport { counter, incCounter } from './lib';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n```\n\n上面代码说明，ES6模块输入的变量`counter`是活的，完全反应其所在模块`lib.js`内部的变化。\n\n再举一个出现在`export`一节中的例子。\n\n```javascript\n// m1.js\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n\n// m2.js\nimport {foo} from './m1.js';\nconsole.log(foo);\nsetTimeout(() => console.log(foo), 500);\n```\n\n上面代码中，`m1.js`的变量`foo`，在刚加载时等于`bar`，过了500毫秒，又变为等于`baz`。\n\n让我们看看，`m2.js`能否正确读取这个变化。\n\n```bash\n$ babel-node m2.js\n\nbar\nbaz\n```\n\n上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。\n\n由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。\n\n```javascript\n// lib.js\nexport let obj = {};\n\n// main.js\nimport { obj } from './lib';\n\nobj.prop = 123; // OK\nobj = {}; // TypeError\n```\n\n上面代码中，`main.js`从`lib.js`输入变量`obj`，可以对`obj`添加属性，但是重新赋值就会报错。因为变量`obj`指向的地址是只读的，不能重新赋值，这就好比`main.js`创造了一个名为`obj`的const变量。\n\n最后，`export`通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。\n\n```javascript\n// mod.js\nfunction C() {\n  this.sum = 0;\n  this.add = function () {\n    this.sum += 1;\n  };\n  this.show = function () {\n    console.log(this.sum);\n  };\n}\n\nexport let c = new C();\n```\n\n上面的脚本`mod.js`，输出的是一个`C`的实例。不同的脚本加载这个模块，得到的都是同一个实例。\n\n```javascript\n// x.js\nimport {c} from './mod';\nc.add();\n\n// y.js\nimport {c} from './mod';\nc.show();\n\n// main.js\nimport './x';\nimport './y';\n```\n\n现在执行`main.js`，输出的是1。\n\n```bash\n$ babel-node main.js\n1\n```\n\n这就证明了`x.js`和`y.js`加载的都是`C`的同一个实例。\n","slug":"ES2015的模块化","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfcg000mzk4oy44x0h8t","content":"<h1 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h1><p>ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。</p>\n<p>历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的<code>require</code>、Python的<code>import</code>，甚至就连CSS都有<code>@import</code>，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\n<p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>\n<p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CommonJS模块</span></div><div class=\"line\"><span class=\"keyword\">let</span> &#123; stat, exists, readFile &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">let</span> _fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;</div></pre></td></tr></table></figure>\n<p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>\n<p>ES6模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，输入时也采用静态命令的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; stat, exists, readFile &#125; <span class=\"keyword\">from</span> <span class=\"string\">'fs'</span>;</div></pre></td></tr></table></figure>\n<p>上面代码的实质是从<code>fs</code>模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p>\n<p>由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>\n<p>除了静态加载带来的各种好处，ES6模块还有以下好处。</p>\n<ul>\n<li>不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>\n<li>将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者<code>navigator</code>对象的属性。</li>\n<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>\n</ul>\n<p>浏览器使用ES6模块的语法如下。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"module\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"foo.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个ES6模块。</p>\n<p>Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。</p>\n<p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。<br><a id=\"more\"></a></p>\n<h2 id=\"export命令\"><a href=\"#export命令\" class=\"headerlink\" title=\"export命令\"></a>export命令</h2><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>\n<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个JS文件，里面使用<code>export</code>命令输出变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// profile.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> firstName = <span class=\"string\">'Michael'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> lastName = <span class=\"string\">'Jackson'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> year = <span class=\"number\">1958</span>;</div></pre></td></tr></table></figure>\n<p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p>\n<p><code>export</code>的写法，除了像上面这样，还有另外一种。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// profile.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> firstName = <span class=\"string\">'Michael'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> lastName = <span class=\"string\">'Jackson'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> year = <span class=\"number\">1958</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> &#123;firstName, lastName, year&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>\n<p>export命令除了输出变量，还可以输出函数或类（class）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x * y;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码对外输出一个函数<code>multiply</code>。</p>\n<p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">v1</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">v2</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> &#123;</div><div class=\"line\">  v1 <span class=\"keyword\">as</span> streamV1,</div><div class=\"line\">  v2 <span class=\"keyword\">as</span> streamV2,</div><div class=\"line\">  v2 <span class=\"keyword\">as</span> streamLatestVersion</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p>\n<p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> m;</div></pre></td></tr></table></figure>\n<p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量<code>m</code>，还是直接输出1。<code>1</code>只是一个值，不是接口。正确的写法是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写法一</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写法二</span></div><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> &#123;m&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写法三</span></div><div class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> &#123;n <span class=\"keyword\">as</span> m&#125;;</div></pre></td></tr></table></figure>\n<p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>\n<p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> f;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> &#123;f&#125;;</div></pre></td></tr></table></figure>\n<p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> foo = <span class=\"string\">'baz'</span>, <span class=\"number\">500</span>);</div></pre></td></tr></table></figure>\n<p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500毫秒之后变成<code>baz</code>。</p>\n<p>这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。</p>\n<p>最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"string\">'bar'</span> <span class=\"comment\">// SyntaxError</span></div><div class=\"line\">&#125;</div><div class=\"line\">foo()</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>export</code>语句放在函数之中，结果报错。</p>\n<h2 id=\"import命令\"><a href=\"#import命令\" class=\"headerlink\" title=\"import命令\"></a>import命令</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他JS文件就可以通过<code>import</code>命令加载这个模块（文件）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;firstName, lastName, year&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./profile'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">  element.textContent = firstName + <span class=\"string\">' '</span> + lastName;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码的<code>import</code>命令，就用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>\n<p>如果想为输入的变量重新取一个名字，import命令要使用<code>as</code>关键字，将输入的变量重命名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; lastName <span class=\"keyword\">as</span> surname &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./profile'</span>;</div></pre></td></tr></table></figure>\n<p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; foo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'my_module'</span>;</div></pre></td></tr></table></figure>\n<p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。</p>\n<p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> &#123; es6 <span class=\"keyword\">as</span> <span class=\"keyword\">default</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./someModule'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; es6 &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./someModule'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> es6;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，而应该采用标准写法。</p>\n<p>另外，ES7有一个<a href=\"https://github.com/leebyron/ecmascript-more-export-from\" target=\"_blank\" rel=\"external\">提案</a>，简化先输入后输出的写法，拿掉输出时的大括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 提案的写法</span></div><div class=\"line\"><span class=\"keyword\">export</span> v <span class=\"keyword\">from</span> <span class=\"string\">'mod'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 现行的写法</span></div><div class=\"line\"><span class=\"keyword\">export</span> &#123;v&#125; <span class=\"keyword\">from</span> <span class=\"string\">'mod'</span>;</div></pre></td></tr></table></figure>\n<p><code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'lodash'</span>;</div></pre></td></tr></table></figure>\n<p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>\n<h2 id=\"模块的整体加载\"><a href=\"#模块的整体加载\" class=\"headerlink\" title=\"模块的整体加载\"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p>\n<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// circle.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">radius</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * radius * radius;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">circumference</span>(<span class=\"params\">radius</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI * radius;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，加载这个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; area, circumference &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./circle'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆面积：'</span> + area(<span class=\"number\">4</span>));</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆周长：'</span> + circumference(<span class=\"number\">14</span>));</div></pre></td></tr></table></figure>\n<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> circle <span class=\"keyword\">from</span> <span class=\"string\">'./circle'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆面积：'</span> + circle.area(<span class=\"number\">4</span>));</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆周长：'</span> + circle.circumference(<span class=\"number\">14</span>));</div></pre></td></tr></table></figure>\n<h2 id=\"export-default命令\"><a href=\"#export-default命令\" class=\"headerlink\" title=\"export default命令\"></a>export default命令</h2><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>\n<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// export-default.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p>\n<p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// import-default.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> customName <span class=\"keyword\">from</span> <span class=\"string\">'./export-default'</span>;</div><div class=\"line\">customName(); <span class=\"comment\">// 'foo'</span></div></pre></td></tr></table></figure>\n<p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p>\n<p><code>export default</code>命令用在非匿名函数前，也是可以的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// export-default.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或者写成</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> foo;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>\n<p>下面比较一下默认输出和正常输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 输出</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">crc32</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 输入</span></div><div class=\"line\"><span class=\"keyword\">import</span> crc32 <span class=\"keyword\">from</span> <span class=\"string\">'crc32'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">crc32</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 输入</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;crc32&#125; <span class=\"keyword\">from</span> <span class=\"string\">'crc32'</span>;</div></pre></td></tr></table></figure>\n<p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p>\n<p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export deault</code>命令只能使用一次。所以，<code>import</code>命令后面才不用加大括号，因为只可能对应一个方法。</p>\n<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// modules.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x * y;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> &#123;add <span class=\"keyword\">as</span> <span class=\"keyword\">default</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"comment\">// export default add;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// app.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">default</span> <span class=\"keyword\">as</span> xxx &#125; <span class=\"keyword\">from</span> <span class=\"string\">'modules'</span>;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"comment\">// import xxx from 'modules';</span></div></pre></td></tr></table></figure>\n<p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> a;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 错误</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p>\n<p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入jQuery模块为例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> $ <span class=\"keyword\">from</span> <span class=\"string\">'jquery'</span>;</div></pre></td></tr></table></figure>\n<p>如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> customName, &#123; otherMethod &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./export-default'</span>;</div></pre></td></tr></table></figure>\n<p>如果要输出默认的值，只需将值跟在<code>export default</code>之后即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"number\">42</span>;</div></pre></td></tr></table></figure>\n<p><code>export default</code>也可以用来输出类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MyClass.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyClass <span class=\"keyword\">from</span> <span class=\"string\">'MyClass'</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> MyClass();</div></pre></td></tr></table></figure>\n<h2 id=\"模块的继承\"><a href=\"#模块的继承\" class=\"headerlink\" title=\"模块的继承\"></a>模块的继承</h2><p>模块之间也可以继承。</p>\n<p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// circleplus.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">'circle'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> e = <span class=\"number\">2.71828182846</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.exp(x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p>\n<p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// circleplus.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> &#123; area <span class=\"keyword\">as</span> circleArea &#125; <span class=\"keyword\">from</span> <span class=\"string\">'circle'</span>;</div></pre></td></tr></table></figure>\n<p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p>\n<p>加载上面模块的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> math <span class=\"keyword\">from</span> <span class=\"string\">'circleplus'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> exp <span class=\"keyword\">from</span> <span class=\"string\">'circleplus'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(exp(math.e));</div></pre></td></tr></table></figure>\n<p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p>\n<h2 id=\"ES6模块加载的实质\"><a href=\"#ES6模块加载的实质\" class=\"headerlink\" title=\"ES6模块加载的实质\"></a>ES6模块加载的实质</h2><p>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。</p>\n<p>CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lib.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  counter++;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">counter</span>: counter,</div><div class=\"line\">  <span class=\"attr\">incCounter</span>: incCounter,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> mod = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter);  <span class=\"comment\">// 3</span></div><div class=\"line\">mod.incCounter();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter); <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lib.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  counter++;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  get counter() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> counter</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">incCounter</span>: incCounter,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node main.js</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td></tr></table></figure>\n<p>ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令<code>import</code>时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，<code>import</code>输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>\n<p>还是举上面的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lib.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> counter = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  counter++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; counter, incCounter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lib'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 3</span></div><div class=\"line\">incCounter();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 4</span></div></pre></td></tr></table></figure>\n<p>上面代码说明，ES6模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p>\n<p>再举一个出现在<code>export</code>一节中的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// m1.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> foo = <span class=\"string\">'baz'</span>, <span class=\"number\">500</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// m2.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;foo&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./m1.js'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(foo), <span class=\"number\">500</span>);</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了500毫秒，又变为等于<code>baz</code>。</p>\n<p>让我们看看，<code>m2.js</code>能否正确读取这个变化。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ babel-node m2.js</div><div class=\"line\"></div><div class=\"line\">bar</div><div class=\"line\">baz</div></pre></td></tr></table></figure>\n<p>上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p>\n<p>由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lib.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> obj = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; obj &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lib'</span>;</div><div class=\"line\"></div><div class=\"line\">obj.prop = <span class=\"number\">123</span>; <span class=\"comment\">// OK</span></div><div class=\"line\">obj = &#123;&#125;; <span class=\"comment\">// TypeError</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的const变量。</p>\n<p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// mod.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.sum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.sum += <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">this</span>.show = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sum);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</div></pre></td></tr></table></figure>\n<p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// x.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;c&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mod'</span>;</div><div class=\"line\">c.add();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// y.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;c&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mod'</span>;</div><div class=\"line\">c.show();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./x'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./y'</span>;</div></pre></td></tr></table></figure>\n<p>现在执行<code>main.js</code>，输出的是1。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ babel-node main.js</div><div class=\"line\">1</div></pre></td></tr></table></figure>\n<p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h1><p>ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。</p>\n<p>历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的<code>require</code>、Python的<code>import</code>，甚至就连CSS都有<code>@import</code>，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\n<p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>\n<p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CommonJS模块</span></div><div class=\"line\"><span class=\"keyword\">let</span> &#123; stat, exists, readFile &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">let</span> _fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;</div></pre></td></tr></table></figure>\n<p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>\n<p>ES6模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，输入时也采用静态命令的形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ES6模块</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; stat, exists, readFile &#125; <span class=\"keyword\">from</span> <span class=\"string\">'fs'</span>;</div></pre></td></tr></table></figure>\n<p>上面代码的实质是从<code>fs</code>模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p>\n<p>由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>\n<p>除了静态加载带来的各种好处，ES6模块还有以下好处。</p>\n<ul>\n<li>不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>\n<li>将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者<code>navigator</code>对象的属性。</li>\n<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>\n</ul>\n<p>浏览器使用ES6模块的语法如下。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"module\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"foo.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个ES6模块。</p>\n<p>Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。</p>\n<p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。<br>","more":"</p>\n<h2 id=\"export命令\"><a href=\"#export命令\" class=\"headerlink\" title=\"export命令\"></a>export命令</h2><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>\n<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个JS文件，里面使用<code>export</code>命令输出变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// profile.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> firstName = <span class=\"string\">'Michael'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> lastName = <span class=\"string\">'Jackson'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> year = <span class=\"number\">1958</span>;</div></pre></td></tr></table></figure>\n<p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p>\n<p><code>export</code>的写法，除了像上面这样，还有另外一种。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// profile.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> firstName = <span class=\"string\">'Michael'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> lastName = <span class=\"string\">'Jackson'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> year = <span class=\"number\">1958</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> &#123;firstName, lastName, year&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>\n<p>export命令除了输出变量，还可以输出函数或类（class）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x * y;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码对外输出一个函数<code>multiply</code>。</p>\n<p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">v1</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">v2</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> &#123;</div><div class=\"line\">  v1 <span class=\"keyword\">as</span> streamV1,</div><div class=\"line\">  v2 <span class=\"keyword\">as</span> streamV2,</div><div class=\"line\">  v2 <span class=\"keyword\">as</span> streamLatestVersion</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p>\n<p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> m;</div></pre></td></tr></table></figure>\n<p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量<code>m</code>，还是直接输出1。<code>1</code>只是一个值，不是接口。正确的写法是下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 写法一</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写法二</span></div><div class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> &#123;m&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写法三</span></div><div class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> &#123;n <span class=\"keyword\">as</span> m&#125;;</div></pre></td></tr></table></figure>\n<p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p>\n<p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 报错</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> f;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> &#123;f&#125;;</div></pre></td></tr></table></figure>\n<p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> foo = <span class=\"string\">'baz'</span>, <span class=\"number\">500</span>);</div></pre></td></tr></table></figure>\n<p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500毫秒之后变成<code>baz</code>。</p>\n<p>这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。</p>\n<p>最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"string\">'bar'</span> <span class=\"comment\">// SyntaxError</span></div><div class=\"line\">&#125;</div><div class=\"line\">foo()</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>export</code>语句放在函数之中，结果报错。</p>\n<h2 id=\"import命令\"><a href=\"#import命令\" class=\"headerlink\" title=\"import命令\"></a>import命令</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他JS文件就可以通过<code>import</code>命令加载这个模块（文件）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;firstName, lastName, year&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./profile'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">  element.textContent = firstName + <span class=\"string\">' '</span> + lastName;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码的<code>import</code>命令，就用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>\n<p>如果想为输入的变量重新取一个名字，import命令要使用<code>as</code>关键字，将输入的变量重命名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123; lastName <span class=\"keyword\">as</span> surname &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./profile'</span>;</div></pre></td></tr></table></figure>\n<p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; foo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'my_module'</span>;</div></pre></td></tr></table></figure>\n<p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。</p>\n<p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> &#123; es6 <span class=\"keyword\">as</span> <span class=\"keyword\">default</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./someModule'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; es6 &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./someModule'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> es6;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，而应该采用标准写法。</p>\n<p>另外，ES7有一个<a href=\"https://github.com/leebyron/ecmascript-more-export-from\" target=\"_blank\" rel=\"external\">提案</a>，简化先输入后输出的写法，拿掉输出时的大括号。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 提案的写法</span></div><div class=\"line\"><span class=\"keyword\">export</span> v <span class=\"keyword\">from</span> <span class=\"string\">'mod'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 现行的写法</span></div><div class=\"line\"><span class=\"keyword\">export</span> &#123;v&#125; <span class=\"keyword\">from</span> <span class=\"string\">'mod'</span>;</div></pre></td></tr></table></figure>\n<p><code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'lodash'</span>;</div></pre></td></tr></table></figure>\n<p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>\n<h2 id=\"模块的整体加载\"><a href=\"#模块的整体加载\" class=\"headerlink\" title=\"模块的整体加载\"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p>\n<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// circle.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">radius</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * radius * radius;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">circumference</span>(<span class=\"params\">radius</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI * radius;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，加载这个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; area, circumference &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./circle'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆面积：'</span> + area(<span class=\"number\">4</span>));</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆周长：'</span> + circumference(<span class=\"number\">14</span>));</div></pre></td></tr></table></figure>\n<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> circle <span class=\"keyword\">from</span> <span class=\"string\">'./circle'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆面积：'</span> + circle.area(<span class=\"number\">4</span>));</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆周长：'</span> + circle.circumference(<span class=\"number\">14</span>));</div></pre></td></tr></table></figure>\n<h2 id=\"export-default命令\"><a href=\"#export-default命令\" class=\"headerlink\" title=\"export default命令\"></a>export default命令</h2><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>\n<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// export-default.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p>\n<p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// import-default.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> customName <span class=\"keyword\">from</span> <span class=\"string\">'./export-default'</span>;</div><div class=\"line\">customName(); <span class=\"comment\">// 'foo'</span></div></pre></td></tr></table></figure>\n<p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p>\n<p><code>export default</code>命令用在非匿名函数前，也是可以的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// export-default.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或者写成</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> foo;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>\n<p>下面比较一下默认输出和正常输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 输出</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">crc32</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 输入</span></div><div class=\"line\"><span class=\"keyword\">import</span> crc32 <span class=\"keyword\">from</span> <span class=\"string\">'crc32'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 输出</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">crc32</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 输入</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;crc32&#125; <span class=\"keyword\">from</span> <span class=\"string\">'crc32'</span>;</div></pre></td></tr></table></figure>\n<p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p>\n<p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export deault</code>命令只能使用一次。所以，<code>import</code>命令后面才不用加大括号，因为只可能对应一个方法。</p>\n<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// modules.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> x * y;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">export</span> &#123;add <span class=\"keyword\">as</span> <span class=\"keyword\">default</span>&#125;;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"comment\">// export default add;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// app.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">default</span> <span class=\"keyword\">as</span> xxx &#125; <span class=\"keyword\">from</span> <span class=\"string\">'modules'</span>;</div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\"><span class=\"comment\">// import xxx from 'modules';</span></div></pre></td></tr></table></figure>\n<p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 正确</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> a;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 错误</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p>\n<p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入jQuery模块为例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> $ <span class=\"keyword\">from</span> <span class=\"string\">'jquery'</span>;</div></pre></td></tr></table></figure>\n<p>如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> customName, &#123; otherMethod &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./export-default'</span>;</div></pre></td></tr></table></figure>\n<p>如果要输出默认的值，只需将值跟在<code>export default</code>之后即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"number\">42</span>;</div></pre></td></tr></table></figure>\n<p><code>export default</code>也可以用来输出类。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// MyClass.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123; ... &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> MyClass <span class=\"keyword\">from</span> <span class=\"string\">'MyClass'</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> o = <span class=\"keyword\">new</span> MyClass();</div></pre></td></tr></table></figure>\n<h2 id=\"模块的继承\"><a href=\"#模块的继承\" class=\"headerlink\" title=\"模块的继承\"></a>模块的继承</h2><p>模块之间也可以继承。</p>\n<p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// circleplus.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">'circle'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> e = <span class=\"number\">2.71828182846</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.exp(x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p>\n<p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// circleplus.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> &#123; area <span class=\"keyword\">as</span> circleArea &#125; <span class=\"keyword\">from</span> <span class=\"string\">'circle'</span>;</div></pre></td></tr></table></figure>\n<p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p>\n<p>加载上面模块的写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> math <span class=\"keyword\">from</span> <span class=\"string\">'circleplus'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> exp <span class=\"keyword\">from</span> <span class=\"string\">'circleplus'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(exp(math.e));</div></pre></td></tr></table></figure>\n<p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p>\n<h2 id=\"ES6模块加载的实质\"><a href=\"#ES6模块加载的实质\" class=\"headerlink\" title=\"ES6模块加载的实质\"></a>ES6模块加载的实质</h2><p>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。</p>\n<p>CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件<code>lib.js</code>的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lib.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  counter++;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">counter</span>: counter,</div><div class=\"line\">  <span class=\"attr\">incCounter</span>: incCounter,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> mod = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter);  <span class=\"comment\">// 3</span></div><div class=\"line\">mod.incCounter();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter); <span class=\"comment\">// 3</span></div></pre></td></tr></table></figure>\n<p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lib.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  counter++;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  get counter() &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> counter</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">incCounter</span>: incCounter,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ node main.js</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td></tr></table></figure>\n<p>ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令<code>import</code>时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，<code>import</code>输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>\n<p>还是举上面的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lib.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> counter = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  counter++;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; counter, incCounter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lib'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 3</span></div><div class=\"line\">incCounter();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 4</span></div></pre></td></tr></table></figure>\n<p>上面代码说明，ES6模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p>\n<p>再举一个出现在<code>export</code>一节中的例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// m1.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> foo = <span class=\"string\">'baz'</span>, <span class=\"number\">500</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// m2.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;foo&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./m1.js'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(foo), <span class=\"number\">500</span>);</div></pre></td></tr></table></figure>\n<p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了500毫秒，又变为等于<code>baz</code>。</p>\n<p>让我们看看，<code>m2.js</code>能否正确读取这个变化。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ babel-node m2.js</div><div class=\"line\"></div><div class=\"line\">bar</div><div class=\"line\">baz</div></pre></td></tr></table></figure>\n<p>上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p>\n<p>由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lib.js</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> obj = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; obj &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lib'</span>;</div><div class=\"line\"></div><div class=\"line\">obj.prop = <span class=\"number\">123</span>; <span class=\"comment\">// OK</span></div><div class=\"line\">obj = &#123;&#125;; <span class=\"comment\">// TypeError</span></div></pre></td></tr></table></figure>\n<p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的const变量。</p>\n<p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// mod.js</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.sum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.sum += <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">this</span>.show = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sum);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</div></pre></td></tr></table></figure>\n<p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// x.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;c&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mod'</span>;</div><div class=\"line\">c.add();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// y.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;c&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mod'</span>;</div><div class=\"line\">c.show();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./x'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./y'</span>;</div></pre></td></tr></table></figure>\n<p>现在执行<code>main.js</code>，输出的是1。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ babel-node main.js</div><div class=\"line\">1</div></pre></td></tr></table></figure>\n<p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例。</p>"},{"title":"ES2015第七种数据结构Symbols","date":"2016-11-02T15:39:29.000Z","_content":"\n1997年JavaScript首次被标准化，那时只有六种原始类型，在ES6以前，JS程序中使用的每一个值都是以下几种类型之一：\n\n - Undefined 未定义\n - Null 空值\n - Boolean 布尔类型\n - Number 数字类型\n - String 字符串类型\n - Object 对象类型\n\n每种类型都是多个值的集合，前五个集合是有限的。布尔类型只有两个值，true和false，不会再创造第三种布尔值；数字类型和字符串类型的值更多。然而，对象类型值的集合是无限的。每一个对象都像珍贵的雪花一样独一无二，每一次你打开一个Web页面，都会创建一堆对象。\n\n>  ES6新特性中的symbol也是值，但它不是字符串，也不是对象，而是是全新的——第七种类型的原始值。Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是**独一无二**的，可以保证不会与其他属性名产生冲突。\n\n让我们一起探讨一下symbol的实际应用场景。\n\n### 从一个简单的布尔类型出发\n\n有时候你可以非常轻松地将别人的外部数据存储到一个JavaScript对象中。\n\n举 个例子，假设你正在写一个JS库，可以通过CSS transitions使DOM元素在屏幕上移动。你可能会注意到，当你尝试在一个div元素上同时应用多重CSS transitions时并不会生效。实际效果是丑陋而又不连续的“跳闪”。你认为可以修复这个问题，但前提是你需要一种发现给定元素是否已经移动过的方 法。\n\n###### 应当如何解决这个问题呢？\n\n一种方法是，用CSS API来告诉浏览器元素是否正在移动，但这样简直小题大做。在元素移动的第一时间内你的库就应该记录下移动的状态，所以它自然知道元素正在移动。\n\n你真正想要的是一种持续跟踪某个元素正在移动的方法。你可以维护一个数组，记录所有正在移动的元素，每当你的库被调用来移动某个元素时，你可以检索数组来查看元素是否已经存在，亦即它是否正在移动中。\n\n当然，如果数组非常大的话，线性搜索将会非常缓慢。\n\n实际上你只想为元素设置一个标记：\n```javascript\nif (element.isMoving) {\n  smoothAnimations(element);\n}\nelement.isMoving = true;\n```\n这样也会有一些潜在的问题，事实上，你的代码很可能不是唯一一段操作DOM的代码。\n\n1. 你创建的属性很可能影响到其它使用了for-in或Object.keys()的代码。\n2. 一些聪明的库作者可能已经考虑并使用了这项技术，这样一来你的库就会与已有的库产生某些冲突\n3. 当然，很可能你比他们更聪明，你先采用了这项技术，但是他们的库仍然无法与你的库默契配合。\n4. 标准委员会可能决定为所有的元素增加一个.isMoving()方法，到那时你需要重写相关逻辑，必定会有深深的挫败感。\n当然你可以选择一个乏味而愚蠢的命名（其他人根本不会想用的那些名称）来解决最后的三个问题：\n```javascript\nif (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) {\n  smoothAnimations(element);\n}\nelement.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true;\n```\n这只会造成无畏的眼疲劳。为什么这个问题如此困难？我们只想要一个小小的布尔值啊！\n\n### symbol是最终的解决方案\n\nsymbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。\n\n``var mySymbol = Symbol();``\n调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等。\n\n字符串或数字可以作为属性的键，symbol也可以，它不等同于任何字符串，因而这个以symbol为键的属性可以保证不与任何其它属性产生冲突。\n```javascript\nobj[mySymbol] = \"ok!\";  // 保证不会冲突\nconsole.log(obj[mySymbol]);  // ok!\n```\n想要在上述讨论的场景中使用symbol，你可以这样做：\n```javascript\n// 创建一个独一无二的symbol\nvar isMoving = Symbol(\"isMoving\");\n...\nif (element[isMoving]) {\n  smoothAnimations(element);\n}\nelement[isMoving] = true;\n```\n有关这段代码的一些解释：\n\n - **Symbol(\"isMoving\")**中的isMoving被称作描述。你可以通过console.log()将它打印出来，对调试非常有帮助；你也可以用.toString()方法将它转换为字符串呈现；它也可以被用在错误信息中。\n\n - element[isMoving]被称作一个以symbol为键（symbol-keyed）的属性。简而言之，它的名字是symbol而不是一个字符串。除此之外，它与一个普通的属性没有什么区别。\n\n - 以symbol为键的属性属性与数组元素类似，**不能被类似obj.name的点号法访问，你必须使用方括号访问**这些属性。\n\n - 如果你已经得到了symbol，那么访问一个以symbol为键的属性同样简单，以上的示例很好地展示了如何获取element[isMoving]的值以及如何为它赋值。如果我们需要，可以查看属性是否存在：``if (isMoving in element)``，也可以删除属性：``delete element[isMoving]``。\n\n - 另一方面，只有当isMoving在当前作用域中时才会生效。这是symbol的弱封装机制：模块创建了几个symbol，可以在任意对象上使用，无须担心与其它代码创建的属性产生冲突。\n\nsymbol键的设计初衷是避免冲突，因此JavaScript中最常见的对象检查的特性会忽略symbol键。例如，for-in循环只会遍历对象的字符串键，symbol键直接跳过，Object.keys(obj)和Object.getOwnPropertyNames(obj)也是一样。但是symbols也不完全是私有的：用新的APIObject.getOwnPropertySymbols(obj)就可以列出对象的symbol键。另一个新的API，Reflect.ownKeys(obj)，会同时返回字符串键和symbol键。（我们将在随后的文章中讲解Reflect(反射) API）。\n\n慢慢地我们会发现，越来越多的库和框架将大量使用symbol，语言本身也会将symbol应用于广泛的用途。\n\n但是，到底什么是symbol呢？\n```javascript\n> typeof Symbol()\n\"symbol\"\n```\n确切地说，symbol与其它类型并不完全相像。\n\nsymbol被创建后就不可变更，你不能为它设置属性（在严格模式下尝试设置属性会得到TypeError的错误）。他们可以用作属性名称，这些性质与字符串类似。\n\n另一方面，每一个symbol都独一无二，不与其它symbol等同，即使二者有相同的描述也不相等；你可以轻松地创建一个新的symbol。这些性质与对象类似。\n\nES6中的symbol与Lisp和Ruby这些语言中更传统的symbol类似，但不像它们集成得那么紧密。在Lisp中，所有的标识符都是symbol；在JS中，标识符和大多数的属性键仍然是字符串，symbol只是一个额外的选项。\n\n关于symbol的忠告：symbol不能被自动转换为字符串，这和语言中的其它类型不同。尝试拼接symbol与字符串将得到TypeError错误。\n```javascript\n> var sym = Symbol(\"<3\");\n> \"your symbol is \" + sym\n// TypeError: can't convert symbol to string\n> `your symbol is ${sym}`\n// TypeError: can't convert symbol to string\n```\n通过String(sym)或sym.toString()可以显示地将symbol转换为一个字符串，从而回避这个问题。\n\n获取symbol的三种方法\n\n有三种获取symbol的方法。\n\n1. 调用Symbol()。正如我们上文中所讨论的，这种方式每次调用都会返回一个新的唯一symbol。\n\n2. 调用Symbol.for(string)。这种方式会访问symbol注册表，其中存储了已经存在的一系列symbol。这种方式与通过Symbol()定义的独立symbol不同，symbol注册表中的symbol是共享的。如果你连续三十次调用Symbol.for(\"cat\")，每次都会返回相同的symbol。注册表非常有用，在多个web页面或同一个web页面的多个模块中经常需要共享一个symbol。\n\n3. 使用标准定义的symbol，例如：Symbol.iterator。标准根据一些特殊用途定义了少许的几个symbol。\n\n\n","source":"_posts/ES2015第七种数据结构Symbols.md","raw":"---\ntitle: ES2015第七种数据结构Symbols\ndate: 2016-11-02 23:39:29\ntags: ES2015\n---\n\n1997年JavaScript首次被标准化，那时只有六种原始类型，在ES6以前，JS程序中使用的每一个值都是以下几种类型之一：\n\n - Undefined 未定义\n - Null 空值\n - Boolean 布尔类型\n - Number 数字类型\n - String 字符串类型\n - Object 对象类型\n\n每种类型都是多个值的集合，前五个集合是有限的。布尔类型只有两个值，true和false，不会再创造第三种布尔值；数字类型和字符串类型的值更多。然而，对象类型值的集合是无限的。每一个对象都像珍贵的雪花一样独一无二，每一次你打开一个Web页面，都会创建一堆对象。\n\n>  ES6新特性中的symbol也是值，但它不是字符串，也不是对象，而是是全新的——第七种类型的原始值。Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是**独一无二**的，可以保证不会与其他属性名产生冲突。\n\n让我们一起探讨一下symbol的实际应用场景。\n\n### 从一个简单的布尔类型出发\n\n有时候你可以非常轻松地将别人的外部数据存储到一个JavaScript对象中。\n\n举 个例子，假设你正在写一个JS库，可以通过CSS transitions使DOM元素在屏幕上移动。你可能会注意到，当你尝试在一个div元素上同时应用多重CSS transitions时并不会生效。实际效果是丑陋而又不连续的“跳闪”。你认为可以修复这个问题，但前提是你需要一种发现给定元素是否已经移动过的方 法。\n\n###### 应当如何解决这个问题呢？\n\n一种方法是，用CSS API来告诉浏览器元素是否正在移动，但这样简直小题大做。在元素移动的第一时间内你的库就应该记录下移动的状态，所以它自然知道元素正在移动。\n\n你真正想要的是一种持续跟踪某个元素正在移动的方法。你可以维护一个数组，记录所有正在移动的元素，每当你的库被调用来移动某个元素时，你可以检索数组来查看元素是否已经存在，亦即它是否正在移动中。\n\n当然，如果数组非常大的话，线性搜索将会非常缓慢。\n\n实际上你只想为元素设置一个标记：\n```javascript\nif (element.isMoving) {\n  smoothAnimations(element);\n}\nelement.isMoving = true;\n```\n这样也会有一些潜在的问题，事实上，你的代码很可能不是唯一一段操作DOM的代码。\n\n1. 你创建的属性很可能影响到其它使用了for-in或Object.keys()的代码。\n2. 一些聪明的库作者可能已经考虑并使用了这项技术，这样一来你的库就会与已有的库产生某些冲突\n3. 当然，很可能你比他们更聪明，你先采用了这项技术，但是他们的库仍然无法与你的库默契配合。\n4. 标准委员会可能决定为所有的元素增加一个.isMoving()方法，到那时你需要重写相关逻辑，必定会有深深的挫败感。\n当然你可以选择一个乏味而愚蠢的命名（其他人根本不会想用的那些名称）来解决最后的三个问题：\n```javascript\nif (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) {\n  smoothAnimations(element);\n}\nelement.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true;\n```\n这只会造成无畏的眼疲劳。为什么这个问题如此困难？我们只想要一个小小的布尔值啊！\n\n### symbol是最终的解决方案\n\nsymbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。\n\n``var mySymbol = Symbol();``\n调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等。\n\n字符串或数字可以作为属性的键，symbol也可以，它不等同于任何字符串，因而这个以symbol为键的属性可以保证不与任何其它属性产生冲突。\n```javascript\nobj[mySymbol] = \"ok!\";  // 保证不会冲突\nconsole.log(obj[mySymbol]);  // ok!\n```\n想要在上述讨论的场景中使用symbol，你可以这样做：\n```javascript\n// 创建一个独一无二的symbol\nvar isMoving = Symbol(\"isMoving\");\n...\nif (element[isMoving]) {\n  smoothAnimations(element);\n}\nelement[isMoving] = true;\n```\n有关这段代码的一些解释：\n\n - **Symbol(\"isMoving\")**中的isMoving被称作描述。你可以通过console.log()将它打印出来，对调试非常有帮助；你也可以用.toString()方法将它转换为字符串呈现；它也可以被用在错误信息中。\n\n - element[isMoving]被称作一个以symbol为键（symbol-keyed）的属性。简而言之，它的名字是symbol而不是一个字符串。除此之外，它与一个普通的属性没有什么区别。\n\n - 以symbol为键的属性属性与数组元素类似，**不能被类似obj.name的点号法访问，你必须使用方括号访问**这些属性。\n\n - 如果你已经得到了symbol，那么访问一个以symbol为键的属性同样简单，以上的示例很好地展示了如何获取element[isMoving]的值以及如何为它赋值。如果我们需要，可以查看属性是否存在：``if (isMoving in element)``，也可以删除属性：``delete element[isMoving]``。\n\n - 另一方面，只有当isMoving在当前作用域中时才会生效。这是symbol的弱封装机制：模块创建了几个symbol，可以在任意对象上使用，无须担心与其它代码创建的属性产生冲突。\n\nsymbol键的设计初衷是避免冲突，因此JavaScript中最常见的对象检查的特性会忽略symbol键。例如，for-in循环只会遍历对象的字符串键，symbol键直接跳过，Object.keys(obj)和Object.getOwnPropertyNames(obj)也是一样。但是symbols也不完全是私有的：用新的APIObject.getOwnPropertySymbols(obj)就可以列出对象的symbol键。另一个新的API，Reflect.ownKeys(obj)，会同时返回字符串键和symbol键。（我们将在随后的文章中讲解Reflect(反射) API）。\n\n慢慢地我们会发现，越来越多的库和框架将大量使用symbol，语言本身也会将symbol应用于广泛的用途。\n\n但是，到底什么是symbol呢？\n```javascript\n> typeof Symbol()\n\"symbol\"\n```\n确切地说，symbol与其它类型并不完全相像。\n\nsymbol被创建后就不可变更，你不能为它设置属性（在严格模式下尝试设置属性会得到TypeError的错误）。他们可以用作属性名称，这些性质与字符串类似。\n\n另一方面，每一个symbol都独一无二，不与其它symbol等同，即使二者有相同的描述也不相等；你可以轻松地创建一个新的symbol。这些性质与对象类似。\n\nES6中的symbol与Lisp和Ruby这些语言中更传统的symbol类似，但不像它们集成得那么紧密。在Lisp中，所有的标识符都是symbol；在JS中，标识符和大多数的属性键仍然是字符串，symbol只是一个额外的选项。\n\n关于symbol的忠告：symbol不能被自动转换为字符串，这和语言中的其它类型不同。尝试拼接symbol与字符串将得到TypeError错误。\n```javascript\n> var sym = Symbol(\"<3\");\n> \"your symbol is \" + sym\n// TypeError: can't convert symbol to string\n> `your symbol is ${sym}`\n// TypeError: can't convert symbol to string\n```\n通过String(sym)或sym.toString()可以显示地将symbol转换为一个字符串，从而回避这个问题。\n\n获取symbol的三种方法\n\n有三种获取symbol的方法。\n\n1. 调用Symbol()。正如我们上文中所讨论的，这种方式每次调用都会返回一个新的唯一symbol。\n\n2. 调用Symbol.for(string)。这种方式会访问symbol注册表，其中存储了已经存在的一系列symbol。这种方式与通过Symbol()定义的独立symbol不同，symbol注册表中的symbol是共享的。如果你连续三十次调用Symbol.for(\"cat\")，每次都会返回相同的symbol。注册表非常有用，在多个web页面或同一个web页面的多个模块中经常需要共享一个symbol。\n\n3. 使用标准定义的symbol，例如：Symbol.iterator。标准根据一些特殊用途定义了少许的几个symbol。\n\n\n","slug":"ES2015第七种数据结构Symbols","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfch000ozk4o5kgmv3y9","content":"<p>1997年JavaScript首次被标准化，那时只有六种原始类型，在ES6以前，JS程序中使用的每一个值都是以下几种类型之一：</p>\n<ul>\n<li>Undefined 未定义</li>\n<li>Null 空值</li>\n<li>Boolean 布尔类型</li>\n<li>Number 数字类型</li>\n<li>String 字符串类型</li>\n<li>Object 对象类型</li>\n</ul>\n<p>每种类型都是多个值的集合，前五个集合是有限的。布尔类型只有两个值，true和false，不会再创造第三种布尔值；数字类型和字符串类型的值更多。然而，对象类型值的集合是无限的。每一个对象都像珍贵的雪花一样独一无二，每一次你打开一个Web页面，都会创建一堆对象。</p>\n<blockquote>\n<p> ES6新特性中的symbol也是值，但它不是字符串，也不是对象，而是是全新的——第七种类型的原始值。Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是<strong>独一无二</strong>的，可以保证不会与其他属性名产生冲突。</p>\n</blockquote>\n<p>让我们一起探讨一下symbol的实际应用场景。</p>\n<h3 id=\"从一个简单的布尔类型出发\"><a href=\"#从一个简单的布尔类型出发\" class=\"headerlink\" title=\"从一个简单的布尔类型出发\"></a>从一个简单的布尔类型出发</h3><p>有时候你可以非常轻松地将别人的外部数据存储到一个JavaScript对象中。</p>\n<p>举 个例子，假设你正在写一个JS库，可以通过CSS transitions使DOM元素在屏幕上移动。你可能会注意到，当你尝试在一个div元素上同时应用多重CSS transitions时并不会生效。实际效果是丑陋而又不连续的“跳闪”。你认为可以修复这个问题，但前提是你需要一种发现给定元素是否已经移动过的方 法。</p>\n<h6 id=\"应当如何解决这个问题呢？\"><a href=\"#应当如何解决这个问题呢？\" class=\"headerlink\" title=\"应当如何解决这个问题呢？\"></a>应当如何解决这个问题呢？</h6><p>一种方法是，用CSS API来告诉浏览器元素是否正在移动，但这样简直小题大做。在元素移动的第一时间内你的库就应该记录下移动的状态，所以它自然知道元素正在移动。</p>\n<p>你真正想要的是一种持续跟踪某个元素正在移动的方法。你可以维护一个数组，记录所有正在移动的元素，每当你的库被调用来移动某个元素时，你可以检索数组来查看元素是否已经存在，亦即它是否正在移动中。</p>\n<p>当然，如果数组非常大的话，线性搜索将会非常缓慢。</p>\n<p>实际上你只想为元素设置一个标记：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (element.isMoving) &#123;</div><div class=\"line\">  smoothAnimations(element);</div><div class=\"line\">&#125;</div><div class=\"line\">element.isMoving = <span class=\"literal\">true</span>;</div></pre></td></tr></table></figure></p>\n<p>这样也会有一些潜在的问题，事实上，你的代码很可能不是唯一一段操作DOM的代码。</p>\n<ol>\n<li>你创建的属性很可能影响到其它使用了for-in或Object.keys()的代码。</li>\n<li>一些聪明的库作者可能已经考虑并使用了这项技术，这样一来你的库就会与已有的库产生某些冲突</li>\n<li>当然，很可能你比他们更聪明，你先采用了这项技术，但是他们的库仍然无法与你的库默契配合。</li>\n<li>标准委员会可能决定为所有的元素增加一个.isMoving()方法，到那时你需要重写相关逻辑，必定会有深深的挫败感。<br>当然你可以选择一个乏味而愚蠢的命名（其他人根本不会想用的那些名称）来解决最后的三个问题：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) &#123;</div><div class=\"line\">  smoothAnimations(element);</div><div class=\"line\">&#125;</div><div class=\"line\">element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = <span class=\"literal\">true</span>;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这只会造成无畏的眼疲劳。为什么这个问题如此困难？我们只想要一个小小的布尔值啊！</p>\n<h3 id=\"symbol是最终的解决方案\"><a href=\"#symbol是最终的解决方案\" class=\"headerlink\" title=\"symbol是最终的解决方案\"></a>symbol是最终的解决方案</h3><p>symbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。</p>\n<p><code>var mySymbol = Symbol();</code><br>调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等。</p>\n<p>字符串或数字可以作为属性的键，symbol也可以，它不等同于任何字符串，因而这个以symbol为键的属性可以保证不与任何其它属性产生冲突。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj[mySymbol] = <span class=\"string\">\"ok!\"</span>;  <span class=\"comment\">// 保证不会冲突</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj[mySymbol]);  <span class=\"comment\">// ok!</span></div></pre></td></tr></table></figure></p>\n<p>想要在上述讨论的场景中使用symbol，你可以这样做：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个独一无二的symbol</span></div><div class=\"line\"><span class=\"keyword\">var</span> isMoving = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"isMoving\"</span>);</div><div class=\"line\">...</div><div class=\"line\">if (element[isMoving]) &#123;</div><div class=\"line\">  smoothAnimations(element);</div><div class=\"line\">&#125;</div><div class=\"line\">element[isMoving] = <span class=\"literal\">true</span>;</div></pre></td></tr></table></figure></p>\n<p>有关这段代码的一些解释：</p>\n<ul>\n<li><p><strong>Symbol(“isMoving”)</strong>中的isMoving被称作描述。你可以通过console.log()将它打印出来，对调试非常有帮助；你也可以用.toString()方法将它转换为字符串呈现；它也可以被用在错误信息中。</p>\n</li>\n<li><p>element[isMoving]被称作一个以symbol为键（symbol-keyed）的属性。简而言之，它的名字是symbol而不是一个字符串。除此之外，它与一个普通的属性没有什么区别。</p>\n</li>\n<li><p>以symbol为键的属性属性与数组元素类似，<strong>不能被类似obj.name的点号法访问，你必须使用方括号访问</strong>这些属性。</p>\n</li>\n<li><p>如果你已经得到了symbol，那么访问一个以symbol为键的属性同样简单，以上的示例很好地展示了如何获取element[isMoving]的值以及如何为它赋值。如果我们需要，可以查看属性是否存在：<code>if (isMoving in element)</code>，也可以删除属性：<code>delete element[isMoving]</code>。</p>\n</li>\n<li><p>另一方面，只有当isMoving在当前作用域中时才会生效。这是symbol的弱封装机制：模块创建了几个symbol，可以在任意对象上使用，无须担心与其它代码创建的属性产生冲突。</p>\n</li>\n</ul>\n<p>symbol键的设计初衷是避免冲突，因此JavaScript中最常见的对象检查的特性会忽略symbol键。例如，for-in循环只会遍历对象的字符串键，symbol键直接跳过，Object.keys(obj)和Object.getOwnPropertyNames(obj)也是一样。但是symbols也不完全是私有的：用新的APIObject.getOwnPropertySymbols(obj)就可以列出对象的symbol键。另一个新的API，Reflect.ownKeys(obj)，会同时返回字符串键和symbol键。（我们将在随后的文章中讲解Reflect(反射) API）。</p>\n<p>慢慢地我们会发现，越来越多的库和框架将大量使用symbol，语言本身也会将symbol应用于广泛的用途。</p>\n<p>但是，到底什么是symbol呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; <span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>()</div><div class=\"line\"><span class=\"string\">\"symbol\"</span></div></pre></td></tr></table></figure></p>\n<p>确切地说，symbol与其它类型并不完全相像。</p>\n<p>symbol被创建后就不可变更，你不能为它设置属性（在严格模式下尝试设置属性会得到TypeError的错误）。他们可以用作属性名称，这些性质与字符串类似。</p>\n<p>另一方面，每一个symbol都独一无二，不与其它symbol等同，即使二者有相同的描述也不相等；你可以轻松地创建一个新的symbol。这些性质与对象类似。</p>\n<p>ES6中的symbol与Lisp和Ruby这些语言中更传统的symbol类似，但不像它们集成得那么紧密。在Lisp中，所有的标识符都是symbol；在JS中，标识符和大多数的属性键仍然是字符串，symbol只是一个额外的选项。</p>\n<p>关于symbol的忠告：symbol不能被自动转换为字符串，这和语言中的其它类型不同。尝试拼接symbol与字符串将得到TypeError错误。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; <span class=\"keyword\">var</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"&lt;3\"</span>);</div><div class=\"line\">&gt; <span class=\"string\">\"your symbol is \"</span> + sym</div><div class=\"line\"><span class=\"comment\">// TypeError: can't convert symbol to string</span></div><div class=\"line\">&gt; <span class=\"string\">`your symbol is <span class=\"subst\">$&#123;sym&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// TypeError: can't convert symbol to string</span></div></pre></td></tr></table></figure></p>\n<p>通过String(sym)或sym.toString()可以显示地将symbol转换为一个字符串，从而回避这个问题。</p>\n<p>获取symbol的三种方法</p>\n<p>有三种获取symbol的方法。</p>\n<ol>\n<li><p>调用Symbol()。正如我们上文中所讨论的，这种方式每次调用都会返回一个新的唯一symbol。</p>\n</li>\n<li><p>调用Symbol.for(string)。这种方式会访问symbol注册表，其中存储了已经存在的一系列symbol。这种方式与通过Symbol()定义的独立symbol不同，symbol注册表中的symbol是共享的。如果你连续三十次调用Symbol.for(“cat”)，每次都会返回相同的symbol。注册表非常有用，在多个web页面或同一个web页面的多个模块中经常需要共享一个symbol。</p>\n</li>\n<li><p>使用标准定义的symbol，例如：Symbol.iterator。标准根据一些特殊用途定义了少许的几个symbol。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>1997年JavaScript首次被标准化，那时只有六种原始类型，在ES6以前，JS程序中使用的每一个值都是以下几种类型之一：</p>\n<ul>\n<li>Undefined 未定义</li>\n<li>Null 空值</li>\n<li>Boolean 布尔类型</li>\n<li>Number 数字类型</li>\n<li>String 字符串类型</li>\n<li>Object 对象类型</li>\n</ul>\n<p>每种类型都是多个值的集合，前五个集合是有限的。布尔类型只有两个值，true和false，不会再创造第三种布尔值；数字类型和字符串类型的值更多。然而，对象类型值的集合是无限的。每一个对象都像珍贵的雪花一样独一无二，每一次你打开一个Web页面，都会创建一堆对象。</p>\n<blockquote>\n<p> ES6新特性中的symbol也是值，但它不是字符串，也不是对象，而是是全新的——第七种类型的原始值。Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是<strong>独一无二</strong>的，可以保证不会与其他属性名产生冲突。</p>\n</blockquote>\n<p>让我们一起探讨一下symbol的实际应用场景。</p>\n<h3 id=\"从一个简单的布尔类型出发\"><a href=\"#从一个简单的布尔类型出发\" class=\"headerlink\" title=\"从一个简单的布尔类型出发\"></a>从一个简单的布尔类型出发</h3><p>有时候你可以非常轻松地将别人的外部数据存储到一个JavaScript对象中。</p>\n<p>举 个例子，假设你正在写一个JS库，可以通过CSS transitions使DOM元素在屏幕上移动。你可能会注意到，当你尝试在一个div元素上同时应用多重CSS transitions时并不会生效。实际效果是丑陋而又不连续的“跳闪”。你认为可以修复这个问题，但前提是你需要一种发现给定元素是否已经移动过的方 法。</p>\n<h6 id=\"应当如何解决这个问题呢？\"><a href=\"#应当如何解决这个问题呢？\" class=\"headerlink\" title=\"应当如何解决这个问题呢？\"></a>应当如何解决这个问题呢？</h6><p>一种方法是，用CSS API来告诉浏览器元素是否正在移动，但这样简直小题大做。在元素移动的第一时间内你的库就应该记录下移动的状态，所以它自然知道元素正在移动。</p>\n<p>你真正想要的是一种持续跟踪某个元素正在移动的方法。你可以维护一个数组，记录所有正在移动的元素，每当你的库被调用来移动某个元素时，你可以检索数组来查看元素是否已经存在，亦即它是否正在移动中。</p>\n<p>当然，如果数组非常大的话，线性搜索将会非常缓慢。</p>\n<p>实际上你只想为元素设置一个标记：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (element.isMoving) &#123;</div><div class=\"line\">  smoothAnimations(element);</div><div class=\"line\">&#125;</div><div class=\"line\">element.isMoving = <span class=\"literal\">true</span>;</div></pre></td></tr></table></figure></p>\n<p>这样也会有一些潜在的问题，事实上，你的代码很可能不是唯一一段操作DOM的代码。</p>\n<ol>\n<li>你创建的属性很可能影响到其它使用了for-in或Object.keys()的代码。</li>\n<li>一些聪明的库作者可能已经考虑并使用了这项技术，这样一来你的库就会与已有的库产生某些冲突</li>\n<li>当然，很可能你比他们更聪明，你先采用了这项技术，但是他们的库仍然无法与你的库默契配合。</li>\n<li>标准委员会可能决定为所有的元素增加一个.isMoving()方法，到那时你需要重写相关逻辑，必定会有深深的挫败感。<br>当然你可以选择一个乏味而愚蠢的命名（其他人根本不会想用的那些名称）来解决最后的三个问题：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) &#123;</div><div class=\"line\">  smoothAnimations(element);</div><div class=\"line\">&#125;</div><div class=\"line\">element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = <span class=\"literal\">true</span>;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这只会造成无畏的眼疲劳。为什么这个问题如此困难？我们只想要一个小小的布尔值啊！</p>\n<h3 id=\"symbol是最终的解决方案\"><a href=\"#symbol是最终的解决方案\" class=\"headerlink\" title=\"symbol是最终的解决方案\"></a>symbol是最终的解决方案</h3><p>symbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。</p>\n<p><code>var mySymbol = Symbol();</code><br>调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等。</p>\n<p>字符串或数字可以作为属性的键，symbol也可以，它不等同于任何字符串，因而这个以symbol为键的属性可以保证不与任何其它属性产生冲突。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj[mySymbol] = <span class=\"string\">\"ok!\"</span>;  <span class=\"comment\">// 保证不会冲突</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj[mySymbol]);  <span class=\"comment\">// ok!</span></div></pre></td></tr></table></figure></p>\n<p>想要在上述讨论的场景中使用symbol，你可以这样做：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 创建一个独一无二的symbol</span></div><div class=\"line\"><span class=\"keyword\">var</span> isMoving = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"isMoving\"</span>);</div><div class=\"line\">...</div><div class=\"line\">if (element[isMoving]) &#123;</div><div class=\"line\">  smoothAnimations(element);</div><div class=\"line\">&#125;</div><div class=\"line\">element[isMoving] = <span class=\"literal\">true</span>;</div></pre></td></tr></table></figure></p>\n<p>有关这段代码的一些解释：</p>\n<ul>\n<li><p><strong>Symbol(“isMoving”)</strong>中的isMoving被称作描述。你可以通过console.log()将它打印出来，对调试非常有帮助；你也可以用.toString()方法将它转换为字符串呈现；它也可以被用在错误信息中。</p>\n</li>\n<li><p>element[isMoving]被称作一个以symbol为键（symbol-keyed）的属性。简而言之，它的名字是symbol而不是一个字符串。除此之外，它与一个普通的属性没有什么区别。</p>\n</li>\n<li><p>以symbol为键的属性属性与数组元素类似，<strong>不能被类似obj.name的点号法访问，你必须使用方括号访问</strong>这些属性。</p>\n</li>\n<li><p>如果你已经得到了symbol，那么访问一个以symbol为键的属性同样简单，以上的示例很好地展示了如何获取element[isMoving]的值以及如何为它赋值。如果我们需要，可以查看属性是否存在：<code>if (isMoving in element)</code>，也可以删除属性：<code>delete element[isMoving]</code>。</p>\n</li>\n<li><p>另一方面，只有当isMoving在当前作用域中时才会生效。这是symbol的弱封装机制：模块创建了几个symbol，可以在任意对象上使用，无须担心与其它代码创建的属性产生冲突。</p>\n</li>\n</ul>\n<p>symbol键的设计初衷是避免冲突，因此JavaScript中最常见的对象检查的特性会忽略symbol键。例如，for-in循环只会遍历对象的字符串键，symbol键直接跳过，Object.keys(obj)和Object.getOwnPropertyNames(obj)也是一样。但是symbols也不完全是私有的：用新的APIObject.getOwnPropertySymbols(obj)就可以列出对象的symbol键。另一个新的API，Reflect.ownKeys(obj)，会同时返回字符串键和symbol键。（我们将在随后的文章中讲解Reflect(反射) API）。</p>\n<p>慢慢地我们会发现，越来越多的库和框架将大量使用symbol，语言本身也会将symbol应用于广泛的用途。</p>\n<p>但是，到底什么是symbol呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; <span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>()</div><div class=\"line\"><span class=\"string\">\"symbol\"</span></div></pre></td></tr></table></figure></p>\n<p>确切地说，symbol与其它类型并不完全相像。</p>\n<p>symbol被创建后就不可变更，你不能为它设置属性（在严格模式下尝试设置属性会得到TypeError的错误）。他们可以用作属性名称，这些性质与字符串类似。</p>\n<p>另一方面，每一个symbol都独一无二，不与其它symbol等同，即使二者有相同的描述也不相等；你可以轻松地创建一个新的symbol。这些性质与对象类似。</p>\n<p>ES6中的symbol与Lisp和Ruby这些语言中更传统的symbol类似，但不像它们集成得那么紧密。在Lisp中，所有的标识符都是symbol；在JS中，标识符和大多数的属性键仍然是字符串，symbol只是一个额外的选项。</p>\n<p>关于symbol的忠告：symbol不能被自动转换为字符串，这和语言中的其它类型不同。尝试拼接symbol与字符串将得到TypeError错误。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; <span class=\"keyword\">var</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"&lt;3\"</span>);</div><div class=\"line\">&gt; <span class=\"string\">\"your symbol is \"</span> + sym</div><div class=\"line\"><span class=\"comment\">// TypeError: can't convert symbol to string</span></div><div class=\"line\">&gt; <span class=\"string\">`your symbol is <span class=\"subst\">$&#123;sym&#125;</span>`</span></div><div class=\"line\"><span class=\"comment\">// TypeError: can't convert symbol to string</span></div></pre></td></tr></table></figure></p>\n<p>通过String(sym)或sym.toString()可以显示地将symbol转换为一个字符串，从而回避这个问题。</p>\n<p>获取symbol的三种方法</p>\n<p>有三种获取symbol的方法。</p>\n<ol>\n<li><p>调用Symbol()。正如我们上文中所讨论的，这种方式每次调用都会返回一个新的唯一symbol。</p>\n</li>\n<li><p>调用Symbol.for(string)。这种方式会访问symbol注册表，其中存储了已经存在的一系列symbol。这种方式与通过Symbol()定义的独立symbol不同，symbol注册表中的symbol是共享的。如果你连续三十次调用Symbol.for(“cat”)，每次都会返回相同的symbol。注册表非常有用，在多个web页面或同一个web页面的多个模块中经常需要共享一个symbol。</p>\n</li>\n<li><p>使用标准定义的symbol，例如：Symbol.iterator。标准根据一些特殊用途定义了少许的几个symbol。</p>\n</li>\n</ol>\n"},{"title":"Vue2 中的生命周期","date":"2016-10-25T08:56:34.000Z","_content":">  项目从Vue1升级到Vue2，记录常见的改动。\n\n### 生命周期图示\n\n下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。\n![Vue2的生命周期](https://vuefe.cn/images/lifecycle.png)\n![Vue1和Vue2生命周期的区别](https://cloud.githubusercontent.com/assets/12537013/17702060/f847b38a-63fe-11e6-9c29-38e58d46f036.png)\n\n\n\n","source":"_posts/Vue2-中的生命周期.md","raw":"---\ntitle: Vue2 中的生命周期\ndate: 2016-10-25 16:56:34\ntags: Vue\n---\n>  项目从Vue1升级到Vue2，记录常见的改动。\n\n### 生命周期图示\n\n下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。\n![Vue2的生命周期](https://vuefe.cn/images/lifecycle.png)\n![Vue1和Vue2生命周期的区别](https://cloud.githubusercontent.com/assets/12537013/17702060/f847b38a-63fe-11e6-9c29-38e58d46f036.png)\n\n\n\n","slug":"Vue2-中的生命周期","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfcj000qzk4ocd9mtgjr","content":"<blockquote>\n<p> 项目从Vue1升级到Vue2，记录常见的改动。</p>\n</blockquote>\n<h3 id=\"生命周期图示\"><a href=\"#生命周期图示\" class=\"headerlink\" title=\"生命周期图示\"></a>生命周期图示</h3><p>下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。<br><img src=\"https://vuefe.cn/images/lifecycle.png\" alt=\"Vue2的生命周期\"><br><img src=\"https://cloud.githubusercontent.com/assets/12537013/17702060/f847b38a-63fe-11e6-9c29-38e58d46f036.png\" alt=\"Vue1和Vue2生命周期的区别\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 项目从Vue1升级到Vue2，记录常见的改动。</p>\n</blockquote>\n<h3 id=\"生命周期图示\"><a href=\"#生命周期图示\" class=\"headerlink\" title=\"生命周期图示\"></a>生命周期图示</h3><p>下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。<br><img src=\"https://vuefe.cn/images/lifecycle.png\" alt=\"Vue2的生命周期\"><br><img src=\"https://cloud.githubusercontent.com/assets/12537013/17702060/f847b38a-63fe-11e6-9c29-38e58d46f036.png\" alt=\"Vue1和Vue2生命周期的区别\"></p>\n"},{"title":"Html5的file API","date":"2016-10-21T15:54:13.000Z","_content":"> 在*html4*的年代，我们如果要在网页上呈现一张用户本地的图片，需要用户先把图片上传到服务器，再根据服务器提供的图片地址把图片下载下来，才能把图片在网页上呈现出来。这一来二往，起码已经费了两倍于这张图片的流量了，更别说服务器为了存储这张图片所花费的资源以及用户上传错了图片的冤枉成本（因为在html4时代，用户选择好图片后，往往只能看到图片的文件名，而无法通过预览图来进一步确认这张图片是否就是自己想要上传的）。html5提供了新玩法，光靠浏览器，就可以对本地的（其实也可以是远程的）文件（主要是图片）进行**呈现、读取、处理**等操作，而这一切，则是通过html5 **file api**来实现的。\n\n  首先是*数据结构*，html5定义了一个**file**对象类型来表示文件，每个file对象对应一个文件。file对象有3个属性：*name*、*size*、*type*。name是不包含路径的文件名，size是以字节为单位的文件体积大小，type则是文件的MIME（例如image/jpg）。\n\n  file对象不单独存在，而是以数组形式，存在一个名为FileList的数组中。那么，如何拿到这个FileList数组呢？目前，html5有两个途径可以拿到FileList，**一是通过file类型的input**，**二是通过拖放操作的drop事件**。\n\n### 通过file类型的input获取FileList\n``<input id=\"file-input\" type=\"file\" />``\n或html5新增的可进行文件多选的multiple属性：\n\n``<input id=\"file-input\" type=\"file\" multiple />``\n一般，我们都是给input:file绑上一个*onchange*事件，以便在用户选定文件后，马上进行读取文件等下一步操作：\n{% codeblock lang:js %}\n//原生js\nvar inputElement = document.getElementById(\"file-input\");\ninputElement.addEventListener(\"change\", handleFiles, false);\nfunction handleFiles() {\n  var fileList = this.files; \n}\n\n//jquery版\n$('#file-input').on('change', function() {\n    var fileList = this.files;\n});\n{% endcodeblock %}\n### 通过拖放操作drop事件\n首先要设定一个可供拖放的区域：\n``<div id=\"dropbox\" style=\"width: 200px;height: 200px;\"></div>``\n另外，为了能**触发drop**事件，我们必须阻止dragenter和dragover事件的默认行为：\n{% codeblock lang:js %}\nvar dropbox;\ndropbox = document.getElementById(\"dropbox\");\ndropbox.addEventListener(\"dragenter\", dragenter, false);\ndropbox.addEventListener(\"dragover\", dragover, false);\ndropbox.addEventListener(\"drop\", drop, false);\nfunction dragenter(e) {\n  e.stopPropagation();\n  e.preventDefault();\n}\n\nfunction dragover(e) {\n  e.stopPropagation();\n  e.preventDefault();\n}\n{% endcodeblock %}\n然后，我们就可以在drop事件的callback中，获取到fileList：\n{% codeblock lang:js %}\nfunction drop(e) {\n  e.stopPropagation();\n  e.preventDefault();\n\n  var dt = e.dataTransfer;\n  var files = dt.files;\n\n  handleFiles(files);\n}\n{% endcodeblock %}\n<!--more-->\n>  怎么读取或利用file对象呢？html5提供了两个方案：**FileReader**和**ObjectUrl**。\n\n### 使用FileReader读取file对象\n首先需要实例化FileReader对象：\n``\nvar reader = new FileReader();\n``\n利用FileReader读取file对象是一个**异步**的过程，我们需要先为FileReader设置好load事件的callback，告知FileReader在读取到file对象的数据后应该进行什么进一步的操作：\n``\nreader.onload = function(e) { \n    document.getElementById(\"image\").src = e.target.result; \n}\n``\n上面这段代码的意思是，FileReader读取到图片的数据后，把数据（DataUrl）放到<img>的src属性里。最后，就是通过FileReader不同的方法，来决定读取file对象数据后用什么数据格式来存放，并实施读取：\n\n1. readAsArrayBuffer(file) ：读取file对象并存放为ArrayBuffer对象（ArrayBuffer对象是什么我暂时没有搞清，应该是一种为了高效存取数据而产生的数据结构）。\n2. readAsText(file [, 'UTF-8']) ：以一般文本模式读取file对象，值得注意的是，利用第二个参数（可选）可指定字符编码。\n3. readAsDataURL(file) ：读取file对象并存放为data: URL格式的字符串。\n\n### 利用ObjectURL\nObjectURL相当于文件的一个临时路径，此临时路径可随时生成、随时释放，在本地浏览器使用起来时，与普通的url无异。以把一张本地图片显示在页面上为例：\n``\nvar img = document.createElement(\"img\");\nimg.src = window.URL.createObjectURL(file);\n``\n此时，src形如：blob:http://test.local.com/e03e8bbf-66ce-4fea-a8c8-772f9fdb4d40\n用这个src就能让浏览器从本地读取图片。\n这种方案相对用FileReader生成图片的base64编码并放到<img>的src里来说，性能有了很大的提升。\n\n比较这两种读取File对象的方案，**FileReader适合用来上传文件**，而**ObjectURL则适合直接在浏览器进行操作，然后操作后再把处理后的数据进行上传，例如利用canvas截图或进行图片压缩等**。当然，这一切都是要考虑*兼容性*的。","source":"_posts/Html5的file-API.md","raw":"---\ntitle: Html5的file API\ndate: 2016-10-21 23:54:13\ntags: Html5\n---\n> 在*html4*的年代，我们如果要在网页上呈现一张用户本地的图片，需要用户先把图片上传到服务器，再根据服务器提供的图片地址把图片下载下来，才能把图片在网页上呈现出来。这一来二往，起码已经费了两倍于这张图片的流量了，更别说服务器为了存储这张图片所花费的资源以及用户上传错了图片的冤枉成本（因为在html4时代，用户选择好图片后，往往只能看到图片的文件名，而无法通过预览图来进一步确认这张图片是否就是自己想要上传的）。html5提供了新玩法，光靠浏览器，就可以对本地的（其实也可以是远程的）文件（主要是图片）进行**呈现、读取、处理**等操作，而这一切，则是通过html5 **file api**来实现的。\n\n  首先是*数据结构*，html5定义了一个**file**对象类型来表示文件，每个file对象对应一个文件。file对象有3个属性：*name*、*size*、*type*。name是不包含路径的文件名，size是以字节为单位的文件体积大小，type则是文件的MIME（例如image/jpg）。\n\n  file对象不单独存在，而是以数组形式，存在一个名为FileList的数组中。那么，如何拿到这个FileList数组呢？目前，html5有两个途径可以拿到FileList，**一是通过file类型的input**，**二是通过拖放操作的drop事件**。\n\n### 通过file类型的input获取FileList\n``<input id=\"file-input\" type=\"file\" />``\n或html5新增的可进行文件多选的multiple属性：\n\n``<input id=\"file-input\" type=\"file\" multiple />``\n一般，我们都是给input:file绑上一个*onchange*事件，以便在用户选定文件后，马上进行读取文件等下一步操作：\n{% codeblock lang:js %}\n//原生js\nvar inputElement = document.getElementById(\"file-input\");\ninputElement.addEventListener(\"change\", handleFiles, false);\nfunction handleFiles() {\n  var fileList = this.files; \n}\n\n//jquery版\n$('#file-input').on('change', function() {\n    var fileList = this.files;\n});\n{% endcodeblock %}\n### 通过拖放操作drop事件\n首先要设定一个可供拖放的区域：\n``<div id=\"dropbox\" style=\"width: 200px;height: 200px;\"></div>``\n另外，为了能**触发drop**事件，我们必须阻止dragenter和dragover事件的默认行为：\n{% codeblock lang:js %}\nvar dropbox;\ndropbox = document.getElementById(\"dropbox\");\ndropbox.addEventListener(\"dragenter\", dragenter, false);\ndropbox.addEventListener(\"dragover\", dragover, false);\ndropbox.addEventListener(\"drop\", drop, false);\nfunction dragenter(e) {\n  e.stopPropagation();\n  e.preventDefault();\n}\n\nfunction dragover(e) {\n  e.stopPropagation();\n  e.preventDefault();\n}\n{% endcodeblock %}\n然后，我们就可以在drop事件的callback中，获取到fileList：\n{% codeblock lang:js %}\nfunction drop(e) {\n  e.stopPropagation();\n  e.preventDefault();\n\n  var dt = e.dataTransfer;\n  var files = dt.files;\n\n  handleFiles(files);\n}\n{% endcodeblock %}\n<!--more-->\n>  怎么读取或利用file对象呢？html5提供了两个方案：**FileReader**和**ObjectUrl**。\n\n### 使用FileReader读取file对象\n首先需要实例化FileReader对象：\n``\nvar reader = new FileReader();\n``\n利用FileReader读取file对象是一个**异步**的过程，我们需要先为FileReader设置好load事件的callback，告知FileReader在读取到file对象的数据后应该进行什么进一步的操作：\n``\nreader.onload = function(e) { \n    document.getElementById(\"image\").src = e.target.result; \n}\n``\n上面这段代码的意思是，FileReader读取到图片的数据后，把数据（DataUrl）放到<img>的src属性里。最后，就是通过FileReader不同的方法，来决定读取file对象数据后用什么数据格式来存放，并实施读取：\n\n1. readAsArrayBuffer(file) ：读取file对象并存放为ArrayBuffer对象（ArrayBuffer对象是什么我暂时没有搞清，应该是一种为了高效存取数据而产生的数据结构）。\n2. readAsText(file [, 'UTF-8']) ：以一般文本模式读取file对象，值得注意的是，利用第二个参数（可选）可指定字符编码。\n3. readAsDataURL(file) ：读取file对象并存放为data: URL格式的字符串。\n\n### 利用ObjectURL\nObjectURL相当于文件的一个临时路径，此临时路径可随时生成、随时释放，在本地浏览器使用起来时，与普通的url无异。以把一张本地图片显示在页面上为例：\n``\nvar img = document.createElement(\"img\");\nimg.src = window.URL.createObjectURL(file);\n``\n此时，src形如：blob:http://test.local.com/e03e8bbf-66ce-4fea-a8c8-772f9fdb4d40\n用这个src就能让浏览器从本地读取图片。\n这种方案相对用FileReader生成图片的base64编码并放到<img>的src里来说，性能有了很大的提升。\n\n比较这两种读取File对象的方案，**FileReader适合用来上传文件**，而**ObjectURL则适合直接在浏览器进行操作，然后操作后再把处理后的数据进行上传，例如利用canvas截图或进行图片压缩等**。当然，这一切都是要考虑*兼容性*的。","slug":"Html5的file-API","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfcl000szk4ol8q47ob1","content":"<blockquote>\n<p>在<em>html4</em>的年代，我们如果要在网页上呈现一张用户本地的图片，需要用户先把图片上传到服务器，再根据服务器提供的图片地址把图片下载下来，才能把图片在网页上呈现出来。这一来二往，起码已经费了两倍于这张图片的流量了，更别说服务器为了存储这张图片所花费的资源以及用户上传错了图片的冤枉成本（因为在html4时代，用户选择好图片后，往往只能看到图片的文件名，而无法通过预览图来进一步确认这张图片是否就是自己想要上传的）。html5提供了新玩法，光靠浏览器，就可以对本地的（其实也可以是远程的）文件（主要是图片）进行<strong>呈现、读取、处理</strong>等操作，而这一切，则是通过html5 <strong>file api</strong>来实现的。</p>\n</blockquote>\n<p>  首先是<em>数据结构</em>，html5定义了一个<strong>file</strong>对象类型来表示文件，每个file对象对应一个文件。file对象有3个属性：<em>name</em>、<em>size</em>、<em>type</em>。name是不包含路径的文件名，size是以字节为单位的文件体积大小，type则是文件的MIME（例如image/jpg）。</p>\n<p>  file对象不单独存在，而是以数组形式，存在一个名为FileList的数组中。那么，如何拿到这个FileList数组呢？目前，html5有两个途径可以拿到FileList，<strong>一是通过file类型的input</strong>，<strong>二是通过拖放操作的drop事件</strong>。</p>\n<h3 id=\"通过file类型的input获取FileList\"><a href=\"#通过file类型的input获取FileList\" class=\"headerlink\" title=\"通过file类型的input获取FileList\"></a>通过file类型的input获取FileList</h3><p><code>&lt;input id=&quot;file-input&quot; type=&quot;file&quot; /&gt;</code><br>或html5新增的可进行文件多选的multiple属性：</p>\n<p><code>&lt;input id=&quot;file-input&quot; type=&quot;file&quot; multiple /&gt;</code><br>一般，我们都是给input:file绑上一个<em>onchange</em>事件，以便在用户选定文件后，马上进行读取文件等下一步操作：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//原生js</span></div><div class=\"line\"><span class=\"keyword\">var</span> inputElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"file-input\"</span>);</div><div class=\"line\">inputElement.addEventListener(<span class=\"string\">\"change\"</span>, handleFiles, <span class=\"literal\">false</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleFiles</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fileList = <span class=\"keyword\">this</span>.files; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//jquery版</span></div><div class=\"line\">$(<span class=\"string\">'#file-input'</span>).on(<span class=\"string\">'change'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> fileList = <span class=\"keyword\">this</span>.files;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"通过拖放操作drop事件\"><a href=\"#通过拖放操作drop事件\" class=\"headerlink\" title=\"通过拖放操作drop事件\"></a>通过拖放操作drop事件</h3><p>首先要设定一个可供拖放的区域：<br><code>&lt;div id=&quot;dropbox&quot; style=&quot;width: 200px;height: 200px;&quot;&gt;&lt;/div&gt;</code><br>另外，为了能<strong>触发drop</strong>事件，我们必须阻止dragenter和dragover事件的默认行为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> dropbox;</div><div class=\"line\">dropbox = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"dropbox\"</span>);</div><div class=\"line\">dropbox.addEventListener(<span class=\"string\">\"dragenter\"</span>, dragenter, <span class=\"literal\">false</span>);</div><div class=\"line\">dropbox.addEventListener(<span class=\"string\">\"dragover\"</span>, dragover, <span class=\"literal\">false</span>);</div><div class=\"line\">dropbox.addEventListener(<span class=\"string\">\"drop\"</span>, drop, <span class=\"literal\">false</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragenter</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.stopPropagation();</div><div class=\"line\">  e.preventDefault();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragover</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.stopPropagation();</div><div class=\"line\">  e.preventDefault();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br>然后，我们就可以在drop事件的callback中，获取到fileList：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drop</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.stopPropagation();</div><div class=\"line\">  e.preventDefault();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> dt = e.dataTransfer;</div><div class=\"line\">  <span class=\"keyword\">var</span> files = dt.files;</div><div class=\"line\"></div><div class=\"line\">  handleFiles(files);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br><a id=\"more\"></a></p>\n<blockquote>\n<p> 怎么读取或利用file对象呢？html5提供了两个方案：<strong>FileReader</strong>和<strong>ObjectUrl</strong>。</p>\n</blockquote>\n<h3 id=\"使用FileReader读取file对象\"><a href=\"#使用FileReader读取file对象\" class=\"headerlink\" title=\"使用FileReader读取file对象\"></a>使用FileReader读取file对象</h3><p>首先需要实例化FileReader对象：<br><code>var reader = new FileReader();</code><br>利用FileReader读取file对象是一个<strong>异步</strong>的过程，我们需要先为FileReader设置好load事件的callback，告知FileReader在读取到file对象的数据后应该进行什么进一步的操作：<br><code>reader.onload = function(e) { \n    document.getElementById(&quot;image&quot;).src = e.target.result; \n}</code><br>上面这段代码的意思是，FileReader读取到图片的数据后，把数据（DataUrl）放到<img>的src属性里。最后，就是通过FileReader不同的方法，来决定读取file对象数据后用什么数据格式来存放，并实施读取：</p>\n<ol>\n<li>readAsArrayBuffer(file) ：读取file对象并存放为ArrayBuffer对象（ArrayBuffer对象是什么我暂时没有搞清，应该是一种为了高效存取数据而产生的数据结构）。</li>\n<li>readAsText(file [, ‘UTF-8’]) ：以一般文本模式读取file对象，值得注意的是，利用第二个参数（可选）可指定字符编码。</li>\n<li>readAsDataURL(file) ：读取file对象并存放为data: URL格式的字符串。</li>\n</ol>\n<h3 id=\"利用ObjectURL\"><a href=\"#利用ObjectURL\" class=\"headerlink\" title=\"利用ObjectURL\"></a>利用ObjectURL</h3><p>ObjectURL相当于文件的一个临时路径，此临时路径可随时生成、随时释放，在本地浏览器使用起来时，与普通的url无异。以把一张本地图片显示在页面上为例：<br><code>var img = document.createElement(&quot;img&quot;);\nimg.src = window.URL.createObjectURL(file);</code><br>此时，src形如：blob:<a href=\"http://test.local.com/e03e8bbf-66ce-4fea-a8c8-772f9fdb4d40\" target=\"_blank\" rel=\"external\">http://test.local.com/e03e8bbf-66ce-4fea-a8c8-772f9fdb4d40</a><br>用这个src就能让浏览器从本地读取图片。<br>这种方案相对用FileReader生成图片的base64编码并放到<img>的src里来说，性能有了很大的提升。</p>\n<p>比较这两种读取File对象的方案，<strong>FileReader适合用来上传文件</strong>，而<strong>ObjectURL则适合直接在浏览器进行操作，然后操作后再把处理后的数据进行上传，例如利用canvas截图或进行图片压缩等</strong>。当然，这一切都是要考虑<em>兼容性</em>的。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在<em>html4</em>的年代，我们如果要在网页上呈现一张用户本地的图片，需要用户先把图片上传到服务器，再根据服务器提供的图片地址把图片下载下来，才能把图片在网页上呈现出来。这一来二往，起码已经费了两倍于这张图片的流量了，更别说服务器为了存储这张图片所花费的资源以及用户上传错了图片的冤枉成本（因为在html4时代，用户选择好图片后，往往只能看到图片的文件名，而无法通过预览图来进一步确认这张图片是否就是自己想要上传的）。html5提供了新玩法，光靠浏览器，就可以对本地的（其实也可以是远程的）文件（主要是图片）进行<strong>呈现、读取、处理</strong>等操作，而这一切，则是通过html5 <strong>file api</strong>来实现的。</p>\n</blockquote>\n<p>  首先是<em>数据结构</em>，html5定义了一个<strong>file</strong>对象类型来表示文件，每个file对象对应一个文件。file对象有3个属性：<em>name</em>、<em>size</em>、<em>type</em>。name是不包含路径的文件名，size是以字节为单位的文件体积大小，type则是文件的MIME（例如image/jpg）。</p>\n<p>  file对象不单独存在，而是以数组形式，存在一个名为FileList的数组中。那么，如何拿到这个FileList数组呢？目前，html5有两个途径可以拿到FileList，<strong>一是通过file类型的input</strong>，<strong>二是通过拖放操作的drop事件</strong>。</p>\n<h3 id=\"通过file类型的input获取FileList\"><a href=\"#通过file类型的input获取FileList\" class=\"headerlink\" title=\"通过file类型的input获取FileList\"></a>通过file类型的input获取FileList</h3><p><code>&lt;input id=&quot;file-input&quot; type=&quot;file&quot; /&gt;</code><br>或html5新增的可进行文件多选的multiple属性：</p>\n<p><code>&lt;input id=&quot;file-input&quot; type=&quot;file&quot; multiple /&gt;</code><br>一般，我们都是给input:file绑上一个<em>onchange</em>事件，以便在用户选定文件后，马上进行读取文件等下一步操作：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//原生js</span></div><div class=\"line\"><span class=\"keyword\">var</span> inputElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"file-input\"</span>);</div><div class=\"line\">inputElement.addEventListener(<span class=\"string\">\"change\"</span>, handleFiles, <span class=\"literal\">false</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleFiles</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> fileList = <span class=\"keyword\">this</span>.files; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//jquery版</span></div><div class=\"line\">$(<span class=\"string\">'#file-input'</span>).on(<span class=\"string\">'change'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> fileList = <span class=\"keyword\">this</span>.files;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"通过拖放操作drop事件\"><a href=\"#通过拖放操作drop事件\" class=\"headerlink\" title=\"通过拖放操作drop事件\"></a>通过拖放操作drop事件</h3><p>首先要设定一个可供拖放的区域：<br><code>&lt;div id=&quot;dropbox&quot; style=&quot;width: 200px;height: 200px;&quot;&gt;&lt;/div&gt;</code><br>另外，为了能<strong>触发drop</strong>事件，我们必须阻止dragenter和dragover事件的默认行为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> dropbox;</div><div class=\"line\">dropbox = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"dropbox\"</span>);</div><div class=\"line\">dropbox.addEventListener(<span class=\"string\">\"dragenter\"</span>, dragenter, <span class=\"literal\">false</span>);</div><div class=\"line\">dropbox.addEventListener(<span class=\"string\">\"dragover\"</span>, dragover, <span class=\"literal\">false</span>);</div><div class=\"line\">dropbox.addEventListener(<span class=\"string\">\"drop\"</span>, drop, <span class=\"literal\">false</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragenter</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.stopPropagation();</div><div class=\"line\">  e.preventDefault();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragover</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.stopPropagation();</div><div class=\"line\">  e.preventDefault();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br>然后，我们就可以在drop事件的callback中，获取到fileList：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drop</span>(<span class=\"params\">e</span>) </span>&#123;</div><div class=\"line\">  e.stopPropagation();</div><div class=\"line\">  e.preventDefault();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> dt = e.dataTransfer;</div><div class=\"line\">  <span class=\"keyword\">var</span> files = dt.files;</div><div class=\"line\"></div><div class=\"line\">  handleFiles(files);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br>","more":"</p>\n<blockquote>\n<p> 怎么读取或利用file对象呢？html5提供了两个方案：<strong>FileReader</strong>和<strong>ObjectUrl</strong>。</p>\n</blockquote>\n<h3 id=\"使用FileReader读取file对象\"><a href=\"#使用FileReader读取file对象\" class=\"headerlink\" title=\"使用FileReader读取file对象\"></a>使用FileReader读取file对象</h3><p>首先需要实例化FileReader对象：<br><code>var reader = new FileReader();</code><br>利用FileReader读取file对象是一个<strong>异步</strong>的过程，我们需要先为FileReader设置好load事件的callback，告知FileReader在读取到file对象的数据后应该进行什么进一步的操作：<br><code>reader.onload = function(e) { \n    document.getElementById(&quot;image&quot;).src = e.target.result; \n}</code><br>上面这段代码的意思是，FileReader读取到图片的数据后，把数据（DataUrl）放到<img>的src属性里。最后，就是通过FileReader不同的方法，来决定读取file对象数据后用什么数据格式来存放，并实施读取：</p>\n<ol>\n<li>readAsArrayBuffer(file) ：读取file对象并存放为ArrayBuffer对象（ArrayBuffer对象是什么我暂时没有搞清，应该是一种为了高效存取数据而产生的数据结构）。</li>\n<li>readAsText(file [, ‘UTF-8’]) ：以一般文本模式读取file对象，值得注意的是，利用第二个参数（可选）可指定字符编码。</li>\n<li>readAsDataURL(file) ：读取file对象并存放为data: URL格式的字符串。</li>\n</ol>\n<h3 id=\"利用ObjectURL\"><a href=\"#利用ObjectURL\" class=\"headerlink\" title=\"利用ObjectURL\"></a>利用ObjectURL</h3><p>ObjectURL相当于文件的一个临时路径，此临时路径可随时生成、随时释放，在本地浏览器使用起来时，与普通的url无异。以把一张本地图片显示在页面上为例：<br><code>var img = document.createElement(&quot;img&quot;);\nimg.src = window.URL.createObjectURL(file);</code><br>此时，src形如：blob:<a href=\"http://test.local.com/e03e8bbf-66ce-4fea-a8c8-772f9fdb4d40\" target=\"_blank\" rel=\"external\">http://test.local.com/e03e8bbf-66ce-4fea-a8c8-772f9fdb4d40</a><br>用这个src就能让浏览器从本地读取图片。<br>这种方案相对用FileReader生成图片的base64编码并放到<img>的src里来说，性能有了很大的提升。</p>\n<p>比较这两种读取File对象的方案，<strong>FileReader适合用来上传文件</strong>，而<strong>ObjectURL则适合直接在浏览器进行操作，然后操作后再把处理后的数据进行上传，例如利用canvas截图或进行图片压缩等</strong>。当然，这一切都是要考虑<em>兼容性</em>的。</p>"},{"title":"hexo＋Travis-ci＋github构建自动化博客","date":"2017-06-01T02:08:52.000Z","_content":"> Travis CI：是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清晰。\n\ntarvis－ci是远端服务器构建，跟jenkins 不一样，不用自己搭建一个jenkins服务器。tarvis－ci是用的远端官方提供的服务器。用hexo 搭建博客，然后将博客源码提交到 Git上，用travis－ci 编译git 上的源码，然后将编译后的文件，推送到Github.io仓库下，达到自动化编译构建。\n\n----\n\n#### 构建自动化博客的步骤\n\n由于需要搭建hexo 和本地搭建Travis 所以本地需要有ruby 和 node 环境。本地搭建Travis 是为了和Travis－ci 服务器进行加密解密获得密匙，获得一次即可。\n\n1. 安装rubu 和node.js\n\n2. 搭建hexo\n\n3. 安装 travis\n\n4. 配置git 的ssh key\n\n5. 配置Travis\n\n6. 验证\n\n---\n\n<!--more-->\n\n### 安装ruby和node\n略\n### 搭建hexo\n搭建过程略\n注意的是：博客搭建成功后在github 的your_blog_name.github.io 仓库下新建travis分支，并将博客源码（未编译过的代码）提交到该分支，用于以后**Travis-ci编译**使用。\n### 安装 travis\n```\ngem install travis\n```\n### 配置git 的ssh key\n将本机ssh_key 添加github中。\n### 配置Travis\n1. 进入travis官网Travis 官网传送门用github账号登陆Travis CI\n![CI](http://oqum9wezj.bkt.clouddn.com/WX20170601-110251.png)\n2. 在右上角你的账户名点击进入 account，在Repositories tab页点击Sync now同步你的github项目。选中项目将默认的off改变为on开启项目的持续集成。\n![sync_ci](http://oqum9wezj.bkt.clouddn.com/sync_ci.png)\n\n3. 在你项目的根目录建立一个.travis文件夹\n```\n $ cd 博客项目文件夹根目录\n $ mkdir .travis\n```\n\n4.  复制id_rsa 和 创建 ssh_config文件\n```\n    $ cd 博客项目文件夹根目录/.travis\n    $ cp ~/.ssh/id_rsa ./\n```\n\n5.  创建 ssh_config 文件\n```\n$ cd 博客项目文件夹根目录/.travis\n$ touch ssh_config\n```\n编辑 ssh_config ,输入以下信息\n> Host github.com\nUser git\nStrictHostKeyChecking no\nIdentityFile ~/.ssh/id_rsa\nIdentitiesOnly yes\n\n6. travis 登陆\n```\n$ cd 博客项目文件夹根目录/.travis\n$ travis login --auto\n```\n需要填写github的用户名和密码。\n\n7. 加密操作\n在博客项目文件夹下对ssh的私钥进行加密\n```\n$ cd 博客项目文件夹根目录/.travis\n$ travis encrypt-file id_rsa --add\n```\n此操作会生成加密之后的秘钥文件 id_rsa.enc，删除id_rsa密钥文件(私钥不能随便泄露)。\n你的travis 目前上已经出现了下面加密解密key : \n(点击第2步图中的仓库名可进入下图界面，点击setting可看到加密)\n![enc_code](http://oqum9wezj.bkt.clouddn.com/enc.png)\n\n8. 在你项目的根目录建立一个.travis.yml文件，内容为： \n此步是在我your_blog_name.github.io仓库的travis 分支下编译源码。 \n（用第7步中Travis 生成的 encrypted_xxxxxxxxx_key -iv 和encrypted_xxxxxxxxx_iv 替换travis.yml 中openssl的 key 和 -iv）\n\n``` yml\nlanguage: node_js\nnode_js:\n- '7'\nbranches:\n  only:\n  - travis\ncache:\n  directories:\n  - node_modules\nbefore_install:\n- openssl aes-256-cbc -K $encrypted_xxxxxxxxx_key -iv $encrypted_xxxxxxxxx_iv\n  -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d\n- chmod 600 ~/.ssh/id_rsa\n- eval $(ssh-agent)\n- ssh-add ~/.ssh/id_rsa\n- cp .travis/ssh_config ~/.ssh/config\n- git config --global user.name \"527515025\"\n- git config --global user.email \"527515025@qq.com\"\ninstall:\n- npm install hexo-cli -g\n- npm install hexo-deployer-git --save\n- npm install\nscript:\n- hexo clean\n- hexo g\n\nafter_success:\n- hexo deploy\n```\n\n在travis分支中，操作一下，push到分支上就可以自动构建并发布了~\n\n\n\n\n\n\n","source":"_posts/hexo＋Travis-ci＋github构建自动化博客.md","raw":"---\ntitle: hexo＋Travis-ci＋github构建自动化博客\ndate: 2017-06-01 10:08:52\ntags: \n  - ci \n  - hexo\n---\n> Travis CI：是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清晰。\n\ntarvis－ci是远端服务器构建，跟jenkins 不一样，不用自己搭建一个jenkins服务器。tarvis－ci是用的远端官方提供的服务器。用hexo 搭建博客，然后将博客源码提交到 Git上，用travis－ci 编译git 上的源码，然后将编译后的文件，推送到Github.io仓库下，达到自动化编译构建。\n\n----\n\n#### 构建自动化博客的步骤\n\n由于需要搭建hexo 和本地搭建Travis 所以本地需要有ruby 和 node 环境。本地搭建Travis 是为了和Travis－ci 服务器进行加密解密获得密匙，获得一次即可。\n\n1. 安装rubu 和node.js\n\n2. 搭建hexo\n\n3. 安装 travis\n\n4. 配置git 的ssh key\n\n5. 配置Travis\n\n6. 验证\n\n---\n\n<!--more-->\n\n### 安装ruby和node\n略\n### 搭建hexo\n搭建过程略\n注意的是：博客搭建成功后在github 的your_blog_name.github.io 仓库下新建travis分支，并将博客源码（未编译过的代码）提交到该分支，用于以后**Travis-ci编译**使用。\n### 安装 travis\n```\ngem install travis\n```\n### 配置git 的ssh key\n将本机ssh_key 添加github中。\n### 配置Travis\n1. 进入travis官网Travis 官网传送门用github账号登陆Travis CI\n![CI](http://oqum9wezj.bkt.clouddn.com/WX20170601-110251.png)\n2. 在右上角你的账户名点击进入 account，在Repositories tab页点击Sync now同步你的github项目。选中项目将默认的off改变为on开启项目的持续集成。\n![sync_ci](http://oqum9wezj.bkt.clouddn.com/sync_ci.png)\n\n3. 在你项目的根目录建立一个.travis文件夹\n```\n $ cd 博客项目文件夹根目录\n $ mkdir .travis\n```\n\n4.  复制id_rsa 和 创建 ssh_config文件\n```\n    $ cd 博客项目文件夹根目录/.travis\n    $ cp ~/.ssh/id_rsa ./\n```\n\n5.  创建 ssh_config 文件\n```\n$ cd 博客项目文件夹根目录/.travis\n$ touch ssh_config\n```\n编辑 ssh_config ,输入以下信息\n> Host github.com\nUser git\nStrictHostKeyChecking no\nIdentityFile ~/.ssh/id_rsa\nIdentitiesOnly yes\n\n6. travis 登陆\n```\n$ cd 博客项目文件夹根目录/.travis\n$ travis login --auto\n```\n需要填写github的用户名和密码。\n\n7. 加密操作\n在博客项目文件夹下对ssh的私钥进行加密\n```\n$ cd 博客项目文件夹根目录/.travis\n$ travis encrypt-file id_rsa --add\n```\n此操作会生成加密之后的秘钥文件 id_rsa.enc，删除id_rsa密钥文件(私钥不能随便泄露)。\n你的travis 目前上已经出现了下面加密解密key : \n(点击第2步图中的仓库名可进入下图界面，点击setting可看到加密)\n![enc_code](http://oqum9wezj.bkt.clouddn.com/enc.png)\n\n8. 在你项目的根目录建立一个.travis.yml文件，内容为： \n此步是在我your_blog_name.github.io仓库的travis 分支下编译源码。 \n（用第7步中Travis 生成的 encrypted_xxxxxxxxx_key -iv 和encrypted_xxxxxxxxx_iv 替换travis.yml 中openssl的 key 和 -iv）\n\n``` yml\nlanguage: node_js\nnode_js:\n- '7'\nbranches:\n  only:\n  - travis\ncache:\n  directories:\n  - node_modules\nbefore_install:\n- openssl aes-256-cbc -K $encrypted_xxxxxxxxx_key -iv $encrypted_xxxxxxxxx_iv\n  -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d\n- chmod 600 ~/.ssh/id_rsa\n- eval $(ssh-agent)\n- ssh-add ~/.ssh/id_rsa\n- cp .travis/ssh_config ~/.ssh/config\n- git config --global user.name \"527515025\"\n- git config --global user.email \"527515025@qq.com\"\ninstall:\n- npm install hexo-cli -g\n- npm install hexo-deployer-git --save\n- npm install\nscript:\n- hexo clean\n- hexo g\n\nafter_success:\n- hexo deploy\n```\n\n在travis分支中，操作一下，push到分支上就可以自动构建并发布了~\n\n\n\n\n\n\n","slug":"hexo＋Travis-ci＋github构建自动化博客","published":1,"updated":"2017-06-01T03:43:25.000Z","_id":"cj3dvkfcn000uzk4o6uiaf51s","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>Travis CI：是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清晰。</p>\n</blockquote>\n<p>tarvis－ci是远端服务器构建，跟jenkins 不一样，不用自己搭建一个jenkins服务器。tarvis－ci是用的远端官方提供的服务器。用hexo 搭建博客，然后将博客源码提交到 Git上，用travis－ci 编译git 上的源码，然后将编译后的文件，推送到Github.io仓库下，达到自动化编译构建。</p>\n<hr>\n<h4 id=\"构建自动化博客的步骤\"><a href=\"#构建自动化博客的步骤\" class=\"headerlink\" title=\"构建自动化博客的步骤\"></a>构建自动化博客的步骤</h4><p>由于需要搭建hexo 和本地搭建Travis 所以本地需要有ruby 和 node 环境。本地搭建Travis 是为了和Travis－ci 服务器进行加密解密获得密匙，获得一次即可。</p>\n<ol>\n<li><p>安装rubu 和node.js</p>\n</li>\n<li><p>搭建hexo</p>\n</li>\n<li><p>安装 travis</p>\n</li>\n<li><p>配置git 的ssh key</p>\n</li>\n<li><p>配置Travis</p>\n</li>\n<li><p>验证</p>\n</li>\n</ol>\n<hr>\n<a id=\"more\"></a>\n<h3 id=\"安装ruby和node\"><a href=\"#安装ruby和node\" class=\"headerlink\" title=\"安装ruby和node\"></a>安装ruby和node</h3><p>略</p>\n<h3 id=\"搭建hexo\"><a href=\"#搭建hexo\" class=\"headerlink\" title=\"搭建hexo\"></a>搭建hexo</h3><p>搭建过程略<br>注意的是：博客搭建成功后在github 的your_blog_name.github.io 仓库下新建travis分支，并将博客源码（未编译过的代码）提交到该分支，用于以后<strong>Travis-ci编译</strong>使用。</p>\n<h3 id=\"安装-travis\"><a href=\"#安装-travis\" class=\"headerlink\" title=\"安装 travis\"></a>安装 travis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gem install travis</div></pre></td></tr></table></figure>\n<h3 id=\"配置git-的ssh-key\"><a href=\"#配置git-的ssh-key\" class=\"headerlink\" title=\"配置git 的ssh key\"></a>配置git 的ssh key</h3><p>将本机ssh_key 添加github中。</p>\n<h3 id=\"配置Travis\"><a href=\"#配置Travis\" class=\"headerlink\" title=\"配置Travis\"></a>配置Travis</h3><ol>\n<li>进入travis官网Travis 官网传送门用github账号登陆Travis CI<br><img src=\"http://oqum9wezj.bkt.clouddn.com/WX20170601-110251.png\" alt=\"CI\"></li>\n<li><p>在右上角你的账户名点击进入 account，在Repositories tab页点击Sync now同步你的github项目。选中项目将默认的off改变为on开启项目的持续集成。<br><img src=\"http://oqum9wezj.bkt.clouddn.com/sync_ci.png\" alt=\"sync_ci\"></p>\n</li>\n<li><p>在你项目的根目录建立一个.travis文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录</div><div class=\"line\">$ mkdir .travis</div></pre></td></tr></table></figure>\n</li>\n<li><p>复制id_rsa 和 创建 ssh_config文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录/.travis</div><div class=\"line\">$ cp ~/.ssh/id_rsa ./</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建 ssh_config 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录/.travis</div><div class=\"line\">$ touch ssh_config</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>编辑 ssh_config ,输入以下信息</p>\n<blockquote>\n<p>Host github.com<br>User git<br>StrictHostKeyChecking no<br>IdentityFile ~/.ssh/id_rsa<br>IdentitiesOnly yes</p>\n</blockquote>\n<ol>\n<li>travis 登陆<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录/.travis</div><div class=\"line\">$ travis login --auto</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>需要填写github的用户名和密码。</p>\n<ol>\n<li>加密操作<br>在博客项目文件夹下对ssh的私钥进行加密<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录/.travis</div><div class=\"line\">$ travis encrypt-file id_rsa --add</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>此操作会生成加密之后的秘钥文件 id_rsa.enc，删除id_rsa密钥文件(私钥不能随便泄露)。<br>你的travis 目前上已经出现了下面加密解密key :<br>(点击第2步图中的仓库名可进入下图界面，点击setting可看到加密)<br><img src=\"http://oqum9wezj.bkt.clouddn.com/enc.png\" alt=\"enc_code\"></p>\n<ol>\n<li>在你项目的根目录建立一个.travis.yml文件，内容为：<br>此步是在我your_blog_name.github.io仓库的travis 分支下编译源码。<br>（用第7步中Travis 生成的 encrypted_xxxxxxxxx_key -iv 和encrypted_xxxxxxxxx_iv 替换travis.yml 中openssl的 key 和 -iv）</li>\n</ol>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></div><div class=\"line\"><span class=\"attr\">node_js:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">'7'</span></div><div class=\"line\"><span class=\"attr\">branches:</span></div><div class=\"line\"><span class=\"attr\">  only:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">travis</span></div><div class=\"line\"><span class=\"attr\">cache:</span></div><div class=\"line\"><span class=\"attr\">  directories:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">node_modules</span></div><div class=\"line\"><span class=\"attr\">before_install:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">openssl</span> <span class=\"string\">aes-256-cbc</span> <span class=\"bullet\">-K</span> <span class=\"string\">$encrypted_xxxxxxxxx_key</span> <span class=\"bullet\">-iv</span> <span class=\"string\">$encrypted_xxxxxxxxx_iv</span></div><div class=\"line\"><span class=\"bullet\">  -</span><span class=\"string\">in</span> <span class=\"string\">.travis/id_rsa.enc</span> <span class=\"bullet\">-out</span> <span class=\"string\">~/.ssh/id_rsa</span> <span class=\"bullet\">-d</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">chmod</span> <span class=\"number\">600</span> <span class=\"string\">~/.ssh/id_rsa</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">eval</span> <span class=\"string\">$(ssh-agent)</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">ssh-add</span> <span class=\"string\">~/.ssh/id_rsa</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cp</span> <span class=\"string\">.travis/ssh_config</span> <span class=\"string\">~/.ssh/config</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"bullet\">--global</span> <span class=\"string\">user.name</span> <span class=\"string\">\"527515025\"</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"bullet\">--global</span> <span class=\"string\">user.email</span> <span class=\"string\">\"527515025@qq.com\"</span></div><div class=\"line\"><span class=\"attr\">install:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-cli</span> <span class=\"bullet\">-g</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-deployer-git</span> <span class=\"bullet\">--save</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></div><div class=\"line\"><span class=\"attr\">script:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">g</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">after_success:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">deploy</span></div></pre></td></tr></table></figure>\n<p>在travis分支中，操作一下，push到分支上就可以自动构建并发布了~</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Travis CI：是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清晰。</p>\n</blockquote>\n<p>tarvis－ci是远端服务器构建，跟jenkins 不一样，不用自己搭建一个jenkins服务器。tarvis－ci是用的远端官方提供的服务器。用hexo 搭建博客，然后将博客源码提交到 Git上，用travis－ci 编译git 上的源码，然后将编译后的文件，推送到Github.io仓库下，达到自动化编译构建。</p>\n<hr>\n<h4 id=\"构建自动化博客的步骤\"><a href=\"#构建自动化博客的步骤\" class=\"headerlink\" title=\"构建自动化博客的步骤\"></a>构建自动化博客的步骤</h4><p>由于需要搭建hexo 和本地搭建Travis 所以本地需要有ruby 和 node 环境。本地搭建Travis 是为了和Travis－ci 服务器进行加密解密获得密匙，获得一次即可。</p>\n<ol>\n<li><p>安装rubu 和node.js</p>\n</li>\n<li><p>搭建hexo</p>\n</li>\n<li><p>安装 travis</p>\n</li>\n<li><p>配置git 的ssh key</p>\n</li>\n<li><p>配置Travis</p>\n</li>\n<li><p>验证</p>\n</li>\n</ol>\n<hr>","more":"<h3 id=\"安装ruby和node\"><a href=\"#安装ruby和node\" class=\"headerlink\" title=\"安装ruby和node\"></a>安装ruby和node</h3><p>略</p>\n<h3 id=\"搭建hexo\"><a href=\"#搭建hexo\" class=\"headerlink\" title=\"搭建hexo\"></a>搭建hexo</h3><p>搭建过程略<br>注意的是：博客搭建成功后在github 的your_blog_name.github.io 仓库下新建travis分支，并将博客源码（未编译过的代码）提交到该分支，用于以后<strong>Travis-ci编译</strong>使用。</p>\n<h3 id=\"安装-travis\"><a href=\"#安装-travis\" class=\"headerlink\" title=\"安装 travis\"></a>安装 travis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gem install travis</div></pre></td></tr></table></figure>\n<h3 id=\"配置git-的ssh-key\"><a href=\"#配置git-的ssh-key\" class=\"headerlink\" title=\"配置git 的ssh key\"></a>配置git 的ssh key</h3><p>将本机ssh_key 添加github中。</p>\n<h3 id=\"配置Travis\"><a href=\"#配置Travis\" class=\"headerlink\" title=\"配置Travis\"></a>配置Travis</h3><ol>\n<li>进入travis官网Travis 官网传送门用github账号登陆Travis CI<br><img src=\"http://oqum9wezj.bkt.clouddn.com/WX20170601-110251.png\" alt=\"CI\"></li>\n<li><p>在右上角你的账户名点击进入 account，在Repositories tab页点击Sync now同步你的github项目。选中项目将默认的off改变为on开启项目的持续集成。<br><img src=\"http://oqum9wezj.bkt.clouddn.com/sync_ci.png\" alt=\"sync_ci\"></p>\n</li>\n<li><p>在你项目的根目录建立一个.travis文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录</div><div class=\"line\">$ mkdir .travis</div></pre></td></tr></table></figure>\n</li>\n<li><p>复制id_rsa 和 创建 ssh_config文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录/.travis</div><div class=\"line\">$ cp ~/.ssh/id_rsa ./</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建 ssh_config 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录/.travis</div><div class=\"line\">$ touch ssh_config</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>编辑 ssh_config ,输入以下信息</p>\n<blockquote>\n<p>Host github.com<br>User git<br>StrictHostKeyChecking no<br>IdentityFile ~/.ssh/id_rsa<br>IdentitiesOnly yes</p>\n</blockquote>\n<ol>\n<li>travis 登陆<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录/.travis</div><div class=\"line\">$ travis login --auto</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>需要填写github的用户名和密码。</p>\n<ol>\n<li>加密操作<br>在博客项目文件夹下对ssh的私钥进行加密<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd 博客项目文件夹根目录/.travis</div><div class=\"line\">$ travis encrypt-file id_rsa --add</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>此操作会生成加密之后的秘钥文件 id_rsa.enc，删除id_rsa密钥文件(私钥不能随便泄露)。<br>你的travis 目前上已经出现了下面加密解密key :<br>(点击第2步图中的仓库名可进入下图界面，点击setting可看到加密)<br><img src=\"http://oqum9wezj.bkt.clouddn.com/enc.png\" alt=\"enc_code\"></p>\n<ol>\n<li>在你项目的根目录建立一个.travis.yml文件，内容为：<br>此步是在我your_blog_name.github.io仓库的travis 分支下编译源码。<br>（用第7步中Travis 生成的 encrypted_xxxxxxxxx_key -iv 和encrypted_xxxxxxxxx_iv 替换travis.yml 中openssl的 key 和 -iv）</li>\n</ol>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></div><div class=\"line\"><span class=\"attr\">node_js:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">'7'</span></div><div class=\"line\"><span class=\"attr\">branches:</span></div><div class=\"line\"><span class=\"attr\">  only:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">travis</span></div><div class=\"line\"><span class=\"attr\">cache:</span></div><div class=\"line\"><span class=\"attr\">  directories:</span></div><div class=\"line\"><span class=\"bullet\">  -</span> <span class=\"string\">node_modules</span></div><div class=\"line\"><span class=\"attr\">before_install:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">openssl</span> <span class=\"string\">aes-256-cbc</span> <span class=\"bullet\">-K</span> <span class=\"string\">$encrypted_xxxxxxxxx_key</span> <span class=\"bullet\">-iv</span> <span class=\"string\">$encrypted_xxxxxxxxx_iv</span></div><div class=\"line\"><span class=\"bullet\">  -</span><span class=\"string\">in</span> <span class=\"string\">.travis/id_rsa.enc</span> <span class=\"bullet\">-out</span> <span class=\"string\">~/.ssh/id_rsa</span> <span class=\"bullet\">-d</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">chmod</span> <span class=\"number\">600</span> <span class=\"string\">~/.ssh/id_rsa</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">eval</span> <span class=\"string\">$(ssh-agent)</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">ssh-add</span> <span class=\"string\">~/.ssh/id_rsa</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">cp</span> <span class=\"string\">.travis/ssh_config</span> <span class=\"string\">~/.ssh/config</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"bullet\">--global</span> <span class=\"string\">user.name</span> <span class=\"string\">\"527515025\"</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"bullet\">--global</span> <span class=\"string\">user.email</span> <span class=\"string\">\"527515025@qq.com\"</span></div><div class=\"line\"><span class=\"attr\">install:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-cli</span> <span class=\"bullet\">-g</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-deployer-git</span> <span class=\"bullet\">--save</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></div><div class=\"line\"><span class=\"attr\">script:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">g</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">after_success:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">deploy</span></div></pre></td></tr></table></figure>\n<p>在travis分支中，操作一下，push到分支上就可以自动构建并发布了~</p>"},{"title":"Vue中的过渡效果","date":"2016-10-26T03:10:31.000Z","_content":"\n>  这里只写由css实现的简单过渡，js用到在做记录。\n\n### 过渡效果\n\n#### 概述\n\nVue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。\n包括以下工具：\n\n1. 在 CSS 过渡和动画中自动应用 class\n2. 可以配合使用第三方 CSS 动画库，如 [Animate.css](https://daneden.github.io/animate.css/)\n3. 在过渡钩子函数中使用 JavaScript 直接操作 DOM\n4. 可以配合使用第三方 JavaScript 动画库，如 [Velocity.js](http://velocityjs.org/)\n\n\n#### 单元素/组件的过渡\n\nVue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡\n\n - 条件渲染 （使用 v-if）\n - 条件展示 （使用 v-show）\n - 动态组件\n - 组件根节点\n这里是一个典型的例子：\n```css\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n.fade-enter-active, .fade-leave-active {\n  transition: opacity .5s\n}\n.fade-enter, .fade-leave-active {\n  opacity: 0\n}\n```\n元素封装成过渡组件之后，在遇到插入或删除时，Vue 将自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。\n\n如果过渡组件设置了过渡的 JavaScript 钩子函数，会在相应的阶段调用钩子函数。\n\n如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 nextTick 概念不同)\n\n#### 过渡的-CSS-类名\n\n会有 4 个(CSS)类名在 enter/leave 的过渡中切换\n\n**v-enter**: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。\n\n**v-enter-active**: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。\n\n**v-leave**: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。\n\n**v-leave-active**: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。\n\n![Transition Diagram](https://vuefe.cn/images/transition.png)\n\n对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 <name=\"my-transition>\" 可以重置前缀，比如 v-enter 替换为 my-transition-enter。\n\nv-enter-active 和 v-leave-active 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。\n\n### CSS 过渡\n\n**常用的过渡都是使用 CSS 过渡。**\n\n下面是一个简单例子：\n```css\n<div id=\"example-1\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition name=\"slide-fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\nnew Vue({\n  el: '#example-1',\n  data: {\n    show: true\n  }\n})\n/* 可以设置不同的进入和离开动画 */\n/* 设置持续时间和动画函数 */\n.slide-fade-enter-active {\n  transition: all .3s ease;\n}\n.slide-fade-leave-active {\n  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.slide-fade-enter, .slide-fade-leave-active {\n  padding-left: 10px;\n  opacity: 0;\n}\n```\n\n#### CSS 动画\n\nCSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。\n\n示例： (省略了兼容性前缀)\n```css\n<div id=\"example-2\">\n  <button @click=\"show = !show\">Toggle show</button>\n  <transition name=\"bounce\">\n    <p v-if=\"show\">Look at me!</p>\n  </transition>\n</div>\nnew Vue({\n  el: '#example-2',\n  data: {\n    show: true\n  }\n})\n.bounce-enter-active {\n  animation: bounce-in .5s;\n}\n.bounce-leave-active {\n  animation: bounce-out .5s;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n@keyframes bounce-out {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(0);\n  }\n}\n```\n#### 自定义过渡类名\n\n我们可以通过以下特性来自定义过渡类名：\n\n**enter-class**\n**enter-active-class**\n**leave-class**\n**leave-active-class**\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如** Animate.css **结合使用十分有用。\n\n示例：\n```css\n<link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\">\n<div id=\"example-3\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition\n    name=\"custom-classes-transition\"\n    enter-active-class=\"animated tada\"\n    leave-active-class=\"animated bounceOutRight\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\nnew Vue({\n  el: '#example-3',\n  data: {\n    show: true\n  }\n})\n```\n<!--more-->\n\n#### 同时使用 Transitions 和 Animations\n\nVue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。\n\n但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。\n\n#### 初始渲染的过渡\n\n可以通过 **appear** 特性设置节点的在初始渲染的过渡\n```\n<transition appear>\n\n</transition>\n```\n这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。\n```html\n<transition\n  appear\n  appear-class=\"custom-appear-class\"\n  appear-active-class=\"custom-appear-active-class\"\n>\n\n</transition>\n```\n\n#### 多个元素的过渡\n\n我们之后讨论 **多个组件的过渡**, 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：\n```\n<transition>\n  <table v-if=\"items.length > 0\">\n\n  </table>\n  <p v-else>Sorry, no items found.</p>\n</transition>\n```\n可以这样使用，但是有一点需要注意：\n\n当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <transition> 组件中的多个元素设置 key 是一个更好的实践。\n##### 示例:\n```\n<transition>\n  <button v-if=\"isEditing\" key=\"save\">\n    Save\n  </button>\n  <button v-else key=\"edit\">\n    Edit\n  </button>\n</transition>\n```\n在一些场景中，也可以给通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为：\n```\n<transition>\n  <button v-bind:key=\"isEditing\">\n    {{ isEditing ? 'Save' : 'Edit' }}\n  </button>\n</transition>\n```\n\n使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。 例如：\n```\n<transition>\n  <button v-if=\"docState === 'saved'\" key=\"saved\">\n    Edit\n  </button>\n  <button v-if=\"docState === 'edited'\" key=\"edited\">\n    Save\n  </button>\n  <button v-if=\"docState === 'editing'\" key=\"editing\">\n    Cancel\n  </button>\n</transition>\n```\n\n可以重写为：\n```\n<transition>\n  <button v-bind:key=\"docState\">\n    {{ buttonMessage }}\n  </button>\n</transition>\n\ncomputed: {\n  buttonMessage: function () {\n    switch (docState) {\n      case 'saved': return 'Edit'\n      case 'edited': return 'Save'\n      case 'editing': return 'Cancel'\n    }\n  }\n}\n```\n### [过渡模式](https://vuefe.cn/guide/transitions.html#过渡模式)\n**同时生效**的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 **过渡模式**\n\n - **in-out**: 新元素先进行过渡，完成之后当前元素过渡离开。\n - **out-in**: 当前元素先进行过渡，完成之后新元素过渡进入。\n\n用 **out-in** 重写之前的开关按钮过渡：\n```\n<transition name=\"fade\" mode=\"out-in\"></transition>\n```\n\n只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。\n**in-out** 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。\n\n### 多个组件的过渡\n\n多个组件的过渡很简单很多,我们不需要使用 key 特性。相反，我们只需要**使用动态组件**:\n#### 关于动态组件\n>  多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <component> 元素，动态地绑定到它的 is 特性：\n```\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: 'home'\n  },\n  components: {\n    home: { /* ... */ },\n    posts: { /* ... */ },\n    archive: { /* ... */ }\n  }\n})\n<component v-bind:is=\"currentView\">\n  <!-- 组件在 vm.currentview 变化时改变！ -->\n</component>\n也可以直接绑定到组件对象上：\n\nvar Home = {\n  template: '<p>Welcome home!</p>'\n}\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: Home\n  }\n})\n```\n\n使用动态组件实现过渡\n```\n<transition name=\"component-fade\" mode=\"out-in\">\n  <component v-bind:is=\"view\"></component>\n</transition>\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n.component-fade-enter-active, .component-fade-leave-active {\n  transition: opacity .3s ease;\n}\n.component-fade-enter, .component-fade-leave-active {\n  opacity: 0;\n}\n```\n[更多动画效果请参考这里](https://vuefe.cn/guide/transitions.html)","source":"_posts/Vue中的过渡效果.md","raw":"---\ntitle: Vue中的过渡效果\ndate: 2016-10-26 11:10:31\ntags: Vue\n---\n\n>  这里只写由css实现的简单过渡，js用到在做记录。\n\n### 过渡效果\n\n#### 概述\n\nVue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。\n包括以下工具：\n\n1. 在 CSS 过渡和动画中自动应用 class\n2. 可以配合使用第三方 CSS 动画库，如 [Animate.css](https://daneden.github.io/animate.css/)\n3. 在过渡钩子函数中使用 JavaScript 直接操作 DOM\n4. 可以配合使用第三方 JavaScript 动画库，如 [Velocity.js](http://velocityjs.org/)\n\n\n#### 单元素/组件的过渡\n\nVue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡\n\n - 条件渲染 （使用 v-if）\n - 条件展示 （使用 v-show）\n - 动态组件\n - 组件根节点\n这里是一个典型的例子：\n```css\n<div id=\"demo\">\n  <button v-on:click=\"show = !show\">\n    Toggle\n  </button>\n  <transition name=\"fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\nnew Vue({\n  el: '#demo',\n  data: {\n    show: true\n  }\n})\n.fade-enter-active, .fade-leave-active {\n  transition: opacity .5s\n}\n.fade-enter, .fade-leave-active {\n  opacity: 0\n}\n```\n元素封装成过渡组件之后，在遇到插入或删除时，Vue 将自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。\n\n如果过渡组件设置了过渡的 JavaScript 钩子函数，会在相应的阶段调用钩子函数。\n\n如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 nextTick 概念不同)\n\n#### 过渡的-CSS-类名\n\n会有 4 个(CSS)类名在 enter/leave 的过渡中切换\n\n**v-enter**: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。\n\n**v-enter-active**: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。\n\n**v-leave**: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。\n\n**v-leave-active**: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。\n\n![Transition Diagram](https://vuefe.cn/images/transition.png)\n\n对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 <name=\"my-transition>\" 可以重置前缀，比如 v-enter 替换为 my-transition-enter。\n\nv-enter-active 和 v-leave-active 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。\n\n### CSS 过渡\n\n**常用的过渡都是使用 CSS 过渡。**\n\n下面是一个简单例子：\n```css\n<div id=\"example-1\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition name=\"slide-fade\">\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\nnew Vue({\n  el: '#example-1',\n  data: {\n    show: true\n  }\n})\n/* 可以设置不同的进入和离开动画 */\n/* 设置持续时间和动画函数 */\n.slide-fade-enter-active {\n  transition: all .3s ease;\n}\n.slide-fade-leave-active {\n  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);\n}\n.slide-fade-enter, .slide-fade-leave-active {\n  padding-left: 10px;\n  opacity: 0;\n}\n```\n\n#### CSS 动画\n\nCSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。\n\n示例： (省略了兼容性前缀)\n```css\n<div id=\"example-2\">\n  <button @click=\"show = !show\">Toggle show</button>\n  <transition name=\"bounce\">\n    <p v-if=\"show\">Look at me!</p>\n  </transition>\n</div>\nnew Vue({\n  el: '#example-2',\n  data: {\n    show: true\n  }\n})\n.bounce-enter-active {\n  animation: bounce-in .5s;\n}\n.bounce-leave-active {\n  animation: bounce-out .5s;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n@keyframes bounce-out {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(0);\n  }\n}\n```\n#### 自定义过渡类名\n\n我们可以通过以下特性来自定义过渡类名：\n\n**enter-class**\n**enter-active-class**\n**leave-class**\n**leave-active-class**\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如** Animate.css **结合使用十分有用。\n\n示例：\n```css\n<link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\">\n<div id=\"example-3\">\n  <button @click=\"show = !show\">\n    Toggle render\n  </button>\n  <transition\n    name=\"custom-classes-transition\"\n    enter-active-class=\"animated tada\"\n    leave-active-class=\"animated bounceOutRight\"\n  >\n    <p v-if=\"show\">hello</p>\n  </transition>\n</div>\nnew Vue({\n  el: '#example-3',\n  data: {\n    show: true\n  }\n})\n```\n<!--more-->\n\n#### 同时使用 Transitions 和 Animations\n\nVue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。\n\n但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。\n\n#### 初始渲染的过渡\n\n可以通过 **appear** 特性设置节点的在初始渲染的过渡\n```\n<transition appear>\n\n</transition>\n```\n这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。\n```html\n<transition\n  appear\n  appear-class=\"custom-appear-class\"\n  appear-active-class=\"custom-appear-active-class\"\n>\n\n</transition>\n```\n\n#### 多个元素的过渡\n\n我们之后讨论 **多个组件的过渡**, 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：\n```\n<transition>\n  <table v-if=\"items.length > 0\">\n\n  </table>\n  <p v-else>Sorry, no items found.</p>\n</transition>\n```\n可以这样使用，但是有一点需要注意：\n\n当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <transition> 组件中的多个元素设置 key 是一个更好的实践。\n##### 示例:\n```\n<transition>\n  <button v-if=\"isEditing\" key=\"save\">\n    Save\n  </button>\n  <button v-else key=\"edit\">\n    Edit\n  </button>\n</transition>\n```\n在一些场景中，也可以给通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为：\n```\n<transition>\n  <button v-bind:key=\"isEditing\">\n    {{ isEditing ? 'Save' : 'Edit' }}\n  </button>\n</transition>\n```\n\n使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。 例如：\n```\n<transition>\n  <button v-if=\"docState === 'saved'\" key=\"saved\">\n    Edit\n  </button>\n  <button v-if=\"docState === 'edited'\" key=\"edited\">\n    Save\n  </button>\n  <button v-if=\"docState === 'editing'\" key=\"editing\">\n    Cancel\n  </button>\n</transition>\n```\n\n可以重写为：\n```\n<transition>\n  <button v-bind:key=\"docState\">\n    {{ buttonMessage }}\n  </button>\n</transition>\n\ncomputed: {\n  buttonMessage: function () {\n    switch (docState) {\n      case 'saved': return 'Edit'\n      case 'edited': return 'Save'\n      case 'editing': return 'Cancel'\n    }\n  }\n}\n```\n### [过渡模式](https://vuefe.cn/guide/transitions.html#过渡模式)\n**同时生效**的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 **过渡模式**\n\n - **in-out**: 新元素先进行过渡，完成之后当前元素过渡离开。\n - **out-in**: 当前元素先进行过渡，完成之后新元素过渡进入。\n\n用 **out-in** 重写之前的开关按钮过渡：\n```\n<transition name=\"fade\" mode=\"out-in\"></transition>\n```\n\n只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。\n**in-out** 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。\n\n### 多个组件的过渡\n\n多个组件的过渡很简单很多,我们不需要使用 key 特性。相反，我们只需要**使用动态组件**:\n#### 关于动态组件\n>  多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <component> 元素，动态地绑定到它的 is 特性：\n```\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: 'home'\n  },\n  components: {\n    home: { /* ... */ },\n    posts: { /* ... */ },\n    archive: { /* ... */ }\n  }\n})\n<component v-bind:is=\"currentView\">\n  <!-- 组件在 vm.currentview 变化时改变！ -->\n</component>\n也可以直接绑定到组件对象上：\n\nvar Home = {\n  template: '<p>Welcome home!</p>'\n}\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    currentView: Home\n  }\n})\n```\n\n使用动态组件实现过渡\n```\n<transition name=\"component-fade\" mode=\"out-in\">\n  <component v-bind:is=\"view\"></component>\n</transition>\nnew Vue({\n  el: '#transition-components-demo',\n  data: {\n    view: 'v-a'\n  },\n  components: {\n    'v-a': {\n      template: '<div>Component A</div>'\n    },\n    'v-b': {\n      template: '<div>Component B</div>'\n    }\n  }\n})\n.component-fade-enter-active, .component-fade-leave-active {\n  transition: opacity .3s ease;\n}\n.component-fade-enter, .component-fade-leave-active {\n  opacity: 0;\n}\n```\n[更多动画效果请参考这里](https://vuefe.cn/guide/transitions.html)","slug":"Vue中的过渡效果","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfco000vzk4oqb8az1vu","content":"<blockquote>\n<p> 这里只写由css实现的简单过渡，js用到在做记录。</p>\n</blockquote>\n<h3 id=\"过渡效果\"><a href=\"#过渡效果\" class=\"headerlink\" title=\"过渡效果\"></a>过渡效果</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p>\n<ol>\n<li>在 CSS 过渡和动画中自动应用 class</li>\n<li>可以配合使用第三方 CSS 动画库，如 <a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\" rel=\"external\">Animate.css</a></li>\n<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>\n<li>可以配合使用第三方 JavaScript 动画库，如 <a href=\"http://velocityjs.org/\" target=\"_blank\" rel=\"external\">Velocity.js</a></li>\n</ol>\n<h4 id=\"单元素-组件的过渡\"><a href=\"#单元素-组件的过渡\" class=\"headerlink\" title=\"单元素/组件的过渡\"></a>单元素/组件的过渡</h4><p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡</p>\n<ul>\n<li>条件渲染 （使用 v-if）</li>\n<li>条件展示 （使用 v-show）</li>\n<li>动态组件</li>\n<li>组件根节点<br>这里是一个典型的例子：<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=\"demo\"&gt;</div><div class=\"line\">  &lt;button v-on:click=\"show = !show\"&gt;</div><div class=\"line\">    Toggle</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;transition name=\"fade\"&gt;</div><div class=\"line\">    &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;</div><div class=\"line\">  &lt;/transition&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: '#demo',</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    show: true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.fade-enter-active, .fade-leave-active &#123;</div><div class=\"line\">  transition: opacity .5s</div><div class=\"line\">&#125;</div><div class=\"line\">.fade-enter, .fade-leave-active &#123;</div><div class=\"line\">  opacity: 0</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>元素封装成过渡组件之后，在遇到插入或删除时，Vue 将自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。</p>\n<p>如果过渡组件设置了过渡的 JavaScript 钩子函数，会在相应的阶段调用钩子函数。</p>\n<p>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 nextTick 概念不同)</p>\n<h4 id=\"过渡的-CSS-类名\"><a href=\"#过渡的-CSS-类名\" class=\"headerlink\" title=\"过渡的-CSS-类名\"></a>过渡的-CSS-类名</h4><p>会有 4 个(CSS)类名在 enter/leave 的过渡中切换</p>\n<p><strong>v-enter</strong>: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</p>\n<p><strong>v-enter-active</strong>: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。</p>\n<p><strong>v-leave</strong>: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</p>\n<p><strong>v-leave-active</strong>: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。</p>\n<p><img src=\"https://vuefe.cn/images/transition.png\" alt=\"Transition Diagram\"></p>\n<p>对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 &lt;name=”my-transition&gt;” 可以重置前缀，比如 v-enter 替换为 my-transition-enter。</p>\n<p>v-enter-active 和 v-leave-active 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。</p>\n<h3 id=\"CSS-过渡\"><a href=\"#CSS-过渡\" class=\"headerlink\" title=\"CSS 过渡\"></a>CSS 过渡</h3><p><strong>常用的过渡都是使用 CSS 过渡。</strong></p>\n<p>下面是一个简单例子：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=\"example-1\"&gt;</div><div class=\"line\">  &lt;button @click=\"show = !show\"&gt;</div><div class=\"line\">    Toggle render</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;transition name=\"slide-fade\"&gt;</div><div class=\"line\">    &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;</div><div class=\"line\">  &lt;/transition&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: '#example-1',</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    show: true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">/* 可以设置不同的进入和离开动画 */</div><div class=\"line\">/* 设置持续时间和动画函数 */</div><div class=\"line\">.slide-fade-enter-active &#123;</div><div class=\"line\">  transition: all .3s ease;</div><div class=\"line\">&#125;</div><div class=\"line\">.slide-fade-leave-active &#123;</div><div class=\"line\">  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);</div><div class=\"line\">&#125;</div><div class=\"line\">.slide-fade-enter, .slide-fade-leave-active &#123;</div><div class=\"line\">  padding-left: 10px;</div><div class=\"line\">  opacity: 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"CSS-动画\"><a href=\"#CSS-动画\" class=\"headerlink\" title=\"CSS 动画\"></a>CSS 动画</h4><p>CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。</p>\n<p>示例： (省略了兼容性前缀)<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=\"example-2\"&gt;</div><div class=\"line\">  &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt;</div><div class=\"line\">  &lt;transition name=\"bounce\"&gt;</div><div class=\"line\">    &lt;p v-if=\"show\"&gt;Look at me!&lt;/p&gt;</div><div class=\"line\">  &lt;/transition&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: '#example-2',</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    show: true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.bounce-enter-active &#123;</div><div class=\"line\">  animation: bounce-in .5s;</div><div class=\"line\">&#125;</div><div class=\"line\">.bounce-leave-active &#123;</div><div class=\"line\">  animation: bounce-out .5s;</div><div class=\"line\">&#125;</div><div class=\"line\">@keyframes bounce-in &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    transform: scale(0);</div><div class=\"line\">  &#125;</div><div class=\"line\">  50% &#123;</div><div class=\"line\">    transform: scale(1.5);</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    transform: scale(1);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@keyframes bounce-out &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    transform: scale(1);</div><div class=\"line\">  &#125;</div><div class=\"line\">  50% &#123;</div><div class=\"line\">    transform: scale(1.5);</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    transform: scale(0);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"自定义过渡类名\"><a href=\"#自定义过渡类名\" class=\"headerlink\" title=\"自定义过渡类名\"></a>自定义过渡类名</h4><p>我们可以通过以下特性来自定义过渡类名：</p>\n<p><strong>enter-class</strong><br><strong>enter-active-class</strong><br><strong>leave-class</strong><br><strong>leave-active-class</strong><br>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如<strong> Animate.css </strong>结合使用十分有用。</p>\n<p>示例：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;</div><div class=\"line\">&lt;div id=\"example-3\"&gt;</div><div class=\"line\">  &lt;button @click=\"show = !show\"&gt;</div><div class=\"line\">    Toggle render</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;transition</div><div class=\"line\">    name=\"custom-classes-transition\"</div><div class=\"line\">    enter-active-class=\"animated tada\"</div><div class=\"line\">    leave-active-class=\"animated bounceOutRight\"</div><div class=\"line\">  &gt;</div><div class=\"line\">    &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;</div><div class=\"line\">  &lt;/transition&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: '#example-3',</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    show: true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"同时使用-Transitions-和-Animations\"><a href=\"#同时使用-Transitions-和-Animations\" class=\"headerlink\" title=\"同时使用 Transitions 和 Animations\"></a>同时使用 Transitions 和 Animations</h4><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p>\n<p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。</p>\n<h4 id=\"初始渲染的过渡\"><a href=\"#初始渲染的过渡\" class=\"headerlink\" title=\"初始渲染的过渡\"></a>初始渲染的过渡</h4><p>可以通过 <strong>appear</strong> 特性设置节点的在初始渲染的过渡<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition appear&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></span></div><div class=\"line\">  <span class=\"attr\">appear</span></div><div class=\"line\">  <span class=\"attr\">appear-class</span>=<span class=\"string\">\"custom-appear-class\"</span></div><div class=\"line\">  <span class=\"attr\">appear-active-class</span>=<span class=\"string\">\"custom-appear-active-class\"</span></div><div class=\"line\">&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"多个元素的过渡\"><a href=\"#多个元素的过渡\" class=\"headerlink\" title=\"多个元素的过渡\"></a>多个元素的过渡</h4><p>我们之后讨论 <strong>多个组件的过渡</strong>, 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;/table&gt;</div><div class=\"line\">  &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;</div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>可以这样使用，但是有一点需要注意：</p>\n<p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <transition> 组件中的多个元素设置 key 是一个更好的实践。</transition></p>\n<h5 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例:\"></a>示例:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt;</div><div class=\"line\">    Save</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;button v-else key=&quot;edit&quot;&gt;</div><div class=\"line\">    Edit</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure>\n<p>在一些场景中，也可以给通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;button v-bind:key=&quot;isEditing&quot;&gt;</div><div class=\"line\">    &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125;</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。 例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;button v-if=&quot;docState === &apos;saved&apos;&quot; key=&quot;saved&quot;&gt;</div><div class=\"line\">    Edit</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;button v-if=&quot;docState === &apos;edited&apos;&quot; key=&quot;edited&quot;&gt;</div><div class=\"line\">    Save</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;button v-if=&quot;docState === &apos;editing&apos;&quot; key=&quot;editing&quot;&gt;</div><div class=\"line\">    Cancel</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>可以重写为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;button v-bind:key=&quot;docState&quot;&gt;</div><div class=\"line\">    &#123;&#123; buttonMessage &#125;&#125;</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">&lt;/transition&gt;</div><div class=\"line\"></div><div class=\"line\">computed: &#123;</div><div class=\"line\">  buttonMessage: function () &#123;</div><div class=\"line\">    switch (docState) &#123;</div><div class=\"line\">      case &apos;saved&apos;: return &apos;Edit&apos;</div><div class=\"line\">      case &apos;edited&apos;: return &apos;Save&apos;</div><div class=\"line\">      case &apos;editing&apos;: return &apos;Cancel&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"过渡模式\"><a href=\"#过渡模式\" class=\"headerlink\" title=\"过渡模式\"></a><a href=\"https://vuefe.cn/guide/transitions.html#过渡模式\" target=\"_blank\" rel=\"external\">过渡模式</a></h3><p><strong>同时生效</strong>的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 <strong>过渡模式</strong></p>\n<ul>\n<li><strong>in-out</strong>: 新元素先进行过渡，完成之后当前元素过渡离开。</li>\n<li><strong>out-in</strong>: 当前元素先进行过渡，完成之后新元素过渡进入。</li>\n</ul>\n<p>用 <strong>out-in</strong> 重写之前的开关按钮过渡：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。<br><strong>in-out</strong> 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。</p>\n<h3 id=\"多个组件的过渡\"><a href=\"#多个组件的过渡\" class=\"headerlink\" title=\"多个组件的过渡\"></a>多个组件的过渡</h3><p>多个组件的过渡很简单很多,我们不需要使用 key 特性。相反，我们只需要<strong>使用动态组件</strong>:</p>\n<h4 id=\"关于动态组件\"><a href=\"#关于动态组件\" class=\"headerlink\" title=\"关于动态组件\"></a>关于动态组件</h4><blockquote>\n<p> 多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <component> 元素，动态地绑定到它的 is 特性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">var vm = new Vue(&#123;</div><div class=\"line\">  el: &apos;#example&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    currentView: &apos;home&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    home: &#123; /* ... */ &#125;,</div><div class=\"line\">    posts: &#123; /* ... */ &#125;,</div><div class=\"line\">    archive: &#123; /* ... */ &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">&lt;component v-bind:is=&quot;currentView&quot;&gt;</div><div class=\"line\">  &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</div><div class=\"line\">&lt;/component&gt;</div><div class=\"line\">也可以直接绑定到组件对象上：</div><div class=\"line\"></div><div class=\"line\">var Home = &#123;</div><div class=\"line\">  template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">var vm = new Vue(&#123;</div><div class=\"line\">  el: &apos;#example&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    currentView: Home</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></component></p>\n</blockquote>\n<p>使用动态组件实现过渡<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;</div><div class=\"line\">  &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;</div><div class=\"line\">&lt;/transition&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: &apos;#transition-components-demo&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    view: &apos;v-a&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    &apos;v-a&apos;: &#123;</div><div class=\"line\">      template: &apos;&lt;div&gt;Component A&lt;/div&gt;&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &apos;v-b&apos;: &#123;</div><div class=\"line\">      template: &apos;&lt;div&gt;Component B&lt;/div&gt;&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.component-fade-enter-active, .component-fade-leave-active &#123;</div><div class=\"line\">  transition: opacity .3s ease;</div><div class=\"line\">&#125;</div><div class=\"line\">.component-fade-enter, .component-fade-leave-active &#123;</div><div class=\"line\">  opacity: 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://vuefe.cn/guide/transitions.html\" target=\"_blank\" rel=\"external\">更多动画效果请参考这里</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p> 这里只写由css实现的简单过渡，js用到在做记录。</p>\n</blockquote>\n<h3 id=\"过渡效果\"><a href=\"#过渡效果\" class=\"headerlink\" title=\"过渡效果\"></a>过渡效果</h3><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。<br>包括以下工具：</p>\n<ol>\n<li>在 CSS 过渡和动画中自动应用 class</li>\n<li>可以配合使用第三方 CSS 动画库，如 <a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\" rel=\"external\">Animate.css</a></li>\n<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>\n<li>可以配合使用第三方 JavaScript 动画库，如 <a href=\"http://velocityjs.org/\" target=\"_blank\" rel=\"external\">Velocity.js</a></li>\n</ol>\n<h4 id=\"单元素-组件的过渡\"><a href=\"#单元素-组件的过渡\" class=\"headerlink\" title=\"单元素/组件的过渡\"></a>单元素/组件的过渡</h4><p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡</p>\n<ul>\n<li>条件渲染 （使用 v-if）</li>\n<li>条件展示 （使用 v-show）</li>\n<li>动态组件</li>\n<li>组件根节点<br>这里是一个典型的例子：<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=\"demo\"&gt;</div><div class=\"line\">  &lt;button v-on:click=\"show = !show\"&gt;</div><div class=\"line\">    Toggle</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;transition name=\"fade\"&gt;</div><div class=\"line\">    &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;</div><div class=\"line\">  &lt;/transition&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: '#demo',</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    show: true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.fade-enter-active, .fade-leave-active &#123;</div><div class=\"line\">  transition: opacity .5s</div><div class=\"line\">&#125;</div><div class=\"line\">.fade-enter, .fade-leave-active &#123;</div><div class=\"line\">  opacity: 0</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>元素封装成过渡组件之后，在遇到插入或删除时，Vue 将自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。</p>\n<p>如果过渡组件设置了过渡的 JavaScript 钩子函数，会在相应的阶段调用钩子函数。</p>\n<p>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 nextTick 概念不同)</p>\n<h4 id=\"过渡的-CSS-类名\"><a href=\"#过渡的-CSS-类名\" class=\"headerlink\" title=\"过渡的-CSS-类名\"></a>过渡的-CSS-类名</h4><p>会有 4 个(CSS)类名在 enter/leave 的过渡中切换</p>\n<p><strong>v-enter</strong>: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</p>\n<p><strong>v-enter-active</strong>: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。</p>\n<p><strong>v-leave</strong>: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</p>\n<p><strong>v-leave-active</strong>: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。</p>\n<p><img src=\"https://vuefe.cn/images/transition.png\" alt=\"Transition Diagram\"></p>\n<p>对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 &lt;name=”my-transition&gt;” 可以重置前缀，比如 v-enter 替换为 my-transition-enter。</p>\n<p>v-enter-active 和 v-leave-active 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。</p>\n<h3 id=\"CSS-过渡\"><a href=\"#CSS-过渡\" class=\"headerlink\" title=\"CSS 过渡\"></a>CSS 过渡</h3><p><strong>常用的过渡都是使用 CSS 过渡。</strong></p>\n<p>下面是一个简单例子：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=\"example-1\"&gt;</div><div class=\"line\">  &lt;button @click=\"show = !show\"&gt;</div><div class=\"line\">    Toggle render</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;transition name=\"slide-fade\"&gt;</div><div class=\"line\">    &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;</div><div class=\"line\">  &lt;/transition&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: '#example-1',</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    show: true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">/* 可以设置不同的进入和离开动画 */</div><div class=\"line\">/* 设置持续时间和动画函数 */</div><div class=\"line\">.slide-fade-enter-active &#123;</div><div class=\"line\">  transition: all .3s ease;</div><div class=\"line\">&#125;</div><div class=\"line\">.slide-fade-leave-active &#123;</div><div class=\"line\">  transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);</div><div class=\"line\">&#125;</div><div class=\"line\">.slide-fade-enter, .slide-fade-leave-active &#123;</div><div class=\"line\">  padding-left: 10px;</div><div class=\"line\">  opacity: 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"CSS-动画\"><a href=\"#CSS-动画\" class=\"headerlink\" title=\"CSS 动画\"></a>CSS 动画</h4><p>CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。</p>\n<p>示例： (省略了兼容性前缀)<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=\"example-2\"&gt;</div><div class=\"line\">  &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt;</div><div class=\"line\">  &lt;transition name=\"bounce\"&gt;</div><div class=\"line\">    &lt;p v-if=\"show\"&gt;Look at me!&lt;/p&gt;</div><div class=\"line\">  &lt;/transition&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: '#example-2',</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    show: true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.bounce-enter-active &#123;</div><div class=\"line\">  animation: bounce-in .5s;</div><div class=\"line\">&#125;</div><div class=\"line\">.bounce-leave-active &#123;</div><div class=\"line\">  animation: bounce-out .5s;</div><div class=\"line\">&#125;</div><div class=\"line\">@keyframes bounce-in &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    transform: scale(0);</div><div class=\"line\">  &#125;</div><div class=\"line\">  50% &#123;</div><div class=\"line\">    transform: scale(1.5);</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    transform: scale(1);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@keyframes bounce-out &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    transform: scale(1);</div><div class=\"line\">  &#125;</div><div class=\"line\">  50% &#123;</div><div class=\"line\">    transform: scale(1.5);</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    transform: scale(0);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"自定义过渡类名\"><a href=\"#自定义过渡类名\" class=\"headerlink\" title=\"自定义过渡类名\"></a>自定义过渡类名</h4><p>我们可以通过以下特性来自定义过渡类名：</p>\n<p><strong>enter-class</strong><br><strong>enter-active-class</strong><br><strong>leave-class</strong><br><strong>leave-active-class</strong><br>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如<strong> Animate.css </strong>结合使用十分有用。</p>\n<p>示例：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;</div><div class=\"line\">&lt;div id=\"example-3\"&gt;</div><div class=\"line\">  &lt;button @click=\"show = !show\"&gt;</div><div class=\"line\">    Toggle render</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;transition</div><div class=\"line\">    name=\"custom-classes-transition\"</div><div class=\"line\">    enter-active-class=\"animated tada\"</div><div class=\"line\">    leave-active-class=\"animated bounceOutRight\"</div><div class=\"line\">  &gt;</div><div class=\"line\">    &lt;p v-if=\"show\"&gt;hello&lt;/p&gt;</div><div class=\"line\">  &lt;/transition&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: '#example-3',</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    show: true</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>","more":"<h4 id=\"同时使用-Transitions-和-Animations\"><a href=\"#同时使用-Transitions-和-Animations\" class=\"headerlink\" title=\"同时使用 Transitions 和 Animations\"></a>同时使用 Transitions 和 Animations</h4><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p>\n<p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。</p>\n<h4 id=\"初始渲染的过渡\"><a href=\"#初始渲染的过渡\" class=\"headerlink\" title=\"初始渲染的过渡\"></a>初始渲染的过渡</h4><p>可以通过 <strong>appear</strong> 特性设置节点的在初始渲染的过渡<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition appear&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">transition</span></span></div><div class=\"line\">  <span class=\"attr\">appear</span></div><div class=\"line\">  <span class=\"attr\">appear-class</span>=<span class=\"string\">\"custom-appear-class\"</span></div><div class=\"line\">  <span class=\"attr\">appear-active-class</span>=<span class=\"string\">\"custom-appear-active-class\"</span></div><div class=\"line\">&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"多个元素的过渡\"><a href=\"#多个元素的过渡\" class=\"headerlink\" title=\"多个元素的过渡\"></a>多个元素的过渡</h4><p>我们之后讨论 <strong>多个组件的过渡</strong>, 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;table v-if=&quot;items.length &gt; 0&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;/table&gt;</div><div class=\"line\">  &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;</div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>可以这样使用，但是有一点需要注意：</p>\n<p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <transition> 组件中的多个元素设置 key 是一个更好的实践。</transition></p>\n<h5 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例:\"></a>示例:</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt;</div><div class=\"line\">    Save</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;button v-else key=&quot;edit&quot;&gt;</div><div class=\"line\">    Edit</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure>\n<p>在一些场景中，也可以给通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;button v-bind:key=&quot;isEditing&quot;&gt;</div><div class=\"line\">    &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125;</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。 例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;button v-if=&quot;docState === &apos;saved&apos;&quot; key=&quot;saved&quot;&gt;</div><div class=\"line\">    Edit</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;button v-if=&quot;docState === &apos;edited&apos;&quot; key=&quot;edited&quot;&gt;</div><div class=\"line\">    Save</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">  &lt;button v-if=&quot;docState === &apos;editing&apos;&quot; key=&quot;editing&quot;&gt;</div><div class=\"line\">    Cancel</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>可以重写为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition&gt;</div><div class=\"line\">  &lt;button v-bind:key=&quot;docState&quot;&gt;</div><div class=\"line\">    &#123;&#123; buttonMessage &#125;&#125;</div><div class=\"line\">  &lt;/button&gt;</div><div class=\"line\">&lt;/transition&gt;</div><div class=\"line\"></div><div class=\"line\">computed: &#123;</div><div class=\"line\">  buttonMessage: function () &#123;</div><div class=\"line\">    switch (docState) &#123;</div><div class=\"line\">      case &apos;saved&apos;: return &apos;Edit&apos;</div><div class=\"line\">      case &apos;edited&apos;: return &apos;Save&apos;</div><div class=\"line\">      case &apos;editing&apos;: return &apos;Cancel&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"过渡模式\"><a href=\"#过渡模式\" class=\"headerlink\" title=\"过渡模式\"></a><a href=\"https://vuefe.cn/guide/transitions.html#过渡模式\" target=\"_blank\" rel=\"external\">过渡模式</a></h3><p><strong>同时生效</strong>的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 <strong>过渡模式</strong></p>\n<ul>\n<li><strong>in-out</strong>: 新元素先进行过渡，完成之后当前元素过渡离开。</li>\n<li><strong>out-in</strong>: 当前元素先进行过渡，完成之后新元素过渡进入。</li>\n</ul>\n<p>用 <strong>out-in</strong> 重写之前的开关按钮过渡：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;&lt;/transition&gt;</div></pre></td></tr></table></figure></p>\n<p>只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。<br><strong>in-out</strong> 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。</p>\n<h3 id=\"多个组件的过渡\"><a href=\"#多个组件的过渡\" class=\"headerlink\" title=\"多个组件的过渡\"></a>多个组件的过渡</h3><p>多个组件的过渡很简单很多,我们不需要使用 key 特性。相反，我们只需要<strong>使用动态组件</strong>:</p>\n<h4 id=\"关于动态组件\"><a href=\"#关于动态组件\" class=\"headerlink\" title=\"关于动态组件\"></a>关于动态组件</h4><blockquote>\n<p> 多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <component> 元素，动态地绑定到它的 is 特性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">var vm = new Vue(&#123;</div><div class=\"line\">  el: &apos;#example&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    currentView: &apos;home&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    home: &#123; /* ... */ &#125;,</div><div class=\"line\">    posts: &#123; /* ... */ &#125;,</div><div class=\"line\">    archive: &#123; /* ... */ &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">&lt;component v-bind:is=&quot;currentView&quot;&gt;</div><div class=\"line\">  &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</div><div class=\"line\">&lt;/component&gt;</div><div class=\"line\">也可以直接绑定到组件对象上：</div><div class=\"line\"></div><div class=\"line\">var Home = &#123;</div><div class=\"line\">  template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">var vm = new Vue(&#123;</div><div class=\"line\">  el: &apos;#example&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    currentView: Home</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></component></p>\n</blockquote>\n<p>使用动态组件实现过渡<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;</div><div class=\"line\">  &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;</div><div class=\"line\">&lt;/transition&gt;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: &apos;#transition-components-demo&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    view: &apos;v-a&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  components: &#123;</div><div class=\"line\">    &apos;v-a&apos;: &#123;</div><div class=\"line\">      template: &apos;&lt;div&gt;Component A&lt;/div&gt;&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &apos;v-b&apos;: &#123;</div><div class=\"line\">      template: &apos;&lt;div&gt;Component B&lt;/div&gt;&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.component-fade-enter-active, .component-fade-leave-active &#123;</div><div class=\"line\">  transition: opacity .3s ease;</div><div class=\"line\">&#125;</div><div class=\"line\">.component-fade-enter, .component-fade-leave-active &#123;</div><div class=\"line\">  opacity: 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://vuefe.cn/guide/transitions.html\" target=\"_blank\" rel=\"external\">更多动画效果请参考这里</a></p>"},{"title":"flex","date":"2016-10-17T12:56:08.000Z","_content":">  转载自[阮一峰的网络日志-Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)\n\n### 一、Flex布局是什么？\nFlex是Flexible Box的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n任何一个容器都可以指定为Flex布局。\n``\n.box{\n  display: flex;\n}``\n行内元素也可以使用Flex布局。\n``\n.box{\n  display: inline-flex;\n}``\nWebkit内核的浏览器，必须加上-webkit前缀。\n``\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}``\n**注意，设为Flex布局以后，子元素的*float*、*clear*和*vertical-align*属性将失效。**    \n### 二、基本概念\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n![项目](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n### 三、容器的属性\n以下6个属性设置在容器上。\n - flex-direction\n - flex-wrap\n - flex-flow\n - justify-content\n - align-items\n - align-content\n\n<!--more-->\n##### 3.1 flex-direction属性\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n``\n.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n``\n![flex direction](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png)\n它可能有4个值。\n - *row*（默认值）：主轴为水平方向，起点在左端。\n - *row-reverse*：主轴为水平方向，起点在右端。\n - *column*：主轴为垂直方向，起点在上沿。\n - *column-reverse*：主轴为垂直方向，起点在下沿。\n\n##### 3.2 flex-wrap属性\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n![flex-wrap](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png)\n``\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}``\n它可能取三个值。\n - *nowrap*（默认）：不换行。\n![nowrap](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png)\n - *wrap*：换行，第一行在上方。\n![wrap](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg)\n - *wrap-reverse*：换行，第一行在下方。\n[warap-reverse](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg)\n##### 3.3 flex-flow\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n``\n.box {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}``\n##### 3.4 justify-content属性\n**justify-content**属性定义了项目在**主轴**上的对齐方式。\n``\n.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n``\n![justify-content](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png)\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n - *flex-start*（默认值）：左对齐\n - *flex-end*：右对齐\n - *center*： 居中\n - *space-between*：两端对齐，项目之间的间隔都相等。\n - *space-around*：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n##### 3.5 align-items属性\n**align-item.**s属性定义项目在**交叉轴**上如何对齐。\n``\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n``\n![align-items](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n - flex-start：交叉轴的起点对齐。\n - flex-end：交叉轴的终点对齐。\n - center：交叉轴的中点对齐。\n - baseline: 项目的第一行文字的基线对齐。\n - stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n##### 3.6 align-content属性\n**align-content**属性定义了**多根轴线的对齐方式**。如果项目只有一根轴线，该属性不起作用。\n``\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n``\n![align-content](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)\n该属性可能取6个值。\n - *flex-start*：与交叉轴的起点对齐。\n - *flex-end*：与交叉轴的终点对齐。\n - *center*：与交叉轴的中点对齐。\n - *space-between*：与交叉轴两端对齐，轴线之间的间隔平均分布。\n - *space-around*：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\nstretch（默认值）：轴线占满整个交叉轴。\n### 四、项目的属性\n以下6个属性设置在项目上。\n - *order*\n - *flex-grow*\n - *flex-shrink*\n - *flex-basis*\n - *flex*\n - *align-self*\n##### 4.1 order属性\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n``\n.item {\n  order: <integer>;\n}\n``\n![order](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png)\n##### 4.2 flex-grow属性\nflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n``\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n``\n![flex-grow](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png)\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n##### 4.3 flex-shrink属性\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n``\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n``\n![flex-shrink](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。\n##### 4.4 flex-basis属性\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n``\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}``\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n##### 4.5 flex属性\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n``\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}``\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n##### 4.6 align-self属性\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n``\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n``\n![align-self](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png)\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。      ","source":"_posts/flex.md","raw":"---\ntitle: flex\ndate: 2016-10-17 20:56:08\ntags: css3\n---\n>  转载自[阮一峰的网络日志-Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)\n\n### 一、Flex布局是什么？\nFlex是Flexible Box的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n任何一个容器都可以指定为Flex布局。\n``\n.box{\n  display: flex;\n}``\n行内元素也可以使用Flex布局。\n``\n.box{\n  display: inline-flex;\n}``\nWebkit内核的浏览器，必须加上-webkit前缀。\n``\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}``\n**注意，设为Flex布局以后，子元素的*float*、*clear*和*vertical-align*属性将失效。**    \n### 二、基本概念\n采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n![项目](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n### 三、容器的属性\n以下6个属性设置在容器上。\n - flex-direction\n - flex-wrap\n - flex-flow\n - justify-content\n - align-items\n - align-content\n\n<!--more-->\n##### 3.1 flex-direction属性\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n``\n.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}\n``\n![flex direction](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png)\n它可能有4个值。\n - *row*（默认值）：主轴为水平方向，起点在左端。\n - *row-reverse*：主轴为水平方向，起点在右端。\n - *column*：主轴为垂直方向，起点在上沿。\n - *column-reverse*：主轴为垂直方向，起点在下沿。\n\n##### 3.2 flex-wrap属性\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n![flex-wrap](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png)\n``\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}``\n它可能取三个值。\n - *nowrap*（默认）：不换行。\n![nowrap](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png)\n - *wrap*：换行，第一行在上方。\n![wrap](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg)\n - *wrap-reverse*：换行，第一行在下方。\n[warap-reverse](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg)\n##### 3.3 flex-flow\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n``\n.box {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}``\n##### 3.4 justify-content属性\n**justify-content**属性定义了项目在**主轴**上的对齐方式。\n``\n.box {\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n``\n![justify-content](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png)\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n - *flex-start*（默认值）：左对齐\n - *flex-end*：右对齐\n - *center*： 居中\n - *space-between*：两端对齐，项目之间的间隔都相等。\n - *space-around*：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n##### 3.5 align-items属性\n**align-item.**s属性定义项目在**交叉轴**上如何对齐。\n``\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n``\n![align-items](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n - flex-start：交叉轴的起点对齐。\n - flex-end：交叉轴的终点对齐。\n - center：交叉轴的中点对齐。\n - baseline: 项目的第一行文字的基线对齐。\n - stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n##### 3.6 align-content属性\n**align-content**属性定义了**多根轴线的对齐方式**。如果项目只有一根轴线，该属性不起作用。\n``\n.box {\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n``\n![align-content](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)\n该属性可能取6个值。\n - *flex-start*：与交叉轴的起点对齐。\n - *flex-end*：与交叉轴的终点对齐。\n - *center*：与交叉轴的中点对齐。\n - *space-between*：与交叉轴两端对齐，轴线之间的间隔平均分布。\n - *space-around*：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\nstretch（默认值）：轴线占满整个交叉轴。\n### 四、项目的属性\n以下6个属性设置在项目上。\n - *order*\n - *flex-grow*\n - *flex-shrink*\n - *flex-basis*\n - *flex*\n - *align-self*\n##### 4.1 order属性\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n``\n.item {\n  order: <integer>;\n}\n``\n![order](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png)\n##### 4.2 flex-grow属性\nflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n``\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n``\n![flex-grow](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png)\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n##### 4.3 flex-shrink属性\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n``\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n``\n![flex-shrink](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。\n##### 4.4 flex-basis属性\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n``\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}``\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n##### 4.5 flex属性\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n``\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}``\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n##### 4.6 align-self属性\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n``\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n``\n![align-self](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png)\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。      ","slug":"flex","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdk0014zk4on2o4d1hi","content":"<blockquote>\n<p> 转载自<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool\" target=\"_blank\" rel=\"external\">阮一峰的网络日志-Flex 布局教程：语法篇</a></p>\n</blockquote>\n<h3 id=\"一、Flex布局是什么？\"><a href=\"#一、Flex布局是什么？\" class=\"headerlink\" title=\"一、Flex布局是什么？\"></a>一、Flex布局是什么？</h3><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为Flex布局。<br><code>.box{\n  display: flex;\n}</code><br>行内元素也可以使用Flex布局。<br><code>.box{\n  display: inline-flex;\n}</code><br>Webkit内核的浏览器，必须加上-webkit前缀。<br><code>.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}</code><br><strong>注意，设为Flex布局以后，子元素的<em>float</em>、<em>clear</em>和<em>vertical-align</em>属性将失效。</strong>    </p>\n<h3 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h3><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png\" alt=\"项目\"><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<h3 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h3><p>以下6个属性设置在容器上。</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>\n<a id=\"more\"></a>\n<h5 id=\"3-1-flex-direction属性\"><a href=\"#3-1-flex-direction属性\" class=\"headerlink\" title=\"3.1 flex-direction属性\"></a>3.1 flex-direction属性</h5><p>flex-direction属性决定主轴的方向（即项目的排列方向）。<br><code>.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png\" alt=\"flex direction\"><br>它可能有4个值。</p>\n<ul>\n<li><em>row</em>（默认值）：主轴为水平方向，起点在左端。</li>\n<li><em>row-reverse</em>：主轴为水平方向，起点在右端。</li>\n<li><em>column</em>：主轴为垂直方向，起点在上沿。</li>\n<li><em>column-reverse</em>：主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h5 id=\"3-2-flex-wrap属性\"><a href=\"#3-2-flex-wrap属性\" class=\"headerlink\" title=\"3.2 flex-wrap属性\"></a>3.2 flex-wrap属性</h5><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png\" alt=\"flex-wrap\"><br><code>.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}</code><br>它可能取三个值。</p>\n<ul>\n<li><em>nowrap</em>（默认）：不换行。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png\" alt=\"nowrap\"></li>\n<li><em>wrap</em>：换行，第一行在上方。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg\" alt=\"wrap\"></li>\n<li><em>wrap-reverse</em>：换行，第一行在下方。<br><a href=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg\" target=\"_blank\" rel=\"external\">warap-reverse</a><h5 id=\"3-3-flex-flow\"><a href=\"#3-3-flex-flow\" class=\"headerlink\" title=\"3.3 flex-flow\"></a>3.3 flex-flow</h5>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br><code>.box {\nflex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;\n}</code><h5 id=\"3-4-justify-content属性\"><a href=\"#3-4-justify-content属性\" class=\"headerlink\" title=\"3.4 justify-content属性\"></a>3.4 justify-content属性</h5><strong>justify-content</strong>属性定义了项目在<strong>主轴</strong>上的对齐方式。<br><code>.box {\njustify-content: flex-start | flex-end | center | space-between | space-around;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png\" alt=\"justify-content\"><br>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</li>\n<li><em>flex-start</em>（默认值）：左对齐</li>\n<li><em>flex-end</em>：右对齐</li>\n<li><em>center</em>： 居中</li>\n<li><em>space-between</em>：两端对齐，项目之间的间隔都相等。</li>\n<li><em>space-around</em>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<h5 id=\"3-5-align-items属性\"><a href=\"#3-5-align-items属性\" class=\"headerlink\" title=\"3.5 align-items属性\"></a>3.5 align-items属性</h5><strong>align-item.</strong>s属性定义项目在<strong>交叉轴</strong>上如何对齐。<br><code>.box {\nalign-items: flex-start | flex-end | center | baseline | stretch;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png\" alt=\"align-items\"><br>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</li>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。<h5 id=\"3-6-align-content属性\"><a href=\"#3-6-align-content属性\" class=\"headerlink\" title=\"3.6 align-content属性\"></a>3.6 align-content属性</h5><strong>align-content</strong>属性定义了<strong>多根轴线的对齐方式</strong>。如果项目只有一根轴线，该属性不起作用。<br><code>.box {\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png\" alt=\"align-content\"><br>该属性可能取6个值。</li>\n<li><em>flex-start</em>：与交叉轴的起点对齐。</li>\n<li><em>flex-end</em>：与交叉轴的终点对齐。</li>\n<li><em>center</em>：与交叉轴的中点对齐。</li>\n<li><em>space-between</em>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li><em>space-around</em>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3>以下6个属性设置在项目上。</li>\n<li><em>order</em></li>\n<li><em>flex-grow</em></li>\n<li><em>flex-shrink</em></li>\n<li><em>flex-basis</em></li>\n<li><em>flex</em></li>\n<li><em>align-self</em><h5 id=\"4-1-order属性\"><a href=\"#4-1-order属性\" class=\"headerlink\" title=\"4.1 order属性\"></a>4.1 order属性</h5>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br><code>.item {\norder: &lt;integer&gt;;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png\" alt=\"order\"><h5 id=\"4-2-flex-grow属性\"><a href=\"#4-2-flex-grow属性\" class=\"headerlink\" title=\"4.2 flex-grow属性\"></a>4.2 flex-grow属性</h5>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><code>.item {\nflex-grow: &lt;number&gt;; /* default 0 */\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png\" alt=\"flex-grow\"><br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<h5 id=\"4-3-flex-shrink属性\"><a href=\"#4-3-flex-shrink属性\" class=\"headerlink\" title=\"4.3 flex-shrink属性\"></a>4.3 flex-shrink属性</h5>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br><code>.item {\nflex-shrink: &lt;number&gt;; /* default 1 */\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg\" alt=\"flex-shrink\"><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。<h5 id=\"4-4-flex-basis属性\"><a href=\"#4-4-flex-basis属性\" class=\"headerlink\" title=\"4.4 flex-basis属性\"></a>4.4 flex-basis属性</h5>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><code>.item {\nflex-basis: &lt;length&gt; | auto; /* default auto */\n}</code><br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。<h5 id=\"4-5-flex属性\"><a href=\"#4-5-flex属性\" class=\"headerlink\" title=\"4.5 flex属性\"></a>4.5 flex属性</h5>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br><code>.item {\nflex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]\n}</code><br>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。<h5 id=\"4-6-align-self属性\"><a href=\"#4-6-align-self属性\" class=\"headerlink\" title=\"4.6 align-self属性\"></a>4.6 align-self属性</h5>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><code>.item {\nalign-self: auto | flex-start | flex-end | center | baseline | stretch;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png\" alt=\"align-self\"><br>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。      </li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p> 转载自<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool\" target=\"_blank\" rel=\"external\">阮一峰的网络日志-Flex 布局教程：语法篇</a></p>\n</blockquote>\n<h3 id=\"一、Flex布局是什么？\"><a href=\"#一、Flex布局是什么？\" class=\"headerlink\" title=\"一、Flex布局是什么？\"></a>一、Flex布局是什么？</h3><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为Flex布局。<br><code>.box{\n  display: flex;\n}</code><br>行内元素也可以使用Flex布局。<br><code>.box{\n  display: inline-flex;\n}</code><br>Webkit内核的浏览器，必须加上-webkit前缀。<br><code>.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}</code><br><strong>注意，设为Flex布局以后，子元素的<em>float</em>、<em>clear</em>和<em>vertical-align</em>属性将失效。</strong>    </p>\n<h3 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h3><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png\" alt=\"项目\"><br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>\n<h3 id=\"三、容器的属性\"><a href=\"#三、容器的属性\" class=\"headerlink\" title=\"三、容器的属性\"></a>三、容器的属性</h3><p>以下6个属性设置在容器上。</p>\n<ul>\n<li>flex-direction</li>\n<li>flex-wrap</li>\n<li>flex-flow</li>\n<li>justify-content</li>\n<li>align-items</li>\n<li>align-content</li>\n</ul>","more":"<h5 id=\"3-1-flex-direction属性\"><a href=\"#3-1-flex-direction属性\" class=\"headerlink\" title=\"3.1 flex-direction属性\"></a>3.1 flex-direction属性</h5><p>flex-direction属性决定主轴的方向（即项目的排列方向）。<br><code>.box {\n  flex-direction: row | row-reverse | column | column-reverse;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png\" alt=\"flex direction\"><br>它可能有4个值。</p>\n<ul>\n<li><em>row</em>（默认值）：主轴为水平方向，起点在左端。</li>\n<li><em>row-reverse</em>：主轴为水平方向，起点在右端。</li>\n<li><em>column</em>：主轴为垂直方向，起点在上沿。</li>\n<li><em>column-reverse</em>：主轴为垂直方向，起点在下沿。</li>\n</ul>\n<h5 id=\"3-2-flex-wrap属性\"><a href=\"#3-2-flex-wrap属性\" class=\"headerlink\" title=\"3.2 flex-wrap属性\"></a>3.2 flex-wrap属性</h5><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png\" alt=\"flex-wrap\"><br><code>.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}</code><br>它可能取三个值。</p>\n<ul>\n<li><em>nowrap</em>（默认）：不换行。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png\" alt=\"nowrap\"></li>\n<li><em>wrap</em>：换行，第一行在上方。<br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg\" alt=\"wrap\"></li>\n<li><em>wrap-reverse</em>：换行，第一行在下方。<br><a href=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg\" target=\"_blank\" rel=\"external\">warap-reverse</a><h5 id=\"3-3-flex-flow\"><a href=\"#3-3-flex-flow\" class=\"headerlink\" title=\"3.3 flex-flow\"></a>3.3 flex-flow</h5>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。<br><code>.box {\nflex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;\n}</code><h5 id=\"3-4-justify-content属性\"><a href=\"#3-4-justify-content属性\" class=\"headerlink\" title=\"3.4 justify-content属性\"></a>3.4 justify-content属性</h5><strong>justify-content</strong>属性定义了项目在<strong>主轴</strong>上的对齐方式。<br><code>.box {\njustify-content: flex-start | flex-end | center | space-between | space-around;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png\" alt=\"justify-content\"><br>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</li>\n<li><em>flex-start</em>（默认值）：左对齐</li>\n<li><em>flex-end</em>：右对齐</li>\n<li><em>center</em>： 居中</li>\n<li><em>space-between</em>：两端对齐，项目之间的间隔都相等。</li>\n<li><em>space-around</em>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<h5 id=\"3-5-align-items属性\"><a href=\"#3-5-align-items属性\" class=\"headerlink\" title=\"3.5 align-items属性\"></a>3.5 align-items属性</h5><strong>align-item.</strong>s属性定义项目在<strong>交叉轴</strong>上如何对齐。<br><code>.box {\nalign-items: flex-start | flex-end | center | baseline | stretch;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png\" alt=\"align-items\"><br>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</li>\n<li>flex-start：交叉轴的起点对齐。</li>\n<li>flex-end：交叉轴的终点对齐。</li>\n<li>center：交叉轴的中点对齐。</li>\n<li>baseline: 项目的第一行文字的基线对齐。</li>\n<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。<h5 id=\"3-6-align-content属性\"><a href=\"#3-6-align-content属性\" class=\"headerlink\" title=\"3.6 align-content属性\"></a>3.6 align-content属性</h5><strong>align-content</strong>属性定义了<strong>多根轴线的对齐方式</strong>。如果项目只有一根轴线，该属性不起作用。<br><code>.box {\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png\" alt=\"align-content\"><br>该属性可能取6个值。</li>\n<li><em>flex-start</em>：与交叉轴的起点对齐。</li>\n<li><em>flex-end</em>：与交叉轴的终点对齐。</li>\n<li><em>center</em>：与交叉轴的中点对齐。</li>\n<li><em>space-between</em>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li><em>space-around</em>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。<h3 id=\"四、项目的属性\"><a href=\"#四、项目的属性\" class=\"headerlink\" title=\"四、项目的属性\"></a>四、项目的属性</h3>以下6个属性设置在项目上。</li>\n<li><em>order</em></li>\n<li><em>flex-grow</em></li>\n<li><em>flex-shrink</em></li>\n<li><em>flex-basis</em></li>\n<li><em>flex</em></li>\n<li><em>align-self</em><h5 id=\"4-1-order属性\"><a href=\"#4-1-order属性\" class=\"headerlink\" title=\"4.1 order属性\"></a>4.1 order属性</h5>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br><code>.item {\norder: &lt;integer&gt;;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png\" alt=\"order\"><h5 id=\"4-2-flex-grow属性\"><a href=\"#4-2-flex-grow属性\" class=\"headerlink\" title=\"4.2 flex-grow属性\"></a>4.2 flex-grow属性</h5>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><code>.item {\nflex-grow: &lt;number&gt;; /* default 0 */\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png\" alt=\"flex-grow\"><br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。<h5 id=\"4-3-flex-shrink属性\"><a href=\"#4-3-flex-shrink属性\" class=\"headerlink\" title=\"4.3 flex-shrink属性\"></a>4.3 flex-shrink属性</h5>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br><code>.item {\nflex-shrink: &lt;number&gt;; /* default 1 */\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg\" alt=\"flex-shrink\"><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。<h5 id=\"4-4-flex-basis属性\"><a href=\"#4-4-flex-basis属性\" class=\"headerlink\" title=\"4.4 flex-basis属性\"></a>4.4 flex-basis属性</h5>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br><code>.item {\nflex-basis: &lt;length&gt; | auto; /* default auto */\n}</code><br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。<h5 id=\"4-5-flex属性\"><a href=\"#4-5-flex属性\" class=\"headerlink\" title=\"4.5 flex属性\"></a>4.5 flex属性</h5>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br><code>.item {\nflex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]\n}</code><br>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。<h5 id=\"4-6-align-self属性\"><a href=\"#4-6-align-self属性\" class=\"headerlink\" title=\"4.6 align-self属性\"></a>4.6 align-self属性</h5>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br><code>.item {\nalign-self: auto | flex-start | flex-end | center | baseline | stretch;\n}</code><br><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png\" alt=\"align-self\"><br>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。      </li>\n</ul>"},{"title":"Javascript数据结构:队列","date":"2016-10-02T02:15:27.000Z","_content":">  队列是遵循FIFO(First In First Out,先进先出,也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素,并从顶部移除元素。最新添加的元素必须排在队列的末尾。\n在现实中,最常见的队列的例子就是排队，在电影院、自助餐厅、杂货店收银台,我们也都会排队。排在第一位的人会先接受服务。\n\n### 创建队列\n队列方法\n- enqueue(element(s)):向队列尾部添加一个(或多个)新的项。\n- dequeue():移除队列的第一(即排在队列最前面的)项,并返回被移除的元素。 \n- front():返回队列中第一个元素——最先被添加,也将是最先被移除的元素。队列不做任何变动(不移除元素,只返回元素信息——与Stack类的peek方法非常类似)。 \n-  isEmpty():如果队列中不包含任何元素,返回true,否则返回false。 \n- size():返回队列包含的元素个数,与数组的length属性类似。\n{% codeblock Queue lang:javascript %}\n\tfuncion Queue(){\n\t\tvar items = [];\n\t\tthis.enqueue = function(ele){\n\t\t\titems.push(ele)\n\t\t}\n\t\tthis.dequeue = function(){\n\t\t\treturn items.unshift();\n\t\t}\n\t\tthis.front = function(){\n\t\t\treturn items[0]\n\t\t}\n\t\tthis.isEmpty = function(){\n\t\t\treturn items.length===0\n\t\t}\n\t\tthis.size = function(){\n\t\t\treturn items.length\n\t\t}\n\t\tthis.print = function(){\n\t\t\tconsole.log(items.toString())\n\t\t}\n\t}\n{% endcodeblock %}","source":"_posts/javascript数据结构-队列.md","raw":"---\ntitle: 'Javascript数据结构:队列'\ndate: 2016-10-02 10:15:27\ntags:\n    - Javascript\n    - 队列\n---\n>  队列是遵循FIFO(First In First Out,先进先出,也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素,并从顶部移除元素。最新添加的元素必须排在队列的末尾。\n在现实中,最常见的队列的例子就是排队，在电影院、自助餐厅、杂货店收银台,我们也都会排队。排在第一位的人会先接受服务。\n\n### 创建队列\n队列方法\n- enqueue(element(s)):向队列尾部添加一个(或多个)新的项。\n- dequeue():移除队列的第一(即排在队列最前面的)项,并返回被移除的元素。 \n- front():返回队列中第一个元素——最先被添加,也将是最先被移除的元素。队列不做任何变动(不移除元素,只返回元素信息——与Stack类的peek方法非常类似)。 \n-  isEmpty():如果队列中不包含任何元素,返回true,否则返回false。 \n- size():返回队列包含的元素个数,与数组的length属性类似。\n{% codeblock Queue lang:javascript %}\n\tfuncion Queue(){\n\t\tvar items = [];\n\t\tthis.enqueue = function(ele){\n\t\t\titems.push(ele)\n\t\t}\n\t\tthis.dequeue = function(){\n\t\t\treturn items.unshift();\n\t\t}\n\t\tthis.front = function(){\n\t\t\treturn items[0]\n\t\t}\n\t\tthis.isEmpty = function(){\n\t\t\treturn items.length===0\n\t\t}\n\t\tthis.size = function(){\n\t\t\treturn items.length\n\t\t}\n\t\tthis.print = function(){\n\t\t\tconsole.log(items.toString())\n\t\t}\n\t}\n{% endcodeblock %}","slug":"javascript数据结构-队列","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdm0016zk4o6p1njw0j","content":"<blockquote>\n<p> 队列是遵循FIFO(First In First Out,先进先出,也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素,并从顶部移除元素。最新添加的元素必须排在队列的末尾。<br>在现实中,最常见的队列的例子就是排队，在电影院、自助餐厅、杂货店收银台,我们也都会排队。排在第一位的人会先接受服务。</p>\n</blockquote>\n<h3 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h3><p>队列方法</p>\n<ul>\n<li>enqueue(element(s)):向队列尾部添加一个(或多个)新的项。</li>\n<li>dequeue():移除队列的第一(即排在队列最前面的)项,并返回被移除的元素。 </li>\n<li>front():返回队列中第一个元素——最先被添加,也将是最先被移除的元素。队列不做任何变动(不移除元素,只返回元素信息——与Stack类的peek方法非常类似)。 </li>\n<li>isEmpty():如果队列中不包含任何元素,返回true,否则返回false。 </li>\n<li>size():返回队列包含的元素个数,与数组的length属性类似。<figure class=\"highlight javascript\"><figcaption><span>Queue</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">funcion Queue()&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t<span class=\"keyword\">this</span>.enqueue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele</span>)</span>&#123;</div><div class=\"line\">\t\titems.push(ele)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.dequeue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.unshift();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.front = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items[<span class=\"number\">0</span>]</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.isEmpty = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.length===<span class=\"number\">0</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.length</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(items.toString())</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 队列是遵循FIFO(First In First Out,先进先出,也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素,并从顶部移除元素。最新添加的元素必须排在队列的末尾。<br>在现实中,最常见的队列的例子就是排队，在电影院、自助餐厅、杂货店收银台,我们也都会排队。排在第一位的人会先接受服务。</p>\n</blockquote>\n<h3 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h3><p>队列方法</p>\n<ul>\n<li>enqueue(element(s)):向队列尾部添加一个(或多个)新的项。</li>\n<li>dequeue():移除队列的第一(即排在队列最前面的)项,并返回被移除的元素。 </li>\n<li>front():返回队列中第一个元素——最先被添加,也将是最先被移除的元素。队列不做任何变动(不移除元素,只返回元素信息——与Stack类的peek方法非常类似)。 </li>\n<li>isEmpty():如果队列中不包含任何元素,返回true,否则返回false。 </li>\n<li>size():返回队列包含的元素个数,与数组的length属性类似。<figure class=\"highlight javascript\"><figcaption><span>Queue</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">funcion Queue()&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t<span class=\"keyword\">this</span>.enqueue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele</span>)</span>&#123;</div><div class=\"line\">\t\titems.push(ele)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.dequeue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.unshift();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.front = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items[<span class=\"number\">0</span>]</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.isEmpty = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.length===<span class=\"number\">0</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.length</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(items.toString())</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Javascript 数据结构:栈","date":"2016-09-30T09:03:14.000Z","_content":">  栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 末尾,称作栈顶,另一端就叫栈底。在栈里,新元素都靠近栈顶,旧元素都接近栈底。\n在现实生活中也能发现很多栈的例子。例如,下图里的一摞书或者餐厅里堆放的盘子。\n\n### 栈的创建\n栈的方法:\n  - push(element(s)):添加一个(或几个)新元素到栈顶。 \n  - pop():移除栈顶的元素,同时返回被移除的元素。 \n  - peek():返回栈顶的元素,不对栈做任何修改(这个方法不会移除栈顶的元素,仅仅返回它)。\n  - isEmpty():如果栈里没有任何元素就返回true,否则返回false。 \n  - clear():移除栈里的所有元素。 \n  - size():返回栈里的元素个数。这个方法和数组的length属性很类似。\n使用数组来保存栈里的元素。\t\n{% codeblock Stack lang:javascript %}\n\tfuncion Stack(){\n\t\tvar items = [];\n\t\tthis.push = function(ele){\n\t\t\titems.push(ele)\n\t\t};\n\t\tthis.pop = function(){\n\t\t\treturn items.pop()\n\t\t};\n\t\tthis.peek = function(){\n\t\t\treturn items[items.length-1]\n\t\t};\n\t\tthis.isEmpty = function(){\n\t\t\treturn items.length ===0\n\t\t};\n\t\tthis.clear = function(){\n\t\t\titems.lenth=0\n\t\t};\n\t\tthis.size = function(){\n\t\t\treturn items.length\n\t\t};\n\t\tthis.print = function(){\n\t\t\tconsole.log(items.toString())\n\t\t}\n\t}\n{% endcodeblock %}\n  ","source":"_posts/javascript-数据结构-栈.md","raw":"---\ntitle: 'Javascript 数据结构:栈'\ndate: 2016-09-30 17:03:14\ntags: \n\t- Javascript\n\t- 栈\n---\n>  栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 末尾,称作栈顶,另一端就叫栈底。在栈里,新元素都靠近栈顶,旧元素都接近栈底。\n在现实生活中也能发现很多栈的例子。例如,下图里的一摞书或者餐厅里堆放的盘子。\n\n### 栈的创建\n栈的方法:\n  - push(element(s)):添加一个(或几个)新元素到栈顶。 \n  - pop():移除栈顶的元素,同时返回被移除的元素。 \n  - peek():返回栈顶的元素,不对栈做任何修改(这个方法不会移除栈顶的元素,仅仅返回它)。\n  - isEmpty():如果栈里没有任何元素就返回true,否则返回false。 \n  - clear():移除栈里的所有元素。 \n  - size():返回栈里的元素个数。这个方法和数组的length属性很类似。\n使用数组来保存栈里的元素。\t\n{% codeblock Stack lang:javascript %}\n\tfuncion Stack(){\n\t\tvar items = [];\n\t\tthis.push = function(ele){\n\t\t\titems.push(ele)\n\t\t};\n\t\tthis.pop = function(){\n\t\t\treturn items.pop()\n\t\t};\n\t\tthis.peek = function(){\n\t\t\treturn items[items.length-1]\n\t\t};\n\t\tthis.isEmpty = function(){\n\t\t\treturn items.length ===0\n\t\t};\n\t\tthis.clear = function(){\n\t\t\titems.lenth=0\n\t\t};\n\t\tthis.size = function(){\n\t\t\treturn items.length\n\t\t};\n\t\tthis.print = function(){\n\t\t\tconsole.log(items.toString())\n\t\t}\n\t}\n{% endcodeblock %}\n  ","slug":"javascript-数据结构-栈","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdo0018zk4ojvlo25zi","content":"<blockquote>\n<p> 栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 末尾,称作栈顶,另一端就叫栈底。在栈里,新元素都靠近栈顶,旧元素都接近栈底。<br>在现实生活中也能发现很多栈的例子。例如,下图里的一摞书或者餐厅里堆放的盘子。</p>\n</blockquote>\n<h3 id=\"栈的创建\"><a href=\"#栈的创建\" class=\"headerlink\" title=\"栈的创建\"></a>栈的创建</h3><p>栈的方法:</p>\n<ul>\n<li>push(element(s)):添加一个(或几个)新元素到栈顶。 </li>\n<li>pop():移除栈顶的元素,同时返回被移除的元素。 </li>\n<li>peek():返回栈顶的元素,不对栈做任何修改(这个方法不会移除栈顶的元素,仅仅返回它)。</li>\n<li>isEmpty():如果栈里没有任何元素就返回true,否则返回false。 </li>\n<li>clear():移除栈里的所有元素。 </li>\n<li>size():返回栈里的元素个数。这个方法和数组的length属性很类似。<br>使用数组来保存栈里的元素。    <figure class=\"highlight javascript\"><figcaption><span>Stack</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">funcion Stack()&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t<span class=\"keyword\">this</span>.push = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele</span>)</span>&#123;</div><div class=\"line\">\t\titems.push(ele)</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.pop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.pop()</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.peek = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items[items.length<span class=\"number\">-1</span>]</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.isEmpty = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.length ===<span class=\"number\">0</span></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\titems.lenth=<span class=\"number\">0</span></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.length</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(items.toString())</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 末尾,称作栈顶,另一端就叫栈底。在栈里,新元素都靠近栈顶,旧元素都接近栈底。<br>在现实生活中也能发现很多栈的例子。例如,下图里的一摞书或者餐厅里堆放的盘子。</p>\n</blockquote>\n<h3 id=\"栈的创建\"><a href=\"#栈的创建\" class=\"headerlink\" title=\"栈的创建\"></a>栈的创建</h3><p>栈的方法:</p>\n<ul>\n<li>push(element(s)):添加一个(或几个)新元素到栈顶。 </li>\n<li>pop():移除栈顶的元素,同时返回被移除的元素。 </li>\n<li>peek():返回栈顶的元素,不对栈做任何修改(这个方法不会移除栈顶的元素,仅仅返回它)。</li>\n<li>isEmpty():如果栈里没有任何元素就返回true,否则返回false。 </li>\n<li>clear():移除栈里的所有元素。 </li>\n<li>size():返回栈里的元素个数。这个方法和数组的length属性很类似。<br>使用数组来保存栈里的元素。    <figure class=\"highlight javascript\"><figcaption><span>Stack</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">funcion Stack()&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> items = [];</div><div class=\"line\">\t<span class=\"keyword\">this</span>.push = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele</span>)</span>&#123;</div><div class=\"line\">\t\titems.push(ele)</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.pop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.pop()</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.peek = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items[items.length<span class=\"number\">-1</span>]</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.isEmpty = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.length ===<span class=\"number\">0</span></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\titems.lenth=<span class=\"number\">0</span></div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> items.length</div><div class=\"line\">\t&#125;;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(items.toString())</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"css3笔记","date":"2016-10-14T07:26:35.000Z","_content":">  仅记录一些常用的css3属性\n\n### 边框\n##### border-radius\n向元素添加圆角边框。\nborder-radius: 5px 4px 3px 2px; /* 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 */ \n##### box-shadow\n向盒子添加阴影,支持添加一个或者多个。\nbox-shadow:**X轴偏移** **Y轴偏移** *阴影模糊半径* *阴影扩展半径* *阴影颜色* *投影方式*;\n1. 阴影模糊半径与阴影扩展半径的区别\n阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；\n阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小；\n2. X轴偏移量和Y轴偏移量值可以设置为负数\n### 颜色\n##### Gradient渐变色彩 \nCSS3 Gradient 分为线性渐变(linear)和径向渐变(radial)。由于不同的渲染引擎实现渐变的语法不同，这里我们只针对线性渐变的 W3C 标准语法来分析其用法，其余大家可以查阅相关资料。W3C 语法已经得到了 IE10+、Firefox19.0+、Chrome26.0+ 和 Opera12.1+等浏览器的支持。\n``linear-gradient:(to top,#fff,#999)``\n - 第一个参数省略时，默认为“180deg”，等同于“to bottom”。\n - 第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。\n\n<!--more-->\n### 字体\n##### text-overflow\n用来设置是否使用一个省略标记（...）标示对象内文本的溢出。\n但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下：\n```\ntext-overflow:ellipsis; \noverflow:hidden; \nwhite-space:nowrap; \n```\nword-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行\nword-wrap:normal|| break-word\n##### text-shadow\n可以用来设置文本的阴影效果。\n``text-shadow: X-Offset Y-Offset blur color;``\n### 背景\n##### background-origin\n设置元素背景图片的原始起始位置。\n语法：\n``background-origin ： border-box | padding-box | content-box;``\n参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。\n需要注意的是，如果背景不是no-repeat，这个属性无效，它会从边框开始显示。\n##### background-size\n设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。\n语法：\n``background-size: auto | <长度值> | <百分比> | cover | contain``\n取值说明：\n1. auto：默认值，不改变背景图片的原始高度和宽度；\n2. <长度值>：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；\n3. <百分比>：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；\n4. cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器；\n5. contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。\n\n### 选择器\n##### 属性选择器\n{% codeblock HTML lang:html %}\n<a href=\"xxx.pdf\">我链接的是PDF文件</a>\n<a href=\"#\" class=\"icon\">我类名是icon</a>\n<a href=\"#\" title=\"我的title是more\">我的title是more</a>\n{% endcodeblock %}\n{% codeblock CSS lang:css %}  \na[class^=icon]{\n  background: green;\n  color:#fff;\n}\na[href$=pdf]{\n  background: orange;\n  color: #fff;\n}\na[title*=more]{\n  background: blue;\n  color: #fff;\n}\n{% endcodeblock %}\n##### 结构性伪类选择器—root\n``:root``选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是<html>。\n##### 结构性伪类选择器—not\n``:not``选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。\n##### 结构性伪类选择器—empty\n:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。\n##### 结构性伪类选择器—target\n:target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。\n多个url（多个target）处理：\n就像上面的例子，#brand与后面的id=\"brand\"是对应的，当同一个页面上有很多的url的时候你可以取不同的名字，只要#号后对的名称与id=\"\"中的名称对应就可以了。\n##### 结构性伪类选择器—first-child\n“:first-child”选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。\n``ol > li:first-child{\n  color: red;\n}\n``\n##### 结构性伪类选择器—last-child\n“:last-child”选择器与“:first-child”选择器作用类似，不同的是“:last-child”选择器选择的是元素的最后一个子元素。例如，需要改变的是列表中的最后一个“li”的背景色，就可以使用这个选择器.\n``ul>li:last-child{background:blue;}``\n##### 结构性伪类选择器—nth-child(n)\n“:nth-child(n)”选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。\n经验与技巧:当“:nth-child(n)”选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素。\n``ol > li:nth-child(2n){\n  background: orange;\n}\n``\n##### 结构性伪类选择器—nth-last-child(n)\n“:nth-last-child(n)”选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。\n##### first-of-type选择器\n“:first-of-type”选择器类似于“:first-child”选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。\n*我要改变第一个段落的背景为橙色*\n``.wrapper > p:first-of-type {\n  background: orange;\n}``\n通过“:first-of-type”选择器，定位div容器中的第一个p元素（p不一定是容器中的第一个子元素），并设置其背景色为橙色。\n##### nth-of-type(n)选择器\n“:nth-of-type(n)”选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词。\n##### last-of-type选择器\n“:last-of-type”选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素。\n##### nth-last-of-type(n)选择器\n“:nth-last-of-type(n)”选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。\n##### only-child选择器\n“:only-child”选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。\n##### only-of-type选择器\n“:only-of-type”选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。\n##### :enabled选择器\n在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器“:enabled”对这些表单元素设置样式。\n``input[type=\"text\"]:enabled {\n  background: #ccc;\n  border: 2px solid red;\n}``\n通过“:enabled”选择器，修改文本输入框的边框为2像素的红色边框，并设置它的背景为灰色。\n#####:disabled选择器\n“:disabled”选择器刚好与“:enabled”选择器相反，用来选择不可用表单元素。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。\n``\ninput[type=\"text\"]:disabled {\n  background: rgba(0,0,0,.15);\n  border: 1px solid rgba(0,0,0,.15);\n  color: rgba(0,0,0,.15);\n}\n``\n通过“:disabled”选择器，给不可用输入框设置明显的样式。\n##### :checked选择器\n在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而“:checked”表示的是选中状态。\n``\ninput[type=\"checkbox\"]:checked + span {\n  opacity: 1;\n}\n``\n##### ::selection选择器\n“::selection”伪元素是用来匹配突出显示的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示.\n有的时候设计要求,不使用上图那种浏览器默认的突出文本效果，需要一个与众不同的效果，此时“::selection”伪元素就非常的实用。不过在Firefox浏览器还需要添加前缀。\n``\n::-moz-selection {\n  background: red;\n  color: green;\n}\n::selection {\n  background: red;\n  color: green;\n}\n``\n:read-only选择器\n“:read-only”伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了“readonly=’readonly’”\n``input[type=\"text\"]:read-only{\n  border-color: #ccc;\n}``\n通过“:read-only”选择器来设置地址文本框的样式。\n##### :read-write选择器\n“:read-write”选择器刚好与“:read-only”选择器相反，主要用来指定当元素处于非只读状态时的样式。\n``\ninput[type=\"text\"]:read-write{\n  border-color: #f36;\n}\n``\n使用“:read-write”选择器来设置不是只读控件的文本框样式。\n##### ::before和::after\n**::before**和**::after**这两个主要用来给元素的前面或后面插入内容，这两个常和\"content\"配合使用，使用的场景最多的就是清除浮动。\n{% codeblock lang:css %}\n.clearfix::before,\n.clearfix::after {\n    content: \".\";\n    display: block;\n    height: 0;\n    visibility: hidden;\n}\n.clearfix:after {clear: both;}\n.clearfix {zoom: 1;}\n{% endcodeblock %}\n当然可以利用他们制作出其他更好的效果，比如右侧中的阴影效果，也是通过这个来实现的。\n\n关键代码分析：\n{% codeblock lang:css %}\n.effect::before, .effect::after{\n    content:\"\";\n    position:absolute;\n    z-index:-1;\n    -webkit-box-shadow:0 0 20px rgba(0,0,0,0.8);\n    -moz-box-shadow:0 0 20px rgba(0,0,0,0.8);\n    box-shadow:0 0 20px rgba(0,0,0,0.8);\n    top:50%;\n    bottom:0;\n    left:10px;\n    right:10px;\n    -moz-border-radius:100px / 10px;\n    border-radius:100px / 10px;\n}\n{% endcodeblock %}\n上面代码作用在class名叫.effect上的div的前（before）后(after)都添加一个空元素，然后为这两个空元素添加阴影特效。\n## 变形与动画 transform\n##### 变形--旋转 rotate()\n旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。\n```\n.wrapper div {\n  width: 200px;\n  height: 200px;\n  background: orange;\n  -webkit-transform: rotate(45deg);\n  transform: rotate(45deg);\n}\n```\n##### 变形--扭曲 skew()\n扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。这与rotate()函数的旋转不同，rotate()函数只是旋转，而不会改变元素的形状。skew()函数不会旋转，而只会改变元素的形状。\nSkew()具有**三种**情况：\n1. skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；\n![X,Y扭曲](http://ww1.sinaimg.cn/large/0060lm7Tgw1f8t3j7iejxj309z066mxr.jpg)\n第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。\n2. skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）；\n![X扭曲](http://ww4.sinaimg.cn/large/0060lm7Tgw1f8t3kqlvs1j30a805t0ta.jpg)\n3. skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形）\n![Y扭曲](http://ww4.sinaimg.cn/large/0060lm7Tgw1f8t3l1aem0j30a705saak.jpg)\n##### 变形--缩放 scale()\n缩放 scale()函数 让元素根据中心原点对对象进行缩放。\n缩放 scale 具有**三种**情况：\n1. scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）\n![X,Y缩放](http://img.mukewang.com/53391aff000181f703520211.jpg)\n``div:hover {\n  -webkit-transform: scale(1.5,0.5);\n  -moz-transform:scale(1.5,0.5)\n  transform: scale(1.5,0.5);\n}``\n**注意：Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。**\n2. scaleX(x)元素仅水平方向缩放（X轴缩放）\n![X缩放](http://img.mukewang.com/53391b0b00016a7002920170.jpg)\n3. scaleY(y)元素仅垂直方向缩放（Y轴缩放）\n![Y缩放](http://img.mukewang.com/53391b14000169cf03280183.jpg)\n##### 变形--位移 translate()\ntranslate()函数可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。\ntranslate我们分为**三种**情况：\n1、translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动），一个参数时仅X位移。\n![X,Y位移](http://img.mukewang.com/53391c640001709503850257.jpg)\n2、translateX(x)仅水平方向移动（X轴移动）\n![X位移](http://img.mukewang.com/53391c920001420703810201.jpg)\n3、translateY(Y)仅垂直方向移动（Y轴移动）\n![Y位移](http://img.mukewang.com/53391ca70001da5e03570211.jpg)\n##### 变形--矩阵 matrix()\nmatrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果需要深入了解，需要对数学矩阵有一定的知识。\n示例演示：通过matrix()函数来模拟transform中translate()位移的效果。\n{% codeblock lang:html %}\n<div class=\"wrapper\">\n  <div></div>\n</div>\n{% endcodeblock %}\n{% codeblock lang:css %}\n.wrapper {\n  width: 300px;\n  height: 200px;\n  border: 2px dotted red;\n  margin: 40px auto;\n}\n.wrapper div {\n  width:300px;\n  height: 200px;\n  background: orange;\n  -webkit-transform: matrix(1,0,0,1,50,50);\n  -moz-transform:matrix(1,0,0,1,50,50);\n  transform: matrix(1,0,0,1,50,50);\n}\n{% endcodeblock %}\n演示结果：\n![矩阵变换](http://img.mukewang.com/53391e000001b60b03890278.jpg)\n>  matrix(scaleX(),skewX(),skewY(),scaleY(),translateX(),translateY());\n\n## 动画--过渡属性 transition\n早期在Web中要实现动画效果，都是依赖于JavaScript或Flash来完成。但在CSS3中新增加了一个新的模块transition，它可以通过一些简单的CSS事件来触发元素的外观变化，让效果显得更加细腻。简单点说，就是通过鼠标的单击、获得焦点，被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。\n\n在CSS中创建简单的过渡效果可以从以下几个步骤来实现：\n1. 在默认样式中声明元素的初始状态样式；\n2. 声明过渡元素最终状态样式，比如悬浮状态；\n3. 在默认样式中通过添加过渡函数，添加一些不同的样式。\n\nCSS3的过度transition属性是一个复合属性，主要包括以下几个子属性：\n\n**transition-property**:指定过渡或动态模拟的CSS属性(width,height,transform...)\n**transition-duration**:指定完成过渡所需的时间\n**transition-timing-function**:指定过渡函数(ease,ease-in,ease-out,ease-in-out,linear...)\n**transition-delay**:指定开始出现的延迟时间\n先来看transition-property属性\n\ntransition-property用来指定过渡动画的CSS属性名称，而这个过渡属性只有具备一个中点值的属性（需要产生动画的属性）才能具备过渡效果,**特别注意：当“transition-property”属性设置为all时，表示的是所有中点值的属性。**\n用一个简单的例子来说明这个问题：\n>  假设你的初始状态设置了样式“width”,“height”,“background”,当你在终始状态都改变了这三个属性，那么all代表的就是“width”、“height”和“background”。如果你的终始状态只改变了“width”和“height”时，那么all代表的就是“width”和“height”。\n\n## 动画--animation\n##### Keyframes介绍\nKeyframes被称为关键帧，其类似于Flash中的关键帧。在CSS3中其主要以“@keyframes”开头，后面紧跟着是动画名称加上一对花括号“{…}”，括号中就是一些不同时间段样式规则。\n```\n@keyframes changecolor{\n  0%{\n   background: red;\n  }\n  100%{\n    background: green;\n  }\n}\n```\n在一个“@keyframes”中的样式规则可以由多个百分比构成的，如在“0%”到“100%”之间创建更多个百分比，分别给每个百分比中给需要有动画效果的元素加上不同的样式，从而达到一种在不断变化的效果。\n经验与技巧：在@keyframes中定义动画名称时，**其中0%和100%还可以使用关键词from和to来代表，其中0%对应的是from，100%对应的是to。**\n案例演示\n通过“@keyframes”声明一个名叫“wobble”的动画，从“0%”开始到“100%”结束，同时还经历了一个“40%”和“60%”两个过程。“wobble”动画在“0%”时元素定位到left为100px，背景色为green，然后在“40%”时元素过渡到left为150px,背景色为orange,接着在“60%”时元素过渡到left为75px，背景色为blue，最后“100%”时结束动画，元素又回到起点left为100px处，背景色变为red。\n``animation: wobble 5s ease .1s;``后三个参数与transition相同。\n```\nHTML:\n\n<div>鼠标放到我身上</div>\nCSS:\n\n@keyframes wobble {\n  0% {\n    margin-left: 100px;\n    background:green;\n  }\n  40% {\n    margin-left:150px;\n    background:orange;\n  }\n  60% {\n    margin-left: 75px;\n    background: blue;\n  }\n  100% {\n    margin-left: 100px;\n    background: red;\n  }\n}\ndiv {\n  width: 100px;\n  height: 100px;\n  background:red;\n  color: #fff;\n}\ndiv:hover{\n  animation: wobble 5s ease .1s;\n}\n```\n**animation-iteration-count**属性主要用来定义动画的播放次数。\n语法规则：\nanimation-iteration-count: infinite | <number> [, infinite | <number>]*\n1. 其值通常为整数，但也可以使用带有小数的数字，其默认值为1，这意味着动画将从开始到结束只播放一次。\n2. 如果取值为infinite，动画将会无限次的播放。\n##### 设置动画播放方向\n**animation-direction**属性主要用来设置动画播放方向，其语法规则如下：\nanimation-direction:normal | alternate [, normal | alternate]*\n其主要有两个值：normal、alternate\n1. normal是默认值，如果设置为normal时，动画的每次循环都是向前播放；\n2. 另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。\n例如：通过animation-direction属性，将move动画播放动画方向设置为alternate，代码为：\n``animation-direction:alternate;``\n###### 设置动画的播放状态\n**animation-play-state**属性主要用来控制元素动画的播放状态。\n参数：\n其主要有两个值：*running*和*paused*。\n\n其中running是其默认值，主要作用就是类似于音乐播放器一样，可以通过paused将正在播放的动画停下来，也可以通过running将暂停的动画重新播放，这里的重新播放不一定是从元素动画的开始播放，而是从暂停的那个位置开始播放。另外如果暂停了动画的播放，元素的样式将回到最原始设置状态。\n例如，页面加载时，动画不播放。代码如下：\n``animation-play-state:paused;``\n##### 设置动画时间外属性\n**animation-fill-mode**属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：none、forwards、backwords和both。其四个属性值对应效果如下：\n\n|属性值     |效果                                                                |\n|:--------:|-------------------------------------------------------------------|\n|none      |默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时,动画会反转到初始帧处 |\n|forwards  |表示动画在结束后继续应用最后的关键帧的位置                                |\n|backwards |会在向元素应用动画样式时迅速应用动画的初始帧                               |\n|both      |元素动画同时具有forwards和backwards效果                                |\n\n在默认情况之下，动画不会影响它的关键帧之外的属性，使用animation-fill-mode属性可以修改动画的默认行为。简单的说就是告诉动画在第一关键帧上等待动画开始，或者在动画结束时停在最后一个关键帧上而不回到动画的第一帧上。或者同时具有这两个效果。\n例如：让动画停在最一帧处。代码如下：\n``animation-fill-mode:forwards; ``\n","source":"_posts/css3笔记.md","raw":"---\ntitle: css3笔记\ndate: 2016-10-14 15:26:35\ntags: css3\n---\n>  仅记录一些常用的css3属性\n\n### 边框\n##### border-radius\n向元素添加圆角边框。\nborder-radius: 5px 4px 3px 2px; /* 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 */ \n##### box-shadow\n向盒子添加阴影,支持添加一个或者多个。\nbox-shadow:**X轴偏移** **Y轴偏移** *阴影模糊半径* *阴影扩展半径* *阴影颜色* *投影方式*;\n1. 阴影模糊半径与阴影扩展半径的区别\n阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；\n阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小；\n2. X轴偏移量和Y轴偏移量值可以设置为负数\n### 颜色\n##### Gradient渐变色彩 \nCSS3 Gradient 分为线性渐变(linear)和径向渐变(radial)。由于不同的渲染引擎实现渐变的语法不同，这里我们只针对线性渐变的 W3C 标准语法来分析其用法，其余大家可以查阅相关资料。W3C 语法已经得到了 IE10+、Firefox19.0+、Chrome26.0+ 和 Opera12.1+等浏览器的支持。\n``linear-gradient:(to top,#fff,#999)``\n - 第一个参数省略时，默认为“180deg”，等同于“to bottom”。\n - 第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。\n\n<!--more-->\n### 字体\n##### text-overflow\n用来设置是否使用一个省略标记（...）标示对象内文本的溢出。\n但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下：\n```\ntext-overflow:ellipsis; \noverflow:hidden; \nwhite-space:nowrap; \n```\nword-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行\nword-wrap:normal|| break-word\n##### text-shadow\n可以用来设置文本的阴影效果。\n``text-shadow: X-Offset Y-Offset blur color;``\n### 背景\n##### background-origin\n设置元素背景图片的原始起始位置。\n语法：\n``background-origin ： border-box | padding-box | content-box;``\n参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。\n需要注意的是，如果背景不是no-repeat，这个属性无效，它会从边框开始显示。\n##### background-size\n设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。\n语法：\n``background-size: auto | <长度值> | <百分比> | cover | contain``\n取值说明：\n1. auto：默认值，不改变背景图片的原始高度和宽度；\n2. <长度值>：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；\n3. <百分比>：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；\n4. cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器；\n5. contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。\n\n### 选择器\n##### 属性选择器\n{% codeblock HTML lang:html %}\n<a href=\"xxx.pdf\">我链接的是PDF文件</a>\n<a href=\"#\" class=\"icon\">我类名是icon</a>\n<a href=\"#\" title=\"我的title是more\">我的title是more</a>\n{% endcodeblock %}\n{% codeblock CSS lang:css %}  \na[class^=icon]{\n  background: green;\n  color:#fff;\n}\na[href$=pdf]{\n  background: orange;\n  color: #fff;\n}\na[title*=more]{\n  background: blue;\n  color: #fff;\n}\n{% endcodeblock %}\n##### 结构性伪类选择器—root\n``:root``选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是<html>。\n##### 结构性伪类选择器—not\n``:not``选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。\n##### 结构性伪类选择器—empty\n:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。\n##### 结构性伪类选择器—target\n:target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。\n多个url（多个target）处理：\n就像上面的例子，#brand与后面的id=\"brand\"是对应的，当同一个页面上有很多的url的时候你可以取不同的名字，只要#号后对的名称与id=\"\"中的名称对应就可以了。\n##### 结构性伪类选择器—first-child\n“:first-child”选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。\n``ol > li:first-child{\n  color: red;\n}\n``\n##### 结构性伪类选择器—last-child\n“:last-child”选择器与“:first-child”选择器作用类似，不同的是“:last-child”选择器选择的是元素的最后一个子元素。例如，需要改变的是列表中的最后一个“li”的背景色，就可以使用这个选择器.\n``ul>li:last-child{background:blue;}``\n##### 结构性伪类选择器—nth-child(n)\n“:nth-child(n)”选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。\n经验与技巧:当“:nth-child(n)”选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素。\n``ol > li:nth-child(2n){\n  background: orange;\n}\n``\n##### 结构性伪类选择器—nth-last-child(n)\n“:nth-last-child(n)”选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。\n##### first-of-type选择器\n“:first-of-type”选择器类似于“:first-child”选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。\n*我要改变第一个段落的背景为橙色*\n``.wrapper > p:first-of-type {\n  background: orange;\n}``\n通过“:first-of-type”选择器，定位div容器中的第一个p元素（p不一定是容器中的第一个子元素），并设置其背景色为橙色。\n##### nth-of-type(n)选择器\n“:nth-of-type(n)”选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词。\n##### last-of-type选择器\n“:last-of-type”选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素。\n##### nth-last-of-type(n)选择器\n“:nth-last-of-type(n)”选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。\n##### only-child选择器\n“:only-child”选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。\n##### only-of-type选择器\n“:only-of-type”选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。\n##### :enabled选择器\n在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器“:enabled”对这些表单元素设置样式。\n``input[type=\"text\"]:enabled {\n  background: #ccc;\n  border: 2px solid red;\n}``\n通过“:enabled”选择器，修改文本输入框的边框为2像素的红色边框，并设置它的背景为灰色。\n#####:disabled选择器\n“:disabled”选择器刚好与“:enabled”选择器相反，用来选择不可用表单元素。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。\n``\ninput[type=\"text\"]:disabled {\n  background: rgba(0,0,0,.15);\n  border: 1px solid rgba(0,0,0,.15);\n  color: rgba(0,0,0,.15);\n}\n``\n通过“:disabled”选择器，给不可用输入框设置明显的样式。\n##### :checked选择器\n在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而“:checked”表示的是选中状态。\n``\ninput[type=\"checkbox\"]:checked + span {\n  opacity: 1;\n}\n``\n##### ::selection选择器\n“::selection”伪元素是用来匹配突出显示的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示.\n有的时候设计要求,不使用上图那种浏览器默认的突出文本效果，需要一个与众不同的效果，此时“::selection”伪元素就非常的实用。不过在Firefox浏览器还需要添加前缀。\n``\n::-moz-selection {\n  background: red;\n  color: green;\n}\n::selection {\n  background: red;\n  color: green;\n}\n``\n:read-only选择器\n“:read-only”伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了“readonly=’readonly’”\n``input[type=\"text\"]:read-only{\n  border-color: #ccc;\n}``\n通过“:read-only”选择器来设置地址文本框的样式。\n##### :read-write选择器\n“:read-write”选择器刚好与“:read-only”选择器相反，主要用来指定当元素处于非只读状态时的样式。\n``\ninput[type=\"text\"]:read-write{\n  border-color: #f36;\n}\n``\n使用“:read-write”选择器来设置不是只读控件的文本框样式。\n##### ::before和::after\n**::before**和**::after**这两个主要用来给元素的前面或后面插入内容，这两个常和\"content\"配合使用，使用的场景最多的就是清除浮动。\n{% codeblock lang:css %}\n.clearfix::before,\n.clearfix::after {\n    content: \".\";\n    display: block;\n    height: 0;\n    visibility: hidden;\n}\n.clearfix:after {clear: both;}\n.clearfix {zoom: 1;}\n{% endcodeblock %}\n当然可以利用他们制作出其他更好的效果，比如右侧中的阴影效果，也是通过这个来实现的。\n\n关键代码分析：\n{% codeblock lang:css %}\n.effect::before, .effect::after{\n    content:\"\";\n    position:absolute;\n    z-index:-1;\n    -webkit-box-shadow:0 0 20px rgba(0,0,0,0.8);\n    -moz-box-shadow:0 0 20px rgba(0,0,0,0.8);\n    box-shadow:0 0 20px rgba(0,0,0,0.8);\n    top:50%;\n    bottom:0;\n    left:10px;\n    right:10px;\n    -moz-border-radius:100px / 10px;\n    border-radius:100px / 10px;\n}\n{% endcodeblock %}\n上面代码作用在class名叫.effect上的div的前（before）后(after)都添加一个空元素，然后为这两个空元素添加阴影特效。\n## 变形与动画 transform\n##### 变形--旋转 rotate()\n旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。\n```\n.wrapper div {\n  width: 200px;\n  height: 200px;\n  background: orange;\n  -webkit-transform: rotate(45deg);\n  transform: rotate(45deg);\n}\n```\n##### 变形--扭曲 skew()\n扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。这与rotate()函数的旋转不同，rotate()函数只是旋转，而不会改变元素的形状。skew()函数不会旋转，而只会改变元素的形状。\nSkew()具有**三种**情况：\n1. skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；\n![X,Y扭曲](http://ww1.sinaimg.cn/large/0060lm7Tgw1f8t3j7iejxj309z066mxr.jpg)\n第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。\n2. skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）；\n![X扭曲](http://ww4.sinaimg.cn/large/0060lm7Tgw1f8t3kqlvs1j30a805t0ta.jpg)\n3. skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形）\n![Y扭曲](http://ww4.sinaimg.cn/large/0060lm7Tgw1f8t3l1aem0j30a705saak.jpg)\n##### 变形--缩放 scale()\n缩放 scale()函数 让元素根据中心原点对对象进行缩放。\n缩放 scale 具有**三种**情况：\n1. scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）\n![X,Y缩放](http://img.mukewang.com/53391aff000181f703520211.jpg)\n``div:hover {\n  -webkit-transform: scale(1.5,0.5);\n  -moz-transform:scale(1.5,0.5)\n  transform: scale(1.5,0.5);\n}``\n**注意：Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。**\n2. scaleX(x)元素仅水平方向缩放（X轴缩放）\n![X缩放](http://img.mukewang.com/53391b0b00016a7002920170.jpg)\n3. scaleY(y)元素仅垂直方向缩放（Y轴缩放）\n![Y缩放](http://img.mukewang.com/53391b14000169cf03280183.jpg)\n##### 变形--位移 translate()\ntranslate()函数可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。\ntranslate我们分为**三种**情况：\n1、translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动），一个参数时仅X位移。\n![X,Y位移](http://img.mukewang.com/53391c640001709503850257.jpg)\n2、translateX(x)仅水平方向移动（X轴移动）\n![X位移](http://img.mukewang.com/53391c920001420703810201.jpg)\n3、translateY(Y)仅垂直方向移动（Y轴移动）\n![Y位移](http://img.mukewang.com/53391ca70001da5e03570211.jpg)\n##### 变形--矩阵 matrix()\nmatrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果需要深入了解，需要对数学矩阵有一定的知识。\n示例演示：通过matrix()函数来模拟transform中translate()位移的效果。\n{% codeblock lang:html %}\n<div class=\"wrapper\">\n  <div></div>\n</div>\n{% endcodeblock %}\n{% codeblock lang:css %}\n.wrapper {\n  width: 300px;\n  height: 200px;\n  border: 2px dotted red;\n  margin: 40px auto;\n}\n.wrapper div {\n  width:300px;\n  height: 200px;\n  background: orange;\n  -webkit-transform: matrix(1,0,0,1,50,50);\n  -moz-transform:matrix(1,0,0,1,50,50);\n  transform: matrix(1,0,0,1,50,50);\n}\n{% endcodeblock %}\n演示结果：\n![矩阵变换](http://img.mukewang.com/53391e000001b60b03890278.jpg)\n>  matrix(scaleX(),skewX(),skewY(),scaleY(),translateX(),translateY());\n\n## 动画--过渡属性 transition\n早期在Web中要实现动画效果，都是依赖于JavaScript或Flash来完成。但在CSS3中新增加了一个新的模块transition，它可以通过一些简单的CSS事件来触发元素的外观变化，让效果显得更加细腻。简单点说，就是通过鼠标的单击、获得焦点，被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。\n\n在CSS中创建简单的过渡效果可以从以下几个步骤来实现：\n1. 在默认样式中声明元素的初始状态样式；\n2. 声明过渡元素最终状态样式，比如悬浮状态；\n3. 在默认样式中通过添加过渡函数，添加一些不同的样式。\n\nCSS3的过度transition属性是一个复合属性，主要包括以下几个子属性：\n\n**transition-property**:指定过渡或动态模拟的CSS属性(width,height,transform...)\n**transition-duration**:指定完成过渡所需的时间\n**transition-timing-function**:指定过渡函数(ease,ease-in,ease-out,ease-in-out,linear...)\n**transition-delay**:指定开始出现的延迟时间\n先来看transition-property属性\n\ntransition-property用来指定过渡动画的CSS属性名称，而这个过渡属性只有具备一个中点值的属性（需要产生动画的属性）才能具备过渡效果,**特别注意：当“transition-property”属性设置为all时，表示的是所有中点值的属性。**\n用一个简单的例子来说明这个问题：\n>  假设你的初始状态设置了样式“width”,“height”,“background”,当你在终始状态都改变了这三个属性，那么all代表的就是“width”、“height”和“background”。如果你的终始状态只改变了“width”和“height”时，那么all代表的就是“width”和“height”。\n\n## 动画--animation\n##### Keyframes介绍\nKeyframes被称为关键帧，其类似于Flash中的关键帧。在CSS3中其主要以“@keyframes”开头，后面紧跟着是动画名称加上一对花括号“{…}”，括号中就是一些不同时间段样式规则。\n```\n@keyframes changecolor{\n  0%{\n   background: red;\n  }\n  100%{\n    background: green;\n  }\n}\n```\n在一个“@keyframes”中的样式规则可以由多个百分比构成的，如在“0%”到“100%”之间创建更多个百分比，分别给每个百分比中给需要有动画效果的元素加上不同的样式，从而达到一种在不断变化的效果。\n经验与技巧：在@keyframes中定义动画名称时，**其中0%和100%还可以使用关键词from和to来代表，其中0%对应的是from，100%对应的是to。**\n案例演示\n通过“@keyframes”声明一个名叫“wobble”的动画，从“0%”开始到“100%”结束，同时还经历了一个“40%”和“60%”两个过程。“wobble”动画在“0%”时元素定位到left为100px，背景色为green，然后在“40%”时元素过渡到left为150px,背景色为orange,接着在“60%”时元素过渡到left为75px，背景色为blue，最后“100%”时结束动画，元素又回到起点left为100px处，背景色变为red。\n``animation: wobble 5s ease .1s;``后三个参数与transition相同。\n```\nHTML:\n\n<div>鼠标放到我身上</div>\nCSS:\n\n@keyframes wobble {\n  0% {\n    margin-left: 100px;\n    background:green;\n  }\n  40% {\n    margin-left:150px;\n    background:orange;\n  }\n  60% {\n    margin-left: 75px;\n    background: blue;\n  }\n  100% {\n    margin-left: 100px;\n    background: red;\n  }\n}\ndiv {\n  width: 100px;\n  height: 100px;\n  background:red;\n  color: #fff;\n}\ndiv:hover{\n  animation: wobble 5s ease .1s;\n}\n```\n**animation-iteration-count**属性主要用来定义动画的播放次数。\n语法规则：\nanimation-iteration-count: infinite | <number> [, infinite | <number>]*\n1. 其值通常为整数，但也可以使用带有小数的数字，其默认值为1，这意味着动画将从开始到结束只播放一次。\n2. 如果取值为infinite，动画将会无限次的播放。\n##### 设置动画播放方向\n**animation-direction**属性主要用来设置动画播放方向，其语法规则如下：\nanimation-direction:normal | alternate [, normal | alternate]*\n其主要有两个值：normal、alternate\n1. normal是默认值，如果设置为normal时，动画的每次循环都是向前播放；\n2. 另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。\n例如：通过animation-direction属性，将move动画播放动画方向设置为alternate，代码为：\n``animation-direction:alternate;``\n###### 设置动画的播放状态\n**animation-play-state**属性主要用来控制元素动画的播放状态。\n参数：\n其主要有两个值：*running*和*paused*。\n\n其中running是其默认值，主要作用就是类似于音乐播放器一样，可以通过paused将正在播放的动画停下来，也可以通过running将暂停的动画重新播放，这里的重新播放不一定是从元素动画的开始播放，而是从暂停的那个位置开始播放。另外如果暂停了动画的播放，元素的样式将回到最原始设置状态。\n例如，页面加载时，动画不播放。代码如下：\n``animation-play-state:paused;``\n##### 设置动画时间外属性\n**animation-fill-mode**属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：none、forwards、backwords和both。其四个属性值对应效果如下：\n\n|属性值     |效果                                                                |\n|:--------:|-------------------------------------------------------------------|\n|none      |默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时,动画会反转到初始帧处 |\n|forwards  |表示动画在结束后继续应用最后的关键帧的位置                                |\n|backwards |会在向元素应用动画样式时迅速应用动画的初始帧                               |\n|both      |元素动画同时具有forwards和backwards效果                                |\n\n在默认情况之下，动画不会影响它的关键帧之外的属性，使用animation-fill-mode属性可以修改动画的默认行为。简单的说就是告诉动画在第一关键帧上等待动画开始，或者在动画结束时停在最后一个关键帧上而不回到动画的第一帧上。或者同时具有这两个效果。\n例如：让动画停在最一帧处。代码如下：\n``animation-fill-mode:forwards; ``\n","slug":"css3笔记","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdq0019zk4o8eczpe6y","content":"<blockquote>\n<p> 仅记录一些常用的css3属性</p>\n</blockquote>\n<h3 id=\"边框\"><a href=\"#边框\" class=\"headerlink\" title=\"边框\"></a>边框</h3><h5 id=\"border-radius\"><a href=\"#border-radius\" class=\"headerlink\" title=\"border-radius\"></a>border-radius</h5><p>向元素添加圆角边框。<br>border-radius: 5px 4px 3px 2px; /<em> 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 </em>/ </p>\n<h5 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h5><p>向盒子添加阴影,支持添加一个或者多个。<br>box-shadow:<strong>X轴偏移</strong> <strong>Y轴偏移</strong> <em>阴影模糊半径</em> <em>阴影扩展半径</em> <em>阴影颜色</em> <em>投影方式</em>;</p>\n<ol>\n<li>阴影模糊半径与阴影扩展半径的区别<br>阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；<br>阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小；</li>\n<li>X轴偏移量和Y轴偏移量值可以设置为负数<h3 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h3><h5 id=\"Gradient渐变色彩\"><a href=\"#Gradient渐变色彩\" class=\"headerlink\" title=\"Gradient渐变色彩\"></a>Gradient渐变色彩</h5>CSS3 Gradient 分为线性渐变(linear)和径向渐变(radial)。由于不同的渲染引擎实现渐变的语法不同，这里我们只针对线性渐变的 W3C 标准语法来分析其用法，其余大家可以查阅相关资料。W3C 语法已经得到了 IE10+、Firefox19.0+、Chrome26.0+ 和 Opera12.1+等浏览器的支持。<br><code>linear-gradient:(to top,#fff,#999)</code><ul>\n<li>第一个参数省略时，默认为“180deg”，等同于“to bottom”。</li>\n<li>第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。</li>\n</ul>\n</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><h5 id=\"text-overflow\"><a href=\"#text-overflow\" class=\"headerlink\" title=\"text-overflow\"></a>text-overflow</h5><p>用来设置是否使用一个省略标记（…）标示对象内文本的溢出。<br>但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">text-overflow:ellipsis; </div><div class=\"line\">overflow:hidden; </div><div class=\"line\">white-space:nowrap;</div></pre></td></tr></table></figure></p>\n<p>word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行<br>word-wrap:normal|| break-word</p>\n<h5 id=\"text-shadow\"><a href=\"#text-shadow\" class=\"headerlink\" title=\"text-shadow\"></a>text-shadow</h5><p>可以用来设置文本的阴影效果。<br><code>text-shadow: X-Offset Y-Offset blur color;</code></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><h5 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h5><p>设置元素背景图片的原始起始位置。<br>语法：<br><code>background-origin ： border-box | padding-box | content-box;</code><br>参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。<br>需要注意的是，如果背景不是no-repeat，这个属性无效，它会从边框开始显示。</p>\n<h5 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h5><p>设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。<br>语法：<br><code>background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain</code><br>取值说明：</p>\n<ol>\n<li>auto：默认值，不改变背景图片的原始高度和宽度；</li>\n<li>&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；</li>\n<li>&lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；</li>\n<li>cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器；</li>\n<li>contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。</li>\n</ol>\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><h5 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h5><figure class=\"highlight html\"><figcaption><span>HTML</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"xxx.pdf\"</span>&gt;</span>我链接的是PDF文件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon\"</span>&gt;</span>我类名是icon<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"我的title是more\"</span>&gt;</span>我的title是more<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><figcaption><span>CSS</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">  </div><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[class^=icon]</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: green;</div><div class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[href$=pdf]</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: orange;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[title*=more]</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"结构性伪类选择器—root\"><a href=\"#结构性伪类选择器—root\" class=\"headerlink\" title=\"结构性伪类选择器—root\"></a>结构性伪类选择器—root</h5><p><code>:root</code>选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是<html>。</html></p>\n<h5 id=\"结构性伪类选择器—not\"><a href=\"#结构性伪类选择器—not\" class=\"headerlink\" title=\"结构性伪类选择器—not\"></a>结构性伪类选择器—not</h5><p><code>:not</code>选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。</p>\n<h5 id=\"结构性伪类选择器—empty\"><a href=\"#结构性伪类选择器—empty\" class=\"headerlink\" title=\"结构性伪类选择器—empty\"></a>结构性伪类选择器—empty</h5><p>:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。</p>\n<h5 id=\"结构性伪类选择器—target\"><a href=\"#结构性伪类选择器—target\" class=\"headerlink\" title=\"结构性伪类选择器—target\"></a>结构性伪类选择器—target</h5><p>:target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。<br>多个url（多个target）处理：<br>就像上面的例子，#brand与后面的id=”brand”是对应的，当同一个页面上有很多的url的时候你可以取不同的名字，只要#号后对的名称与id=””中的名称对应就可以了。</p>\n<h5 id=\"结构性伪类选择器—first-child\"><a href=\"#结构性伪类选择器—first-child\" class=\"headerlink\" title=\"结构性伪类选择器—first-child\"></a>结构性伪类选择器—first-child</h5><p>“:first-child”选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。<br><code>ol &gt; li:first-child{\n  color: red;\n}</code></p>\n<h5 id=\"结构性伪类选择器—last-child\"><a href=\"#结构性伪类选择器—last-child\" class=\"headerlink\" title=\"结构性伪类选择器—last-child\"></a>结构性伪类选择器—last-child</h5><p>“:last-child”选择器与“:first-child”选择器作用类似，不同的是“:last-child”选择器选择的是元素的最后一个子元素。例如，需要改变的是列表中的最后一个“li”的背景色，就可以使用这个选择器.<br><code>ul&gt;li:last-child{background:blue;}</code></p>\n<h5 id=\"结构性伪类选择器—nth-child-n\"><a href=\"#结构性伪类选择器—nth-child-n\" class=\"headerlink\" title=\"结构性伪类选择器—nth-child(n)\"></a>结构性伪类选择器—nth-child(n)</h5><p>“:nth-child(n)”选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。<br>经验与技巧:当“:nth-child(n)”选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素。<br><code>ol &gt; li:nth-child(2n){\n  background: orange;\n}</code></p>\n<h5 id=\"结构性伪类选择器—nth-last-child-n\"><a href=\"#结构性伪类选择器—nth-last-child-n\" class=\"headerlink\" title=\"结构性伪类选择器—nth-last-child(n)\"></a>结构性伪类选择器—nth-last-child(n)</h5><p>“:nth-last-child(n)”选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。</p>\n<h5 id=\"first-of-type选择器\"><a href=\"#first-of-type选择器\" class=\"headerlink\" title=\"first-of-type选择器\"></a>first-of-type选择器</h5><p>“:first-of-type”选择器类似于“:first-child”选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。<br><em>我要改变第一个段落的背景为橙色</em><br><code>.wrapper &gt; p:first-of-type {\n  background: orange;\n}</code><br>通过“:first-of-type”选择器，定位div容器中的第一个p元素（p不一定是容器中的第一个子元素），并设置其背景色为橙色。</p>\n<h5 id=\"nth-of-type-n-选择器\"><a href=\"#nth-of-type-n-选择器\" class=\"headerlink\" title=\"nth-of-type(n)选择器\"></a>nth-of-type(n)选择器</h5><p>“:nth-of-type(n)”选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词。</p>\n<h5 id=\"last-of-type选择器\"><a href=\"#last-of-type选择器\" class=\"headerlink\" title=\"last-of-type选择器\"></a>last-of-type选择器</h5><p>“:last-of-type”选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素。</p>\n<h5 id=\"nth-last-of-type-n-选择器\"><a href=\"#nth-last-of-type-n-选择器\" class=\"headerlink\" title=\"nth-last-of-type(n)选择器\"></a>nth-last-of-type(n)选择器</h5><p>“:nth-last-of-type(n)”选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。</p>\n<h5 id=\"only-child选择器\"><a href=\"#only-child选择器\" class=\"headerlink\" title=\"only-child选择器\"></a>only-child选择器</h5><p>“:only-child”选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。</p>\n<h5 id=\"only-of-type选择器\"><a href=\"#only-of-type选择器\" class=\"headerlink\" title=\"only-of-type选择器\"></a>only-of-type选择器</h5><p>“:only-of-type”选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。</p>\n<h5 id=\"enabled选择器\"><a href=\"#enabled选择器\" class=\"headerlink\" title=\":enabled选择器\"></a>:enabled选择器</h5><p>在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器“:enabled”对这些表单元素设置样式。<br><code>input[type=&quot;text&quot;]:enabled {\n  background: #ccc;\n  border: 2px solid red;\n}</code><br>通过“:enabled”选择器，修改文本输入框的边框为2像素的红色边框，并设置它的背景为灰色。</p>\n<p>#####:disabled选择器<br>“:disabled”选择器刚好与“:enabled”选择器相反，用来选择不可用表单元素。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。<br><code>input[type=&quot;text&quot;]:disabled {\n  background: rgba(0,0,0,.15);\n  border: 1px solid rgba(0,0,0,.15);\n  color: rgba(0,0,0,.15);\n}</code><br>通过“:disabled”选择器，给不可用输入框设置明显的样式。</p>\n<h5 id=\"checked选择器\"><a href=\"#checked选择器\" class=\"headerlink\" title=\":checked选择器\"></a>:checked选择器</h5><p>在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而“:checked”表示的是选中状态。<br><code>input[type=&quot;checkbox&quot;]:checked + span {\n  opacity: 1;\n}</code></p>\n<h5 id=\"selection选择器\"><a href=\"#selection选择器\" class=\"headerlink\" title=\"::selection选择器\"></a>::selection选择器</h5><p>“::selection”伪元素是用来匹配突出显示的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示.<br>有的时候设计要求,不使用上图那种浏览器默认的突出文本效果，需要一个与众不同的效果，此时“::selection”伪元素就非常的实用。不过在Firefox浏览器还需要添加前缀。<br><code>::-moz-selection {\n  background: red;\n  color: green;\n}\n::selection {\n  background: red;\n  color: green;\n}</code><br>:read-only选择器<br>“:read-only”伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了“readonly=’readonly’”<br><code>input[type=&quot;text&quot;]:read-only{\n  border-color: #ccc;\n}</code><br>通过“:read-only”选择器来设置地址文本框的样式。</p>\n<h5 id=\"read-write选择器\"><a href=\"#read-write选择器\" class=\"headerlink\" title=\":read-write选择器\"></a>:read-write选择器</h5><p>“:read-write”选择器刚好与“:read-only”选择器相反，主要用来指定当元素处于非只读状态时的样式。<br><code>input[type=&quot;text&quot;]:read-write{\n  border-color: #f36;\n}</code><br>使用“:read-write”选择器来设置不是只读控件的文本框样式。</p>\n<h5 id=\"before和-after\"><a href=\"#before和-after\" class=\"headerlink\" title=\"::before和::after\"></a>::before和::after</h5><p><strong>::before</strong>和<strong>::after</strong>这两个主要用来给元素的前面或后面插入内容，这两个常和”content”配合使用，使用的场景最多的就是清除浮动。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">::before</span>,</div><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">::after</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</div><div class=\"line\">    <span class=\"attribute\">display</span>: block;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">visibility</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span> &#123;<span class=\"attribute\">clear</span>: both;&#125;</div><div class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;<span class=\"attribute\">zoom</span>: <span class=\"number\">1</span>;&#125;</div></pre></td></tr></table></figure><br>当然可以利用他们制作出其他更好的效果，比如右侧中的阴影效果，也是通过这个来实现的。</p>\n<p>关键代码分析：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.effect</span><span class=\"selector-pseudo\">::before</span>, <span class=\"selector-class\">.effect</span><span class=\"selector-pseudo\">::after</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>:<span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"attribute\">position</span>:absolute;</div><div class=\"line\">    <span class=\"attribute\">z-index</span>:-<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"attribute\">-webkit-box-shadow</span>:<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">20px</span> <span class=\"built_in\">rgba</span>(0,0,0,0.8);</div><div class=\"line\">    <span class=\"attribute\">-moz-box-shadow</span>:<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">20px</span> <span class=\"built_in\">rgba</span>(0,0,0,0.8);</div><div class=\"line\">    <span class=\"attribute\">box-shadow</span>:<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">20px</span> <span class=\"built_in\">rgba</span>(0,0,0,0.8);</div><div class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">10px</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">10px</span>;</div><div class=\"line\">    <span class=\"attribute\">-moz-border-radius</span>:<span class=\"number\">100px</span> / <span class=\"number\">10px</span>;</div><div class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">100px</span> / <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br>上面代码作用在class名叫.effect上的div的前（before）后(after)都添加一个空元素，然后为这两个空元素添加阴影特效。</p>\n<h2 id=\"变形与动画-transform\"><a href=\"#变形与动画-transform\" class=\"headerlink\" title=\"变形与动画 transform\"></a>变形与动画 transform</h2><h5 id=\"变形–旋转-rotate\"><a href=\"#变形–旋转-rotate\" class=\"headerlink\" title=\"变形–旋转 rotate()\"></a>变形–旋转 rotate()</h5><p>旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper div &#123;</div><div class=\"line\">  width: 200px;</div><div class=\"line\">  height: 200px;</div><div class=\"line\">  background: orange;</div><div class=\"line\">  -webkit-transform: rotate(45deg);</div><div class=\"line\">  transform: rotate(45deg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"变形–扭曲-skew\"><a href=\"#变形–扭曲-skew\" class=\"headerlink\" title=\"变形–扭曲 skew()\"></a>变形–扭曲 skew()</h5><p>扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。这与rotate()函数的旋转不同，rotate()函数只是旋转，而不会改变元素的形状。skew()函数不会旋转，而只会改变元素的形状。<br>Skew()具有<strong>三种</strong>情况：</p>\n<ol>\n<li>skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；<br><img src=\"http://ww1.sinaimg.cn/large/0060lm7Tgw1f8t3j7iejxj309z066mxr.jpg\" alt=\"X,Y扭曲\"><br>第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。</li>\n<li>skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）；<br><img src=\"http://ww4.sinaimg.cn/large/0060lm7Tgw1f8t3kqlvs1j30a805t0ta.jpg\" alt=\"X扭曲\"></li>\n<li>skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形）<br><img src=\"http://ww4.sinaimg.cn/large/0060lm7Tgw1f8t3l1aem0j30a705saak.jpg\" alt=\"Y扭曲\"><h5 id=\"变形–缩放-scale\"><a href=\"#变形–缩放-scale\" class=\"headerlink\" title=\"变形–缩放 scale()\"></a>变形–缩放 scale()</h5>缩放 scale()函数 让元素根据中心原点对对象进行缩放。<br>缩放 scale 具有<strong>三种</strong>情况：</li>\n<li>scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）<br><img src=\"http://img.mukewang.com/53391aff000181f703520211.jpg\" alt=\"X,Y缩放\"><br><code>div:hover {\n-webkit-transform: scale(1.5,0.5);\n-moz-transform:scale(1.5,0.5)\ntransform: scale(1.5,0.5);\n}</code><br><strong>注意：Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。</strong></li>\n<li>scaleX(x)元素仅水平方向缩放（X轴缩放）<br><img src=\"http://img.mukewang.com/53391b0b00016a7002920170.jpg\" alt=\"X缩放\"></li>\n<li>scaleY(y)元素仅垂直方向缩放（Y轴缩放）<br><img src=\"http://img.mukewang.com/53391b14000169cf03280183.jpg\" alt=\"Y缩放\"><h5 id=\"变形–位移-translate\"><a href=\"#变形–位移-translate\" class=\"headerlink\" title=\"变形–位移 translate()\"></a>变形–位移 translate()</h5>translate()函数可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。<br>translate我们分为<strong>三种</strong>情况：<br>1、translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动），一个参数时仅X位移。<br><img src=\"http://img.mukewang.com/53391c640001709503850257.jpg\" alt=\"X,Y位移\"><br>2、translateX(x)仅水平方向移动（X轴移动）<br><img src=\"http://img.mukewang.com/53391c920001420703810201.jpg\" alt=\"X位移\"><br>3、translateY(Y)仅垂直方向移动（Y轴移动）<br><img src=\"http://img.mukewang.com/53391ca70001da5e03570211.jpg\" alt=\"Y位移\"><h5 id=\"变形–矩阵-matrix\"><a href=\"#变形–矩阵-matrix\" class=\"headerlink\" title=\"变形–矩阵 matrix()\"></a>变形–矩阵 matrix()</h5>matrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果需要深入了解，需要对数学矩阵有一定的知识。<br>示例演示：通过matrix()函数来模拟transform中translate()位移的效果。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.wrapper</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> dotted red;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">40px</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrapper</span> <span class=\"selector-tag\">div</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: orange;</div><div class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">matrix</span>(1,0,0,1,50,50);</div><div class=\"line\">  <span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">matrix</span>(1,0,0,1,50,50);</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">matrix</span>(1,0,0,1,50,50);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n演示结果：<br><img src=\"http://img.mukewang.com/53391e000001b60b03890278.jpg\" alt=\"矩阵变换\"><blockquote>\n<p> matrix(scaleX(),skewX(),skewY(),scaleY(),translateX(),translateY());</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"动画–过渡属性-transition\"><a href=\"#动画–过渡属性-transition\" class=\"headerlink\" title=\"动画–过渡属性 transition\"></a>动画–过渡属性 transition</h2><p>早期在Web中要实现动画效果，都是依赖于JavaScript或Flash来完成。但在CSS3中新增加了一个新的模块transition，它可以通过一些简单的CSS事件来触发元素的外观变化，让效果显得更加细腻。简单点说，就是通过鼠标的单击、获得焦点，被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。</p>\n<p>在CSS中创建简单的过渡效果可以从以下几个步骤来实现：</p>\n<ol>\n<li>在默认样式中声明元素的初始状态样式；</li>\n<li>声明过渡元素最终状态样式，比如悬浮状态；</li>\n<li>在默认样式中通过添加过渡函数，添加一些不同的样式。</li>\n</ol>\n<p>CSS3的过度transition属性是一个复合属性，主要包括以下几个子属性：</p>\n<p><strong>transition-property</strong>:指定过渡或动态模拟的CSS属性(width,height,transform…)<br><strong>transition-duration</strong>:指定完成过渡所需的时间<br><strong>transition-timing-function</strong>:指定过渡函数(ease,ease-in,ease-out,ease-in-out,linear…)<br><strong>transition-delay</strong>:指定开始出现的延迟时间<br>先来看transition-property属性</p>\n<p>transition-property用来指定过渡动画的CSS属性名称，而这个过渡属性只有具备一个中点值的属性（需要产生动画的属性）才能具备过渡效果,<strong>特别注意：当“transition-property”属性设置为all时，表示的是所有中点值的属性。</strong><br>用一个简单的例子来说明这个问题：</p>\n<blockquote>\n<p> 假设你的初始状态设置了样式“width”,“height”,“background”,当你在终始状态都改变了这三个属性，那么all代表的就是“width”、“height”和“background”。如果你的终始状态只改变了“width”和“height”时，那么all代表的就是“width”和“height”。</p>\n</blockquote>\n<h2 id=\"动画–animation\"><a href=\"#动画–animation\" class=\"headerlink\" title=\"动画–animation\"></a>动画–animation</h2><h5 id=\"Keyframes介绍\"><a href=\"#Keyframes介绍\" class=\"headerlink\" title=\"Keyframes介绍\"></a>Keyframes介绍</h5><p>Keyframes被称为关键帧，其类似于Flash中的关键帧。在CSS3中其主要以“@keyframes”开头，后面紧跟着是动画名称加上一对花括号“{…}”，括号中就是一些不同时间段样式规则。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@keyframes changecolor&#123;</div><div class=\"line\">  0%&#123;</div><div class=\"line\">   background: red;</div><div class=\"line\">  &#125;</div><div class=\"line\">  100%&#123;</div><div class=\"line\">    background: green;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在一个“@keyframes”中的样式规则可以由多个百分比构成的，如在“0%”到“100%”之间创建更多个百分比，分别给每个百分比中给需要有动画效果的元素加上不同的样式，从而达到一种在不断变化的效果。<br>经验与技巧：在@keyframes中定义动画名称时，<strong>其中0%和100%还可以使用关键词from和to来代表，其中0%对应的是from，100%对应的是to。</strong><br>案例演示<br>通过“@keyframes”声明一个名叫“wobble”的动画，从“0%”开始到“100%”结束，同时还经历了一个“40%”和“60%”两个过程。“wobble”动画在“0%”时元素定位到left为100px，背景色为green，然后在“40%”时元素过渡到left为150px,背景色为orange,接着在“60%”时元素过渡到left为75px，背景色为blue，最后“100%”时结束动画，元素又回到起点left为100px处，背景色变为red。<br><code>animation: wobble 5s ease .1s;</code>后三个参数与transition相同。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTML:</div><div class=\"line\"></div><div class=\"line\">&lt;div&gt;鼠标放到我身上&lt;/div&gt;</div><div class=\"line\">CSS:</div><div class=\"line\"></div><div class=\"line\">@keyframes wobble &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    margin-left: 100px;</div><div class=\"line\">    background:green;</div><div class=\"line\">  &#125;</div><div class=\"line\">  40% &#123;</div><div class=\"line\">    margin-left:150px;</div><div class=\"line\">    background:orange;</div><div class=\"line\">  &#125;</div><div class=\"line\">  60% &#123;</div><div class=\"line\">    margin-left: 75px;</div><div class=\"line\">    background: blue;</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    margin-left: 100px;</div><div class=\"line\">    background: red;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">div &#123;</div><div class=\"line\">  width: 100px;</div><div class=\"line\">  height: 100px;</div><div class=\"line\">  background:red;</div><div class=\"line\">  color: #fff;</div><div class=\"line\">&#125;</div><div class=\"line\">div:hover&#123;</div><div class=\"line\">  animation: wobble 5s ease .1s;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>animation-iteration-count</strong>属性主要用来定义动画的播放次数。<br>语法规则：<br>animation-iteration-count: infinite | <number> [, infinite | <number>]*</number></number></p>\n<ol>\n<li>其值通常为整数，但也可以使用带有小数的数字，其默认值为1，这意味着动画将从开始到结束只播放一次。</li>\n<li>如果取值为infinite，动画将会无限次的播放。<h5 id=\"设置动画播放方向\"><a href=\"#设置动画播放方向\" class=\"headerlink\" title=\"设置动画播放方向\"></a>设置动画播放方向</h5><strong>animation-direction</strong>属性主要用来设置动画播放方向，其语法规则如下：<br>animation-direction:normal | alternate [, normal | alternate]*<br>其主要有两个值：normal、alternate</li>\n<li>normal是默认值，如果设置为normal时，动画的每次循环都是向前播放；</li>\n<li>另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。<br>例如：通过animation-direction属性，将move动画播放动画方向设置为alternate，代码为：<br><code>animation-direction:alternate;</code><h6 id=\"设置动画的播放状态\"><a href=\"#设置动画的播放状态\" class=\"headerlink\" title=\"设置动画的播放状态\"></a>设置动画的播放状态</h6><strong>animation-play-state</strong>属性主要用来控制元素动画的播放状态。<br>参数：<br>其主要有两个值：<em>running</em>和<em>paused</em>。</li>\n</ol>\n<p>其中running是其默认值，主要作用就是类似于音乐播放器一样，可以通过paused将正在播放的动画停下来，也可以通过running将暂停的动画重新播放，这里的重新播放不一定是从元素动画的开始播放，而是从暂停的那个位置开始播放。另外如果暂停了动画的播放，元素的样式将回到最原始设置状态。<br>例如，页面加载时，动画不播放。代码如下：<br><code>animation-play-state:paused;</code></p>\n<h5 id=\"设置动画时间外属性\"><a href=\"#设置动画时间外属性\" class=\"headerlink\" title=\"设置动画时间外属性\"></a>设置动画时间外属性</h5><p><strong>animation-fill-mode</strong>属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：none、forwards、backwords和both。其四个属性值对应效果如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性值</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">none</td>\n<td>默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时,动画会反转到初始帧处</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">forwards</td>\n<td>表示动画在结束后继续应用最后的关键帧的位置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">backwards</td>\n<td>会在向元素应用动画样式时迅速应用动画的初始帧</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">both</td>\n<td>元素动画同时具有forwards和backwards效果</td>\n</tr>\n</tbody>\n</table>\n<p>在默认情况之下，动画不会影响它的关键帧之外的属性，使用animation-fill-mode属性可以修改动画的默认行为。简单的说就是告诉动画在第一关键帧上等待动画开始，或者在动画结束时停在最后一个关键帧上而不回到动画的第一帧上。或者同时具有这两个效果。<br>例如：让动画停在最一帧处。代码如下：<br><code>animation-fill-mode:forwards;</code></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p> 仅记录一些常用的css3属性</p>\n</blockquote>\n<h3 id=\"边框\"><a href=\"#边框\" class=\"headerlink\" title=\"边框\"></a>边框</h3><h5 id=\"border-radius\"><a href=\"#border-radius\" class=\"headerlink\" title=\"border-radius\"></a>border-radius</h5><p>向元素添加圆角边框。<br>border-radius: 5px 4px 3px 2px; /<em> 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 </em>/ </p>\n<h5 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h5><p>向盒子添加阴影,支持添加一个或者多个。<br>box-shadow:<strong>X轴偏移</strong> <strong>Y轴偏移</strong> <em>阴影模糊半径</em> <em>阴影扩展半径</em> <em>阴影颜色</em> <em>投影方式</em>;</p>\n<ol>\n<li>阴影模糊半径与阴影扩展半径的区别<br>阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；<br>阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小；</li>\n<li>X轴偏移量和Y轴偏移量值可以设置为负数<h3 id=\"颜色\"><a href=\"#颜色\" class=\"headerlink\" title=\"颜色\"></a>颜色</h3><h5 id=\"Gradient渐变色彩\"><a href=\"#Gradient渐变色彩\" class=\"headerlink\" title=\"Gradient渐变色彩\"></a>Gradient渐变色彩</h5>CSS3 Gradient 分为线性渐变(linear)和径向渐变(radial)。由于不同的渲染引擎实现渐变的语法不同，这里我们只针对线性渐变的 W3C 标准语法来分析其用法，其余大家可以查阅相关资料。W3C 语法已经得到了 IE10+、Firefox19.0+、Chrome26.0+ 和 Opera12.1+等浏览器的支持。<br><code>linear-gradient:(to top,#fff,#999)</code><ul>\n<li>第一个参数省略时，默认为“180deg”，等同于“to bottom”。</li>\n<li>第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。</li>\n</ul>\n</li>\n</ol>","more":"<h3 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h3><h5 id=\"text-overflow\"><a href=\"#text-overflow\" class=\"headerlink\" title=\"text-overflow\"></a>text-overflow</h5><p>用来设置是否使用一个省略标记（…）标示对象内文本的溢出。<br>但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">text-overflow:ellipsis; </div><div class=\"line\">overflow:hidden; </div><div class=\"line\">white-space:nowrap;</div></pre></td></tr></table></figure></p>\n<p>word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行<br>word-wrap:normal|| break-word</p>\n<h5 id=\"text-shadow\"><a href=\"#text-shadow\" class=\"headerlink\" title=\"text-shadow\"></a>text-shadow</h5><p>可以用来设置文本的阴影效果。<br><code>text-shadow: X-Offset Y-Offset blur color;</code></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><h5 id=\"background-origin\"><a href=\"#background-origin\" class=\"headerlink\" title=\"background-origin\"></a>background-origin</h5><p>设置元素背景图片的原始起始位置。<br>语法：<br><code>background-origin ： border-box | padding-box | content-box;</code><br>参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。<br>需要注意的是，如果背景不是no-repeat，这个属性无效，它会从边框开始显示。</p>\n<h5 id=\"background-size\"><a href=\"#background-size\" class=\"headerlink\" title=\"background-size\"></a>background-size</h5><p>设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。<br>语法：<br><code>background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain</code><br>取值说明：</p>\n<ol>\n<li>auto：默认值，不改变背景图片的原始高度和宽度；</li>\n<li>&lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放；</li>\n<li>&lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上；</li>\n<li>cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器；</li>\n<li>contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。</li>\n</ol>\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><h5 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h5><figure class=\"highlight html\"><figcaption><span>HTML</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"xxx.pdf\"</span>&gt;</span>我链接的是PDF文件<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"icon\"</span>&gt;</span>我类名是icon<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"我的title是more\"</span>&gt;</span>我的title是more<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><figcaption><span>CSS</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">  </div><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[class^=icon]</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: green;</div><div class=\"line\">  <span class=\"attribute\">color</span>:<span class=\"number\">#fff</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[href$=pdf]</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: orange;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[title*=more]</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"结构性伪类选择器—root\"><a href=\"#结构性伪类选择器—root\" class=\"headerlink\" title=\"结构性伪类选择器—root\"></a>结构性伪类选择器—root</h5><p><code>:root</code>选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是<html>。</html></p>\n<h5 id=\"结构性伪类选择器—not\"><a href=\"#结构性伪类选择器—not\" class=\"headerlink\" title=\"结构性伪类选择器—not\"></a>结构性伪类选择器—not</h5><p><code>:not</code>选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。</p>\n<h5 id=\"结构性伪类选择器—empty\"><a href=\"#结构性伪类选择器—empty\" class=\"headerlink\" title=\"结构性伪类选择器—empty\"></a>结构性伪类选择器—empty</h5><p>:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。</p>\n<h5 id=\"结构性伪类选择器—target\"><a href=\"#结构性伪类选择器—target\" class=\"headerlink\" title=\"结构性伪类选择器—target\"></a>结构性伪类选择器—target</h5><p>:target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。<br>多个url（多个target）处理：<br>就像上面的例子，#brand与后面的id=”brand”是对应的，当同一个页面上有很多的url的时候你可以取不同的名字，只要#号后对的名称与id=””中的名称对应就可以了。</p>\n<h5 id=\"结构性伪类选择器—first-child\"><a href=\"#结构性伪类选择器—first-child\" class=\"headerlink\" title=\"结构性伪类选择器—first-child\"></a>结构性伪类选择器—first-child</h5><p>“:first-child”选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。<br><code>ol &gt; li:first-child{\n  color: red;\n}</code></p>\n<h5 id=\"结构性伪类选择器—last-child\"><a href=\"#结构性伪类选择器—last-child\" class=\"headerlink\" title=\"结构性伪类选择器—last-child\"></a>结构性伪类选择器—last-child</h5><p>“:last-child”选择器与“:first-child”选择器作用类似，不同的是“:last-child”选择器选择的是元素的最后一个子元素。例如，需要改变的是列表中的最后一个“li”的背景色，就可以使用这个选择器.<br><code>ul&gt;li:last-child{background:blue;}</code></p>\n<h5 id=\"结构性伪类选择器—nth-child-n\"><a href=\"#结构性伪类选择器—nth-child-n\" class=\"headerlink\" title=\"结构性伪类选择器—nth-child(n)\"></a>结构性伪类选择器—nth-child(n)</h5><p>“:nth-child(n)”选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。<br>经验与技巧:当“:nth-child(n)”选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素。<br><code>ol &gt; li:nth-child(2n){\n  background: orange;\n}</code></p>\n<h5 id=\"结构性伪类选择器—nth-last-child-n\"><a href=\"#结构性伪类选择器—nth-last-child-n\" class=\"headerlink\" title=\"结构性伪类选择器—nth-last-child(n)\"></a>结构性伪类选择器—nth-last-child(n)</h5><p>“:nth-last-child(n)”选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。</p>\n<h5 id=\"first-of-type选择器\"><a href=\"#first-of-type选择器\" class=\"headerlink\" title=\"first-of-type选择器\"></a>first-of-type选择器</h5><p>“:first-of-type”选择器类似于“:first-child”选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。<br><em>我要改变第一个段落的背景为橙色</em><br><code>.wrapper &gt; p:first-of-type {\n  background: orange;\n}</code><br>通过“:first-of-type”选择器，定位div容器中的第一个p元素（p不一定是容器中的第一个子元素），并设置其背景色为橙色。</p>\n<h5 id=\"nth-of-type-n-选择器\"><a href=\"#nth-of-type-n-选择器\" class=\"headerlink\" title=\"nth-of-type(n)选择器\"></a>nth-of-type(n)选择器</h5><p>“:nth-of-type(n)”选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词。</p>\n<h5 id=\"last-of-type选择器\"><a href=\"#last-of-type选择器\" class=\"headerlink\" title=\"last-of-type选择器\"></a>last-of-type选择器</h5><p>“:last-of-type”选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素。</p>\n<h5 id=\"nth-last-of-type-n-选择器\"><a href=\"#nth-last-of-type-n-选择器\" class=\"headerlink\" title=\"nth-last-of-type(n)选择器\"></a>nth-last-of-type(n)选择器</h5><p>“:nth-last-of-type(n)”选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。</p>\n<h5 id=\"only-child选择器\"><a href=\"#only-child选择器\" class=\"headerlink\" title=\"only-child选择器\"></a>only-child选择器</h5><p>“:only-child”选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。</p>\n<h5 id=\"only-of-type选择器\"><a href=\"#only-of-type选择器\" class=\"headerlink\" title=\"only-of-type选择器\"></a>only-of-type选择器</h5><p>“:only-of-type”选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。</p>\n<h5 id=\"enabled选择器\"><a href=\"#enabled选择器\" class=\"headerlink\" title=\":enabled选择器\"></a>:enabled选择器</h5><p>在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器“:enabled”对这些表单元素设置样式。<br><code>input[type=&quot;text&quot;]:enabled {\n  background: #ccc;\n  border: 2px solid red;\n}</code><br>通过“:enabled”选择器，修改文本输入框的边框为2像素的红色边框，并设置它的背景为灰色。</p>\n<p>#####:disabled选择器<br>“:disabled”选择器刚好与“:enabled”选择器相反，用来选择不可用表单元素。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。<br><code>input[type=&quot;text&quot;]:disabled {\n  background: rgba(0,0,0,.15);\n  border: 1px solid rgba(0,0,0,.15);\n  color: rgba(0,0,0,.15);\n}</code><br>通过“:disabled”选择器，给不可用输入框设置明显的样式。</p>\n<h5 id=\"checked选择器\"><a href=\"#checked选择器\" class=\"headerlink\" title=\":checked选择器\"></a>:checked选择器</h5><p>在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而“:checked”表示的是选中状态。<br><code>input[type=&quot;checkbox&quot;]:checked + span {\n  opacity: 1;\n}</code></p>\n<h5 id=\"selection选择器\"><a href=\"#selection选择器\" class=\"headerlink\" title=\"::selection选择器\"></a>::selection选择器</h5><p>“::selection”伪元素是用来匹配突出显示的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示.<br>有的时候设计要求,不使用上图那种浏览器默认的突出文本效果，需要一个与众不同的效果，此时“::selection”伪元素就非常的实用。不过在Firefox浏览器还需要添加前缀。<br><code>::-moz-selection {\n  background: red;\n  color: green;\n}\n::selection {\n  background: red;\n  color: green;\n}</code><br>:read-only选择器<br>“:read-only”伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了“readonly=’readonly’”<br><code>input[type=&quot;text&quot;]:read-only{\n  border-color: #ccc;\n}</code><br>通过“:read-only”选择器来设置地址文本框的样式。</p>\n<h5 id=\"read-write选择器\"><a href=\"#read-write选择器\" class=\"headerlink\" title=\":read-write选择器\"></a>:read-write选择器</h5><p>“:read-write”选择器刚好与“:read-only”选择器相反，主要用来指定当元素处于非只读状态时的样式。<br><code>input[type=&quot;text&quot;]:read-write{\n  border-color: #f36;\n}</code><br>使用“:read-write”选择器来设置不是只读控件的文本框样式。</p>\n<h5 id=\"before和-after\"><a href=\"#before和-after\" class=\"headerlink\" title=\"::before和::after\"></a>::before和::after</h5><p><strong>::before</strong>和<strong>::after</strong>这两个主要用来给元素的前面或后面插入内容，这两个常和”content”配合使用，使用的场景最多的就是清除浮动。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">::before</span>,</div><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">::after</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">\".\"</span>;</div><div class=\"line\">    <span class=\"attribute\">display</span>: block;</div><div class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">visibility</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.clearfix</span><span class=\"selector-pseudo\">:after</span> &#123;<span class=\"attribute\">clear</span>: both;&#125;</div><div class=\"line\"><span class=\"selector-class\">.clearfix</span> &#123;<span class=\"attribute\">zoom</span>: <span class=\"number\">1</span>;&#125;</div></pre></td></tr></table></figure><br>当然可以利用他们制作出其他更好的效果，比如右侧中的阴影效果，也是通过这个来实现的。</p>\n<p>关键代码分析：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.effect</span><span class=\"selector-pseudo\">::before</span>, <span class=\"selector-class\">.effect</span><span class=\"selector-pseudo\">::after</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">content</span>:<span class=\"string\">\"\"</span>;</div><div class=\"line\">    <span class=\"attribute\">position</span>:absolute;</div><div class=\"line\">    <span class=\"attribute\">z-index</span>:-<span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"attribute\">-webkit-box-shadow</span>:<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">20px</span> <span class=\"built_in\">rgba</span>(0,0,0,0.8);</div><div class=\"line\">    <span class=\"attribute\">-moz-box-shadow</span>:<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">20px</span> <span class=\"built_in\">rgba</span>(0,0,0,0.8);</div><div class=\"line\">    <span class=\"attribute\">box-shadow</span>:<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">20px</span> <span class=\"built_in\">rgba</span>(0,0,0,0.8);</div><div class=\"line\">    <span class=\"attribute\">top</span>:<span class=\"number\">50%</span>;</div><div class=\"line\">    <span class=\"attribute\">bottom</span>:<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"attribute\">left</span>:<span class=\"number\">10px</span>;</div><div class=\"line\">    <span class=\"attribute\">right</span>:<span class=\"number\">10px</span>;</div><div class=\"line\">    <span class=\"attribute\">-moz-border-radius</span>:<span class=\"number\">100px</span> / <span class=\"number\">10px</span>;</div><div class=\"line\">    <span class=\"attribute\">border-radius</span>:<span class=\"number\">100px</span> / <span class=\"number\">10px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure><br>上面代码作用在class名叫.effect上的div的前（before）后(after)都添加一个空元素，然后为这两个空元素添加阴影特效。</p>\n<h2 id=\"变形与动画-transform\"><a href=\"#变形与动画-transform\" class=\"headerlink\" title=\"变形与动画 transform\"></a>变形与动画 transform</h2><h5 id=\"变形–旋转-rotate\"><a href=\"#变形–旋转-rotate\" class=\"headerlink\" title=\"变形–旋转 rotate()\"></a>变形–旋转 rotate()</h5><p>旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.wrapper div &#123;</div><div class=\"line\">  width: 200px;</div><div class=\"line\">  height: 200px;</div><div class=\"line\">  background: orange;</div><div class=\"line\">  -webkit-transform: rotate(45deg);</div><div class=\"line\">  transform: rotate(45deg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h5 id=\"变形–扭曲-skew\"><a href=\"#变形–扭曲-skew\" class=\"headerlink\" title=\"变形–扭曲 skew()\"></a>变形–扭曲 skew()</h5><p>扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。这与rotate()函数的旋转不同，rotate()函数只是旋转，而不会改变元素的形状。skew()函数不会旋转，而只会改变元素的形状。<br>Skew()具有<strong>三种</strong>情况：</p>\n<ol>\n<li>skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；<br><img src=\"http://ww1.sinaimg.cn/large/0060lm7Tgw1f8t3j7iejxj309z066mxr.jpg\" alt=\"X,Y扭曲\"><br>第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。</li>\n<li>skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）；<br><img src=\"http://ww4.sinaimg.cn/large/0060lm7Tgw1f8t3kqlvs1j30a805t0ta.jpg\" alt=\"X扭曲\"></li>\n<li>skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形）<br><img src=\"http://ww4.sinaimg.cn/large/0060lm7Tgw1f8t3l1aem0j30a705saak.jpg\" alt=\"Y扭曲\"><h5 id=\"变形–缩放-scale\"><a href=\"#变形–缩放-scale\" class=\"headerlink\" title=\"变形–缩放 scale()\"></a>变形–缩放 scale()</h5>缩放 scale()函数 让元素根据中心原点对对象进行缩放。<br>缩放 scale 具有<strong>三种</strong>情况：</li>\n<li>scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）<br><img src=\"http://img.mukewang.com/53391aff000181f703520211.jpg\" alt=\"X,Y缩放\"><br><code>div:hover {\n-webkit-transform: scale(1.5,0.5);\n-moz-transform:scale(1.5,0.5)\ntransform: scale(1.5,0.5);\n}</code><br><strong>注意：Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。</strong></li>\n<li>scaleX(x)元素仅水平方向缩放（X轴缩放）<br><img src=\"http://img.mukewang.com/53391b0b00016a7002920170.jpg\" alt=\"X缩放\"></li>\n<li>scaleY(y)元素仅垂直方向缩放（Y轴缩放）<br><img src=\"http://img.mukewang.com/53391b14000169cf03280183.jpg\" alt=\"Y缩放\"><h5 id=\"变形–位移-translate\"><a href=\"#变形–位移-translate\" class=\"headerlink\" title=\"变形–位移 translate()\"></a>变形–位移 translate()</h5>translate()函数可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。<br>translate我们分为<strong>三种</strong>情况：<br>1、translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动），一个参数时仅X位移。<br><img src=\"http://img.mukewang.com/53391c640001709503850257.jpg\" alt=\"X,Y位移\"><br>2、translateX(x)仅水平方向移动（X轴移动）<br><img src=\"http://img.mukewang.com/53391c920001420703810201.jpg\" alt=\"X位移\"><br>3、translateY(Y)仅垂直方向移动（Y轴移动）<br><img src=\"http://img.mukewang.com/53391ca70001da5e03570211.jpg\" alt=\"Y位移\"><h5 id=\"变形–矩阵-matrix\"><a href=\"#变形–矩阵-matrix\" class=\"headerlink\" title=\"变形–矩阵 matrix()\"></a>变形–矩阵 matrix()</h5>matrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果需要深入了解，需要对数学矩阵有一定的知识。<br>示例演示：通过matrix()函数来模拟transform中translate()位移的效果。<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.wrapper</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">2px</span> dotted red;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">40px</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.wrapper</span> <span class=\"selector-tag\">div</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: orange;</div><div class=\"line\">  <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">matrix</span>(1,0,0,1,50,50);</div><div class=\"line\">  <span class=\"attribute\">-moz-transform</span>:<span class=\"built_in\">matrix</span>(1,0,0,1,50,50);</div><div class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">matrix</span>(1,0,0,1,50,50);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n演示结果：<br><img src=\"http://img.mukewang.com/53391e000001b60b03890278.jpg\" alt=\"矩阵变换\"><blockquote>\n<p> matrix(scaleX(),skewX(),skewY(),scaleY(),translateX(),translateY());</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"动画–过渡属性-transition\"><a href=\"#动画–过渡属性-transition\" class=\"headerlink\" title=\"动画–过渡属性 transition\"></a>动画–过渡属性 transition</h2><p>早期在Web中要实现动画效果，都是依赖于JavaScript或Flash来完成。但在CSS3中新增加了一个新的模块transition，它可以通过一些简单的CSS事件来触发元素的外观变化，让效果显得更加细腻。简单点说，就是通过鼠标的单击、获得焦点，被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。</p>\n<p>在CSS中创建简单的过渡效果可以从以下几个步骤来实现：</p>\n<ol>\n<li>在默认样式中声明元素的初始状态样式；</li>\n<li>声明过渡元素最终状态样式，比如悬浮状态；</li>\n<li>在默认样式中通过添加过渡函数，添加一些不同的样式。</li>\n</ol>\n<p>CSS3的过度transition属性是一个复合属性，主要包括以下几个子属性：</p>\n<p><strong>transition-property</strong>:指定过渡或动态模拟的CSS属性(width,height,transform…)<br><strong>transition-duration</strong>:指定完成过渡所需的时间<br><strong>transition-timing-function</strong>:指定过渡函数(ease,ease-in,ease-out,ease-in-out,linear…)<br><strong>transition-delay</strong>:指定开始出现的延迟时间<br>先来看transition-property属性</p>\n<p>transition-property用来指定过渡动画的CSS属性名称，而这个过渡属性只有具备一个中点值的属性（需要产生动画的属性）才能具备过渡效果,<strong>特别注意：当“transition-property”属性设置为all时，表示的是所有中点值的属性。</strong><br>用一个简单的例子来说明这个问题：</p>\n<blockquote>\n<p> 假设你的初始状态设置了样式“width”,“height”,“background”,当你在终始状态都改变了这三个属性，那么all代表的就是“width”、“height”和“background”。如果你的终始状态只改变了“width”和“height”时，那么all代表的就是“width”和“height”。</p>\n</blockquote>\n<h2 id=\"动画–animation\"><a href=\"#动画–animation\" class=\"headerlink\" title=\"动画–animation\"></a>动画–animation</h2><h5 id=\"Keyframes介绍\"><a href=\"#Keyframes介绍\" class=\"headerlink\" title=\"Keyframes介绍\"></a>Keyframes介绍</h5><p>Keyframes被称为关键帧，其类似于Flash中的关键帧。在CSS3中其主要以“@keyframes”开头，后面紧跟着是动画名称加上一对花括号“{…}”，括号中就是一些不同时间段样式规则。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@keyframes changecolor&#123;</div><div class=\"line\">  0%&#123;</div><div class=\"line\">   background: red;</div><div class=\"line\">  &#125;</div><div class=\"line\">  100%&#123;</div><div class=\"line\">    background: green;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在一个“@keyframes”中的样式规则可以由多个百分比构成的，如在“0%”到“100%”之间创建更多个百分比，分别给每个百分比中给需要有动画效果的元素加上不同的样式，从而达到一种在不断变化的效果。<br>经验与技巧：在@keyframes中定义动画名称时，<strong>其中0%和100%还可以使用关键词from和to来代表，其中0%对应的是from，100%对应的是to。</strong><br>案例演示<br>通过“@keyframes”声明一个名叫“wobble”的动画，从“0%”开始到“100%”结束，同时还经历了一个“40%”和“60%”两个过程。“wobble”动画在“0%”时元素定位到left为100px，背景色为green，然后在“40%”时元素过渡到left为150px,背景色为orange,接着在“60%”时元素过渡到left为75px，背景色为blue，最后“100%”时结束动画，元素又回到起点left为100px处，背景色变为red。<br><code>animation: wobble 5s ease .1s;</code>后三个参数与transition相同。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTML:</div><div class=\"line\"></div><div class=\"line\">&lt;div&gt;鼠标放到我身上&lt;/div&gt;</div><div class=\"line\">CSS:</div><div class=\"line\"></div><div class=\"line\">@keyframes wobble &#123;</div><div class=\"line\">  0% &#123;</div><div class=\"line\">    margin-left: 100px;</div><div class=\"line\">    background:green;</div><div class=\"line\">  &#125;</div><div class=\"line\">  40% &#123;</div><div class=\"line\">    margin-left:150px;</div><div class=\"line\">    background:orange;</div><div class=\"line\">  &#125;</div><div class=\"line\">  60% &#123;</div><div class=\"line\">    margin-left: 75px;</div><div class=\"line\">    background: blue;</div><div class=\"line\">  &#125;</div><div class=\"line\">  100% &#123;</div><div class=\"line\">    margin-left: 100px;</div><div class=\"line\">    background: red;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">div &#123;</div><div class=\"line\">  width: 100px;</div><div class=\"line\">  height: 100px;</div><div class=\"line\">  background:red;</div><div class=\"line\">  color: #fff;</div><div class=\"line\">&#125;</div><div class=\"line\">div:hover&#123;</div><div class=\"line\">  animation: wobble 5s ease .1s;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>animation-iteration-count</strong>属性主要用来定义动画的播放次数。<br>语法规则：<br>animation-iteration-count: infinite | <number> [, infinite | <number>]*</number></number></p>\n<ol>\n<li>其值通常为整数，但也可以使用带有小数的数字，其默认值为1，这意味着动画将从开始到结束只播放一次。</li>\n<li>如果取值为infinite，动画将会无限次的播放。<h5 id=\"设置动画播放方向\"><a href=\"#设置动画播放方向\" class=\"headerlink\" title=\"设置动画播放方向\"></a>设置动画播放方向</h5><strong>animation-direction</strong>属性主要用来设置动画播放方向，其语法规则如下：<br>animation-direction:normal | alternate [, normal | alternate]*<br>其主要有两个值：normal、alternate</li>\n<li>normal是默认值，如果设置为normal时，动画的每次循环都是向前播放；</li>\n<li>另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。<br>例如：通过animation-direction属性，将move动画播放动画方向设置为alternate，代码为：<br><code>animation-direction:alternate;</code><h6 id=\"设置动画的播放状态\"><a href=\"#设置动画的播放状态\" class=\"headerlink\" title=\"设置动画的播放状态\"></a>设置动画的播放状态</h6><strong>animation-play-state</strong>属性主要用来控制元素动画的播放状态。<br>参数：<br>其主要有两个值：<em>running</em>和<em>paused</em>。</li>\n</ol>\n<p>其中running是其默认值，主要作用就是类似于音乐播放器一样，可以通过paused将正在播放的动画停下来，也可以通过running将暂停的动画重新播放，这里的重新播放不一定是从元素动画的开始播放，而是从暂停的那个位置开始播放。另外如果暂停了动画的播放，元素的样式将回到最原始设置状态。<br>例如，页面加载时，动画不播放。代码如下：<br><code>animation-play-state:paused;</code></p>\n<h5 id=\"设置动画时间外属性\"><a href=\"#设置动画时间外属性\" class=\"headerlink\" title=\"设置动画时间外属性\"></a>设置动画时间外属性</h5><p><strong>animation-fill-mode</strong>属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：none、forwards、backwords和both。其四个属性值对应效果如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性值</th>\n<th>效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">none</td>\n<td>默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时,动画会反转到初始帧处</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">forwards</td>\n<td>表示动画在结束后继续应用最后的关键帧的位置</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">backwards</td>\n<td>会在向元素应用动画样式时迅速应用动画的初始帧</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">both</td>\n<td>元素动画同时具有forwards和backwards效果</td>\n</tr>\n</tbody>\n</table>\n<p>在默认情况之下，动画不会影响它的关键帧之外的属性，使用animation-fill-mode属性可以修改动画的默认行为。简单的说就是告诉动画在第一关键帧上等待动画开始，或者在动画结束时停在最后一个关键帧上而不回到动画的第一帧上。或者同时具有这两个效果。<br>例如：让动画停在最一帧处。代码如下：<br><code>animation-fill-mode:forwards;</code></p>"},{"layout":"post","title":"github添加ssh-key之后push还要输入账号密码的解决方法","date":"2016-10-08T06:30:09.000Z","_content":"> ssh-keygen -t rsa -C \"your_email@example.com\"将生成的公钥添加后,但是push的时候还是要输入账号密码。\n\n这是因为clone的时候**应该使用ssh的方法**，而现在用的是~~https~~方法。\n只需要克隆的时候在github上选择ssh而不是https就可以了(clone的地址下面有)。\n如果是已经克隆好的只需要改config就可以\nvim .git/config\n像下面改url\n```\n[remote \"origin\"]\nurl = git@github.com:wxrbwran/hexo-blog.git\n```\n\n","source":"_posts/key之后push还要输入账号密码的解决方法.md","raw":"layout: \ntitle: github添加ssh-key之后push还要输入账号密码的解决方法\ndate: 2016-10-08 14:30:09\ntags: git\n---\n> ssh-keygen -t rsa -C \"your_email@example.com\"将生成的公钥添加后,但是push的时候还是要输入账号密码。\n\n这是因为clone的时候**应该使用ssh的方法**，而现在用的是~~https~~方法。\n只需要克隆的时候在github上选择ssh而不是https就可以了(clone的地址下面有)。\n如果是已经克隆好的只需要改config就可以\nvim .git/config\n像下面改url\n```\n[remote \"origin\"]\nurl = git@github.com:wxrbwran/hexo-blog.git\n```\n\n","slug":"key之后push还要输入账号密码的解决方法","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"photos":[],"link":"","_id":"cj3dvkfdr001azk4obxbogjg9","content":"<blockquote>\n<p>ssh-keygen -t rsa -C “your_email@example.com”将生成的公钥添加后,但是push的时候还是要输入账号密码。</p>\n</blockquote>\n<p>这是因为clone的时候<strong>应该使用ssh的方法</strong>，而现在用的是<del>https</del>方法。<br>只需要克隆的时候在github上选择ssh而不是https就可以了(clone的地址下面有)。<br>如果是已经克隆好的只需要改config就可以<br>vim .git/config<br>像下面改url<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">url = git@github.com:wxrbwran/hexo-blog.git</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>ssh-keygen -t rsa -C “your_email@example.com”将生成的公钥添加后,但是push的时候还是要输入账号密码。</p>\n</blockquote>\n<p>这是因为clone的时候<strong>应该使用ssh的方法</strong>，而现在用的是<del>https</del>方法。<br>只需要克隆的时候在github上选择ssh而不是https就可以了(clone的地址下面有)。<br>如果是已经克隆好的只需要改config就可以<br>vim .git/config<br>像下面改url<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[remote &quot;origin&quot;]</div><div class=\"line\">url = git@github.com:wxrbwran/hexo-blog.git</div></pre></td></tr></table></figure></p>\n"},{"title":"linux 交换alt和ctrl按键","date":"2016-10-14T03:49:11.000Z","_content":"### 为什么要交换alt键和ctrl键呢?\n珍爱小拇指,远离ctrl, ctrl键每次按时都要移动整个手掌, 而且还要看一眼键盘,实在是不爽啊\nalt键就好了只要大拇指稍微移一下就可以按到了.\n方法:\n在home目录建一个文件  ``.Xmodmap ``\n然后在文件中写入下面几句:\n```\n remove control = Control_L                                                  \n remove mod1 = Alt_L\n keysym Control_L = Alt_L\n keysym Alt_L = Control_L\n add control = Control_L\n add mod1 = Alt_L\n ```\n然后logout再登录就好了.上面的代码一定要写在 .Xmodmap 文件中才行.","source":"_posts/linux-交换alt和ctrl按键.md","raw":"---\ntitle: linux 交换alt和ctrl按键\ndate: 2016-10-14 11:49:11\ntags: ubuntu\n---\n### 为什么要交换alt键和ctrl键呢?\n珍爱小拇指,远离ctrl, ctrl键每次按时都要移动整个手掌, 而且还要看一眼键盘,实在是不爽啊\nalt键就好了只要大拇指稍微移一下就可以按到了.\n方法:\n在home目录建一个文件  ``.Xmodmap ``\n然后在文件中写入下面几句:\n```\n remove control = Control_L                                                  \n remove mod1 = Alt_L\n keysym Control_L = Alt_L\n keysym Alt_L = Control_L\n add control = Control_L\n add mod1 = Alt_L\n ```\n然后logout再登录就好了.上面的代码一定要写在 .Xmodmap 文件中才行.","slug":"linux-交换alt和ctrl按键","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdt001dzk4oz9x4obi0","content":"<h3 id=\"为什么要交换alt键和ctrl键呢\"><a href=\"#为什么要交换alt键和ctrl键呢\" class=\"headerlink\" title=\"为什么要交换alt键和ctrl键呢?\"></a>为什么要交换alt键和ctrl键呢?</h3><p>珍爱小拇指,远离ctrl, ctrl键每次按时都要移动整个手掌, 而且还要看一眼键盘,实在是不爽啊<br>alt键就好了只要大拇指稍微移一下就可以按到了.<br>方法:<br>在home目录建一个文件  <code>.Xmodmap</code><br>然后在文件中写入下面几句:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove control = Control_L                                                  </div><div class=\"line\">remove mod1 = Alt_L</div><div class=\"line\">keysym Control_L = Alt_L</div><div class=\"line\">keysym Alt_L = Control_L</div><div class=\"line\">add control = Control_L</div><div class=\"line\">add mod1 = Alt_L</div></pre></td></tr></table></figure></p>\n<p>然后logout再登录就好了.上面的代码一定要写在 .Xmodmap 文件中才行.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么要交换alt键和ctrl键呢\"><a href=\"#为什么要交换alt键和ctrl键呢\" class=\"headerlink\" title=\"为什么要交换alt键和ctrl键呢?\"></a>为什么要交换alt键和ctrl键呢?</h3><p>珍爱小拇指,远离ctrl, ctrl键每次按时都要移动整个手掌, 而且还要看一眼键盘,实在是不爽啊<br>alt键就好了只要大拇指稍微移一下就可以按到了.<br>方法:<br>在home目录建一个文件  <code>.Xmodmap</code><br>然后在文件中写入下面几句:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">remove control = Control_L                                                  </div><div class=\"line\">remove mod1 = Alt_L</div><div class=\"line\">keysym Control_L = Alt_L</div><div class=\"line\">keysym Alt_L = Control_L</div><div class=\"line\">add control = Control_L</div><div class=\"line\">add mod1 = Alt_L</div></pre></td></tr></table></figure></p>\n<p>然后logout再登录就好了.上面的代码一定要写在 .Xmodmap 文件中才行.</p>\n"},{"title":"react中context的使用","date":"2017-05-27T06:29:39.000Z","_content":"\n## 使用 Context 的原因\n\n为了有时候想传递数据通过组件树，但是不想给每一层级的组件手动传递属性，那么 context 就能帮你 \"越级\" 传递数据到组件树中你想传递到的深层次组件。\n\n<!--more-->\n\n有时候 A组件 为了给 B组件 中的 C组件 传递一个 prop ，而需要把参数在组件中传递两次才能最终将 A组件 中的 prop 传递给 C组件 。\n\n官方文档的示例代码如下\n``` javascript\nvar Button = React.createClass({\n  render: function() {\n    return (\n      <button style={{background: this.props.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n});\n\nvar Message = React.createClass({\n  render: function() {\n    return (\n      <div>\n        {this.props.text} <Button color={this.props.color}>Delete</Button>\n      </div>\n    );\n  }\n});\n\nvar MessageList = React.createClass({\n  render: function() {\n    var color = \"purple\";\n    var children = this.props.messages.map(function(message) {\n      return <Message text={message.text} color={color} />;\n    });\n    return <div>{children}</div>;\n  }\n});\n```\n\n### 使用 context 改进数据传递\n\n现在我们使用 context 来完成参数的传递试试\n``` javascript\nvar Button = React.createClass({\n  // 必须指定context的数据类型\n  contextTypes: {\n    color: React.PropTypes.string\n  },\n  render: function() {\n    return (\n      <button style={{background: this.context.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n});\n\nvar Message = React.createClass({\n  render: function() {\n    return (\n      <div>\n        {this.props.text} <Button>Delete</Button>\n      </div>\n    );\n  }\n});\n\nvar MessageList = React.createClass({\n  //\n  childContextTypes: {\n    color: React.PropTypes.string\n  },\n  getChildContext: function() {\n    return {color: \"purple\"};\n  },\n  render: function() {\n    var children = this.props.messages.map(function(message) {\n      return <Message text={message.text} />;\n    });\n    return <div>{children}</div>;\n  }\n});\n```\n示例代码中通过添加 **childContextTypes** 和**getChildContext()** 到 MessageList （ context 的提供者），React 自动向下传递数据然后在组件树中的任意组件（也就是说任意子组件，在此示例代码中也就是 Button ）都能通过定义 **contextTypes** 访问 context 中的数据。\n\n\n### 总结\n\n1. 指定数据并要将数据传递下去的父组件要定义 **childContextTypes** 和 **getChildContext()**；\n2. 想要接收到数据的子组件 必须定义 **contextTypes** 来使用传递过来的 context 。","source":"_posts/react中context的使用.md","raw":"---\ntitle: react中context的使用\ndate: 2017-05-27 14:29:39\ntags: react\n---\n\n## 使用 Context 的原因\n\n为了有时候想传递数据通过组件树，但是不想给每一层级的组件手动传递属性，那么 context 就能帮你 \"越级\" 传递数据到组件树中你想传递到的深层次组件。\n\n<!--more-->\n\n有时候 A组件 为了给 B组件 中的 C组件 传递一个 prop ，而需要把参数在组件中传递两次才能最终将 A组件 中的 prop 传递给 C组件 。\n\n官方文档的示例代码如下\n``` javascript\nvar Button = React.createClass({\n  render: function() {\n    return (\n      <button style={{background: this.props.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n});\n\nvar Message = React.createClass({\n  render: function() {\n    return (\n      <div>\n        {this.props.text} <Button color={this.props.color}>Delete</Button>\n      </div>\n    );\n  }\n});\n\nvar MessageList = React.createClass({\n  render: function() {\n    var color = \"purple\";\n    var children = this.props.messages.map(function(message) {\n      return <Message text={message.text} color={color} />;\n    });\n    return <div>{children}</div>;\n  }\n});\n```\n\n### 使用 context 改进数据传递\n\n现在我们使用 context 来完成参数的传递试试\n``` javascript\nvar Button = React.createClass({\n  // 必须指定context的数据类型\n  contextTypes: {\n    color: React.PropTypes.string\n  },\n  render: function() {\n    return (\n      <button style={{background: this.context.color}}>\n        {this.props.children}\n      </button>\n    );\n  }\n});\n\nvar Message = React.createClass({\n  render: function() {\n    return (\n      <div>\n        {this.props.text} <Button>Delete</Button>\n      </div>\n    );\n  }\n});\n\nvar MessageList = React.createClass({\n  //\n  childContextTypes: {\n    color: React.PropTypes.string\n  },\n  getChildContext: function() {\n    return {color: \"purple\"};\n  },\n  render: function() {\n    var children = this.props.messages.map(function(message) {\n      return <Message text={message.text} />;\n    });\n    return <div>{children}</div>;\n  }\n});\n```\n示例代码中通过添加 **childContextTypes** 和**getChildContext()** 到 MessageList （ context 的提供者），React 自动向下传递数据然后在组件树中的任意组件（也就是说任意子组件，在此示例代码中也就是 Button ）都能通过定义 **contextTypes** 访问 context 中的数据。\n\n\n### 总结\n\n1. 指定数据并要将数据传递下去的父组件要定义 **childContextTypes** 和 **getChildContext()**；\n2. 想要接收到数据的子组件 必须定义 **contextTypes** 来使用传递过来的 context 。","slug":"react中context的使用","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdu001fzk4ovm03468h","content":"<h2 id=\"使用-Context-的原因\"><a href=\"#使用-Context-的原因\" class=\"headerlink\" title=\"使用 Context 的原因\"></a>使用 Context 的原因</h2><p>为了有时候想传递数据通过组件树，但是不想给每一层级的组件手动传递属性，那么 context 就能帮你 “越级” 传递数据到组件树中你想传递到的深层次组件。</p>\n<a id=\"more\"></a>\n<p>有时候 A组件 为了给 B组件 中的 C组件 传递一个 prop ，而需要把参数在组件中传递两次才能最终将 A组件 中的 prop 传递给 C组件 。</p>\n<p>官方文档的示例代码如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Button = React.createClass(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;background:</span> <span class=\"attr\">this.props.color</span>&#125;&#125;&gt;</span></span></div><div class=\"line\">        &#123;this.props.children&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Message = React.createClass(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        &#123;this.props.text&#125; <span class=\"tag\">&lt;<span class=\"name\">Button</span> <span class=\"attr\">color</span>=<span class=\"string\">&#123;this.props.color&#125;</span>&gt;</span>Delete<span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> MessageList = React.createClass(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> color = <span class=\"string\">\"purple\"</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> children = <span class=\"keyword\">this</span>.props.messages.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Message</span> <span class=\"attr\">text</span>=<span class=\"string\">&#123;message.text&#125;</span> <span class=\"attr\">color</span>=<span class=\"string\">&#123;color&#125;</span> /&gt;</span>;</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">    return <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用-context-改进数据传递\"><a href=\"#使用-context-改进数据传递\" class=\"headerlink\" title=\"使用 context 改进数据传递\"></a>使用 context 改进数据传递</h3><p>现在我们使用 context 来完成参数的传递试试<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Button = React.createClass(&#123;</div><div class=\"line\">  <span class=\"comment\">// 必须指定context的数据类型</span></div><div class=\"line\">  contextTypes: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: React.PropTypes.string</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;background:</span> <span class=\"attr\">this.context.color</span>&#125;&#125;&gt;</span></span></div><div class=\"line\">        &#123;this.props.children&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Message = React.createClass(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        &#123;this.props.text&#125; <span class=\"tag\">&lt;<span class=\"name\">Button</span>&gt;</span>Delete<span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> MessageList = React.createClass(&#123;</div><div class=\"line\">  <span class=\"comment\">//</span></div><div class=\"line\">  childContextTypes: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: React.PropTypes.string</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">getChildContext</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">color</span>: <span class=\"string\">\"purple\"</span>&#125;;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> children = <span class=\"keyword\">this</span>.props.messages.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Message</span> <span class=\"attr\">text</span>=<span class=\"string\">&#123;message.text&#125;</span> /&gt;</span>;</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">    return <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>示例代码中通过添加 <strong>childContextTypes</strong> 和<strong>getChildContext()</strong> 到 MessageList （ context 的提供者），React 自动向下传递数据然后在组件树中的任意组件（也就是说任意子组件，在此示例代码中也就是 Button ）都能通过定义 <strong>contextTypes</strong> 访问 context 中的数据。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>指定数据并要将数据传递下去的父组件要定义 <strong>childContextTypes</strong> 和 <strong>getChildContext()</strong>；</li>\n<li>想要接收到数据的子组件 必须定义 <strong>contextTypes</strong> 来使用传递过来的 context 。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"使用-Context-的原因\"><a href=\"#使用-Context-的原因\" class=\"headerlink\" title=\"使用 Context 的原因\"></a>使用 Context 的原因</h2><p>为了有时候想传递数据通过组件树，但是不想给每一层级的组件手动传递属性，那么 context 就能帮你 “越级” 传递数据到组件树中你想传递到的深层次组件。</p>","more":"<p>有时候 A组件 为了给 B组件 中的 C组件 传递一个 prop ，而需要把参数在组件中传递两次才能最终将 A组件 中的 prop 传递给 C组件 。</p>\n<p>官方文档的示例代码如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Button = React.createClass(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;background:</span> <span class=\"attr\">this.props.color</span>&#125;&#125;&gt;</span></span></div><div class=\"line\">        &#123;this.props.children&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Message = React.createClass(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        &#123;this.props.text&#125; <span class=\"tag\">&lt;<span class=\"name\">Button</span> <span class=\"attr\">color</span>=<span class=\"string\">&#123;this.props.color&#125;</span>&gt;</span>Delete<span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> MessageList = React.createClass(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> color = <span class=\"string\">\"purple\"</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> children = <span class=\"keyword\">this</span>.props.messages.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Message</span> <span class=\"attr\">text</span>=<span class=\"string\">&#123;message.text&#125;</span> <span class=\"attr\">color</span>=<span class=\"string\">&#123;color&#125;</span> /&gt;</span>;</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">    return <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用-context-改进数据传递\"><a href=\"#使用-context-改进数据传递\" class=\"headerlink\" title=\"使用 context 改进数据传递\"></a>使用 context 改进数据传递</h3><p>现在我们使用 context 来完成参数的传递试试<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Button = React.createClass(&#123;</div><div class=\"line\">  <span class=\"comment\">// 必须指定context的数据类型</span></div><div class=\"line\">  contextTypes: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: React.PropTypes.string</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;background:</span> <span class=\"attr\">this.context.color</span>&#125;&#125;&gt;</span></span></div><div class=\"line\">        &#123;this.props.children&#125;</div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Message = React.createClass(&#123;</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">        &#123;this.props.text&#125; <span class=\"tag\">&lt;<span class=\"name\">Button</span>&gt;</span>Delete<span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> MessageList = React.createClass(&#123;</div><div class=\"line\">  <span class=\"comment\">//</span></div><div class=\"line\">  childContextTypes: &#123;</div><div class=\"line\">    <span class=\"attr\">color</span>: React.PropTypes.string</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">getChildContext</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">color</span>: <span class=\"string\">\"purple\"</span>&#125;;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> children = <span class=\"keyword\">this</span>.props.messages.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Message</span> <span class=\"attr\">text</span>=<span class=\"string\">&#123;message.text&#125;</span> /&gt;</span>;</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">    return <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>示例代码中通过添加 <strong>childContextTypes</strong> 和<strong>getChildContext()</strong> 到 MessageList （ context 的提供者），React 自动向下传递数据然后在组件树中的任意组件（也就是说任意子组件，在此示例代码中也就是 Button ）都能通过定义 <strong>contextTypes</strong> 访问 context 中的数据。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>指定数据并要将数据传递下去的父组件要定义 <strong>childContextTypes</strong> 和 <strong>getChildContext()</strong>；</li>\n<li>想要接收到数据的子组件 必须定义 <strong>contextTypes</strong> 来使用传递过来的 context 。</li>\n</ol>"},{"title":"ubuntu设置杂记","date":"2016-10-08T07:13:34.000Z","_content":"### 在任务栏显示网速\n```\nsudo add-apt-repository ppa:nilarimogard/webupd8\nsudo apt-get update\nsudo apt-get install indicator-netspeed```\n\n### 设置显示桌面快捷键\n\n如果想设置“显示桌面”为“win + D”，步骤如下：\n```\nsudo apt-get install compizconfig-settings-manager\nccsm```\n\n\n","source":"_posts/ubuntu 设置杂记.mkd","raw":"---\ntitle: ubuntu设置杂记\ndate: 2016-10-08 15:13:34\ntags: ubuntu\n---\n### 在任务栏显示网速\n```\nsudo add-apt-repository ppa:nilarimogard/webupd8\nsudo apt-get update\nsudo apt-get install indicator-netspeed```\n\n### 设置显示桌面快捷键\n\n如果想设置“显示桌面”为“win + D”，步骤如下：\n```\nsudo apt-get install compizconfig-settings-manager\nccsm```\n\n\n","slug":"ubuntu 设置杂记","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdv001hzk4oj3d9sdkj","content":"<h3 id=\"在任务栏显示网速\"><a href=\"#在任务栏显示网速\" class=\"headerlink\" title=\"在任务栏显示网速\"></a>在任务栏显示网速</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo add-apt-repository ppa:nilarimogard/webupd8</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install indicator-netspeed</div></pre></td></tr></table></figure>\n<h3 id=\"设置显示桌面快捷键\"><a href=\"#设置显示桌面快捷键\" class=\"headerlink\" title=\"设置显示桌面快捷键\"></a>设置显示桌面快捷键</h3><p>如果想设置“显示桌面”为“win + D”，步骤如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install compizconfig-settings-manager</div><div class=\"line\">ccsm</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"在任务栏显示网速\"><a href=\"#在任务栏显示网速\" class=\"headerlink\" title=\"在任务栏显示网速\"></a>在任务栏显示网速</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo add-apt-repository ppa:nilarimogard/webupd8</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install indicator-netspeed</div></pre></td></tr></table></figure>\n<h3 id=\"设置显示桌面快捷键\"><a href=\"#设置显示桌面快捷键\" class=\"headerlink\" title=\"设置显示桌面快捷键\"></a>设置显示桌面快捷键</h3><p>如果想设置“显示桌面”为“win + D”，步骤如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install compizconfig-settings-manager</div><div class=\"line\">ccsm</div></pre></td></tr></table></figure></p>\n"},{"title":"linux中使用deepinQQ","date":"2016-10-10T02:09:38.000Z","thumbnail":"https://sqimg.qq.com/qq_product_operations/im/qqlogo/logo.png","banner":null,"_content":"### linux 运行QQ\n\n我们知道在deepin linux上面，deepin团队做了很多wine的应用程序，但是在其他的linux发行版上却没有这种待遇，下面介绍一下，如何在继续debian的linux发行版上运行deepin的wine应用程序。\n\n---\n>       本文基于ubuntu16.04\n\n### 安装crossover\n\n[crossover百度网盘下载](http://pan.baidu.com/s/1gflTQd9#list/path=%2F)\n\n注：资源文件夹里面有多个版本的crossover，后缀加了free是临时破解版，请支持正版，但是存在部分功能性问题，不影响deepinwine的软件包使用。没有free的没有功能性问题，但是可能出现deepinwine软件兼容性问题，试用15天的，如果支持crossover的朋友请购买正版。建议大家来回覆盖安装这两个版本使用，基本可以互补。如果有兴趣的朋友可以和我一起讨论研究解决问题。\n对于什么是来回覆盖安装，举个例子：free版是不能创建容器的，那么我们先安装不是free的版本也就是试用版，把容器创建好了以后，在覆盖安装free版就可以使用了。所以两个版本功能是互补的，虽然麻烦，但还是不影响正常使用的。\n\n##### 添加32位库的支持\n\n如果是64位系统，先添加对32位库的支持：\n```\nsudo dpkg --add-architecture i386\nsudo apt-get update\n###### 可能需要添加下列32位库\nsudo apt-get install lib32z1 lib32ncurses5\n```\n\n##### 安装crossover\n\n如果要安装14版本，\n从上面的分享地址里下载crossover_14.1.11-1_all.deb crossover_14.1.11-1_all-free.deb deepin-crossover_0.5.14_all.deb三个文件,依次安装。\n如果安装15，crossover-15_15.0.3-1_all.deb crossover-15_15.0.3-1_all-free.deb deepin-crossover-helper_1.0deepin0_all.deb 并依次安装。\n\n### 安装deepin的wine程序\n\n[QQ 8.x，需要Crossover 15](http://packages.deepin.com/deepin/pool/non-free/a/apps.com.qq.im/)\n[QQ 7.x 支持Crossover 14](http://packages.deepin.com/deepin/pool/non-free/d/deepinwine-qq/)\n[其他的deepin wine程序](http://packages.deepin.com/deepin/pool/non-free/d/) 下载，实际上这就是deepin的源\n\n都是deb包，可以直接下载安装。\n\n### 遇到的问题\n - 安装后启动不起来：重启系统。\n - 点击QQ的退出后，QQ在后台并没有真正关闭。这是需要``ps -A |grep QQ``,列出所有QQ程序，然后kill掉就可以了。","source":"_posts/linux中使用deepinQQ.md","raw":"---\ntitle: linux中使用deepinQQ\ndate: 2016-10-10 10:09:38\nthumbnail: https://sqimg.qq.com/qq_product_operations/im/qqlogo/logo.png\nbanner: \ntags: \n  - ubuntu\n  - software\n---\n### linux 运行QQ\n\n我们知道在deepin linux上面，deepin团队做了很多wine的应用程序，但是在其他的linux发行版上却没有这种待遇，下面介绍一下，如何在继续debian的linux发行版上运行deepin的wine应用程序。\n\n---\n>       本文基于ubuntu16.04\n\n### 安装crossover\n\n[crossover百度网盘下载](http://pan.baidu.com/s/1gflTQd9#list/path=%2F)\n\n注：资源文件夹里面有多个版本的crossover，后缀加了free是临时破解版，请支持正版，但是存在部分功能性问题，不影响deepinwine的软件包使用。没有free的没有功能性问题，但是可能出现deepinwine软件兼容性问题，试用15天的，如果支持crossover的朋友请购买正版。建议大家来回覆盖安装这两个版本使用，基本可以互补。如果有兴趣的朋友可以和我一起讨论研究解决问题。\n对于什么是来回覆盖安装，举个例子：free版是不能创建容器的，那么我们先安装不是free的版本也就是试用版，把容器创建好了以后，在覆盖安装free版就可以使用了。所以两个版本功能是互补的，虽然麻烦，但还是不影响正常使用的。\n\n##### 添加32位库的支持\n\n如果是64位系统，先添加对32位库的支持：\n```\nsudo dpkg --add-architecture i386\nsudo apt-get update\n###### 可能需要添加下列32位库\nsudo apt-get install lib32z1 lib32ncurses5\n```\n\n##### 安装crossover\n\n如果要安装14版本，\n从上面的分享地址里下载crossover_14.1.11-1_all.deb crossover_14.1.11-1_all-free.deb deepin-crossover_0.5.14_all.deb三个文件,依次安装。\n如果安装15，crossover-15_15.0.3-1_all.deb crossover-15_15.0.3-1_all-free.deb deepin-crossover-helper_1.0deepin0_all.deb 并依次安装。\n\n### 安装deepin的wine程序\n\n[QQ 8.x，需要Crossover 15](http://packages.deepin.com/deepin/pool/non-free/a/apps.com.qq.im/)\n[QQ 7.x 支持Crossover 14](http://packages.deepin.com/deepin/pool/non-free/d/deepinwine-qq/)\n[其他的deepin wine程序](http://packages.deepin.com/deepin/pool/non-free/d/) 下载，实际上这就是deepin的源\n\n都是deb包，可以直接下载安装。\n\n### 遇到的问题\n - 安装后启动不起来：重启系统。\n - 点击QQ的退出后，QQ在后台并没有真正关闭。这是需要``ps -A |grep QQ``,列出所有QQ程序，然后kill掉就可以了。","slug":"linux中使用deepinQQ","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdw001izk4op8dpl228","content":"<h3 id=\"linux-运行QQ\"><a href=\"#linux-运行QQ\" class=\"headerlink\" title=\"linux 运行QQ\"></a>linux 运行QQ</h3><p>我们知道在deepin linux上面，deepin团队做了很多wine的应用程序，但是在其他的linux发行版上却没有这种待遇，下面介绍一下，如何在继续debian的linux发行版上运行deepin的wine应用程序。</p>\n<hr>\n<blockquote>\n<pre><code>本文基于ubuntu16.04\n</code></pre></blockquote>\n<h3 id=\"安装crossover\"><a href=\"#安装crossover\" class=\"headerlink\" title=\"安装crossover\"></a>安装crossover</h3><p><a href=\"http://pan.baidu.com/s/1gflTQd9#list/path=%2F\" target=\"_blank\" rel=\"external\">crossover百度网盘下载</a></p>\n<p>注：资源文件夹里面有多个版本的crossover，后缀加了free是临时破解版，请支持正版，但是存在部分功能性问题，不影响deepinwine的软件包使用。没有free的没有功能性问题，但是可能出现deepinwine软件兼容性问题，试用15天的，如果支持crossover的朋友请购买正版。建议大家来回覆盖安装这两个版本使用，基本可以互补。如果有兴趣的朋友可以和我一起讨论研究解决问题。<br>对于什么是来回覆盖安装，举个例子：free版是不能创建容器的，那么我们先安装不是free的版本也就是试用版，把容器创建好了以后，在覆盖安装free版就可以使用了。所以两个版本功能是互补的，虽然麻烦，但还是不影响正常使用的。</p>\n<h5 id=\"添加32位库的支持\"><a href=\"#添加32位库的支持\" class=\"headerlink\" title=\"添加32位库的支持\"></a>添加32位库的支持</h5><p>如果是64位系统，先添加对32位库的支持：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo dpkg --add-architecture i386</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">###### 可能需要添加下列32位库</div><div class=\"line\">sudo apt-get install lib32z1 lib32ncurses5</div></pre></td></tr></table></figure></p>\n<h5 id=\"安装crossover-1\"><a href=\"#安装crossover-1\" class=\"headerlink\" title=\"安装crossover\"></a>安装crossover</h5><p>如果要安装14版本，<br>从上面的分享地址里下载crossover_14.1.11-1_all.deb crossover_14.1.11-1_all-free.deb deepin-crossover_0.5.14_all.deb三个文件,依次安装。<br>如果安装15，crossover-15_15.0.3-1_all.deb crossover-15_15.0.3-1_all-free.deb deepin-crossover-helper_1.0deepin0_all.deb 并依次安装。</p>\n<h3 id=\"安装deepin的wine程序\"><a href=\"#安装deepin的wine程序\" class=\"headerlink\" title=\"安装deepin的wine程序\"></a>安装deepin的wine程序</h3><p><a href=\"http://packages.deepin.com/deepin/pool/non-free/a/apps.com.qq.im/\" target=\"_blank\" rel=\"external\">QQ 8.x，需要Crossover 15</a><br><a href=\"http://packages.deepin.com/deepin/pool/non-free/d/deepinwine-qq/\" target=\"_blank\" rel=\"external\">QQ 7.x 支持Crossover 14</a><br><a href=\"http://packages.deepin.com/deepin/pool/non-free/d/\" target=\"_blank\" rel=\"external\">其他的deepin wine程序</a> 下载，实际上这就是deepin的源</p>\n<p>都是deb包，可以直接下载安装。</p>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ul>\n<li>安装后启动不起来：重启系统。</li>\n<li>点击QQ的退出后，QQ在后台并没有真正关闭。这是需要<code>ps -A |grep QQ</code>,列出所有QQ程序，然后kill掉就可以了。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"linux-运行QQ\"><a href=\"#linux-运行QQ\" class=\"headerlink\" title=\"linux 运行QQ\"></a>linux 运行QQ</h3><p>我们知道在deepin linux上面，deepin团队做了很多wine的应用程序，但是在其他的linux发行版上却没有这种待遇，下面介绍一下，如何在继续debian的linux发行版上运行deepin的wine应用程序。</p>\n<hr>\n<blockquote>\n<pre><code>本文基于ubuntu16.04\n</code></pre></blockquote>\n<h3 id=\"安装crossover\"><a href=\"#安装crossover\" class=\"headerlink\" title=\"安装crossover\"></a>安装crossover</h3><p><a href=\"http://pan.baidu.com/s/1gflTQd9#list/path=%2F\" target=\"_blank\" rel=\"external\">crossover百度网盘下载</a></p>\n<p>注：资源文件夹里面有多个版本的crossover，后缀加了free是临时破解版，请支持正版，但是存在部分功能性问题，不影响deepinwine的软件包使用。没有free的没有功能性问题，但是可能出现deepinwine软件兼容性问题，试用15天的，如果支持crossover的朋友请购买正版。建议大家来回覆盖安装这两个版本使用，基本可以互补。如果有兴趣的朋友可以和我一起讨论研究解决问题。<br>对于什么是来回覆盖安装，举个例子：free版是不能创建容器的，那么我们先安装不是free的版本也就是试用版，把容器创建好了以后，在覆盖安装free版就可以使用了。所以两个版本功能是互补的，虽然麻烦，但还是不影响正常使用的。</p>\n<h5 id=\"添加32位库的支持\"><a href=\"#添加32位库的支持\" class=\"headerlink\" title=\"添加32位库的支持\"></a>添加32位库的支持</h5><p>如果是64位系统，先添加对32位库的支持：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo dpkg --add-architecture i386</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">###### 可能需要添加下列32位库</div><div class=\"line\">sudo apt-get install lib32z1 lib32ncurses5</div></pre></td></tr></table></figure></p>\n<h5 id=\"安装crossover-1\"><a href=\"#安装crossover-1\" class=\"headerlink\" title=\"安装crossover\"></a>安装crossover</h5><p>如果要安装14版本，<br>从上面的分享地址里下载crossover_14.1.11-1_all.deb crossover_14.1.11-1_all-free.deb deepin-crossover_0.5.14_all.deb三个文件,依次安装。<br>如果安装15，crossover-15_15.0.3-1_all.deb crossover-15_15.0.3-1_all-free.deb deepin-crossover-helper_1.0deepin0_all.deb 并依次安装。</p>\n<h3 id=\"安装deepin的wine程序\"><a href=\"#安装deepin的wine程序\" class=\"headerlink\" title=\"安装deepin的wine程序\"></a>安装deepin的wine程序</h3><p><a href=\"http://packages.deepin.com/deepin/pool/non-free/a/apps.com.qq.im/\" target=\"_blank\" rel=\"external\">QQ 8.x，需要Crossover 15</a><br><a href=\"http://packages.deepin.com/deepin/pool/non-free/d/deepinwine-qq/\" target=\"_blank\" rel=\"external\">QQ 7.x 支持Crossover 14</a><br><a href=\"http://packages.deepin.com/deepin/pool/non-free/d/\" target=\"_blank\" rel=\"external\">其他的deepin wine程序</a> 下载，实际上这就是deepin的源</p>\n<p>都是deb包，可以直接下载安装。</p>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ul>\n<li>安装后启动不起来：重启系统。</li>\n<li>点击QQ的退出后，QQ在后台并没有真正关闭。这是需要<code>ps -A |grep QQ</code>,列出所有QQ程序，然后kill掉就可以了。</li>\n</ul>\n"},{"title":"vue-router2的一些变化","date":"2016-10-28T09:23:32.000Z","_content":"[vue-router2详细文档](http://router.vuejs.org/zh-cn/index.html)\nv-link由router-link替换，router-view 的name属性，可以匹配多个路由component**(s)**\n~~hashbang 弃用~~\nrouter.map,router.start,router.redirect，saveScrollPosition等都变为router的实例属性\nrouter.go()->router.push()\n{% codeblock lang:\"html\" router %}\n<p style=\"display: flex;justify-content:space-around;\n    align-items:center;flex-flow:row wrap;align-content:flex-start;\">\n    <router-link to=\"/foo\">go to foo</router-link>\n    <router-link to=\"/bar\">go to bar</router-link>\n    <router-link to=\"/user/dxf\">go to user:dxf</router-link>\n    <router-link to=\"/user/wxr/profile\">go to wxr profile</router-link>\n    <router-link to=\"/user/wxr/posts\">go to wxr posts</router-link>\n    <router-link to=\"/multi\">go to multi</router-link>\n  </p>\n  <transition name=\"fade\" mode=\"out-in\">\n    <keep-alive>\n      <router-view name=\"default\"></router-view>\n      <router-view name=\"r2\"></router-view>\n    </keep-alive>\n  </transition>\n{% endcodeblock %}\n<!--more-->\n{% codeblock lang:\"javascript\" router %}\n\nimport vueRouter from 'vue-router'\nimport {mapState} from 'vuex'\nimport {mapGetters} from 'vuex'\nimport {mapActions} from 'vuex'\n\nconst Foo = resolve => {\n  // require.ensure 是 Webpack 的特殊语法，用来设置 code-split point\n  // （代码分块）\n  require.ensure(['../components/Foo.vue'], () => {\n    resolve(require('../components/Foo.vue'))\n  })\n};\nconst Bar = resolve => {\n  require.ensure(['../components/Bar.vue'], () => {\n    resolve(require('../components/Bar.vue'))\n  })\n};\nconst User = {\n  template: `<section>\n  <h3>{{$store.state.count}} is {{evenOrOdd}}</h3>\n  <div @click=\"increment\">User:{{ $route.params.name }}</div>\n  <router-view></router-view>\n</section>`,\n  computed: mapGetters([\n    'evenOrOdd'\n  ]),\n  methods: mapActions([\n    'increment'\n  ])\n}\nconst Profile = {\n  template: '<div @click=\"increment\">profiles,and num is {{$store.state.count}}</div>',\n  methods: mapActions([\n    'increment'\n  ])\n}\nconst UserPosts = {template: '<div @click=\"alertCount\">posts</div>',\n  methods:mapActions([\n    'alertCount'\n  ])\n}\nconst UserHome = {template: '<div>homePage</div>'}\n\n\nconst router = new vueRouter({\n  mode: 'hash',//history\n  routes:[\n    {path: '/foo', component: Foo},\n    {path: '/bar', component: Bar},\n    {\n      path: '/multi', components: {\n      default: Foo,\n      r2: Bar\n      }\n    },\n    {\n      path: '/user/:name', component: User, name: 'user',\n      children: [\n        {\n          path: '', component: UserHome,\n          beforeEnter: (to, from, next) => {\n            console.log('enter user homepage');\n            next()\n          }\n        },\n        {\n          path: 'profile', component: Profile,\n          beforeEnter: (to, from, next) => {\n            console.log('enter user profile');\n            next()\n          }\n        },\n        {path: 'posts', component: UserPosts},\n        {path: 'post',redirect: 'posts'}\n      ]\n    },\n  ],\n  linkActiveClass: 'current'\n});\nexport default router\n{% endcodeblock %}\n{% codeblock lang:\"javascript\" Vue实例 %}\nimport  Vue from 'vue'\nimport vueRouter from 'vue-router'\nimport Vuex from 'vuex'\n\nimport store from './vuex/store'\nimport router from './route/routers'\nVue.use(vueRouter);\nVue.use(Vuex);\n//异步懒加载\n\nconst app = new Vue({\n  router,\n  store,\n  mounted: function () {\n    console.log('mounted...')\n    console.log(this.$router)\n  },\n  watch: {\n    '$route' (to, from) {\n      // 对路由变化作出响应...\n      console.log('to', to)\n      console.log('from', from)\n    }\n  }\n}).$mount('#app');\nrouter.beforeEach((to, from, next) => {\n  console.log('before each')\n  next()\n});\nrouter.push('/user/sss/posts');\n\n{% endcodeblock %}","source":"_posts/vue-router2的一些变化.md","raw":"---\ntitle: vue-router2的一些变化\ndate: 2016-10-28 17:23:32\ntags: Vue\n---\n[vue-router2详细文档](http://router.vuejs.org/zh-cn/index.html)\nv-link由router-link替换，router-view 的name属性，可以匹配多个路由component**(s)**\n~~hashbang 弃用~~\nrouter.map,router.start,router.redirect，saveScrollPosition等都变为router的实例属性\nrouter.go()->router.push()\n{% codeblock lang:\"html\" router %}\n<p style=\"display: flex;justify-content:space-around;\n    align-items:center;flex-flow:row wrap;align-content:flex-start;\">\n    <router-link to=\"/foo\">go to foo</router-link>\n    <router-link to=\"/bar\">go to bar</router-link>\n    <router-link to=\"/user/dxf\">go to user:dxf</router-link>\n    <router-link to=\"/user/wxr/profile\">go to wxr profile</router-link>\n    <router-link to=\"/user/wxr/posts\">go to wxr posts</router-link>\n    <router-link to=\"/multi\">go to multi</router-link>\n  </p>\n  <transition name=\"fade\" mode=\"out-in\">\n    <keep-alive>\n      <router-view name=\"default\"></router-view>\n      <router-view name=\"r2\"></router-view>\n    </keep-alive>\n  </transition>\n{% endcodeblock %}\n<!--more-->\n{% codeblock lang:\"javascript\" router %}\n\nimport vueRouter from 'vue-router'\nimport {mapState} from 'vuex'\nimport {mapGetters} from 'vuex'\nimport {mapActions} from 'vuex'\n\nconst Foo = resolve => {\n  // require.ensure 是 Webpack 的特殊语法，用来设置 code-split point\n  // （代码分块）\n  require.ensure(['../components/Foo.vue'], () => {\n    resolve(require('../components/Foo.vue'))\n  })\n};\nconst Bar = resolve => {\n  require.ensure(['../components/Bar.vue'], () => {\n    resolve(require('../components/Bar.vue'))\n  })\n};\nconst User = {\n  template: `<section>\n  <h3>{{$store.state.count}} is {{evenOrOdd}}</h3>\n  <div @click=\"increment\">User:{{ $route.params.name }}</div>\n  <router-view></router-view>\n</section>`,\n  computed: mapGetters([\n    'evenOrOdd'\n  ]),\n  methods: mapActions([\n    'increment'\n  ])\n}\nconst Profile = {\n  template: '<div @click=\"increment\">profiles,and num is {{$store.state.count}}</div>',\n  methods: mapActions([\n    'increment'\n  ])\n}\nconst UserPosts = {template: '<div @click=\"alertCount\">posts</div>',\n  methods:mapActions([\n    'alertCount'\n  ])\n}\nconst UserHome = {template: '<div>homePage</div>'}\n\n\nconst router = new vueRouter({\n  mode: 'hash',//history\n  routes:[\n    {path: '/foo', component: Foo},\n    {path: '/bar', component: Bar},\n    {\n      path: '/multi', components: {\n      default: Foo,\n      r2: Bar\n      }\n    },\n    {\n      path: '/user/:name', component: User, name: 'user',\n      children: [\n        {\n          path: '', component: UserHome,\n          beforeEnter: (to, from, next) => {\n            console.log('enter user homepage');\n            next()\n          }\n        },\n        {\n          path: 'profile', component: Profile,\n          beforeEnter: (to, from, next) => {\n            console.log('enter user profile');\n            next()\n          }\n        },\n        {path: 'posts', component: UserPosts},\n        {path: 'post',redirect: 'posts'}\n      ]\n    },\n  ],\n  linkActiveClass: 'current'\n});\nexport default router\n{% endcodeblock %}\n{% codeblock lang:\"javascript\" Vue实例 %}\nimport  Vue from 'vue'\nimport vueRouter from 'vue-router'\nimport Vuex from 'vuex'\n\nimport store from './vuex/store'\nimport router from './route/routers'\nVue.use(vueRouter);\nVue.use(Vuex);\n//异步懒加载\n\nconst app = new Vue({\n  router,\n  store,\n  mounted: function () {\n    console.log('mounted...')\n    console.log(this.$router)\n  },\n  watch: {\n    '$route' (to, from) {\n      // 对路由变化作出响应...\n      console.log('to', to)\n      console.log('from', from)\n    }\n  }\n}).$mount('#app');\nrouter.beforeEach((to, from, next) => {\n  console.log('before each')\n  next()\n});\nrouter.push('/user/sss/posts');\n\n{% endcodeblock %}","slug":"vue-router2的一些变化","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdx001kzk4ofc0vgw60","content":"<p><a href=\"http://router.vuejs.org/zh-cn/index.html\" target=\"_blank\" rel=\"external\">vue-router2详细文档</a><br>v-link由router-link替换，router-view 的name属性，可以匹配多个路由component<strong>(s)</strong><br><del>hashbang 弃用</del><br>router.map,router.start,router.redirect，saveScrollPosition等都变为router的实例属性<br>router.go()-&gt;router.push()<br><figure class=\"highlight html\"><figcaption><span>router</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display: flex;justify-content:space-around;</span></span></div><div class=\"line\">    align-items:center;flex-flow:row wrap;align-content:flex-start;\"&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/foo\"</span>&gt;</span>go to foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bar\"</span>&gt;</span>go to bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/dxf\"</span>&gt;</span>go to user:dxf<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/wxr/profile\"</span>&gt;</span>go to wxr profile<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/wxr/posts\"</span>&gt;</span>go to wxr posts<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/multi\"</span>&gt;</span>go to multi<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">name</span>=<span class=\"string\">\"default\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">name</span>=<span class=\"string\">\"r2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure><br><a id=\"more\"></a><br><figure class=\"highlight javascript\"><figcaption><span>router</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> vueRouter <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;mapState&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;mapGetters&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;mapActions&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Foo = <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// require.ensure 是 Webpack 的特殊语法，用来设置 code-split point</span></div><div class=\"line\">  <span class=\"comment\">// （代码分块）</span></div><div class=\"line\">  <span class=\"built_in\">require</span>.ensure([<span class=\"string\">'../components/Foo.vue'</span>], () =&gt; &#123;</div><div class=\"line\">    resolve(<span class=\"built_in\">require</span>(<span class=\"string\">'../components/Foo.vue'</span>))</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> Bar = <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">require</span>.ensure([<span class=\"string\">'../components/Bar.vue'</span>], () =&gt; &#123;</div><div class=\"line\">    resolve(<span class=\"built_in\">require</span>(<span class=\"string\">'../components/Bar.vue'</span>))</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> User = &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">`&lt;section&gt;</span></div><div class=\"line\">  &lt;h3&gt; is &lt;/h3&gt;</div><div class=\"line\">  &lt;div @click=\"increment\"&gt;User:&lt;/div&gt;</div><div class=\"line\">  &lt;router-view&gt;&lt;/router-view&gt;</div><div class=\"line\">&lt;/section&gt;`,</div><div class=\"line\">  <span class=\"attr\">computed</span>: mapGetters([</div><div class=\"line\">    <span class=\"string\">'evenOrOdd'</span></div><div class=\"line\">  ]),</div><div class=\"line\">  <span class=\"attr\">methods</span>: mapActions([</div><div class=\"line\">    <span class=\"string\">'increment'</span></div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> Profile = &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div @click=\"increment\"&gt;profiles,and num is &lt;/div&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">methods</span>: mapActions([</div><div class=\"line\">    <span class=\"string\">'increment'</span></div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> UserPosts = &#123;<span class=\"attr\">template</span>: <span class=\"string\">'&lt;div @click=\"alertCount\"&gt;posts&lt;/div&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">methods</span>:mapActions([</div><div class=\"line\">    <span class=\"string\">'alertCount'</span></div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> UserHome = &#123;<span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;homePage&lt;/div&gt;'</span>&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> vueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">'hash'</span>,<span class=\"comment\">//history</span></div><div class=\"line\">  routes:[</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">component</span>: Foo&#125;,</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/bar'</span>, <span class=\"attr\">component</span>: Bar&#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"attr\">path</span>: <span class=\"string\">'/multi'</span>, <span class=\"attr\">components</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">default</span>: Foo,</div><div class=\"line\">      <span class=\"attr\">r2</span>: Bar</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"attr\">path</span>: <span class=\"string\">'/user/:name'</span>, <span class=\"attr\">component</span>: User, <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>,</div><div class=\"line\">      <span class=\"attr\">children</span>: [</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">path</span>: <span class=\"string\">''</span>, <span class=\"attr\">component</span>: UserHome,</div><div class=\"line\">          <span class=\"attr\">beforeEnter</span>: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'enter user homepage'</span>);</div><div class=\"line\">            next()</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">path</span>: <span class=\"string\">'profile'</span>, <span class=\"attr\">component</span>: Profile,</div><div class=\"line\">          <span class=\"attr\">beforeEnter</span>: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'enter user profile'</span>);</div><div class=\"line\">            next()</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;<span class=\"attr\">path</span>: <span class=\"string\">'posts'</span>, <span class=\"attr\">component</span>: UserPosts&#125;,</div><div class=\"line\">        &#123;<span class=\"attr\">path</span>: <span class=\"string\">'post'</span>,<span class=\"attr\">redirect</span>: <span class=\"string\">'posts'</span>&#125;</div><div class=\"line\">      ]</div><div class=\"line\">    &#125;,</div><div class=\"line\">  ],</div><div class=\"line\">  <span class=\"attr\">linkActiveClass</span>: <span class=\"string\">'current'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> router</div></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><figcaption><span>Vue实例</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span>  Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> vueRouter <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./vuex/store'</span></div><div class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./route/routers'</span></div><div class=\"line\">Vue.use(vueRouter);</div><div class=\"line\">Vue.use(Vuex);</div><div class=\"line\"><span class=\"comment\">//异步懒加载</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  router,</div><div class=\"line\">  store,</div><div class=\"line\">  <span class=\"attr\">mounted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'mounted...'</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$router)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"string\">'$route'</span> (to, <span class=\"keyword\">from</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 对路由变化作出响应...</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'to'</span>, to)</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from'</span>, <span class=\"keyword\">from</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;).$mount(<span class=\"string\">'#app'</span>);</div><div class=\"line\">router.beforeEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before each'</span>)</div><div class=\"line\">  next()</div><div class=\"line\">&#125;);</div><div class=\"line\">router.push(<span class=\"string\">'/user/sss/posts'</span>);</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://router.vuejs.org/zh-cn/index.html\" target=\"_blank\" rel=\"external\">vue-router2详细文档</a><br>v-link由router-link替换，router-view 的name属性，可以匹配多个路由component<strong>(s)</strong><br><del>hashbang 弃用</del><br>router.map,router.start,router.redirect，saveScrollPosition等都变为router的实例属性<br>router.go()-&gt;router.push()<br><figure class=\"highlight html\"><figcaption><span>router</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display: flex;justify-content:space-around;</span></span></div><div class=\"line\">    align-items:center;flex-flow:row wrap;align-content:flex-start;\"&gt;</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/foo\"</span>&gt;</span>go to foo<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/bar\"</span>&gt;</span>go to bar<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/dxf\"</span>&gt;</span>go to user:dxf<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/wxr/profile\"</span>&gt;</span>go to wxr profile<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/user/wxr/posts\"</span>&gt;</span>go to wxr posts<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">to</span>=<span class=\"string\">\"/multi\"</span>&gt;</span>go to multi<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">transition</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fade\"</span> <span class=\"attr\">mode</span>=<span class=\"string\">\"out-in\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">name</span>=<span class=\"string\">\"default\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">router-view</span> <span class=\"attr\">name</span>=<span class=\"string\">\"r2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">router-view</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">keep-alive</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">transition</span>&gt;</span></div></pre></td></tr></table></figure><br>","more":"<br><figure class=\"highlight javascript\"><figcaption><span>router</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> vueRouter <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;mapState&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;mapGetters&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123;mapActions&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> Foo = <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"comment\">// require.ensure 是 Webpack 的特殊语法，用来设置 code-split point</span></div><div class=\"line\">  <span class=\"comment\">// （代码分块）</span></div><div class=\"line\">  <span class=\"built_in\">require</span>.ensure([<span class=\"string\">'../components/Foo.vue'</span>], () =&gt; &#123;</div><div class=\"line\">    resolve(<span class=\"built_in\">require</span>(<span class=\"string\">'../components/Foo.vue'</span>))</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> Bar = <span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">require</span>.ensure([<span class=\"string\">'../components/Bar.vue'</span>], () =&gt; &#123;</div><div class=\"line\">    resolve(<span class=\"built_in\">require</span>(<span class=\"string\">'../components/Bar.vue'</span>))</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> User = &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">`&lt;section&gt;</span></div><div class=\"line\">  &lt;h3&gt; is &lt;/h3&gt;</div><div class=\"line\">  &lt;div @click=\"increment\"&gt;User:&lt;/div&gt;</div><div class=\"line\">  &lt;router-view&gt;&lt;/router-view&gt;</div><div class=\"line\">&lt;/section&gt;`,</div><div class=\"line\">  <span class=\"attr\">computed</span>: mapGetters([</div><div class=\"line\">    <span class=\"string\">'evenOrOdd'</span></div><div class=\"line\">  ]),</div><div class=\"line\">  <span class=\"attr\">methods</span>: mapActions([</div><div class=\"line\">    <span class=\"string\">'increment'</span></div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> Profile = &#123;</div><div class=\"line\">  <span class=\"attr\">template</span>: <span class=\"string\">'&lt;div @click=\"increment\"&gt;profiles,and num is &lt;/div&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">methods</span>: mapActions([</div><div class=\"line\">    <span class=\"string\">'increment'</span></div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> UserPosts = &#123;<span class=\"attr\">template</span>: <span class=\"string\">'&lt;div @click=\"alertCount\"&gt;posts&lt;/div&gt;'</span>,</div><div class=\"line\">  <span class=\"attr\">methods</span>:mapActions([</div><div class=\"line\">    <span class=\"string\">'alertCount'</span></div><div class=\"line\">  ])</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> UserHome = &#123;<span class=\"attr\">template</span>: <span class=\"string\">'&lt;div&gt;homePage&lt;/div&gt;'</span>&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> vueRouter(&#123;</div><div class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">'hash'</span>,<span class=\"comment\">//history</span></div><div class=\"line\">  routes:[</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/foo'</span>, <span class=\"attr\">component</span>: Foo&#125;,</div><div class=\"line\">    &#123;<span class=\"attr\">path</span>: <span class=\"string\">'/bar'</span>, <span class=\"attr\">component</span>: Bar&#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"attr\">path</span>: <span class=\"string\">'/multi'</span>, <span class=\"attr\">components</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">default</span>: Foo,</div><div class=\"line\">      <span class=\"attr\">r2</span>: Bar</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"attr\">path</span>: <span class=\"string\">'/user/:name'</span>, <span class=\"attr\">component</span>: User, <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>,</div><div class=\"line\">      <span class=\"attr\">children</span>: [</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">path</span>: <span class=\"string\">''</span>, <span class=\"attr\">component</span>: UserHome,</div><div class=\"line\">          <span class=\"attr\">beforeEnter</span>: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'enter user homepage'</span>);</div><div class=\"line\">            next()</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">path</span>: <span class=\"string\">'profile'</span>, <span class=\"attr\">component</span>: Profile,</div><div class=\"line\">          <span class=\"attr\">beforeEnter</span>: <span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'enter user profile'</span>);</div><div class=\"line\">            next()</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        &#123;<span class=\"attr\">path</span>: <span class=\"string\">'posts'</span>, <span class=\"attr\">component</span>: UserPosts&#125;,</div><div class=\"line\">        &#123;<span class=\"attr\">path</span>: <span class=\"string\">'post'</span>,<span class=\"attr\">redirect</span>: <span class=\"string\">'posts'</span>&#125;</div><div class=\"line\">      ]</div><div class=\"line\">    &#125;,</div><div class=\"line\">  ],</div><div class=\"line\">  <span class=\"attr\">linkActiveClass</span>: <span class=\"string\">'current'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> router</div></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><figcaption><span>Vue实例</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span>  Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> vueRouter <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./vuex/store'</span></div><div class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">'./route/routers'</span></div><div class=\"line\">Vue.use(vueRouter);</div><div class=\"line\">Vue.use(Vuex);</div><div class=\"line\"><span class=\"comment\">//异步懒加载</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  router,</div><div class=\"line\">  store,</div><div class=\"line\">  <span class=\"attr\">mounted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'mounted...'</span>)</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.$router)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">watch</span>: &#123;</div><div class=\"line\">    <span class=\"string\">'$route'</span> (to, <span class=\"keyword\">from</span>) &#123;</div><div class=\"line\">      <span class=\"comment\">// 对路由变化作出响应...</span></div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'to'</span>, to)</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'from'</span>, <span class=\"keyword\">from</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;).$mount(<span class=\"string\">'#app'</span>);</div><div class=\"line\">router.beforeEach(<span class=\"function\">(<span class=\"params\">to, <span class=\"keyword\">from</span>, next</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'before each'</span>)</div><div class=\"line\">  next()</div><div class=\"line\">&#125;);</div><div class=\"line\">router.push(<span class=\"string\">'/user/sss/posts'</span>);</div><div class=\"line\"></div></pre></td></tr></table></figure></p>"},{"title":"ubuntu1604 git结合beyond compare","date":"2016-10-09T03:29:28.000Z","_content":"在[beyond compare官网](http://www.scootersoftware.com/download.php)下载Debian选项的安装包，然后\n``dpkg -i *.deb``安装依赖等。\n在~/.gitconfig文件中增加：\n```\n[diff]\n    tool = bc3\n[difftool]\n    prompt = false\n[merge]\n    tool = bc3\n[mergetool]\n    prompt = false\n```\n当执行git difftool的时候，就会启动bcompare比较","source":"_posts/ubuntu1604-git结合beyond-compare.md","raw":"---\ntitle: ubuntu1604 git结合beyond compare\ndate: 2016-10-09 11:29:28\ntags:\n  - ubuntu\n  - git\n---\n在[beyond compare官网](http://www.scootersoftware.com/download.php)下载Debian选项的安装包，然后\n``dpkg -i *.deb``安装依赖等。\n在~/.gitconfig文件中增加：\n```\n[diff]\n    tool = bc3\n[difftool]\n    prompt = false\n[merge]\n    tool = bc3\n[mergetool]\n    prompt = false\n```\n当执行git difftool的时候，就会启动bcompare比较","slug":"ubuntu1604-git结合beyond-compare","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfdy001mzk4oeq66wqkx","content":"<p>在<a href=\"http://www.scootersoftware.com/download.php\" target=\"_blank\" rel=\"external\">beyond compare官网</a>下载Debian选项的安装包，然后<br><code>dpkg -i *.deb</code>安装依赖等。<br>在~/.gitconfig文件中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[diff]</div><div class=\"line\">    tool = bc3</div><div class=\"line\">[difftool]</div><div class=\"line\">    prompt = false</div><div class=\"line\">[merge]</div><div class=\"line\">    tool = bc3</div><div class=\"line\">[mergetool]</div><div class=\"line\">    prompt = false</div></pre></td></tr></table></figure></p>\n<p>当执行git difftool的时候，就会启动bcompare比较</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"http://www.scootersoftware.com/download.php\" target=\"_blank\" rel=\"external\">beyond compare官网</a>下载Debian选项的安装包，然后<br><code>dpkg -i *.deb</code>安装依赖等。<br>在~/.gitconfig文件中增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[diff]</div><div class=\"line\">    tool = bc3</div><div class=\"line\">[difftool]</div><div class=\"line\">    prompt = false</div><div class=\"line\">[merge]</div><div class=\"line\">    tool = bc3</div><div class=\"line\">[mergetool]</div><div class=\"line\">    prompt = false</div></pre></td></tr></table></figure></p>\n<p>当执行git difftool的时候，就会启动bcompare比较</p>\n"},{"title":"vuex2 的一些变化","date":"2016-10-28T09:46:15.000Z","_content":"\n`` $store.state.count ``可以直接获取Store中的状态参数，但是getters可以返回对参数进行处理后的结果。\n``mutations``可以直接使用，但必须为同步方法。如果想使用异步方法，请使用``actions``，actions异步同步方法都可以。\n``import { mapGetters, mapActions,mapMutations } from 'vuex'``提供了使用方法的简便模式\n{%  codeblock lang:javascript Store %}\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\n// root state object.\n// each Vuex instance is just a single state tree.\nconst state = {\n  count: 0\n}\n\n// mutations are operations that actually mutates the state.\n// each mutation handler gets the entire state tree as the\n// first argument, followed by additional payload arguments.\n// mutations must be synchronous and can be recorded by plugins\n// for debugging purposes.必须为同步方法\nconst mutations = {\n  increment (state) {\n    state.count++\n  },\n  decrement (state,amount) {\n    state.count-= amount\n  }\n}\n\n// actions are functions that causes side effects and can involve\n// asynchronous operations. 可以加入异步方法\nconst actions = {\n  // increment: ({ commit }) => commit('increment'),\n  // decrement: ({ commit }) => commit('decrement'),\n  incrementIfOdd ({ commit, state }) {\n    if ((state.count + 1) % 2 === 0) {\n      commit('increment')\n    }\n  },\n  incrementAsync ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('increment')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n\n// getters are functions\nconst getters = {\n  evenOrOdd: state => state.count % 2 === 0 ? 'even' : 'odd'\n}\n\n// A Vuex instance is created by combining the state, mutations, actions,\n// and getters.\nexport default new Vuex.Store({\n  state,\n  getters,\n  actions,\n  mutations\n})\n{% endcodeblock %}\n<!--more-->\n{%  codeblock lang:html Vue组件 %}\n<template>\n  <div id=\"app\">\n    \\为转义字符，请忽略\n    Clicked: \\{\\{ $store.state.count \\}\\} times, count is \\{\\{ evenOrOdd \\}\\}.\n    <button @click=\"increment\">+</button>\n    <button @click=\"decrement(2)\">-</button>\n    <button @click=\"incrementIfOdd\">Increment if odd</button>\n    <button @click=\"incrementAsync\">Increment async</button>\n  </div>\n</template>\n\n<script>\nimport { mapGetters, mapActions,mapMutations } from 'vuex'\nexport default {\n  computed: mapGetters([\n    'evenOrOdd'\n  ]),\n  methods: {\n    ...mapMutations([\n      'increment',\n      'decrement',\n    ]),\n    ...mapActions([\n      'incrementIfOdd',\n      'incrementAsync'\n    ])\n  }\n}\n</script>\n\n{% endcodeblock %}\n{%  codeblock lang:javascript Vue实例 %}\nimport Vue from 'vue'\nimport Counter from './Counter.vue'\nimport store from './store'\n\nnew Vue({\n  el: '#app',\n  store,\n  render: h => h(Counter)\n});\n\n{% endcodeblock %}","source":"_posts/vuex2-的一些变化.md","raw":"---\ntitle: vuex2 的一些变化\ndate: 2016-10-28 17:46:15\ntags: Vue\n---\n\n`` $store.state.count ``可以直接获取Store中的状态参数，但是getters可以返回对参数进行处理后的结果。\n``mutations``可以直接使用，但必须为同步方法。如果想使用异步方法，请使用``actions``，actions异步同步方法都可以。\n``import { mapGetters, mapActions,mapMutations } from 'vuex'``提供了使用方法的简便模式\n{%  codeblock lang:javascript Store %}\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\n// root state object.\n// each Vuex instance is just a single state tree.\nconst state = {\n  count: 0\n}\n\n// mutations are operations that actually mutates the state.\n// each mutation handler gets the entire state tree as the\n// first argument, followed by additional payload arguments.\n// mutations must be synchronous and can be recorded by plugins\n// for debugging purposes.必须为同步方法\nconst mutations = {\n  increment (state) {\n    state.count++\n  },\n  decrement (state,amount) {\n    state.count-= amount\n  }\n}\n\n// actions are functions that causes side effects and can involve\n// asynchronous operations. 可以加入异步方法\nconst actions = {\n  // increment: ({ commit }) => commit('increment'),\n  // decrement: ({ commit }) => commit('decrement'),\n  incrementIfOdd ({ commit, state }) {\n    if ((state.count + 1) % 2 === 0) {\n      commit('increment')\n    }\n  },\n  incrementAsync ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('increment')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n\n// getters are functions\nconst getters = {\n  evenOrOdd: state => state.count % 2 === 0 ? 'even' : 'odd'\n}\n\n// A Vuex instance is created by combining the state, mutations, actions,\n// and getters.\nexport default new Vuex.Store({\n  state,\n  getters,\n  actions,\n  mutations\n})\n{% endcodeblock %}\n<!--more-->\n{%  codeblock lang:html Vue组件 %}\n<template>\n  <div id=\"app\">\n    \\为转义字符，请忽略\n    Clicked: \\{\\{ $store.state.count \\}\\} times, count is \\{\\{ evenOrOdd \\}\\}.\n    <button @click=\"increment\">+</button>\n    <button @click=\"decrement(2)\">-</button>\n    <button @click=\"incrementIfOdd\">Increment if odd</button>\n    <button @click=\"incrementAsync\">Increment async</button>\n  </div>\n</template>\n\n<script>\nimport { mapGetters, mapActions,mapMutations } from 'vuex'\nexport default {\n  computed: mapGetters([\n    'evenOrOdd'\n  ]),\n  methods: {\n    ...mapMutations([\n      'increment',\n      'decrement',\n    ]),\n    ...mapActions([\n      'incrementIfOdd',\n      'incrementAsync'\n    ])\n  }\n}\n</script>\n\n{% endcodeblock %}\n{%  codeblock lang:javascript Vue实例 %}\nimport Vue from 'vue'\nimport Counter from './Counter.vue'\nimport store from './store'\n\nnew Vue({\n  el: '#app',\n  store,\n  render: h => h(Counter)\n});\n\n{% endcodeblock %}","slug":"vuex2-的一些变化","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfe0001pzk4oglcp0v1a","content":"<p><code>$store.state.count</code>可以直接获取Store中的状态参数，但是getters可以返回对参数进行处理后的结果。<br><code>mutations</code>可以直接使用，但必须为同步方法。如果想使用异步方法，请使用<code>actions</code>，actions异步同步方法都可以。<br><code>import { mapGetters, mapActions,mapMutations } from &#39;vuex&#39;</code>提供了使用方法的简便模式<br><figure class=\"highlight javascript\"><figcaption><span>Store</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"></div><div class=\"line\">Vue.use(Vuex)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// root state object.</span></div><div class=\"line\"><span class=\"comment\">// each Vuex instance is just a single state tree.</span></div><div class=\"line\"><span class=\"keyword\">const</span> state = &#123;</div><div class=\"line\">  <span class=\"attr\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// mutations are operations that actually mutates the state.</span></div><div class=\"line\"><span class=\"comment\">// each mutation handler gets the entire state tree as the</span></div><div class=\"line\"><span class=\"comment\">// first argument, followed by additional payload arguments.</span></div><div class=\"line\"><span class=\"comment\">// mutations must be synchronous and can be recorded by plugins</span></div><div class=\"line\"><span class=\"comment\">// for debugging purposes.必须为同步方法</span></div><div class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;</div><div class=\"line\">  increment (state) &#123;</div><div class=\"line\">    state.count++</div><div class=\"line\">  &#125;,</div><div class=\"line\">  decrement (state,amount) &#123;</div><div class=\"line\">    state.count-= amount</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// actions are functions that causes side effects and can involve</span></div><div class=\"line\"><span class=\"comment\">// asynchronous operations. 可以加入异步方法</span></div><div class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</div><div class=\"line\">  <span class=\"comment\">// increment: (&#123; commit &#125;) =&gt; commit('increment'),</span></div><div class=\"line\">  <span class=\"comment\">// decrement: (&#123; commit &#125;) =&gt; commit('decrement'),</span></div><div class=\"line\">  incrementIfOdd (&#123; commit, state &#125;) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((state.count + <span class=\"number\">1</span>) % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      commit(<span class=\"string\">'increment'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        commit(<span class=\"string\">'increment'</span>)</div><div class=\"line\">        resolve()</div><div class=\"line\">      &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getters are functions</span></div><div class=\"line\"><span class=\"keyword\">const</span> getters = &#123;</div><div class=\"line\">  <span class=\"attr\">evenOrOdd</span>: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? <span class=\"string\">'even'</span> : <span class=\"string\">'odd'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// A Vuex instance is created by combining the state, mutations, actions,</span></div><div class=\"line\"><span class=\"comment\">// and getters.</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</div><div class=\"line\">  state,</div><div class=\"line\">  getters,</div><div class=\"line\">  actions,</div><div class=\"line\">  mutations</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><br><a id=\"more\"></a><br><figure class=\"highlight html\"><figcaption><span>Vue组件</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">    \\为转义字符，请忽略</div><div class=\"line\">    Clicked: \\&#123;\\&#123; $store.state.count \\&#125;\\&#125; times, count is \\&#123;\\&#123; evenOrOdd \\&#125;\\&#125;.</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"increment\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"decrement(2)\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"incrementIfOdd\"</span>&gt;</span>Increment if odd<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"incrementAsync\"</span>&gt;</span>Increment async<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters, mapActions,mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">  <span class=\"attr\">computed</span>: mapGetters([</div><div class=\"line\">    <span class=\"string\">'evenOrOdd'</span></div><div class=\"line\">  ]),</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    ...mapMutations([</div><div class=\"line\">      <span class=\"string\">'increment'</span>,</div><div class=\"line\">      <span class=\"string\">'decrement'</span>,</div><div class=\"line\">    ]),</div><div class=\"line\">    ...mapActions([</div><div class=\"line\">      <span class=\"string\">'incrementIfOdd'</span>,</div><div class=\"line\">      <span class=\"string\">'incrementAsync'</span></div><div class=\"line\">    ])</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><figcaption><span>Vue实例</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./Counter.vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  store,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(Counter)</div><div class=\"line\">&#125;);</div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><code>$store.state.count</code>可以直接获取Store中的状态参数，但是getters可以返回对参数进行处理后的结果。<br><code>mutations</code>可以直接使用，但必须为同步方法。如果想使用异步方法，请使用<code>actions</code>，actions异步同步方法都可以。<br><code>import { mapGetters, mapActions,mapMutations } from &#39;vuex&#39;</code>提供了使用方法的简便模式<br><figure class=\"highlight javascript\"><figcaption><span>Store</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"></div><div class=\"line\">Vue.use(Vuex)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// root state object.</span></div><div class=\"line\"><span class=\"comment\">// each Vuex instance is just a single state tree.</span></div><div class=\"line\"><span class=\"keyword\">const</span> state = &#123;</div><div class=\"line\">  <span class=\"attr\">count</span>: <span class=\"number\">0</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// mutations are operations that actually mutates the state.</span></div><div class=\"line\"><span class=\"comment\">// each mutation handler gets the entire state tree as the</span></div><div class=\"line\"><span class=\"comment\">// first argument, followed by additional payload arguments.</span></div><div class=\"line\"><span class=\"comment\">// mutations must be synchronous and can be recorded by plugins</span></div><div class=\"line\"><span class=\"comment\">// for debugging purposes.必须为同步方法</span></div><div class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;</div><div class=\"line\">  increment (state) &#123;</div><div class=\"line\">    state.count++</div><div class=\"line\">  &#125;,</div><div class=\"line\">  decrement (state,amount) &#123;</div><div class=\"line\">    state.count-= amount</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// actions are functions that causes side effects and can involve</span></div><div class=\"line\"><span class=\"comment\">// asynchronous operations. 可以加入异步方法</span></div><div class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</div><div class=\"line\">  <span class=\"comment\">// increment: (&#123; commit &#125;) =&gt; commit('increment'),</span></div><div class=\"line\">  <span class=\"comment\">// decrement: (&#123; commit &#125;) =&gt; commit('decrement'),</span></div><div class=\"line\">  incrementIfOdd (&#123; commit, state &#125;) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((state.count + <span class=\"number\">1</span>) % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      commit(<span class=\"string\">'increment'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</div><div class=\"line\">      setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        commit(<span class=\"string\">'increment'</span>)</div><div class=\"line\">        resolve()</div><div class=\"line\">      &#125;, <span class=\"number\">1000</span>)</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getters are functions</span></div><div class=\"line\"><span class=\"keyword\">const</span> getters = &#123;</div><div class=\"line\">  <span class=\"attr\">evenOrOdd</span>: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? <span class=\"string\">'even'</span> : <span class=\"string\">'odd'</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// A Vuex instance is created by combining the state, mutations, actions,</span></div><div class=\"line\"><span class=\"comment\">// and getters.</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">new</span> Vuex.Store(&#123;</div><div class=\"line\">  state,</div><div class=\"line\">  getters,</div><div class=\"line\">  actions,</div><div class=\"line\">  mutations</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure><br>","more":"<br><figure class=\"highlight html\"><figcaption><span>Vue组件</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\">    \\为转义字符，请忽略</div><div class=\"line\">    Clicked: \\&#123;\\&#123; $store.state.count \\&#125;\\&#125; times, count is \\&#123;\\&#123; evenOrOdd \\&#125;\\&#125;.</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"increment\"</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"decrement(2)\"</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"incrementIfOdd\"</span>&gt;</span>Increment if odd<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"incrementAsync\"</span>&gt;</span>Increment async<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters, mapActions,mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">  <span class=\"attr\">computed</span>: mapGetters([</div><div class=\"line\">    <span class=\"string\">'evenOrOdd'</span></div><div class=\"line\">  ]),</div><div class=\"line\">  <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">    ...mapMutations([</div><div class=\"line\">      <span class=\"string\">'increment'</span>,</div><div class=\"line\">      <span class=\"string\">'decrement'</span>,</div><div class=\"line\">    ]),</div><div class=\"line\">    ...mapActions([</div><div class=\"line\">      <span class=\"string\">'incrementIfOdd'</span>,</div><div class=\"line\">      <span class=\"string\">'incrementAsync'</span></div><div class=\"line\">    ])</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div></pre></td></tr></table></figure><br><figure class=\"highlight javascript\"><figcaption><span>Vue实例</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'./Counter.vue'</span></div><div class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</div><div class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">'#app'</span>,</div><div class=\"line\">  store,</div><div class=\"line\">  <span class=\"attr\">render</span>: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span> h(Counter)</div><div class=\"line\">&#125;);</div><div class=\"line\"></div></pre></td></tr></table></figure></p>"},{"title":"你可能并不需要jQuery","date":"2016-10-11T02:54:55.000Z","_content":"> jQuery是非常优秀的工具，它能让我们开发项目时变得更容易，但如果你想从零开始开发一个全新的项目，你应该考虑一下你的项目是否真的需要引入jQuery。\n- 也许你只需要几行技巧性的代码就能解决问题。如果你的项目是面向最新的现代浏览器，你真的可以考虑其它的一些简单的技术来代替jQuery。\n- 浏览器的进步给我们带来了很多先进的JavaScript特征，新出现的原生内置(native)JavaScript功能可以很大程度的实现jQuery提供的功能。如果你能了解这些JavaScript新技术，就能在很多地方用纯JavaScript实现以前需要jQuery才能实现的技术。\n- 新的mvvm框架的出现，数据驱动的方式解决了项目数据交互量大的时候，操作dom的代码混乱的问题。\n## 元素操作\n#### addClass\njQuery\n``$(el).addClass(className);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.classList)\n  el.classList.add(className);\nelse\n  el.className += ' ' + className;\n```\n谷歌浏览器，火狐浏览器，IE10+\n``el.classList.add(className);``\n#### After\njQuery\n``$(el).after(htmlString);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.insertAdjacentHTML('afterend', htmlString);``\n#### Append\njQuery\n``$(parent).append(el);``\n谷歌浏览器，火狐浏览器，IE8+\n``parent.appendChild(el);``\n#### Before\njQuery\n``$(el).before(htmlString);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.insertAdjacentHTML('beforebegin', htmlString);``\n#### Children\njQuery\n``$(el).children();``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar children = [];\nfor (var i = el.children.length; i--;) {\n  // Skip comment nodes on IE8\n  if (el.children[i].nodeType != 8)\n    children.unshift(el.children[i]);\n}```\n谷歌浏览器，火狐浏览器，IE9+\n``el.children``\n<!--more-->\n#### Clone\njQuery\n`$(el).clone();`\n谷歌浏览器，火狐浏览器，IE8+\n`el.cloneNode(true);``\n#### Contains\njQuery\n``$.contains(el, child);``\n谷歌浏览器，火狐浏览器，IE8+\n``el !== child && el.contains(child);``\n#### Contains Selector\njQuery\n``$(el).find(selector).length;``\n谷歌浏览器，火狐浏览器，IE8+\n``el.querySelector(selector) !== null``\n#### Each\njQuery\n``$(selector).each(function(i, el){});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction forEachElement(selector, fn) {\n  var elements = document.querySelectorAll(selector);\n  for (var i = 0; i < elements.length; i++)\n    fn(elements[i], i);\n}\nforEachElement(selector, function(el, i){});```\n谷歌浏览器，火狐浏览器，IE9+\n```\nvar elements = document.querySelectorAll(selector);\nArray.prototype.forEach.call(elements, function(el, i){});```\n#### Empty\njQuery\n``$(el).empty();``\n谷歌浏览器，火狐浏览器，IE8+\n```\nwhile(el.firstChild)\n  el.removeChild(el.firstChild);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.innerHTML = '';``\n#### 过滤\njQuery\n``$(selector).filter(filterFn);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction filter(selector, filterFn) {\n  var elements = document.querySelectorAll(selector);\n  var out = [];\n  for (var i = elements.length; i--;) {\n    if (filterFn(elements[i])){\n      out.unshift(elements[i]);\n      }\n    }\n  }\n  return out;\n}\nfilter(selector, filterFn);```\n谷歌浏览器，火狐浏览器，IE9+\n``Array.prototype.filter.call(document.querySelectorAll(selector), filterFn);``\n#### 查找子元素\njQuery\n``$(el).find(selector);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.querySelectorAll(selector);``\n#### 查找\njQuery\n``$('.my #awesome selector');``\n谷歌浏览器，火狐浏览器，IE8+\n``document.querySelectorAll('.my #awesome selector');``\n#### 获取属性值\njQuery\n``$(el).attr('tabindex');``\n谷歌浏览器，火狐浏览器，IE8+\n``el.getAttribute('tabindex');``\n#### 获取Html内容\njQuery\n``$(el).html();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.innerHTML``\n#### 获取外层Html内容\njQuery\n``$('<div>').append($(el).clone()).html();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.outerHTML``\n#### 获取CSS样式\njQuery\n``$(el).css(ruleName);``\n谷歌浏览器，火狐浏览器，IE8+\n// Varies based on the properties being retrieved, some can be retrieved from\n\nel.currentStyle\n// https://github.com/jonathantneal/Polyfills-for-IE8/blob/master/\n\ngetComputedStyle.js\n谷歌浏览器，火狐浏览器，IE9+\n``getComputedStyle(el)[ruleName];``\n#### 获取文本内容\njQuery\n``$(el).text();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.textContent || el.innerText``\n谷歌浏览器，火狐浏览器，IE9+\n``el.textContent``\n#### Has Class\njQuery\n``$(el).hasClass(className);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.classList){\n  el.classList.contains(className);\n}\nelse{\n  new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);\n}```\n谷歌浏览器，火狐浏览器，IE10+\n``el.classList.contains(className);``\n#### 元素比较\njQuery\n``$(el).is($(otherEl));``\n谷歌浏览器，火狐浏览器，IE8+\n``el === otherEl``\n#### 比较类名\njQuery\n``$(el).is('.my-class');``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar matches = function(el, selector) {\n  var _matches = (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector);\n  if (_matches) {\n    return _matches.call(el, selector);\n  } else {\n    var nodes = el.parentNode.querySelectorAll(selector);\n    for (var i = nodes.length; i--;) {\n      if (nodes[i] === el)\n        return true;\n    }\n    return false;\n  }\n};\nmatches(el, '.my-class');```\n谷歌浏览器，火狐浏览器，IE9+\n```\nvar matches = function(el, selector) {\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\n};\nmatches(el, '.my-class');```\n#### Next\njQuery\n``$(el).next();``\n谷歌浏览器，火狐浏览器，IE8+\n// nextSibling can include text nodes\n```\nfunction nextElementSibling(el) {\n  do { el = el.nextSibling; } while ( el && el.nodeType !== 1 );\n  return el;\n}\nel.nextElementSibling || nextElementSibling(el);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.nextElementSibling``\n#### Offset\njQuery\n``$(el).offset();``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar rect = el.getBoundingClientRect()\n{\n  top: rect.top + document.body.scrollTop,\n  left: rect.left + document.body.scrollLeft\n}```\n#### Offset Parent\njQuery\n``$(el).offsetParent();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.offsetParent || el``\n#### Outer Height\njQuery\n``$(el).outerHeight();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.offsetHeight``\n#### Outer Height With Margin\njQuery\n``$(el).outerHeight(true);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction outerHeight(el) {\n  var height = el.offsetHeight;\n  var style = el.currentStyle || getComputedStyle(el);\n\n  height += parseInt(style.marginTop) + parseInt(style.marginBottom);\n  return height;\n}\nouterHeight(el);```\n谷歌浏览器，火狐浏览器，IE9+\n```\nfunction outerHeight(el) {\n  var height = el.offsetHeight;\n  var style = getComputedStyle(el);\n\n  height += parseInt(style.marginTop) + parseInt(style.marginBottom);\n  return height;\n}\nouterHeight(el);```\n#### Outer Width With Margin\njQuery\n``$(el).outerWidth(true);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction outerWidth(el) {\n  var width = el.offsetWidth;\n  var style = el.currentStyle || getComputedStyle(el);\n\n  width += parseInt(style.marginLeft) + parseInt(style.marginRight);\n  return width;\n}\nouterWidth(el);```\n谷歌浏览器，火狐浏览器，IE9+\n```\nfunction outerWidth(el) {\n  var width = el.offsetWidth;\n  var style = getComputedStyle(el);\n\n  width += parseInt(style.marginLeft) + parseInt(style.marginRight);\n  return width;\n}\nouterWidth(el);```\n#### Outer Width\njQuery\n``$(el).outerWidth();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.offsetWidth``\n#### Parent\njQuery\n``$(el).parent();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.parentNode``\n#### Position\njQuery\n``$(el).position();``\n谷歌浏览器，火狐浏览器，IE8+\n``{left: el.offsetLeft, top: el.offsetTop}``\n#### Position Relative To Viewport\njQuery\n```\nvar offset = el.offset();\n{\n  top: offset.top - document.body.scrollTop,\n  left: offset.left - document.body.scrollLeft\n}```\n谷歌浏览器，火狐浏览器，IE8+\n``el.getBoundingClientRect()``\n#### Prepend\njQuery\n``$(parent).prepend(el);``\n谷歌浏览器，火狐浏览器，IE8+\n``parent.insertBefore(el, parent.firstChild);``\n#### Prev\njQuery\n``$(el).prev();``\n谷歌浏览器，火狐浏览器，IE8+\n// prevSibling can include text nodes\n```\nfunction previousElementSibling(el) {\n  do { el = el.previousSibling; } while ( el && el.nodeType !== 1 );\n  return el;\n}\nel.previousElementSibling || previousElementSibling(el);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.previousElementSibling``\n#### Remove\njQuery\n``$(el).remove();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.parentNode.removeChild(el);``\n#### Remove Class\njQuery\n``$(el).removeClass(className);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.classList)\n  el.classList.remove(className);\nelse\n  el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');```\n谷歌浏览器，火狐浏览器，IE10+\n``el.classList.remove(className);``\n#### Replace From Html\njQuery\n``$(el).replaceWith(string);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.outerHTML = string;``\n#### Set Attributes\njQuery\n``$(el).attr('tabindex', 3);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.setAttribute('tabindex', 3);``\n#### Set Html\njQuery\n``$(el).html(string);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.innerHTML = string;``\n#### Set Style\njQuery\n``$(el).css('border-width', '20px');``\n谷歌浏览器，火狐浏览器，IE8+\n// Use a class if possible\n``el.style.borderWidth = '20px';``\n#### Set Text\njQuery\n``$(el).text(string);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.textContent !== undefined)\n  el.textContent = string;\nelse\n  el.innerText = string;```\n谷歌浏览器，火狐浏览器，IE9+\n``el.textContent = string;``\n#### Siblings\njQuery\n``$(el).siblings();``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar siblings = Array.prototype.slice.call(el.parentNode.children);\nfor (var i = siblings.length; i--;) {\n  if (siblings[i] === el) {\n    siblings.splice(i, 1);\n    break;\n  }\n}```\n谷歌浏览器，火狐浏览器，IE9+\n``Array.prototype.filter.call(el.parentNode.children, function(child){\n  return child !== el;\n});``\n#### Toggle Class\njQuery\n``$(el).toggleClass(className);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.classList) {\n  el.classList.toggle(className);\n} else {\n    var classes = el.className.split(' ');\n    var existingIndex = -1;\n    for (var i = classes.length; i--;) {\n      if (classes[i] === className)\n        existingIndex = i;\n    }\n    if (existingIndex >= 0)\n      classes.splice(existingIndex, 1);\n    else\n      classes.push(className);\n  el.className = classes.join(' ');\n}```\n谷歌浏览器，火狐浏览器，IE9+\n```\nif (el.classList) {\n  el.classList.toggle(className);\n} else {\n  var classes = el.className.split(' ');\n  var existingIndex = classes.indexOf(className);\n  if (existingIndex >= 0)\n    classes.splice(existingIndex, 1);\n  else\n    classes.push(className);\n  el.className = classes.join(' ');\n}```\n谷歌浏览器，火狐浏览器，IE10+\n``el.classList.toggle(className);``\n## 事件\n#### #### Off\njQuery\n``$(el).off(eventName, eventHandler);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction removeEventListener(el, eventName, handler) {\n  if (el.removeEventListener)\n    el.removeEventListener(eventName, handler);\n  else\n    el.detachEvent('on' + eventName, handler);\n}\nremoveEventListener(el, eventName, handler);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.removeEventListener(eventName, eventHandler);``\n#### On\njQuery\n``$(el).on(eventName, eventHandler);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction addEventListener(el, eventName, handler) {\n  if (el.addEventListener) {\n    el.addEventListener(eventName, handler);\n  } else {\n    el.attachEvent('on' + eventName, function(){\n      handler.call(el);\n    });\n  }\n}\naddEventListener(el, eventName, handler);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.addEventListener(eventName, eventHandler);``\n#### Ready\njQuery\n``$(document).ready(function(){});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction ready(fn) {\n  if (document.readyState != 'loading'){\n    fn();\n  } else if (document.addEventListener) {\n    document.addEventListener('DOMContentLoaded', fn);\n  } else {\n    document.attachEvent('onreadystatechange', function() {\n      if (document.readyState != 'loading')\n        fn();\n    });\n  }\n}```\n谷歌浏览器，火狐浏览器，IE9+\n```\nfunction ready(fn) {\n  if (document.readyState != 'loading'){\n    fn();\n  } else {\n    document.addEventListener('DOMContentLoaded', fn);\n  }\n}```\n#### 指定事件触发\njQuery\n``$(el).trigger('my-event', {some: 'data'});``\n谷歌浏览器，火狐浏览器，IE8+\n// Custom events are not natively supported, so you have to hijack a rndomevent.\n// Just use jQuery.\n谷歌浏览器，火狐浏览器，IE9+\n```\nif (window.CustomEvent) {\n  var event = new CustomEvent('my-event', {detail: {some: 'data'}});\n} else {\n  var event = document.createEvent('CustomEvent');\n  event.initCustomEvent('my-event', true, true, {some: 'data'});\n}\nel.dispatchEvent(event);```\n#### Trigger Native\njQuery\n``$(el).trigger('change');``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (document.createEvent) {\n  var event = document.createEvent('HTMLEvents');\n  event.initEvent('change', true, false);\n  el.dispatchEvent(event);\n} else {\n  el.fireEvent('onchange');\n}```\n谷歌浏览器，火狐浏览器，IE9+\n// For a full list of event types: https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent\n```\nvar event = document.createEvent('HTMLEvents');\nevent.initEvent('change', true, false);\nel.dispatchEvent(event);```\n## 技巧\n#### Array Each\njQuery\n``$.each(array, function(i, item){});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction forEach(array, fn) {\n  for (i = 0; i < array.length; i++)\n    fn(array[i], i);\n}\nforEach(array, function(item, i){});```\n谷歌浏览器，火狐浏览器，IE9+\n``array.forEach(function(item, i){});``\n#### 深度扩展\njQuery\n``$.extend(true, {}, objA, objB);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar deepExtend = function(out) {\n  out = out || {};\n  for (var i = 1; i < arguments.length; i++) {\n    var obj = arguments[i];\n    if (!obj)\n      continue;\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (typeof obj[key] === 'object')\n          deepExtend(out[key], obj[key]);\n        else\n          out[key] = obj[key];\n      }\n    }\n  }\n  return out;\n};\ndeepExtend({}, objA, objB);```\n#### Bind\njQuery\n``$.proxy(fn, context);``\n谷歌浏览器，火狐浏览器，IE8+\n``fn.apply(context, arguments);``\n谷歌浏览器，火狐浏览器，IE9+\n``fn.bind(context);``\njQuery\n``$.extend({}, objA, objB);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar extend = function(out) {\n  out = out || {};\n  for (var i = 1; i < arguments.length; i++) {\n    if (!arguments[i])\n      continue;\n    for (var key in arguments[i]) {\n      if (arguments[i].hasOwnProperty(key))\n        out[key] = arguments[i][key];\n    }\n  }\n  return out;\n};\nextend({}, objA, objB);```\n#### Index Of\njQuery\n``$.inArray(item, array);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction indexOf(array, item) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === item)\n      return i;\n  }\n  return -1;\n}\nindexOf(array, item);```\n谷歌浏览器，火狐浏览器，IE9+\n``array.indexOf(item);``\n#### Is Array\njQuery\n``$.isArray(arr);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nisArray = Array.isArray || function(arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n}\nisArray(arr);```\n谷歌浏览器，火狐浏览器，IE9+\n``Array.isArray(arr);``\n#### Map\njQuery\n``$.map(array, function(value, index){});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction map(arr, fn) {\n  var results = [];\n  for (var i = 0; i < arr.length; i++)\n    results.push(fn(arr[i], i));\n  return results;\nmap(array, function(value, index){});```\n谷歌浏览器，火狐浏览器，IE9+\n``array.map(function(value, index){});``\n#### Now\njQuery\n``$.now();``\n谷歌浏览器，火狐浏览器，IE8+\n``new Date().getTime();``\n谷歌浏览器，火狐浏览器，IE9+\n``Date.now();``\n#### Parse Html\njQuery\n``$.parseHTML(htmlString);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar parseHTML = function(str) {\n  var el = document.createElement('div');\n  el.innerHTML = str;\n  return el.children;\n};\nparseHTML(htmlString);```\n谷歌浏览器，火狐浏览器，IE9+\n``var parseHTML = function(str) {\n  var tmp = document.implementation.createHTMLDocument();\n  tmp.body.innerHTML = str;\n  return tmp.body.children;\n};\nparseHTML(htmlString);``\n#### 解析 Json\njQuery\n``$.parseJSON(string);``\n谷歌浏览器，火狐浏览器，IE8+\n``JSON.parse(string);``\n#### Trim\njQuery\n``$.trim(string);``\n谷歌浏览器，火狐浏览器，IE8+\n``string.replace(/^\\s+|\\s+$/g, '');``\n谷歌浏览器，火狐浏览器，IE9+\n``string.trim();``\n#### Type\njQuery\n``$.type(obj);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nObject.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, \"$1\").toLowerCase();```\n## AJAX\n#### JSON\njQuery\n``$.getJSON('/my/url', function(data) {});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onreadystatechange = function() {\n  if (this.readyState === 4) {\n    if (this.status >= 200 && this.status < 400) {\n      // Success!\n      var data = JSON.parse(this.responseText);\n    } else {\n      // Error :(\n    }\n  }\n};\nrequest.send();\nrequest = null;```\n谷歌浏览器，火狐浏览器，IE9+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onload = function() {\n  if (request.status >= 200 && request.status < 400) {\n    // Success!\n    var data = JSON.parse(request.responseText);\n  } else {\n    // We reached our target server, but it returned an error\n  }\n};\nrequest.onerror = function() {\n  // There was a connection error of some sort\n};\nrequest.send();```\n谷歌浏览器，火狐浏览器，IE10+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onload = function() {\n  if (this.status >= 200 && this.status < 400) {\n    // Success!\n    var data = JSON.parse(this.response);\n  } else {\n    // We reached our target server, but it returned an error\n  }\n};\nrequest.onerror = function() {\n  // There was a connection error of some sort\n};\nrequest.send();```\n#### Post\njQuery\n``$.ajax({type: 'POST',url: '/my/url',data: data});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar request = new XMLHttpRequest();\nrequest.open('POST', '/my/url', true);\nrequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\nrequest.send(data);```\n#### Request\njQuery\n``$.ajax({type: 'GET',url: '/my/url',success: function(resp) {},error: function() {}});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onreadystatechange = function() {\n  if (this.readyState === 4) {\n    if (this.status >= 200 && this.status < 400) {\n      // Success!\n      var resp = this.responseText;\n    } else {\n      // Error :(\n    }\n  }\n};\nrequest.send();\nrequest = null;```\n谷歌浏览器，火狐浏览器，IE9+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onload = function() {\n  if (request.status >= 200 && request.status < 400) {\n    // Success!\n    var resp = request.responseText;\n  } else {\n    // We reached our target server, but it returned an error\n  }\n};\nrequest.onerror = function() {\n  // There was a connection error of some sort\n};\nrequest.send();```\n谷歌浏览器，火狐浏览器，IE10+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onload = function() {\n  if (this.status >= 200 && this.status < 400) {\n    // Success!\n    var resp = this.response;\n  } else {\n    // We reached our target server, but it returned an error\n  }\n};\nrequest.onerror = function() {\n  // There was a connection error of some sort\n};\nrequest.send();\n```\n## 特效\n#### 淡入淡出\njQuery\n``$(el).fadeIn();``\n谷歌浏览器，火狐浏览器，IE8+\n``` \nfunction fadeIn(el) {\n  var opacity = 0;\n  el.style.opacity = 0;\n  el.style.filter = '';\n  var last = +new Date();\n  var tick = function() {\n    opacity += (new Date() - last) / 400;\n    el.style.opacity = opacity;\n    el.style.filter = 'alpha(opacity=' + (100 * opacity)|0 + ')';\n    last = +new Date();\n    if (opacity < 1) {\n      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);\n    }\n  };\n  tick();\n}\nfadeIn(el);\n```\n谷歌浏览器，火狐浏览器，IE9+\n```function fadeIn(el) {\n  el.style.opacity = 0;\n  var last = +new Date();\n  var tick = function() {\n    el.style.opacity = +el.style.opacity + (new Date() - last) / 400;\n    last = +new Date();\n    if (+el.style.opacity < 1) {\n      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16)\n    }\n  };\n  tick();\n}\nfadeIn(el);\n```\n谷歌浏览器，火狐浏览器，IE10+\n```\nel.classList.add('show');\nel.classList.remove('hide');\n.show {transition: opacity 400ms;}\n.hide {opacity: 0;}```\n#### Hide\njQuery\n``$(el).hide();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.style.display = 'none';``\n#### Show\njQuery\n``$(el).show();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.style.display = '';``","source":"_posts/你可能并不需要jQuery.md","raw":"---\ntitle: 你可能并不需要jQuery\ndate: 2016-10-11 10:54:55\ntags: \n  - javascript\n  - jQuery\n---\n> jQuery是非常优秀的工具，它能让我们开发项目时变得更容易，但如果你想从零开始开发一个全新的项目，你应该考虑一下你的项目是否真的需要引入jQuery。\n- 也许你只需要几行技巧性的代码就能解决问题。如果你的项目是面向最新的现代浏览器，你真的可以考虑其它的一些简单的技术来代替jQuery。\n- 浏览器的进步给我们带来了很多先进的JavaScript特征，新出现的原生内置(native)JavaScript功能可以很大程度的实现jQuery提供的功能。如果你能了解这些JavaScript新技术，就能在很多地方用纯JavaScript实现以前需要jQuery才能实现的技术。\n- 新的mvvm框架的出现，数据驱动的方式解决了项目数据交互量大的时候，操作dom的代码混乱的问题。\n## 元素操作\n#### addClass\njQuery\n``$(el).addClass(className);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.classList)\n  el.classList.add(className);\nelse\n  el.className += ' ' + className;\n```\n谷歌浏览器，火狐浏览器，IE10+\n``el.classList.add(className);``\n#### After\njQuery\n``$(el).after(htmlString);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.insertAdjacentHTML('afterend', htmlString);``\n#### Append\njQuery\n``$(parent).append(el);``\n谷歌浏览器，火狐浏览器，IE8+\n``parent.appendChild(el);``\n#### Before\njQuery\n``$(el).before(htmlString);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.insertAdjacentHTML('beforebegin', htmlString);``\n#### Children\njQuery\n``$(el).children();``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar children = [];\nfor (var i = el.children.length; i--;) {\n  // Skip comment nodes on IE8\n  if (el.children[i].nodeType != 8)\n    children.unshift(el.children[i]);\n}```\n谷歌浏览器，火狐浏览器，IE9+\n``el.children``\n<!--more-->\n#### Clone\njQuery\n`$(el).clone();`\n谷歌浏览器，火狐浏览器，IE8+\n`el.cloneNode(true);``\n#### Contains\njQuery\n``$.contains(el, child);``\n谷歌浏览器，火狐浏览器，IE8+\n``el !== child && el.contains(child);``\n#### Contains Selector\njQuery\n``$(el).find(selector).length;``\n谷歌浏览器，火狐浏览器，IE8+\n``el.querySelector(selector) !== null``\n#### Each\njQuery\n``$(selector).each(function(i, el){});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction forEachElement(selector, fn) {\n  var elements = document.querySelectorAll(selector);\n  for (var i = 0; i < elements.length; i++)\n    fn(elements[i], i);\n}\nforEachElement(selector, function(el, i){});```\n谷歌浏览器，火狐浏览器，IE9+\n```\nvar elements = document.querySelectorAll(selector);\nArray.prototype.forEach.call(elements, function(el, i){});```\n#### Empty\njQuery\n``$(el).empty();``\n谷歌浏览器，火狐浏览器，IE8+\n```\nwhile(el.firstChild)\n  el.removeChild(el.firstChild);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.innerHTML = '';``\n#### 过滤\njQuery\n``$(selector).filter(filterFn);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction filter(selector, filterFn) {\n  var elements = document.querySelectorAll(selector);\n  var out = [];\n  for (var i = elements.length; i--;) {\n    if (filterFn(elements[i])){\n      out.unshift(elements[i]);\n      }\n    }\n  }\n  return out;\n}\nfilter(selector, filterFn);```\n谷歌浏览器，火狐浏览器，IE9+\n``Array.prototype.filter.call(document.querySelectorAll(selector), filterFn);``\n#### 查找子元素\njQuery\n``$(el).find(selector);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.querySelectorAll(selector);``\n#### 查找\njQuery\n``$('.my #awesome selector');``\n谷歌浏览器，火狐浏览器，IE8+\n``document.querySelectorAll('.my #awesome selector');``\n#### 获取属性值\njQuery\n``$(el).attr('tabindex');``\n谷歌浏览器，火狐浏览器，IE8+\n``el.getAttribute('tabindex');``\n#### 获取Html内容\njQuery\n``$(el).html();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.innerHTML``\n#### 获取外层Html内容\njQuery\n``$('<div>').append($(el).clone()).html();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.outerHTML``\n#### 获取CSS样式\njQuery\n``$(el).css(ruleName);``\n谷歌浏览器，火狐浏览器，IE8+\n// Varies based on the properties being retrieved, some can be retrieved from\n\nel.currentStyle\n// https://github.com/jonathantneal/Polyfills-for-IE8/blob/master/\n\ngetComputedStyle.js\n谷歌浏览器，火狐浏览器，IE9+\n``getComputedStyle(el)[ruleName];``\n#### 获取文本内容\njQuery\n``$(el).text();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.textContent || el.innerText``\n谷歌浏览器，火狐浏览器，IE9+\n``el.textContent``\n#### Has Class\njQuery\n``$(el).hasClass(className);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.classList){\n  el.classList.contains(className);\n}\nelse{\n  new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);\n}```\n谷歌浏览器，火狐浏览器，IE10+\n``el.classList.contains(className);``\n#### 元素比较\njQuery\n``$(el).is($(otherEl));``\n谷歌浏览器，火狐浏览器，IE8+\n``el === otherEl``\n#### 比较类名\njQuery\n``$(el).is('.my-class');``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar matches = function(el, selector) {\n  var _matches = (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector);\n  if (_matches) {\n    return _matches.call(el, selector);\n  } else {\n    var nodes = el.parentNode.querySelectorAll(selector);\n    for (var i = nodes.length; i--;) {\n      if (nodes[i] === el)\n        return true;\n    }\n    return false;\n  }\n};\nmatches(el, '.my-class');```\n谷歌浏览器，火狐浏览器，IE9+\n```\nvar matches = function(el, selector) {\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\n};\nmatches(el, '.my-class');```\n#### Next\njQuery\n``$(el).next();``\n谷歌浏览器，火狐浏览器，IE8+\n// nextSibling can include text nodes\n```\nfunction nextElementSibling(el) {\n  do { el = el.nextSibling; } while ( el && el.nodeType !== 1 );\n  return el;\n}\nel.nextElementSibling || nextElementSibling(el);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.nextElementSibling``\n#### Offset\njQuery\n``$(el).offset();``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar rect = el.getBoundingClientRect()\n{\n  top: rect.top + document.body.scrollTop,\n  left: rect.left + document.body.scrollLeft\n}```\n#### Offset Parent\njQuery\n``$(el).offsetParent();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.offsetParent || el``\n#### Outer Height\njQuery\n``$(el).outerHeight();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.offsetHeight``\n#### Outer Height With Margin\njQuery\n``$(el).outerHeight(true);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction outerHeight(el) {\n  var height = el.offsetHeight;\n  var style = el.currentStyle || getComputedStyle(el);\n\n  height += parseInt(style.marginTop) + parseInt(style.marginBottom);\n  return height;\n}\nouterHeight(el);```\n谷歌浏览器，火狐浏览器，IE9+\n```\nfunction outerHeight(el) {\n  var height = el.offsetHeight;\n  var style = getComputedStyle(el);\n\n  height += parseInt(style.marginTop) + parseInt(style.marginBottom);\n  return height;\n}\nouterHeight(el);```\n#### Outer Width With Margin\njQuery\n``$(el).outerWidth(true);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction outerWidth(el) {\n  var width = el.offsetWidth;\n  var style = el.currentStyle || getComputedStyle(el);\n\n  width += parseInt(style.marginLeft) + parseInt(style.marginRight);\n  return width;\n}\nouterWidth(el);```\n谷歌浏览器，火狐浏览器，IE9+\n```\nfunction outerWidth(el) {\n  var width = el.offsetWidth;\n  var style = getComputedStyle(el);\n\n  width += parseInt(style.marginLeft) + parseInt(style.marginRight);\n  return width;\n}\nouterWidth(el);```\n#### Outer Width\njQuery\n``$(el).outerWidth();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.offsetWidth``\n#### Parent\njQuery\n``$(el).parent();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.parentNode``\n#### Position\njQuery\n``$(el).position();``\n谷歌浏览器，火狐浏览器，IE8+\n``{left: el.offsetLeft, top: el.offsetTop}``\n#### Position Relative To Viewport\njQuery\n```\nvar offset = el.offset();\n{\n  top: offset.top - document.body.scrollTop,\n  left: offset.left - document.body.scrollLeft\n}```\n谷歌浏览器，火狐浏览器，IE8+\n``el.getBoundingClientRect()``\n#### Prepend\njQuery\n``$(parent).prepend(el);``\n谷歌浏览器，火狐浏览器，IE8+\n``parent.insertBefore(el, parent.firstChild);``\n#### Prev\njQuery\n``$(el).prev();``\n谷歌浏览器，火狐浏览器，IE8+\n// prevSibling can include text nodes\n```\nfunction previousElementSibling(el) {\n  do { el = el.previousSibling; } while ( el && el.nodeType !== 1 );\n  return el;\n}\nel.previousElementSibling || previousElementSibling(el);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.previousElementSibling``\n#### Remove\njQuery\n``$(el).remove();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.parentNode.removeChild(el);``\n#### Remove Class\njQuery\n``$(el).removeClass(className);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.classList)\n  el.classList.remove(className);\nelse\n  el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');```\n谷歌浏览器，火狐浏览器，IE10+\n``el.classList.remove(className);``\n#### Replace From Html\njQuery\n``$(el).replaceWith(string);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.outerHTML = string;``\n#### Set Attributes\njQuery\n``$(el).attr('tabindex', 3);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.setAttribute('tabindex', 3);``\n#### Set Html\njQuery\n``$(el).html(string);``\n谷歌浏览器，火狐浏览器，IE8+\n``el.innerHTML = string;``\n#### Set Style\njQuery\n``$(el).css('border-width', '20px');``\n谷歌浏览器，火狐浏览器，IE8+\n// Use a class if possible\n``el.style.borderWidth = '20px';``\n#### Set Text\njQuery\n``$(el).text(string);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.textContent !== undefined)\n  el.textContent = string;\nelse\n  el.innerText = string;```\n谷歌浏览器，火狐浏览器，IE9+\n``el.textContent = string;``\n#### Siblings\njQuery\n``$(el).siblings();``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar siblings = Array.prototype.slice.call(el.parentNode.children);\nfor (var i = siblings.length; i--;) {\n  if (siblings[i] === el) {\n    siblings.splice(i, 1);\n    break;\n  }\n}```\n谷歌浏览器，火狐浏览器，IE9+\n``Array.prototype.filter.call(el.parentNode.children, function(child){\n  return child !== el;\n});``\n#### Toggle Class\njQuery\n``$(el).toggleClass(className);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (el.classList) {\n  el.classList.toggle(className);\n} else {\n    var classes = el.className.split(' ');\n    var existingIndex = -1;\n    for (var i = classes.length; i--;) {\n      if (classes[i] === className)\n        existingIndex = i;\n    }\n    if (existingIndex >= 0)\n      classes.splice(existingIndex, 1);\n    else\n      classes.push(className);\n  el.className = classes.join(' ');\n}```\n谷歌浏览器，火狐浏览器，IE9+\n```\nif (el.classList) {\n  el.classList.toggle(className);\n} else {\n  var classes = el.className.split(' ');\n  var existingIndex = classes.indexOf(className);\n  if (existingIndex >= 0)\n    classes.splice(existingIndex, 1);\n  else\n    classes.push(className);\n  el.className = classes.join(' ');\n}```\n谷歌浏览器，火狐浏览器，IE10+\n``el.classList.toggle(className);``\n## 事件\n#### #### Off\njQuery\n``$(el).off(eventName, eventHandler);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction removeEventListener(el, eventName, handler) {\n  if (el.removeEventListener)\n    el.removeEventListener(eventName, handler);\n  else\n    el.detachEvent('on' + eventName, handler);\n}\nremoveEventListener(el, eventName, handler);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.removeEventListener(eventName, eventHandler);``\n#### On\njQuery\n``$(el).on(eventName, eventHandler);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction addEventListener(el, eventName, handler) {\n  if (el.addEventListener) {\n    el.addEventListener(eventName, handler);\n  } else {\n    el.attachEvent('on' + eventName, function(){\n      handler.call(el);\n    });\n  }\n}\naddEventListener(el, eventName, handler);```\n谷歌浏览器，火狐浏览器，IE9+\n``el.addEventListener(eventName, eventHandler);``\n#### Ready\njQuery\n``$(document).ready(function(){});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction ready(fn) {\n  if (document.readyState != 'loading'){\n    fn();\n  } else if (document.addEventListener) {\n    document.addEventListener('DOMContentLoaded', fn);\n  } else {\n    document.attachEvent('onreadystatechange', function() {\n      if (document.readyState != 'loading')\n        fn();\n    });\n  }\n}```\n谷歌浏览器，火狐浏览器，IE9+\n```\nfunction ready(fn) {\n  if (document.readyState != 'loading'){\n    fn();\n  } else {\n    document.addEventListener('DOMContentLoaded', fn);\n  }\n}```\n#### 指定事件触发\njQuery\n``$(el).trigger('my-event', {some: 'data'});``\n谷歌浏览器，火狐浏览器，IE8+\n// Custom events are not natively supported, so you have to hijack a rndomevent.\n// Just use jQuery.\n谷歌浏览器，火狐浏览器，IE9+\n```\nif (window.CustomEvent) {\n  var event = new CustomEvent('my-event', {detail: {some: 'data'}});\n} else {\n  var event = document.createEvent('CustomEvent');\n  event.initCustomEvent('my-event', true, true, {some: 'data'});\n}\nel.dispatchEvent(event);```\n#### Trigger Native\njQuery\n``$(el).trigger('change');``\n谷歌浏览器，火狐浏览器，IE8+\n```\nif (document.createEvent) {\n  var event = document.createEvent('HTMLEvents');\n  event.initEvent('change', true, false);\n  el.dispatchEvent(event);\n} else {\n  el.fireEvent('onchange');\n}```\n谷歌浏览器，火狐浏览器，IE9+\n// For a full list of event types: https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent\n```\nvar event = document.createEvent('HTMLEvents');\nevent.initEvent('change', true, false);\nel.dispatchEvent(event);```\n## 技巧\n#### Array Each\njQuery\n``$.each(array, function(i, item){});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction forEach(array, fn) {\n  for (i = 0; i < array.length; i++)\n    fn(array[i], i);\n}\nforEach(array, function(item, i){});```\n谷歌浏览器，火狐浏览器，IE9+\n``array.forEach(function(item, i){});``\n#### 深度扩展\njQuery\n``$.extend(true, {}, objA, objB);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar deepExtend = function(out) {\n  out = out || {};\n  for (var i = 1; i < arguments.length; i++) {\n    var obj = arguments[i];\n    if (!obj)\n      continue;\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (typeof obj[key] === 'object')\n          deepExtend(out[key], obj[key]);\n        else\n          out[key] = obj[key];\n      }\n    }\n  }\n  return out;\n};\ndeepExtend({}, objA, objB);```\n#### Bind\njQuery\n``$.proxy(fn, context);``\n谷歌浏览器，火狐浏览器，IE8+\n``fn.apply(context, arguments);``\n谷歌浏览器，火狐浏览器，IE9+\n``fn.bind(context);``\njQuery\n``$.extend({}, objA, objB);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar extend = function(out) {\n  out = out || {};\n  for (var i = 1; i < arguments.length; i++) {\n    if (!arguments[i])\n      continue;\n    for (var key in arguments[i]) {\n      if (arguments[i].hasOwnProperty(key))\n        out[key] = arguments[i][key];\n    }\n  }\n  return out;\n};\nextend({}, objA, objB);```\n#### Index Of\njQuery\n``$.inArray(item, array);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction indexOf(array, item) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === item)\n      return i;\n  }\n  return -1;\n}\nindexOf(array, item);```\n谷歌浏览器，火狐浏览器，IE9+\n``array.indexOf(item);``\n#### Is Array\njQuery\n``$.isArray(arr);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nisArray = Array.isArray || function(arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n}\nisArray(arr);```\n谷歌浏览器，火狐浏览器，IE9+\n``Array.isArray(arr);``\n#### Map\njQuery\n``$.map(array, function(value, index){});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nfunction map(arr, fn) {\n  var results = [];\n  for (var i = 0; i < arr.length; i++)\n    results.push(fn(arr[i], i));\n  return results;\nmap(array, function(value, index){});```\n谷歌浏览器，火狐浏览器，IE9+\n``array.map(function(value, index){});``\n#### Now\njQuery\n``$.now();``\n谷歌浏览器，火狐浏览器，IE8+\n``new Date().getTime();``\n谷歌浏览器，火狐浏览器，IE9+\n``Date.now();``\n#### Parse Html\njQuery\n``$.parseHTML(htmlString);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar parseHTML = function(str) {\n  var el = document.createElement('div');\n  el.innerHTML = str;\n  return el.children;\n};\nparseHTML(htmlString);```\n谷歌浏览器，火狐浏览器，IE9+\n``var parseHTML = function(str) {\n  var tmp = document.implementation.createHTMLDocument();\n  tmp.body.innerHTML = str;\n  return tmp.body.children;\n};\nparseHTML(htmlString);``\n#### 解析 Json\njQuery\n``$.parseJSON(string);``\n谷歌浏览器，火狐浏览器，IE8+\n``JSON.parse(string);``\n#### Trim\njQuery\n``$.trim(string);``\n谷歌浏览器，火狐浏览器，IE8+\n``string.replace(/^\\s+|\\s+$/g, '');``\n谷歌浏览器，火狐浏览器，IE9+\n``string.trim();``\n#### Type\njQuery\n``$.type(obj);``\n谷歌浏览器，火狐浏览器，IE8+\n```\nObject.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, \"$1\").toLowerCase();```\n## AJAX\n#### JSON\njQuery\n``$.getJSON('/my/url', function(data) {});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onreadystatechange = function() {\n  if (this.readyState === 4) {\n    if (this.status >= 200 && this.status < 400) {\n      // Success!\n      var data = JSON.parse(this.responseText);\n    } else {\n      // Error :(\n    }\n  }\n};\nrequest.send();\nrequest = null;```\n谷歌浏览器，火狐浏览器，IE9+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onload = function() {\n  if (request.status >= 200 && request.status < 400) {\n    // Success!\n    var data = JSON.parse(request.responseText);\n  } else {\n    // We reached our target server, but it returned an error\n  }\n};\nrequest.onerror = function() {\n  // There was a connection error of some sort\n};\nrequest.send();```\n谷歌浏览器，火狐浏览器，IE10+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onload = function() {\n  if (this.status >= 200 && this.status < 400) {\n    // Success!\n    var data = JSON.parse(this.response);\n  } else {\n    // We reached our target server, but it returned an error\n  }\n};\nrequest.onerror = function() {\n  // There was a connection error of some sort\n};\nrequest.send();```\n#### Post\njQuery\n``$.ajax({type: 'POST',url: '/my/url',data: data});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar request = new XMLHttpRequest();\nrequest.open('POST', '/my/url', true);\nrequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\nrequest.send(data);```\n#### Request\njQuery\n``$.ajax({type: 'GET',url: '/my/url',success: function(resp) {},error: function() {}});``\n谷歌浏览器，火狐浏览器，IE8+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onreadystatechange = function() {\n  if (this.readyState === 4) {\n    if (this.status >= 200 && this.status < 400) {\n      // Success!\n      var resp = this.responseText;\n    } else {\n      // Error :(\n    }\n  }\n};\nrequest.send();\nrequest = null;```\n谷歌浏览器，火狐浏览器，IE9+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onload = function() {\n  if (request.status >= 200 && request.status < 400) {\n    // Success!\n    var resp = request.responseText;\n  } else {\n    // We reached our target server, but it returned an error\n  }\n};\nrequest.onerror = function() {\n  // There was a connection error of some sort\n};\nrequest.send();```\n谷歌浏览器，火狐浏览器，IE10+\n```\nvar request = new XMLHttpRequest();\nrequest.open('GET', '/my/url', true);\nrequest.onload = function() {\n  if (this.status >= 200 && this.status < 400) {\n    // Success!\n    var resp = this.response;\n  } else {\n    // We reached our target server, but it returned an error\n  }\n};\nrequest.onerror = function() {\n  // There was a connection error of some sort\n};\nrequest.send();\n```\n## 特效\n#### 淡入淡出\njQuery\n``$(el).fadeIn();``\n谷歌浏览器，火狐浏览器，IE8+\n``` \nfunction fadeIn(el) {\n  var opacity = 0;\n  el.style.opacity = 0;\n  el.style.filter = '';\n  var last = +new Date();\n  var tick = function() {\n    opacity += (new Date() - last) / 400;\n    el.style.opacity = opacity;\n    el.style.filter = 'alpha(opacity=' + (100 * opacity)|0 + ')';\n    last = +new Date();\n    if (opacity < 1) {\n      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);\n    }\n  };\n  tick();\n}\nfadeIn(el);\n```\n谷歌浏览器，火狐浏览器，IE9+\n```function fadeIn(el) {\n  el.style.opacity = 0;\n  var last = +new Date();\n  var tick = function() {\n    el.style.opacity = +el.style.opacity + (new Date() - last) / 400;\n    last = +new Date();\n    if (+el.style.opacity < 1) {\n      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16)\n    }\n  };\n  tick();\n}\nfadeIn(el);\n```\n谷歌浏览器，火狐浏览器，IE10+\n```\nel.classList.add('show');\nel.classList.remove('hide');\n.show {transition: opacity 400ms;}\n.hide {opacity: 0;}```\n#### Hide\njQuery\n``$(el).hide();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.style.display = 'none';``\n#### Show\njQuery\n``$(el).show();``\n谷歌浏览器，火狐浏览器，IE8+\n``el.style.display = '';``","slug":"你可能并不需要jQuery","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfe1001rzk4od0pqg6vp","content":"<blockquote>\n<p>jQuery是非常优秀的工具，它能让我们开发项目时变得更容易，但如果你想从零开始开发一个全新的项目，你应该考虑一下你的项目是否真的需要引入jQuery。</p>\n<ul>\n<li>也许你只需要几行技巧性的代码就能解决问题。如果你的项目是面向最新的现代浏览器，你真的可以考虑其它的一些简单的技术来代替jQuery。</li>\n<li>浏览器的进步给我们带来了很多先进的JavaScript特征，新出现的原生内置(native)JavaScript功能可以很大程度的实现jQuery提供的功能。如果你能了解这些JavaScript新技术，就能在很多地方用纯JavaScript实现以前需要jQuery才能实现的技术。</li>\n<li>新的mvvm框架的出现，数据驱动的方式解决了项目数据交互量大的时候，操作dom的代码混乱的问题。<h2 id=\"元素操作\"><a href=\"#元素操作\" class=\"headerlink\" title=\"元素操作\"></a>元素操作</h2><h4 id=\"addClass\"><a href=\"#addClass\" class=\"headerlink\" title=\"addClass\"></a>addClass</h4>jQuery<br><code>$(el).addClass(className);</code><br>谷歌浏览器，火狐浏览器，IE8+<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList)</div><div class=\"line\">  el.classList.add(className);</div><div class=\"line\">else</div><div class=\"line\">  el.className += &apos; &apos; + className;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><code>el.classList.add(className);</code></p>\n<h4 id=\"After\"><a href=\"#After\" class=\"headerlink\" title=\"After\"></a>After</h4><p>jQuery<br><code>$(el).after(htmlString);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.insertAdjacentHTML(&#39;afterend&#39;, htmlString);</code></p>\n<h4 id=\"Append\"><a href=\"#Append\" class=\"headerlink\" title=\"Append\"></a>Append</h4><p>jQuery<br><code>$(parent).append(el);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>parent.appendChild(el);</code></p>\n<h4 id=\"Before\"><a href=\"#Before\" class=\"headerlink\" title=\"Before\"></a>Before</h4><p>jQuery<br><code>$(el).before(htmlString);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.insertAdjacentHTML(&#39;beforebegin&#39;, htmlString);</code></p>\n<h4 id=\"Children\"><a href=\"#Children\" class=\"headerlink\" title=\"Children\"></a>Children</h4><p>jQuery<br><code>$(el).children();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var children = [];</div><div class=\"line\">for (var i = el.children.length; i--;) &#123;</div><div class=\"line\">  // Skip comment nodes on IE8</div><div class=\"line\">  if (el.children[i].nodeType != 8)</div><div class=\"line\">    children.unshift(el.children[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.children</code><br><a id=\"more\"></a></p>\n<h4 id=\"Clone\"><a href=\"#Clone\" class=\"headerlink\" title=\"Clone\"></a>Clone</h4><p>jQuery<br><code>$(el).clone();</code><br>谷歌浏览器，火狐浏览器，IE8+<br>`el.cloneNode(true);``</p>\n<h4 id=\"Contains\"><a href=\"#Contains\" class=\"headerlink\" title=\"Contains\"></a>Contains</h4><p>jQuery<br><code>$.contains(el, child);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el !== child &amp;&amp; el.contains(child);</code></p>\n<h4 id=\"Contains-Selector\"><a href=\"#Contains-Selector\" class=\"headerlink\" title=\"Contains Selector\"></a>Contains Selector</h4><p>jQuery<br><code>$(el).find(selector).length;</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.querySelector(selector) !== null</code></p>\n<h4 id=\"Each\"><a href=\"#Each\" class=\"headerlink\" title=\"Each\"></a>Each</h4><p>jQuery<br><code>$(selector).each(function(i, el){});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function forEachElement(selector, fn) &#123;</div><div class=\"line\">  var elements = document.querySelectorAll(selector);</div><div class=\"line\">  for (var i = 0; i &lt; elements.length; i++)</div><div class=\"line\">    fn(elements[i], i);</div><div class=\"line\">&#125;</div><div class=\"line\">forEachElement(selector, function(el, i)&#123;&#125;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var elements = document.querySelectorAll(selector);</div><div class=\"line\">Array.prototype.forEach.call(elements, function(el, i)&#123;&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Empty\"><a href=\"#Empty\" class=\"headerlink\" title=\"Empty\"></a>Empty</h4><p>jQuery<br><code>$(el).empty();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">while(el.firstChild)</div><div class=\"line\">  el.removeChild(el.firstChild);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.innerHTML = &#39;&#39;;</code></p>\n<h4 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h4><p>jQuery<br><code>$(selector).filter(filterFn);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function filter(selector, filterFn) &#123;</div><div class=\"line\">  var elements = document.querySelectorAll(selector);</div><div class=\"line\">  var out = [];</div><div class=\"line\">  for (var i = elements.length; i--;) &#123;</div><div class=\"line\">    if (filterFn(elements[i]))&#123;</div><div class=\"line\">      out.unshift(elements[i]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return out;</div><div class=\"line\">&#125;</div><div class=\"line\">filter(selector, filterFn);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>Array.prototype.filter.call(document.querySelectorAll(selector), filterFn);</code></p>\n<h4 id=\"查找子元素\"><a href=\"#查找子元素\" class=\"headerlink\" title=\"查找子元素\"></a>查找子元素</h4><p>jQuery<br><code>$(el).find(selector);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.querySelectorAll(selector);</code></p>\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><p>jQuery<br><code>$(&#39;.my #awesome selector&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>document.querySelectorAll(&#39;.my #awesome selector&#39;);</code></p>\n<h4 id=\"获取属性值\"><a href=\"#获取属性值\" class=\"headerlink\" title=\"获取属性值\"></a>获取属性值</h4><p>jQuery<br><code>$(el).attr(&#39;tabindex&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.getAttribute(&#39;tabindex&#39;);</code></p>\n<h4 id=\"获取Html内容\"><a href=\"#获取Html内容\" class=\"headerlink\" title=\"获取Html内容\"></a>获取Html内容</h4><p>jQuery<br><code>$(el).html();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.innerHTML</code></p>\n<h4 id=\"获取外层Html内容\"><a href=\"#获取外层Html内容\" class=\"headerlink\" title=\"获取外层Html内容\"></a>获取外层Html内容</h4><p>jQuery<br><code>$(&#39;&lt;div&gt;&#39;).append($(el).clone()).html();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.outerHTML</code></p>\n<h4 id=\"获取CSS样式\"><a href=\"#获取CSS样式\" class=\"headerlink\" title=\"获取CSS样式\"></a>获取CSS样式</h4><p>jQuery<br><code>$(el).css(ruleName);</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// Varies based on the properties being retrieved, some can be retrieved from</p>\n<p>el.currentStyle<br>// <a href=\"https://github.com/jonathantneal/Polyfills-for-IE8/blob/master/\" target=\"_blank\" rel=\"external\">https://github.com/jonathantneal/Polyfills-for-IE8/blob/master/</a></p>\n<p>getComputedStyle.js<br>谷歌浏览器，火狐浏览器，IE9+<br><code>getComputedStyle(el)[ruleName];</code></p>\n<h4 id=\"获取文本内容\"><a href=\"#获取文本内容\" class=\"headerlink\" title=\"获取文本内容\"></a>获取文本内容</h4><p>jQuery<br><code>$(el).text();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.textContent || el.innerText</code><br>谷歌浏览器，火狐浏览器，IE9+<br><code>el.textContent</code></p>\n<h4 id=\"Has-Class\"><a href=\"#Has-Class\" class=\"headerlink\" title=\"Has Class\"></a>Has Class</h4><p>jQuery<br><code>$(el).hasClass(className);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList)&#123;</div><div class=\"line\">  el.classList.contains(className);</div><div class=\"line\">&#125;</div><div class=\"line\">else&#123;</div><div class=\"line\">  new RegExp(&apos;(^| )&apos; + className + &apos;( |$)&apos;, &apos;gi&apos;).test(el.className);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><code>el.classList.contains(className);</code></p>\n<h4 id=\"元素比较\"><a href=\"#元素比较\" class=\"headerlink\" title=\"元素比较\"></a>元素比较</h4><p>jQuery<br><code>$(el).is($(otherEl));</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el === otherEl</code></p>\n<h4 id=\"比较类名\"><a href=\"#比较类名\" class=\"headerlink\" title=\"比较类名\"></a>比较类名</h4><p>jQuery<br><code>$(el).is(&#39;.my-class&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var matches = function(el, selector) &#123;</div><div class=\"line\">  var _matches = (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector);</div><div class=\"line\">  if (_matches) &#123;</div><div class=\"line\">    return _matches.call(el, selector);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    var nodes = el.parentNode.querySelectorAll(selector);</div><div class=\"line\">    for (var i = nodes.length; i--;) &#123;</div><div class=\"line\">      if (nodes[i] === el)</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">matches(el, &apos;.my-class&apos;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var matches = function(el, selector) &#123;</div><div class=\"line\">  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);</div><div class=\"line\">&#125;;</div><div class=\"line\">matches(el, &apos;.my-class&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Next\"><a href=\"#Next\" class=\"headerlink\" title=\"Next\"></a>Next</h4><p>jQuery<br><code>$(el).next();</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// nextSibling can include text nodes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function nextElementSibling(el) &#123;</div><div class=\"line\">  do &#123; el = el.nextSibling; &#125; while ( el &amp;&amp; el.nodeType !== 1 );</div><div class=\"line\">  return el;</div><div class=\"line\">&#125;</div><div class=\"line\">el.nextElementSibling || nextElementSibling(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.nextElementSibling</code></p>\n<h4 id=\"Offset\"><a href=\"#Offset\" class=\"headerlink\" title=\"Offset\"></a>Offset</h4><p>jQuery<br><code>$(el).offset();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var rect = el.getBoundingClientRect()</div><div class=\"line\">&#123;</div><div class=\"line\">  top: rect.top + document.body.scrollTop,</div><div class=\"line\">  left: rect.left + document.body.scrollLeft</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Offset-Parent\"><a href=\"#Offset-Parent\" class=\"headerlink\" title=\"Offset Parent\"></a>Offset Parent</h4><p>jQuery<br><code>$(el).offsetParent();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.offsetParent || el</code></p>\n<h4 id=\"Outer-Height\"><a href=\"#Outer-Height\" class=\"headerlink\" title=\"Outer Height\"></a>Outer Height</h4><p>jQuery<br><code>$(el).outerHeight();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.offsetHeight</code></p>\n<h4 id=\"Outer-Height-With-Margin\"><a href=\"#Outer-Height-With-Margin\" class=\"headerlink\" title=\"Outer Height With Margin\"></a>Outer Height With Margin</h4><p>jQuery<br><code>$(el).outerHeight(true);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerHeight(el) &#123;</div><div class=\"line\">  var height = el.offsetHeight;</div><div class=\"line\">  var style = el.currentStyle || getComputedStyle(el);</div><div class=\"line\"></div><div class=\"line\">  height += parseInt(style.marginTop) + parseInt(style.marginBottom);</div><div class=\"line\">  return height;</div><div class=\"line\">&#125;</div><div class=\"line\">outerHeight(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerHeight(el) &#123;</div><div class=\"line\">  var height = el.offsetHeight;</div><div class=\"line\">  var style = getComputedStyle(el);</div><div class=\"line\"></div><div class=\"line\">  height += parseInt(style.marginTop) + parseInt(style.marginBottom);</div><div class=\"line\">  return height;</div><div class=\"line\">&#125;</div><div class=\"line\">outerHeight(el);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Outer-Width-With-Margin\"><a href=\"#Outer-Width-With-Margin\" class=\"headerlink\" title=\"Outer Width With Margin\"></a>Outer Width With Margin</h4><p>jQuery<br><code>$(el).outerWidth(true);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerWidth(el) &#123;</div><div class=\"line\">  var width = el.offsetWidth;</div><div class=\"line\">  var style = el.currentStyle || getComputedStyle(el);</div><div class=\"line\"></div><div class=\"line\">  width += parseInt(style.marginLeft) + parseInt(style.marginRight);</div><div class=\"line\">  return width;</div><div class=\"line\">&#125;</div><div class=\"line\">outerWidth(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerWidth(el) &#123;</div><div class=\"line\">  var width = el.offsetWidth;</div><div class=\"line\">  var style = getComputedStyle(el);</div><div class=\"line\"></div><div class=\"line\">  width += parseInt(style.marginLeft) + parseInt(style.marginRight);</div><div class=\"line\">  return width;</div><div class=\"line\">&#125;</div><div class=\"line\">outerWidth(el);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Outer-Width\"><a href=\"#Outer-Width\" class=\"headerlink\" title=\"Outer Width\"></a>Outer Width</h4><p>jQuery<br><code>$(el).outerWidth();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.offsetWidth</code></p>\n<h4 id=\"Parent\"><a href=\"#Parent\" class=\"headerlink\" title=\"Parent\"></a>Parent</h4><p>jQuery<br><code>$(el).parent();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.parentNode</code></p>\n<h4 id=\"Position\"><a href=\"#Position\" class=\"headerlink\" title=\"Position\"></a>Position</h4><p>jQuery<br><code>$(el).position();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>{left: el.offsetLeft, top: el.offsetTop}</code></p>\n<h4 id=\"Position-Relative-To-Viewport\"><a href=\"#Position-Relative-To-Viewport\" class=\"headerlink\" title=\"Position Relative To Viewport\"></a>Position Relative To Viewport</h4><p>jQuery<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var offset = el.offset();</div><div class=\"line\">&#123;</div><div class=\"line\">  top: offset.top - document.body.scrollTop,</div><div class=\"line\">  left: offset.left - document.body.scrollLeft</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE8+<br><code>el.getBoundingClientRect()</code></p>\n<h4 id=\"Prepend\"><a href=\"#Prepend\" class=\"headerlink\" title=\"Prepend\"></a>Prepend</h4><p>jQuery<br><code>$(parent).prepend(el);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>parent.insertBefore(el, parent.firstChild);</code></p>\n<h4 id=\"Prev\"><a href=\"#Prev\" class=\"headerlink\" title=\"Prev\"></a>Prev</h4><p>jQuery<br><code>$(el).prev();</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// prevSibling can include text nodes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function previousElementSibling(el) &#123;</div><div class=\"line\">  do &#123; el = el.previousSibling; &#125; while ( el &amp;&amp; el.nodeType !== 1 );</div><div class=\"line\">  return el;</div><div class=\"line\">&#125;</div><div class=\"line\">el.previousElementSibling || previousElementSibling(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.previousElementSibling</code></p>\n<h4 id=\"Remove\"><a href=\"#Remove\" class=\"headerlink\" title=\"Remove\"></a>Remove</h4><p>jQuery<br><code>$(el).remove();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.parentNode.removeChild(el);</code></p>\n<h4 id=\"Remove-Class\"><a href=\"#Remove-Class\" class=\"headerlink\" title=\"Remove Class\"></a>Remove Class</h4><p>jQuery<br><code>$(el).removeClass(className);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList)</div><div class=\"line\">  el.classList.remove(className);</div><div class=\"line\">else</div><div class=\"line\">  el.className = el.className.replace(new RegExp(&apos;(^|\\\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\\\b|$)&apos;, &apos;gi&apos;), &apos; &apos;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><code>el.classList.remove(className);</code></p>\n<h4 id=\"Replace-From-Html\"><a href=\"#Replace-From-Html\" class=\"headerlink\" title=\"Replace From Html\"></a>Replace From Html</h4><p>jQuery<br><code>$(el).replaceWith(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.outerHTML = string;</code></p>\n<h4 id=\"Set-Attributes\"><a href=\"#Set-Attributes\" class=\"headerlink\" title=\"Set Attributes\"></a>Set Attributes</h4><p>jQuery<br><code>$(el).attr(&#39;tabindex&#39;, 3);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.setAttribute(&#39;tabindex&#39;, 3);</code></p>\n<h4 id=\"Set-Html\"><a href=\"#Set-Html\" class=\"headerlink\" title=\"Set Html\"></a>Set Html</h4><p>jQuery<br><code>$(el).html(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.innerHTML = string;</code></p>\n<h4 id=\"Set-Style\"><a href=\"#Set-Style\" class=\"headerlink\" title=\"Set Style\"></a>Set Style</h4><p>jQuery<br><code>$(el).css(&#39;border-width&#39;, &#39;20px&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// Use a class if possible<br><code>el.style.borderWidth = &#39;20px&#39;;</code></p>\n<h4 id=\"Set-Text\"><a href=\"#Set-Text\" class=\"headerlink\" title=\"Set Text\"></a>Set Text</h4><p>jQuery<br><code>$(el).text(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.textContent !== undefined)</div><div class=\"line\">  el.textContent = string;</div><div class=\"line\">else</div><div class=\"line\">  el.innerText = string;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.textContent = string;</code></p>\n<h4 id=\"Siblings\"><a href=\"#Siblings\" class=\"headerlink\" title=\"Siblings\"></a>Siblings</h4><p>jQuery<br><code>$(el).siblings();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var siblings = Array.prototype.slice.call(el.parentNode.children);</div><div class=\"line\">for (var i = siblings.length; i--;) &#123;</div><div class=\"line\">  if (siblings[i] === el) &#123;</div><div class=\"line\">    siblings.splice(i, 1);</div><div class=\"line\">    break;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>Array.prototype.filter.call(el.parentNode.children, function(child){\n  return child !== el;\n});</code></p>\n<h4 id=\"Toggle-Class\"><a href=\"#Toggle-Class\" class=\"headerlink\" title=\"Toggle Class\"></a>Toggle Class</h4><p>jQuery<br><code>$(el).toggleClass(className);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList) &#123;</div><div class=\"line\">  el.classList.toggle(className);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    var classes = el.className.split(&apos; &apos;);</div><div class=\"line\">    var existingIndex = -1;</div><div class=\"line\">    for (var i = classes.length; i--;) &#123;</div><div class=\"line\">      if (classes[i] === className)</div><div class=\"line\">        existingIndex = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (existingIndex &gt;= 0)</div><div class=\"line\">      classes.splice(existingIndex, 1);</div><div class=\"line\">    else</div><div class=\"line\">      classes.push(className);</div><div class=\"line\">  el.className = classes.join(&apos; &apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList) &#123;</div><div class=\"line\">  el.classList.toggle(className);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  var classes = el.className.split(&apos; &apos;);</div><div class=\"line\">  var existingIndex = classes.indexOf(className);</div><div class=\"line\">  if (existingIndex &gt;= 0)</div><div class=\"line\">    classes.splice(existingIndex, 1);</div><div class=\"line\">  else</div><div class=\"line\">    classes.push(className);</div><div class=\"line\">  el.className = classes.join(&apos; &apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><code>el.classList.toggle(className);</code></p>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h4 id=\"Off\"><a href=\"#Off\" class=\"headerlink\" title=\"#### Off\"></a>#### Off</h4><p>jQuery<br><code>$(el).off(eventName, eventHandler);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function removeEventListener(el, eventName, handler) &#123;</div><div class=\"line\">  if (el.removeEventListener)</div><div class=\"line\">    el.removeEventListener(eventName, handler);</div><div class=\"line\">  else</div><div class=\"line\">    el.detachEvent(&apos;on&apos; + eventName, handler);</div><div class=\"line\">&#125;</div><div class=\"line\">removeEventListener(el, eventName, handler);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.removeEventListener(eventName, eventHandler);</code></p>\n<h4 id=\"On\"><a href=\"#On\" class=\"headerlink\" title=\"On\"></a>On</h4><p>jQuery<br><code>$(el).on(eventName, eventHandler);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function addEventListener(el, eventName, handler) &#123;</div><div class=\"line\">  if (el.addEventListener) &#123;</div><div class=\"line\">    el.addEventListener(eventName, handler);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    el.attachEvent(&apos;on&apos; + eventName, function()&#123;</div><div class=\"line\">      handler.call(el);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">addEventListener(el, eventName, handler);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.addEventListener(eventName, eventHandler);</code></p>\n<h4 id=\"Ready\"><a href=\"#Ready\" class=\"headerlink\" title=\"Ready\"></a>Ready</h4><p>jQuery<br><code>$(document).ready(function(){});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function ready(fn) &#123;</div><div class=\"line\">  if (document.readyState != &apos;loading&apos;)&#123;</div><div class=\"line\">    fn();</div><div class=\"line\">  &#125; else if (document.addEventListener) &#123;</div><div class=\"line\">    document.addEventListener(&apos;DOMContentLoaded&apos;, fn);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    document.attachEvent(&apos;onreadystatechange&apos;, function() &#123;</div><div class=\"line\">      if (document.readyState != &apos;loading&apos;)</div><div class=\"line\">        fn();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function ready(fn) &#123;</div><div class=\"line\">  if (document.readyState != &apos;loading&apos;)&#123;</div><div class=\"line\">    fn();</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    document.addEventListener(&apos;DOMContentLoaded&apos;, fn);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"指定事件触发\"><a href=\"#指定事件触发\" class=\"headerlink\" title=\"指定事件触发\"></a>指定事件触发</h4><p>jQuery<br><code>$(el).trigger(&#39;my-event&#39;, {some: &#39;data&#39;});</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// Custom events are not natively supported, so you have to hijack a rndomevent.<br>// Just use jQuery.<br>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (window.CustomEvent) &#123;</div><div class=\"line\">  var event = new CustomEvent(&apos;my-event&apos;, &#123;detail: &#123;some: &apos;data&apos;&#125;&#125;);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  var event = document.createEvent(&apos;CustomEvent&apos;);</div><div class=\"line\">  event.initCustomEvent(&apos;my-event&apos;, true, true, &#123;some: &apos;data&apos;&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">el.dispatchEvent(event);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Trigger-Native\"><a href=\"#Trigger-Native\" class=\"headerlink\" title=\"Trigger Native\"></a>Trigger Native</h4><p>jQuery<br><code>$(el).trigger(&#39;change&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (document.createEvent) &#123;</div><div class=\"line\">  var event = document.createEvent(&apos;HTMLEvents&apos;);</div><div class=\"line\">  event.initEvent(&apos;change&apos;, true, false);</div><div class=\"line\">  el.dispatchEvent(event);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  el.fireEvent(&apos;onchange&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br>// For a full list of event types: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var event = document.createEvent(&apos;HTMLEvents&apos;);</div><div class=\"line\">event.initEvent(&apos;change&apos;, true, false);</div><div class=\"line\">el.dispatchEvent(event);</div></pre></td></tr></table></figure></p>\n<h2 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h2><h4 id=\"Array-Each\"><a href=\"#Array-Each\" class=\"headerlink\" title=\"Array Each\"></a>Array Each</h4><p>jQuery<br><code>$.each(array, function(i, item){});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function forEach(array, fn) &#123;</div><div class=\"line\">  for (i = 0; i &lt; array.length; i++)</div><div class=\"line\">    fn(array[i], i);</div><div class=\"line\">&#125;</div><div class=\"line\">forEach(array, function(item, i)&#123;&#125;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>array.forEach(function(item, i){});</code></p>\n<h4 id=\"深度扩展\"><a href=\"#深度扩展\" class=\"headerlink\" title=\"深度扩展\"></a>深度扩展</h4><p>jQuery<br><code>$.extend(true, {}, objA, objB);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var deepExtend = function(out) &#123;</div><div class=\"line\">  out = out || &#123;&#125;;</div><div class=\"line\">  for (var i = 1; i &lt; arguments.length; i++) &#123;</div><div class=\"line\">    var obj = arguments[i];</div><div class=\"line\">    if (!obj)</div><div class=\"line\">      continue;</div><div class=\"line\">    for (var key in obj) &#123;</div><div class=\"line\">      if (obj.hasOwnProperty(key)) &#123;</div><div class=\"line\">        if (typeof obj[key] === &apos;object&apos;)</div><div class=\"line\">          deepExtend(out[key], obj[key]);</div><div class=\"line\">        else</div><div class=\"line\">          out[key] = obj[key];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return out;</div><div class=\"line\">&#125;;</div><div class=\"line\">deepExtend(&#123;&#125;, objA, objB);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Bind\"><a href=\"#Bind\" class=\"headerlink\" title=\"Bind\"></a>Bind</h4><p>jQuery<br><code>$.proxy(fn, context);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>fn.apply(context, arguments);</code><br>谷歌浏览器，火狐浏览器，IE9+<br><code>fn.bind(context);</code><br>jQuery<br><code>$.extend({}, objA, objB);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var extend = function(out) &#123;</div><div class=\"line\">  out = out || &#123;&#125;;</div><div class=\"line\">  for (var i = 1; i &lt; arguments.length; i++) &#123;</div><div class=\"line\">    if (!arguments[i])</div><div class=\"line\">      continue;</div><div class=\"line\">    for (var key in arguments[i]) &#123;</div><div class=\"line\">      if (arguments[i].hasOwnProperty(key))</div><div class=\"line\">        out[key] = arguments[i][key];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return out;</div><div class=\"line\">&#125;;</div><div class=\"line\">extend(&#123;&#125;, objA, objB);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Index-Of\"><a href=\"#Index-Of\" class=\"headerlink\" title=\"Index Of\"></a>Index Of</h4><p>jQuery<br><code>$.inArray(item, array);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function indexOf(array, item) &#123;</div><div class=\"line\">  for (var i = 0; i &lt; array.length; i++) &#123;</div><div class=\"line\">    if (array[i] === item)</div><div class=\"line\">      return i;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return -1;</div><div class=\"line\">&#125;</div><div class=\"line\">indexOf(array, item);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>array.indexOf(item);</code></p>\n<h4 id=\"Is-Array\"><a href=\"#Is-Array\" class=\"headerlink\" title=\"Is Array\"></a>Is Array</h4><p>jQuery<br><code>$.isArray(arr);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">isArray = Array.isArray || function(arr) &#123;</div><div class=\"line\">  return Object.prototype.toString.call(arr) == &apos;[object Array]&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\">isArray(arr);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>Array.isArray(arr);</code></p>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><p>jQuery<br><code>$.map(array, function(value, index){});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function map(arr, fn) &#123;</div><div class=\"line\">  var results = [];</div><div class=\"line\">  for (var i = 0; i &lt; arr.length; i++)</div><div class=\"line\">    results.push(fn(arr[i], i));</div><div class=\"line\">  return results;</div><div class=\"line\">map(array, function(value, index)&#123;&#125;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>array.map(function(value, index){});</code></p>\n<h4 id=\"Now\"><a href=\"#Now\" class=\"headerlink\" title=\"Now\"></a>Now</h4><p>jQuery<br><code>$.now();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>new Date().getTime();</code><br>谷歌浏览器，火狐浏览器，IE9+<br><code>Date.now();</code></p>\n<h4 id=\"Parse-Html\"><a href=\"#Parse-Html\" class=\"headerlink\" title=\"Parse Html\"></a>Parse Html</h4><p>jQuery<br><code>$.parseHTML(htmlString);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var parseHTML = function(str) &#123;</div><div class=\"line\">  var el = document.createElement(&apos;div&apos;);</div><div class=\"line\">  el.innerHTML = str;</div><div class=\"line\">  return el.children;</div><div class=\"line\">&#125;;</div><div class=\"line\">parseHTML(htmlString);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>var parseHTML = function(str) {\n  var tmp = document.implementation.createHTMLDocument();\n  tmp.body.innerHTML = str;\n  return tmp.body.children;\n};\nparseHTML(htmlString);</code></p>\n<h4 id=\"解析-Json\"><a href=\"#解析-Json\" class=\"headerlink\" title=\"解析 Json\"></a>解析 Json</h4><p>jQuery<br><code>$.parseJSON(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>JSON.parse(string);</code></p>\n<h4 id=\"Trim\"><a href=\"#Trim\" class=\"headerlink\" title=\"Trim\"></a>Trim</h4><p>jQuery<br><code>$.trim(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>string.replace(/^\\s+|\\s+$/g, &#39;&#39;);</code><br>谷歌浏览器，火狐浏览器，IE9+<br><code>string.trim();</code></p>\n<h4 id=\"Type\"><a href=\"#Type\" class=\"headerlink\" title=\"Type\"></a>Type</h4><p>jQuery<br><code>$.type(obj);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, &quot;$1&quot;).toLowerCase();</div></pre></td></tr></table></figure></p>\n<h2 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h2><h4 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h4><p>jQuery<br><code>$.getJSON(&#39;/my/url&#39;, function(data) {});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onreadystatechange = function() &#123;</div><div class=\"line\">  if (this.readyState === 4) &#123;</div><div class=\"line\">    if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;</div><div class=\"line\">      // Success!</div><div class=\"line\">      var data = JSON.parse(this.responseText);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      // Error :(</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div><div class=\"line\">request = null;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onload = function() &#123;</div><div class=\"line\">  if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123;</div><div class=\"line\">    // Success!</div><div class=\"line\">    var data = JSON.parse(request.responseText);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    // We reached our target server, but it returned an error</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.onerror = function() &#123;</div><div class=\"line\">  // There was a connection error of some sort</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onload = function() &#123;</div><div class=\"line\">  if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;</div><div class=\"line\">    // Success!</div><div class=\"line\">    var data = JSON.parse(this.response);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    // We reached our target server, but it returned an error</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.onerror = function() &#123;</div><div class=\"line\">  // There was a connection error of some sort</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div></pre></td></tr></table></figure></p>\n<h4 id=\"Post\"><a href=\"#Post\" class=\"headerlink\" title=\"Post\"></a>Post</h4><p>jQuery<br><code>$.ajax({type: &#39;POST&#39;,url: &#39;/my/url&#39;,data: data});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;POST&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;);</div><div class=\"line\">request.send(data);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a>Request</h4><p>jQuery<br><code>$.ajax({type: &#39;GET&#39;,url: &#39;/my/url&#39;,success: function(resp) {},error: function() {}});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onreadystatechange = function() &#123;</div><div class=\"line\">  if (this.readyState === 4) &#123;</div><div class=\"line\">    if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;</div><div class=\"line\">      // Success!</div><div class=\"line\">      var resp = this.responseText;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      // Error :(</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div><div class=\"line\">request = null;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onload = function() &#123;</div><div class=\"line\">  if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123;</div><div class=\"line\">    // Success!</div><div class=\"line\">    var resp = request.responseText;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    // We reached our target server, but it returned an error</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.onerror = function() &#123;</div><div class=\"line\">  // There was a connection error of some sort</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onload = function() &#123;</div><div class=\"line\">  if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;</div><div class=\"line\">    // Success!</div><div class=\"line\">    var resp = this.response;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    // We reached our target server, but it returned an error</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.onerror = function() &#123;</div><div class=\"line\">  // There was a connection error of some sort</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div></pre></td></tr></table></figure></p>\n<h2 id=\"特效\"><a href=\"#特效\" class=\"headerlink\" title=\"特效\"></a>特效</h2><h4 id=\"淡入淡出\"><a href=\"#淡入淡出\" class=\"headerlink\" title=\"淡入淡出\"></a>淡入淡出</h4><p>jQuery<br><code>$(el).fadeIn();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">function fadeIn(el) &#123;</div><div class=\"line\">  var opacity = 0;</div><div class=\"line\">  el.style.opacity = 0;</div><div class=\"line\">  el.style.filter = &apos;&apos;;</div><div class=\"line\">  var last = +new Date();</div><div class=\"line\">  var tick = function() &#123;</div><div class=\"line\">    opacity += (new Date() - last) / 400;</div><div class=\"line\">    el.style.opacity = opacity;</div><div class=\"line\">    el.style.filter = &apos;alpha(opacity=&apos; + (100 * opacity)|0 + &apos;)&apos;;</div><div class=\"line\">    last = +new Date();</div><div class=\"line\">    if (opacity &lt; 1) &#123;</div><div class=\"line\">      (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  tick();</div><div class=\"line\">&#125;</div><div class=\"line\">fadeIn(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><figcaption><span>fadeIn(el) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">  el.style.opacity = 0;</div><div class=\"line\">  var last = +new Date();</div><div class=\"line\">  var tick = function() &#123;</div><div class=\"line\">    el.style.opacity = +el.style.opacity + (new Date() - last) / 400;</div><div class=\"line\">    last = +new Date();</div><div class=\"line\">    if (+el.style.opacity &lt; 1) &#123;</div><div class=\"line\">      (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  tick();</div><div class=\"line\">&#125;</div><div class=\"line\">fadeIn(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">el.classList.add(&apos;show&apos;);</div><div class=\"line\">el.classList.remove(&apos;hide&apos;);</div><div class=\"line\">.show &#123;transition: opacity 400ms;&#125;</div><div class=\"line\">.hide &#123;opacity: 0;&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Hide\"><a href=\"#Hide\" class=\"headerlink\" title=\"Hide\"></a>Hide</h4><p>jQuery<br><code>$(el).hide();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.style.display = &#39;none&#39;;</code></p>\n<h4 id=\"Show\"><a href=\"#Show\" class=\"headerlink\" title=\"Show\"></a>Show</h4><p>jQuery<br><code>$(el).show();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.style.display = &#39;&#39;;</code></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>jQuery是非常优秀的工具，它能让我们开发项目时变得更容易，但如果你想从零开始开发一个全新的项目，你应该考虑一下你的项目是否真的需要引入jQuery。</p>\n<ul>\n<li>也许你只需要几行技巧性的代码就能解决问题。如果你的项目是面向最新的现代浏览器，你真的可以考虑其它的一些简单的技术来代替jQuery。</li>\n<li>浏览器的进步给我们带来了很多先进的JavaScript特征，新出现的原生内置(native)JavaScript功能可以很大程度的实现jQuery提供的功能。如果你能了解这些JavaScript新技术，就能在很多地方用纯JavaScript实现以前需要jQuery才能实现的技术。</li>\n<li>新的mvvm框架的出现，数据驱动的方式解决了项目数据交互量大的时候，操作dom的代码混乱的问题。<h2 id=\"元素操作\"><a href=\"#元素操作\" class=\"headerlink\" title=\"元素操作\"></a>元素操作</h2><h4 id=\"addClass\"><a href=\"#addClass\" class=\"headerlink\" title=\"addClass\"></a>addClass</h4>jQuery<br><code>$(el).addClass(className);</code><br>谷歌浏览器，火狐浏览器，IE8+<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList)</div><div class=\"line\">  el.classList.add(className);</div><div class=\"line\">else</div><div class=\"line\">  el.className += &apos; &apos; + className;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><code>el.classList.add(className);</code></p>\n<h4 id=\"After\"><a href=\"#After\" class=\"headerlink\" title=\"After\"></a>After</h4><p>jQuery<br><code>$(el).after(htmlString);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.insertAdjacentHTML(&#39;afterend&#39;, htmlString);</code></p>\n<h4 id=\"Append\"><a href=\"#Append\" class=\"headerlink\" title=\"Append\"></a>Append</h4><p>jQuery<br><code>$(parent).append(el);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>parent.appendChild(el);</code></p>\n<h4 id=\"Before\"><a href=\"#Before\" class=\"headerlink\" title=\"Before\"></a>Before</h4><p>jQuery<br><code>$(el).before(htmlString);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.insertAdjacentHTML(&#39;beforebegin&#39;, htmlString);</code></p>\n<h4 id=\"Children\"><a href=\"#Children\" class=\"headerlink\" title=\"Children\"></a>Children</h4><p>jQuery<br><code>$(el).children();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var children = [];</div><div class=\"line\">for (var i = el.children.length; i--;) &#123;</div><div class=\"line\">  // Skip comment nodes on IE8</div><div class=\"line\">  if (el.children[i].nodeType != 8)</div><div class=\"line\">    children.unshift(el.children[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.children</code><br>","more":"</p>\n<h4 id=\"Clone\"><a href=\"#Clone\" class=\"headerlink\" title=\"Clone\"></a>Clone</h4><p>jQuery<br><code>$(el).clone();</code><br>谷歌浏览器，火狐浏览器，IE8+<br>`el.cloneNode(true);``</p>\n<h4 id=\"Contains\"><a href=\"#Contains\" class=\"headerlink\" title=\"Contains\"></a>Contains</h4><p>jQuery<br><code>$.contains(el, child);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el !== child &amp;&amp; el.contains(child);</code></p>\n<h4 id=\"Contains-Selector\"><a href=\"#Contains-Selector\" class=\"headerlink\" title=\"Contains Selector\"></a>Contains Selector</h4><p>jQuery<br><code>$(el).find(selector).length;</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.querySelector(selector) !== null</code></p>\n<h4 id=\"Each\"><a href=\"#Each\" class=\"headerlink\" title=\"Each\"></a>Each</h4><p>jQuery<br><code>$(selector).each(function(i, el){});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function forEachElement(selector, fn) &#123;</div><div class=\"line\">  var elements = document.querySelectorAll(selector);</div><div class=\"line\">  for (var i = 0; i &lt; elements.length; i++)</div><div class=\"line\">    fn(elements[i], i);</div><div class=\"line\">&#125;</div><div class=\"line\">forEachElement(selector, function(el, i)&#123;&#125;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var elements = document.querySelectorAll(selector);</div><div class=\"line\">Array.prototype.forEach.call(elements, function(el, i)&#123;&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Empty\"><a href=\"#Empty\" class=\"headerlink\" title=\"Empty\"></a>Empty</h4><p>jQuery<br><code>$(el).empty();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">while(el.firstChild)</div><div class=\"line\">  el.removeChild(el.firstChild);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.innerHTML = &#39;&#39;;</code></p>\n<h4 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h4><p>jQuery<br><code>$(selector).filter(filterFn);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function filter(selector, filterFn) &#123;</div><div class=\"line\">  var elements = document.querySelectorAll(selector);</div><div class=\"line\">  var out = [];</div><div class=\"line\">  for (var i = elements.length; i--;) &#123;</div><div class=\"line\">    if (filterFn(elements[i]))&#123;</div><div class=\"line\">      out.unshift(elements[i]);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return out;</div><div class=\"line\">&#125;</div><div class=\"line\">filter(selector, filterFn);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>Array.prototype.filter.call(document.querySelectorAll(selector), filterFn);</code></p>\n<h4 id=\"查找子元素\"><a href=\"#查找子元素\" class=\"headerlink\" title=\"查找子元素\"></a>查找子元素</h4><p>jQuery<br><code>$(el).find(selector);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.querySelectorAll(selector);</code></p>\n<h4 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h4><p>jQuery<br><code>$(&#39;.my #awesome selector&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>document.querySelectorAll(&#39;.my #awesome selector&#39;);</code></p>\n<h4 id=\"获取属性值\"><a href=\"#获取属性值\" class=\"headerlink\" title=\"获取属性值\"></a>获取属性值</h4><p>jQuery<br><code>$(el).attr(&#39;tabindex&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.getAttribute(&#39;tabindex&#39;);</code></p>\n<h4 id=\"获取Html内容\"><a href=\"#获取Html内容\" class=\"headerlink\" title=\"获取Html内容\"></a>获取Html内容</h4><p>jQuery<br><code>$(el).html();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.innerHTML</code></p>\n<h4 id=\"获取外层Html内容\"><a href=\"#获取外层Html内容\" class=\"headerlink\" title=\"获取外层Html内容\"></a>获取外层Html内容</h4><p>jQuery<br><code>$(&#39;&lt;div&gt;&#39;).append($(el).clone()).html();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.outerHTML</code></p>\n<h4 id=\"获取CSS样式\"><a href=\"#获取CSS样式\" class=\"headerlink\" title=\"获取CSS样式\"></a>获取CSS样式</h4><p>jQuery<br><code>$(el).css(ruleName);</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// Varies based on the properties being retrieved, some can be retrieved from</p>\n<p>el.currentStyle<br>// <a href=\"https://github.com/jonathantneal/Polyfills-for-IE8/blob/master/\" target=\"_blank\" rel=\"external\">https://github.com/jonathantneal/Polyfills-for-IE8/blob/master/</a></p>\n<p>getComputedStyle.js<br>谷歌浏览器，火狐浏览器，IE9+<br><code>getComputedStyle(el)[ruleName];</code></p>\n<h4 id=\"获取文本内容\"><a href=\"#获取文本内容\" class=\"headerlink\" title=\"获取文本内容\"></a>获取文本内容</h4><p>jQuery<br><code>$(el).text();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.textContent || el.innerText</code><br>谷歌浏览器，火狐浏览器，IE9+<br><code>el.textContent</code></p>\n<h4 id=\"Has-Class\"><a href=\"#Has-Class\" class=\"headerlink\" title=\"Has Class\"></a>Has Class</h4><p>jQuery<br><code>$(el).hasClass(className);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList)&#123;</div><div class=\"line\">  el.classList.contains(className);</div><div class=\"line\">&#125;</div><div class=\"line\">else&#123;</div><div class=\"line\">  new RegExp(&apos;(^| )&apos; + className + &apos;( |$)&apos;, &apos;gi&apos;).test(el.className);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><code>el.classList.contains(className);</code></p>\n<h4 id=\"元素比较\"><a href=\"#元素比较\" class=\"headerlink\" title=\"元素比较\"></a>元素比较</h4><p>jQuery<br><code>$(el).is($(otherEl));</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el === otherEl</code></p>\n<h4 id=\"比较类名\"><a href=\"#比较类名\" class=\"headerlink\" title=\"比较类名\"></a>比较类名</h4><p>jQuery<br><code>$(el).is(&#39;.my-class&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var matches = function(el, selector) &#123;</div><div class=\"line\">  var _matches = (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector);</div><div class=\"line\">  if (_matches) &#123;</div><div class=\"line\">    return _matches.call(el, selector);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    var nodes = el.parentNode.querySelectorAll(selector);</div><div class=\"line\">    for (var i = nodes.length; i--;) &#123;</div><div class=\"line\">      if (nodes[i] === el)</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">matches(el, &apos;.my-class&apos;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var matches = function(el, selector) &#123;</div><div class=\"line\">  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);</div><div class=\"line\">&#125;;</div><div class=\"line\">matches(el, &apos;.my-class&apos;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Next\"><a href=\"#Next\" class=\"headerlink\" title=\"Next\"></a>Next</h4><p>jQuery<br><code>$(el).next();</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// nextSibling can include text nodes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function nextElementSibling(el) &#123;</div><div class=\"line\">  do &#123; el = el.nextSibling; &#125; while ( el &amp;&amp; el.nodeType !== 1 );</div><div class=\"line\">  return el;</div><div class=\"line\">&#125;</div><div class=\"line\">el.nextElementSibling || nextElementSibling(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.nextElementSibling</code></p>\n<h4 id=\"Offset\"><a href=\"#Offset\" class=\"headerlink\" title=\"Offset\"></a>Offset</h4><p>jQuery<br><code>$(el).offset();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var rect = el.getBoundingClientRect()</div><div class=\"line\">&#123;</div><div class=\"line\">  top: rect.top + document.body.scrollTop,</div><div class=\"line\">  left: rect.left + document.body.scrollLeft</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Offset-Parent\"><a href=\"#Offset-Parent\" class=\"headerlink\" title=\"Offset Parent\"></a>Offset Parent</h4><p>jQuery<br><code>$(el).offsetParent();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.offsetParent || el</code></p>\n<h4 id=\"Outer-Height\"><a href=\"#Outer-Height\" class=\"headerlink\" title=\"Outer Height\"></a>Outer Height</h4><p>jQuery<br><code>$(el).outerHeight();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.offsetHeight</code></p>\n<h4 id=\"Outer-Height-With-Margin\"><a href=\"#Outer-Height-With-Margin\" class=\"headerlink\" title=\"Outer Height With Margin\"></a>Outer Height With Margin</h4><p>jQuery<br><code>$(el).outerHeight(true);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerHeight(el) &#123;</div><div class=\"line\">  var height = el.offsetHeight;</div><div class=\"line\">  var style = el.currentStyle || getComputedStyle(el);</div><div class=\"line\"></div><div class=\"line\">  height += parseInt(style.marginTop) + parseInt(style.marginBottom);</div><div class=\"line\">  return height;</div><div class=\"line\">&#125;</div><div class=\"line\">outerHeight(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerHeight(el) &#123;</div><div class=\"line\">  var height = el.offsetHeight;</div><div class=\"line\">  var style = getComputedStyle(el);</div><div class=\"line\"></div><div class=\"line\">  height += parseInt(style.marginTop) + parseInt(style.marginBottom);</div><div class=\"line\">  return height;</div><div class=\"line\">&#125;</div><div class=\"line\">outerHeight(el);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Outer-Width-With-Margin\"><a href=\"#Outer-Width-With-Margin\" class=\"headerlink\" title=\"Outer Width With Margin\"></a>Outer Width With Margin</h4><p>jQuery<br><code>$(el).outerWidth(true);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerWidth(el) &#123;</div><div class=\"line\">  var width = el.offsetWidth;</div><div class=\"line\">  var style = el.currentStyle || getComputedStyle(el);</div><div class=\"line\"></div><div class=\"line\">  width += parseInt(style.marginLeft) + parseInt(style.marginRight);</div><div class=\"line\">  return width;</div><div class=\"line\">&#125;</div><div class=\"line\">outerWidth(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function outerWidth(el) &#123;</div><div class=\"line\">  var width = el.offsetWidth;</div><div class=\"line\">  var style = getComputedStyle(el);</div><div class=\"line\"></div><div class=\"line\">  width += parseInt(style.marginLeft) + parseInt(style.marginRight);</div><div class=\"line\">  return width;</div><div class=\"line\">&#125;</div><div class=\"line\">outerWidth(el);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Outer-Width\"><a href=\"#Outer-Width\" class=\"headerlink\" title=\"Outer Width\"></a>Outer Width</h4><p>jQuery<br><code>$(el).outerWidth();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.offsetWidth</code></p>\n<h4 id=\"Parent\"><a href=\"#Parent\" class=\"headerlink\" title=\"Parent\"></a>Parent</h4><p>jQuery<br><code>$(el).parent();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.parentNode</code></p>\n<h4 id=\"Position\"><a href=\"#Position\" class=\"headerlink\" title=\"Position\"></a>Position</h4><p>jQuery<br><code>$(el).position();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>{left: el.offsetLeft, top: el.offsetTop}</code></p>\n<h4 id=\"Position-Relative-To-Viewport\"><a href=\"#Position-Relative-To-Viewport\" class=\"headerlink\" title=\"Position Relative To Viewport\"></a>Position Relative To Viewport</h4><p>jQuery<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var offset = el.offset();</div><div class=\"line\">&#123;</div><div class=\"line\">  top: offset.top - document.body.scrollTop,</div><div class=\"line\">  left: offset.left - document.body.scrollLeft</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE8+<br><code>el.getBoundingClientRect()</code></p>\n<h4 id=\"Prepend\"><a href=\"#Prepend\" class=\"headerlink\" title=\"Prepend\"></a>Prepend</h4><p>jQuery<br><code>$(parent).prepend(el);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>parent.insertBefore(el, parent.firstChild);</code></p>\n<h4 id=\"Prev\"><a href=\"#Prev\" class=\"headerlink\" title=\"Prev\"></a>Prev</h4><p>jQuery<br><code>$(el).prev();</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// prevSibling can include text nodes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function previousElementSibling(el) &#123;</div><div class=\"line\">  do &#123; el = el.previousSibling; &#125; while ( el &amp;&amp; el.nodeType !== 1 );</div><div class=\"line\">  return el;</div><div class=\"line\">&#125;</div><div class=\"line\">el.previousElementSibling || previousElementSibling(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.previousElementSibling</code></p>\n<h4 id=\"Remove\"><a href=\"#Remove\" class=\"headerlink\" title=\"Remove\"></a>Remove</h4><p>jQuery<br><code>$(el).remove();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.parentNode.removeChild(el);</code></p>\n<h4 id=\"Remove-Class\"><a href=\"#Remove-Class\" class=\"headerlink\" title=\"Remove Class\"></a>Remove Class</h4><p>jQuery<br><code>$(el).removeClass(className);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList)</div><div class=\"line\">  el.classList.remove(className);</div><div class=\"line\">else</div><div class=\"line\">  el.className = el.className.replace(new RegExp(&apos;(^|\\\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\\\b|$)&apos;, &apos;gi&apos;), &apos; &apos;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><code>el.classList.remove(className);</code></p>\n<h4 id=\"Replace-From-Html\"><a href=\"#Replace-From-Html\" class=\"headerlink\" title=\"Replace From Html\"></a>Replace From Html</h4><p>jQuery<br><code>$(el).replaceWith(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.outerHTML = string;</code></p>\n<h4 id=\"Set-Attributes\"><a href=\"#Set-Attributes\" class=\"headerlink\" title=\"Set Attributes\"></a>Set Attributes</h4><p>jQuery<br><code>$(el).attr(&#39;tabindex&#39;, 3);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.setAttribute(&#39;tabindex&#39;, 3);</code></p>\n<h4 id=\"Set-Html\"><a href=\"#Set-Html\" class=\"headerlink\" title=\"Set Html\"></a>Set Html</h4><p>jQuery<br><code>$(el).html(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.innerHTML = string;</code></p>\n<h4 id=\"Set-Style\"><a href=\"#Set-Style\" class=\"headerlink\" title=\"Set Style\"></a>Set Style</h4><p>jQuery<br><code>$(el).css(&#39;border-width&#39;, &#39;20px&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// Use a class if possible<br><code>el.style.borderWidth = &#39;20px&#39;;</code></p>\n<h4 id=\"Set-Text\"><a href=\"#Set-Text\" class=\"headerlink\" title=\"Set Text\"></a>Set Text</h4><p>jQuery<br><code>$(el).text(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.textContent !== undefined)</div><div class=\"line\">  el.textContent = string;</div><div class=\"line\">else</div><div class=\"line\">  el.innerText = string;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.textContent = string;</code></p>\n<h4 id=\"Siblings\"><a href=\"#Siblings\" class=\"headerlink\" title=\"Siblings\"></a>Siblings</h4><p>jQuery<br><code>$(el).siblings();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var siblings = Array.prototype.slice.call(el.parentNode.children);</div><div class=\"line\">for (var i = siblings.length; i--;) &#123;</div><div class=\"line\">  if (siblings[i] === el) &#123;</div><div class=\"line\">    siblings.splice(i, 1);</div><div class=\"line\">    break;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>Array.prototype.filter.call(el.parentNode.children, function(child){\n  return child !== el;\n});</code></p>\n<h4 id=\"Toggle-Class\"><a href=\"#Toggle-Class\" class=\"headerlink\" title=\"Toggle Class\"></a>Toggle Class</h4><p>jQuery<br><code>$(el).toggleClass(className);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList) &#123;</div><div class=\"line\">  el.classList.toggle(className);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    var classes = el.className.split(&apos; &apos;);</div><div class=\"line\">    var existingIndex = -1;</div><div class=\"line\">    for (var i = classes.length; i--;) &#123;</div><div class=\"line\">      if (classes[i] === className)</div><div class=\"line\">        existingIndex = i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (existingIndex &gt;= 0)</div><div class=\"line\">      classes.splice(existingIndex, 1);</div><div class=\"line\">    else</div><div class=\"line\">      classes.push(className);</div><div class=\"line\">  el.className = classes.join(&apos; &apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (el.classList) &#123;</div><div class=\"line\">  el.classList.toggle(className);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  var classes = el.className.split(&apos; &apos;);</div><div class=\"line\">  var existingIndex = classes.indexOf(className);</div><div class=\"line\">  if (existingIndex &gt;= 0)</div><div class=\"line\">    classes.splice(existingIndex, 1);</div><div class=\"line\">  else</div><div class=\"line\">    classes.push(className);</div><div class=\"line\">  el.className = classes.join(&apos; &apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><code>el.classList.toggle(className);</code></p>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><h4 id=\"Off\"><a href=\"#Off\" class=\"headerlink\" title=\"#### Off\"></a>#### Off</h4><p>jQuery<br><code>$(el).off(eventName, eventHandler);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function removeEventListener(el, eventName, handler) &#123;</div><div class=\"line\">  if (el.removeEventListener)</div><div class=\"line\">    el.removeEventListener(eventName, handler);</div><div class=\"line\">  else</div><div class=\"line\">    el.detachEvent(&apos;on&apos; + eventName, handler);</div><div class=\"line\">&#125;</div><div class=\"line\">removeEventListener(el, eventName, handler);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.removeEventListener(eventName, eventHandler);</code></p>\n<h4 id=\"On\"><a href=\"#On\" class=\"headerlink\" title=\"On\"></a>On</h4><p>jQuery<br><code>$(el).on(eventName, eventHandler);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function addEventListener(el, eventName, handler) &#123;</div><div class=\"line\">  if (el.addEventListener) &#123;</div><div class=\"line\">    el.addEventListener(eventName, handler);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    el.attachEvent(&apos;on&apos; + eventName, function()&#123;</div><div class=\"line\">      handler.call(el);</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">addEventListener(el, eventName, handler);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>el.addEventListener(eventName, eventHandler);</code></p>\n<h4 id=\"Ready\"><a href=\"#Ready\" class=\"headerlink\" title=\"Ready\"></a>Ready</h4><p>jQuery<br><code>$(document).ready(function(){});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function ready(fn) &#123;</div><div class=\"line\">  if (document.readyState != &apos;loading&apos;)&#123;</div><div class=\"line\">    fn();</div><div class=\"line\">  &#125; else if (document.addEventListener) &#123;</div><div class=\"line\">    document.addEventListener(&apos;DOMContentLoaded&apos;, fn);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    document.attachEvent(&apos;onreadystatechange&apos;, function() &#123;</div><div class=\"line\">      if (document.readyState != &apos;loading&apos;)</div><div class=\"line\">        fn();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function ready(fn) &#123;</div><div class=\"line\">  if (document.readyState != &apos;loading&apos;)&#123;</div><div class=\"line\">    fn();</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    document.addEventListener(&apos;DOMContentLoaded&apos;, fn);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"指定事件触发\"><a href=\"#指定事件触发\" class=\"headerlink\" title=\"指定事件触发\"></a>指定事件触发</h4><p>jQuery<br><code>$(el).trigger(&#39;my-event&#39;, {some: &#39;data&#39;});</code><br>谷歌浏览器，火狐浏览器，IE8+<br>// Custom events are not natively supported, so you have to hijack a rndomevent.<br>// Just use jQuery.<br>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (window.CustomEvent) &#123;</div><div class=\"line\">  var event = new CustomEvent(&apos;my-event&apos;, &#123;detail: &#123;some: &apos;data&apos;&#125;&#125;);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  var event = document.createEvent(&apos;CustomEvent&apos;);</div><div class=\"line\">  event.initCustomEvent(&apos;my-event&apos;, true, true, &#123;some: &apos;data&apos;&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">el.dispatchEvent(event);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Trigger-Native\"><a href=\"#Trigger-Native\" class=\"headerlink\" title=\"Trigger Native\"></a>Trigger Native</h4><p>jQuery<br><code>$(el).trigger(&#39;change&#39;);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (document.createEvent) &#123;</div><div class=\"line\">  var event = document.createEvent(&apos;HTMLEvents&apos;);</div><div class=\"line\">  event.initEvent(&apos;change&apos;, true, false);</div><div class=\"line\">  el.dispatchEvent(event);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  el.fireEvent(&apos;onchange&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br>// For a full list of event types: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var event = document.createEvent(&apos;HTMLEvents&apos;);</div><div class=\"line\">event.initEvent(&apos;change&apos;, true, false);</div><div class=\"line\">el.dispatchEvent(event);</div></pre></td></tr></table></figure></p>\n<h2 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h2><h4 id=\"Array-Each\"><a href=\"#Array-Each\" class=\"headerlink\" title=\"Array Each\"></a>Array Each</h4><p>jQuery<br><code>$.each(array, function(i, item){});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function forEach(array, fn) &#123;</div><div class=\"line\">  for (i = 0; i &lt; array.length; i++)</div><div class=\"line\">    fn(array[i], i);</div><div class=\"line\">&#125;</div><div class=\"line\">forEach(array, function(item, i)&#123;&#125;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>array.forEach(function(item, i){});</code></p>\n<h4 id=\"深度扩展\"><a href=\"#深度扩展\" class=\"headerlink\" title=\"深度扩展\"></a>深度扩展</h4><p>jQuery<br><code>$.extend(true, {}, objA, objB);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var deepExtend = function(out) &#123;</div><div class=\"line\">  out = out || &#123;&#125;;</div><div class=\"line\">  for (var i = 1; i &lt; arguments.length; i++) &#123;</div><div class=\"line\">    var obj = arguments[i];</div><div class=\"line\">    if (!obj)</div><div class=\"line\">      continue;</div><div class=\"line\">    for (var key in obj) &#123;</div><div class=\"line\">      if (obj.hasOwnProperty(key)) &#123;</div><div class=\"line\">        if (typeof obj[key] === &apos;object&apos;)</div><div class=\"line\">          deepExtend(out[key], obj[key]);</div><div class=\"line\">        else</div><div class=\"line\">          out[key] = obj[key];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return out;</div><div class=\"line\">&#125;;</div><div class=\"line\">deepExtend(&#123;&#125;, objA, objB);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Bind\"><a href=\"#Bind\" class=\"headerlink\" title=\"Bind\"></a>Bind</h4><p>jQuery<br><code>$.proxy(fn, context);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>fn.apply(context, arguments);</code><br>谷歌浏览器，火狐浏览器，IE9+<br><code>fn.bind(context);</code><br>jQuery<br><code>$.extend({}, objA, objB);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var extend = function(out) &#123;</div><div class=\"line\">  out = out || &#123;&#125;;</div><div class=\"line\">  for (var i = 1; i &lt; arguments.length; i++) &#123;</div><div class=\"line\">    if (!arguments[i])</div><div class=\"line\">      continue;</div><div class=\"line\">    for (var key in arguments[i]) &#123;</div><div class=\"line\">      if (arguments[i].hasOwnProperty(key))</div><div class=\"line\">        out[key] = arguments[i][key];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return out;</div><div class=\"line\">&#125;;</div><div class=\"line\">extend(&#123;&#125;, objA, objB);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Index-Of\"><a href=\"#Index-Of\" class=\"headerlink\" title=\"Index Of\"></a>Index Of</h4><p>jQuery<br><code>$.inArray(item, array);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function indexOf(array, item) &#123;</div><div class=\"line\">  for (var i = 0; i &lt; array.length; i++) &#123;</div><div class=\"line\">    if (array[i] === item)</div><div class=\"line\">      return i;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return -1;</div><div class=\"line\">&#125;</div><div class=\"line\">indexOf(array, item);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>array.indexOf(item);</code></p>\n<h4 id=\"Is-Array\"><a href=\"#Is-Array\" class=\"headerlink\" title=\"Is Array\"></a>Is Array</h4><p>jQuery<br><code>$.isArray(arr);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">isArray = Array.isArray || function(arr) &#123;</div><div class=\"line\">  return Object.prototype.toString.call(arr) == &apos;[object Array]&apos;;</div><div class=\"line\">&#125;</div><div class=\"line\">isArray(arr);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>Array.isArray(arr);</code></p>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><p>jQuery<br><code>$.map(array, function(value, index){});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">function map(arr, fn) &#123;</div><div class=\"line\">  var results = [];</div><div class=\"line\">  for (var i = 0; i &lt; arr.length; i++)</div><div class=\"line\">    results.push(fn(arr[i], i));</div><div class=\"line\">  return results;</div><div class=\"line\">map(array, function(value, index)&#123;&#125;);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>array.map(function(value, index){});</code></p>\n<h4 id=\"Now\"><a href=\"#Now\" class=\"headerlink\" title=\"Now\"></a>Now</h4><p>jQuery<br><code>$.now();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>new Date().getTime();</code><br>谷歌浏览器，火狐浏览器，IE9+<br><code>Date.now();</code></p>\n<h4 id=\"Parse-Html\"><a href=\"#Parse-Html\" class=\"headerlink\" title=\"Parse Html\"></a>Parse Html</h4><p>jQuery<br><code>$.parseHTML(htmlString);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var parseHTML = function(str) &#123;</div><div class=\"line\">  var el = document.createElement(&apos;div&apos;);</div><div class=\"line\">  el.innerHTML = str;</div><div class=\"line\">  return el.children;</div><div class=\"line\">&#125;;</div><div class=\"line\">parseHTML(htmlString);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><code>var parseHTML = function(str) {\n  var tmp = document.implementation.createHTMLDocument();\n  tmp.body.innerHTML = str;\n  return tmp.body.children;\n};\nparseHTML(htmlString);</code></p>\n<h4 id=\"解析-Json\"><a href=\"#解析-Json\" class=\"headerlink\" title=\"解析 Json\"></a>解析 Json</h4><p>jQuery<br><code>$.parseJSON(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>JSON.parse(string);</code></p>\n<h4 id=\"Trim\"><a href=\"#Trim\" class=\"headerlink\" title=\"Trim\"></a>Trim</h4><p>jQuery<br><code>$.trim(string);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>string.replace(/^\\s+|\\s+$/g, &#39;&#39;);</code><br>谷歌浏览器，火狐浏览器，IE9+<br><code>string.trim();</code></p>\n<h4 id=\"Type\"><a href=\"#Type\" class=\"headerlink\" title=\"Type\"></a>Type</h4><p>jQuery<br><code>$.type(obj);</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, &quot;$1&quot;).toLowerCase();</div></pre></td></tr></table></figure></p>\n<h2 id=\"AJAX\"><a href=\"#AJAX\" class=\"headerlink\" title=\"AJAX\"></a>AJAX</h2><h4 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h4><p>jQuery<br><code>$.getJSON(&#39;/my/url&#39;, function(data) {});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onreadystatechange = function() &#123;</div><div class=\"line\">  if (this.readyState === 4) &#123;</div><div class=\"line\">    if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;</div><div class=\"line\">      // Success!</div><div class=\"line\">      var data = JSON.parse(this.responseText);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      // Error :(</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div><div class=\"line\">request = null;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onload = function() &#123;</div><div class=\"line\">  if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123;</div><div class=\"line\">    // Success!</div><div class=\"line\">    var data = JSON.parse(request.responseText);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    // We reached our target server, but it returned an error</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.onerror = function() &#123;</div><div class=\"line\">  // There was a connection error of some sort</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onload = function() &#123;</div><div class=\"line\">  if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;</div><div class=\"line\">    // Success!</div><div class=\"line\">    var data = JSON.parse(this.response);</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    // We reached our target server, but it returned an error</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.onerror = function() &#123;</div><div class=\"line\">  // There was a connection error of some sort</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div></pre></td></tr></table></figure></p>\n<h4 id=\"Post\"><a href=\"#Post\" class=\"headerlink\" title=\"Post\"></a>Post</h4><p>jQuery<br><code>$.ajax({type: &#39;POST&#39;,url: &#39;/my/url&#39;,data: data});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;POST&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;);</div><div class=\"line\">request.send(data);</div></pre></td></tr></table></figure></p>\n<h4 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a>Request</h4><p>jQuery<br><code>$.ajax({type: &#39;GET&#39;,url: &#39;/my/url&#39;,success: function(resp) {},error: function() {}});</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onreadystatechange = function() &#123;</div><div class=\"line\">  if (this.readyState === 4) &#123;</div><div class=\"line\">    if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;</div><div class=\"line\">      // Success!</div><div class=\"line\">      var resp = this.responseText;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      // Error :(</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div><div class=\"line\">request = null;</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onload = function() &#123;</div><div class=\"line\">  if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123;</div><div class=\"line\">    // Success!</div><div class=\"line\">    var resp = request.responseText;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    // We reached our target server, but it returned an error</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.onerror = function() &#123;</div><div class=\"line\">  // There was a connection error of some sort</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">var request = new XMLHttpRequest();</div><div class=\"line\">request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);</div><div class=\"line\">request.onload = function() &#123;</div><div class=\"line\">  if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123;</div><div class=\"line\">    // Success!</div><div class=\"line\">    var resp = this.response;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    // We reached our target server, but it returned an error</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">request.onerror = function() &#123;</div><div class=\"line\">  // There was a connection error of some sort</div><div class=\"line\">&#125;;</div><div class=\"line\">request.send();</div></pre></td></tr></table></figure></p>\n<h2 id=\"特效\"><a href=\"#特效\" class=\"headerlink\" title=\"特效\"></a>特效</h2><h4 id=\"淡入淡出\"><a href=\"#淡入淡出\" class=\"headerlink\" title=\"淡入淡出\"></a>淡入淡出</h4><p>jQuery<br><code>$(el).fadeIn();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">function fadeIn(el) &#123;</div><div class=\"line\">  var opacity = 0;</div><div class=\"line\">  el.style.opacity = 0;</div><div class=\"line\">  el.style.filter = &apos;&apos;;</div><div class=\"line\">  var last = +new Date();</div><div class=\"line\">  var tick = function() &#123;</div><div class=\"line\">    opacity += (new Date() - last) / 400;</div><div class=\"line\">    el.style.opacity = opacity;</div><div class=\"line\">    el.style.filter = &apos;alpha(opacity=&apos; + (100 * opacity)|0 + &apos;)&apos;;</div><div class=\"line\">    last = +new Date();</div><div class=\"line\">    if (opacity &lt; 1) &#123;</div><div class=\"line\">      (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  tick();</div><div class=\"line\">&#125;</div><div class=\"line\">fadeIn(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE9+<br><figure class=\"highlight plain\"><figcaption><span>fadeIn(el) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">  el.style.opacity = 0;</div><div class=\"line\">  var last = +new Date();</div><div class=\"line\">  var tick = function() &#123;</div><div class=\"line\">    el.style.opacity = +el.style.opacity + (new Date() - last) / 400;</div><div class=\"line\">    last = +new Date();</div><div class=\"line\">    if (+el.style.opacity &lt; 1) &#123;</div><div class=\"line\">      (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">  tick();</div><div class=\"line\">&#125;</div><div class=\"line\">fadeIn(el);</div></pre></td></tr></table></figure></p>\n<p>谷歌浏览器，火狐浏览器，IE10+<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">el.classList.add(&apos;show&apos;);</div><div class=\"line\">el.classList.remove(&apos;hide&apos;);</div><div class=\"line\">.show &#123;transition: opacity 400ms;&#125;</div><div class=\"line\">.hide &#123;opacity: 0;&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"Hide\"><a href=\"#Hide\" class=\"headerlink\" title=\"Hide\"></a>Hide</h4><p>jQuery<br><code>$(el).hide();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.style.display = &#39;none&#39;;</code></p>\n<h4 id=\"Show\"><a href=\"#Show\" class=\"headerlink\" title=\"Show\"></a>Show</h4><p>jQuery<br><code>$(el).show();</code><br>谷歌浏览器，火狐浏览器，IE8+<br><code>el.style.display = &#39;&#39;;</code></p>"},{"title":"使用ES2015全局对象--webpack下添加polyfill","date":"2017-01-22T08:32:07.000Z","_content":"\n>公司使用的技术栈是*react全家桶*，使用*axios*进行ajax通信,axios使用的基于**Promise**实现。在现代浏览器上使用并没有什么问题，但是~~IE全系列不支持Promise~~，包括IE11...\n\n本来想着使用babel后，将代码转换为es5，应该在IE10以上兼容运行，但是实际运行时，报错，没有Promise...orz\n\n长话短说，解决方案：[babel-polyfill](http://babeljs.io/docs/usage/polyfill/)\n\n<!--more-->\n\n------\n\n原来在.babelrc里面添加的是 *babel-plugin-transform-runtime*，但是在这里并不管用，究竟是为什么呢？\n\n- babel-polyfill 使用场景\n\nBabel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。\n\n- babel-runtime 使用场景\n\nBabel 转译后的代码要实现源代码同样的功能需要借助一些帮助函数，例如，{ [name]: 'JavaScript' } 转译后的代码如下所示：\n{% codeblock lang:javascript %}\n\t'use strict';\n\tfunction _defineProperty(obj, key, value) {\n\t  if (key in obj) {\n\t    Object.defineProperty(obj, key, {\n\t      value: value,\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true\n\t    });\n\t  } else {\n\t    obj[key] = value;\n\t  }\n\t  return obj;\n\t}\n\tvar obj = _defineProperty({}, 'name', 'JavaScript');\n{% endcodeblock %}\n\n类似上面的帮助函数 _defineProperty 可能会重复出现在一些模块里，导致编译后的代码体积变大。Babel 为了解决这个问题，提供了单独的包 babel-runtime 供编译模块复用工具函数。\n\n启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数，转译代码如下：\n{% codeblock lang:javascript %}\n'use strict';\n// 之前的 _defineProperty 函数已经作为公共模块 `babel-runtime/helpers/defineProperty` 使用\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar obj = (0, _defineProperty3.default)({}, 'name', 'JavaScript');\n{% endcodeblock %}","source":"_posts/使用ES2015全局对象--webpack下添加polyfill.md","raw":"---\ntitle: 使用ES2015全局对象--webpack下添加polyfill\ndate: 2017-01-22 16:32:07\ntags: webpack babel\n---\n\n>公司使用的技术栈是*react全家桶*，使用*axios*进行ajax通信,axios使用的基于**Promise**实现。在现代浏览器上使用并没有什么问题，但是~~IE全系列不支持Promise~~，包括IE11...\n\n本来想着使用babel后，将代码转换为es5，应该在IE10以上兼容运行，但是实际运行时，报错，没有Promise...orz\n\n长话短说，解决方案：[babel-polyfill](http://babeljs.io/docs/usage/polyfill/)\n\n<!--more-->\n\n------\n\n原来在.babelrc里面添加的是 *babel-plugin-transform-runtime*，但是在这里并不管用，究竟是为什么呢？\n\n- babel-polyfill 使用场景\n\nBabel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。\n\n- babel-runtime 使用场景\n\nBabel 转译后的代码要实现源代码同样的功能需要借助一些帮助函数，例如，{ [name]: 'JavaScript' } 转译后的代码如下所示：\n{% codeblock lang:javascript %}\n\t'use strict';\n\tfunction _defineProperty(obj, key, value) {\n\t  if (key in obj) {\n\t    Object.defineProperty(obj, key, {\n\t      value: value,\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true\n\t    });\n\t  } else {\n\t    obj[key] = value;\n\t  }\n\t  return obj;\n\t}\n\tvar obj = _defineProperty({}, 'name', 'JavaScript');\n{% endcodeblock %}\n\n类似上面的帮助函数 _defineProperty 可能会重复出现在一些模块里，导致编译后的代码体积变大。Babel 为了解决这个问题，提供了单独的包 babel-runtime 供编译模块复用工具函数。\n\n启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数，转译代码如下：\n{% codeblock lang:javascript %}\n'use strict';\n// 之前的 _defineProperty 函数已经作为公共模块 `babel-runtime/helpers/defineProperty` 使用\nvar _defineProperty2 = require('babel-runtime/helpers/defineProperty');\nvar _defineProperty3 = _interopRequireDefault(_defineProperty2);\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar obj = (0, _defineProperty3.default)({}, 'name', 'JavaScript');\n{% endcodeblock %}","slug":"使用ES2015全局对象--webpack下添加polyfill","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfe3001uzk4ov2kobfbv","content":"<blockquote>\n<p>公司使用的技术栈是<em>react全家桶</em>，使用<em>axios</em>进行ajax通信,axios使用的基于<strong>Promise</strong>实现。在现代浏览器上使用并没有什么问题，但是<del>IE全系列不支持Promise</del>，包括IE11…</p>\n</blockquote>\n<p>本来想着使用babel后，将代码转换为es5，应该在IE10以上兼容运行，但是实际运行时，报错，没有Promise…orz</p>\n<p>长话短说，解决方案：<a href=\"http://babeljs.io/docs/usage/polyfill/\" target=\"_blank\" rel=\"external\">babel-polyfill</a></p>\n<a id=\"more\"></a>\n<hr>\n<p>原来在.babelrc里面添加的是 <em>babel-plugin-transform-runtime</em>，但是在这里并不管用，究竟是为什么呢？</p>\n<ul>\n<li>babel-polyfill 使用场景</li>\n</ul>\n<p>Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。</p>\n<ul>\n<li>babel-runtime 使用场景</li>\n</ul>\n<p>Babel 转译后的代码要实现源代码同样的功能需要借助一些帮助函数，例如，{ [name]: ‘JavaScript’ } 转译后的代码如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_defineProperty</span>(<span class=\"params\">obj, key, value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (key <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</div><div class=\"line\">      <span class=\"attr\">value</span>: value,</div><div class=\"line\">      <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"attr\">writable</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    obj[key] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> obj;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = _defineProperty(&#123;&#125;, <span class=\"string\">'name'</span>, <span class=\"string\">'JavaScript'</span>);</div></pre></td></tr></table></figure></p>\n<p>类似上面的帮助函数 _defineProperty 可能会重复出现在一些模块里，导致编译后的代码体积变大。Babel 为了解决这个问题，提供了单独的包 babel-runtime 供编译模块复用工具函数。</p>\n<p>启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数，转译代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"comment\">// 之前的 _defineProperty 函数已经作为公共模块 `babel-runtime/helpers/defineProperty` 使用</span></div><div class=\"line\"><span class=\"keyword\">var</span> _defineProperty2 = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-runtime/helpers/defineProperty'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _defineProperty3 = _interopRequireDefault(_defineProperty2);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_interopRequireDefault</span>(<span class=\"params\">obj</span>) </span>&#123; <span class=\"keyword\">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class=\"attr\">default</span>: obj &#125;; &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = (<span class=\"number\">0</span>, _defineProperty3.default)(&#123;&#125;, <span class=\"string\">'name'</span>, <span class=\"string\">'JavaScript'</span>);</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>公司使用的技术栈是<em>react全家桶</em>，使用<em>axios</em>进行ajax通信,axios使用的基于<strong>Promise</strong>实现。在现代浏览器上使用并没有什么问题，但是<del>IE全系列不支持Promise</del>，包括IE11…</p>\n</blockquote>\n<p>本来想着使用babel后，将代码转换为es5，应该在IE10以上兼容运行，但是实际运行时，报错，没有Promise…orz</p>\n<p>长话短说，解决方案：<a href=\"http://babeljs.io/docs/usage/polyfill/\" target=\"_blank\" rel=\"external\">babel-polyfill</a></p>","more":"<hr>\n<p>原来在.babelrc里面添加的是 <em>babel-plugin-transform-runtime</em>，但是在这里并不管用，究竟是为什么呢？</p>\n<ul>\n<li>babel-polyfill 使用场景</li>\n</ul>\n<p>Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。</p>\n<ul>\n<li>babel-runtime 使用场景</li>\n</ul>\n<p>Babel 转译后的代码要实现源代码同样的功能需要借助一些帮助函数，例如，{ [name]: ‘JavaScript’ } 转译后的代码如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_defineProperty</span>(<span class=\"params\">obj, key, value</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (key <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</div><div class=\"line\">      <span class=\"attr\">value</span>: value,</div><div class=\"line\">      <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"attr\">writable</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    obj[key] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> obj;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = _defineProperty(&#123;&#125;, <span class=\"string\">'name'</span>, <span class=\"string\">'JavaScript'</span>);</div></pre></td></tr></table></figure></p>\n<p>类似上面的帮助函数 _defineProperty 可能会重复出现在一些模块里，导致编译后的代码体积变大。Babel 为了解决这个问题，提供了单独的包 babel-runtime 供编译模块复用工具函数。</p>\n<p>启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数，转译代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"comment\">// 之前的 _defineProperty 函数已经作为公共模块 `babel-runtime/helpers/defineProperty` 使用</span></div><div class=\"line\"><span class=\"keyword\">var</span> _defineProperty2 = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-runtime/helpers/defineProperty'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> _defineProperty3 = _interopRequireDefault(_defineProperty2);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_interopRequireDefault</span>(<span class=\"params\">obj</span>) </span>&#123; <span class=\"keyword\">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class=\"attr\">default</span>: obj &#125;; &#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = (<span class=\"number\">0</span>, _defineProperty3.default)(&#123;&#125;, <span class=\"string\">'name'</span>, <span class=\"string\">'JavaScript'</span>);</div></pre></td></tr></table></figure></p>"},{"title":"使用MockJs进行独立于后端的前端开发","date":"2016-11-01T03:17:36.000Z","_content":"\n## Mock.js实现的功能\n1. 基于** 数据模板 **生成数据\n2. 基于** HTML模板 **生成数据\n3. 拦截并模拟** Ajax请求**\n## 用法\n------\n浏览器：\n```javascript\n<!-- （必选）加载 Mock -->\n<script src=\"http://mockjs.com/dist/mock.js\"></script>\n<script>\n// 使用 Mock\nvar data = Mock.mock({\n    'list|1-10': [{\n        'id|+1': 1\n    }]\n});\n$('<pre>').text(JSON.stringify(data, null, 4))\n.appendTo('body')\n</script>\n```\n返回值:\n```javascript\n{\n\"list\": [\n    {\n        \"id\": 1\n    },\n    {\n        \"id\": 2\n    },\n    {\n        \"id\": 3\n    }\n    ]\n}\n```\n----\n### JQuery：\n配置模拟数据：\n```javascript\nMock.mock('http://g.cn', {\n    'name'     : '@name',\n    'age|1-100': 100,\n    'color'    : '@color'\n});\n```\n发送Ajax请求：\n```javascript\n$.ajax({\n    url: 'http://g.cn',\n    dataType:'json'\n    }).done(function(data, status, xhr){\n    console.log(\n    JSON.stringify(data, null, 4)\n    )    \n})；\n```\n返回数据：\n```javascript\n// 结果1\n{\n\"name\": \"Elizabeth Hall\",\n\"age\": 91,\n\"color\": \"#0e64ea\"\n}\n\n// 结果2\n{\n\"name\": \"Michael Taylor\",\n\"age\": 61,\n\"color\": \"#081086\"\n}\n```\n---\nNode.js：\n```javascript\n// 安装\nnpm install mockjs\n\n// 使用\nvar Mock = require('mockjs');\nvar data = Mock.mock({\n    'list|1-10': [{\n        'id|+1': 1\n    }]\n});\n\nconsole.log(JSON.stringify(data, null, 4))\n```\n\nmock数据mockData.js:\n```javascript\nMock.mock('http://www.baidu.com', {\n    'name': '@name()',\n    'age|1-100': 100,\n    'color': '@color'\n});\n```\n---\n<!--more-->\n## 语法\nMock.js 的语法规范包括两部分：\n\n1. 数据模板定义（Data Temaplte Definition，DTD）\n2. 数据占位符定义（Data Placeholder Definition，DPD）\n\n### 数据模板定义 DTD\n数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：\n```javascript\n// 属性名   name\n// 生成规则 rule\n// 属性值   value\n'name|rule': value\n```\n注意：\n\n- 属性名 和 生成规则 之间用 | 分隔。\n- 生成规则 是可选的。\n- 生成规则 有 7 种格式：\n  1. ``'name|min-max': value``\n  2. ``'name|count': value``\n  3. ``'name|min-max.dmin-dmax': value``\n  4. ``'name|min-max.dcount': value``\n  5. ``'name|count.dmin-dmax': value``\n  6. ``'name|count.dcount': value``\n  7. ``'name|+step': value``\n\n- 生成规则含需要依赖**属性值 **才能确定。\n- 属性值 中可以含有 ``@占位符``。\n- 属性值 还指定了最终值的初始值和类型。\n\n#### 生成规则和示例：\n\n1. 属性值是字符串 String\n  1. 'name|min-max': 'value' 通过重复 'value' 生成一个字符串，重复次数大于等于 min，小于等于 max。\n  2. 'name|count': 'value' 通过重复 'value' 生成一个字符串，重复次数等于 count。\n  \n2. 属性值是数字 Number\n\n  1. 'name|+1': 100 属性值自动加 1，初始值为 100\n  2. 'name|1-100': 100 生成一个大于等于 1、小于等于 100 的整数，属性值 100 只用来确定类型。\n  3. 'name|1-100.1-10': 100 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。\n```javascript\n    {\n    'number1|1-100.1-10': 1,\n    'number2|123.1-10': 1,\n    'number3|123.3': 1,\n    'number4|123.10': 1.123\n    }\n    // =>\n    {\n    \"number1\": 12.92,\n    \"number2\": 123.51,\n    \"number3\": 123.777,\n    \"number4\": 123.1231091814\n    }\n```\n3. 属性值是布尔型 Boolean\n\n  1. 'name|1': value 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2。\n  2. 'name|min-max': value 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。\n4. 属性值是对象 Object\n\n  1. 'name|min-max': {} 从属性值 {} 中随机选取 min 到 max 个属性。\n  2. 'name|count': {} 从属性值 {} 中随机选取 count 个属性。\n5. 属性值是数组 Array\n\n  1. 'name|1': [{}, {} ...] 从属性值 [{}, {} ...] 中随机选取 1 个元素，作为最终值。\n  2. 'name|min-max': [{}, {} ...] 通过重复属性值 [{}, {} ...] 生成一个新数组，重复次数大于等于 min，小于等于 max。\n  3. 'name|count': [{}, {} ...] 通过重复属性值 [{}, {} ...] 生成一个新数组，重复次数为 count。\n6. 属性值是数组 Function\n\n'name': function(){} 执行函数 function(){}，取其返回值作为最终的属性值，上下文为 'name' 所在的对象。\n\n## 数据占位符定义 DPD\n占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为：\n```\n@占位符\n@占位符(参数 [, 参数])\n```\n注意：\n\n1. 用 @ 来标识其后的字符串是 占位符。\n2. 占位符 引用的是 Mock.Random 中的方法。\n3. 通过 Mock.Random.extend() 来扩展自定义占位符。\n4. 占位符 也可以引用 **数据模板**中的属性。\n5. 占位符 会优先引用 **数据模板**中的属性\n```javascript\n{\n name: {\n first: '@FIRST',\n middle: '@FIRST',\n last: '@LAST',\n full: '@first @middle @last'\n    }\n}\n// =>\n{\n \"name\": {\n \"first\": \"Charles\",\n \"middle\": \"Brenda\",\n \"last\": \"Lopez\",\n \"full\": \"Charles Brenda Lopez\"\n    }\n}\n```\n---\n## 常用方法\n### Mock.mock( rurl?, rtype?, template|function(options) )\n根据数据模板生成模拟数据。\n\n**参数的含义和默认值**如下所示：\n\n - 参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\\/domain\\/list.json/、'/domian/list.json'。\n - 参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。\n - 参数 template：可选。表示数据模板，可以是对象或字符串。例如 { 'data|1-10':[{}] }、'@EMAIL'。\n - 参数 function(options)：可选。表示用于生成响应数据的函数。\n - 参数 options：指向本次请求的 Ajax 选项集。\n\n### Mock.mockjax(library)\n覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。\n\n### Mock.Random\nMock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 。\n\n### Mock.tpl(input, options, helpers, partials)\n基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。\n\n方法使用详情请参考[mock.js文档](http://mockjs.com/#mock)","source":"_posts/使用MockJs进行独立于后端的前端开发.md","raw":"---\ntitle: 使用MockJs进行独立于后端的前端开发\ndate: 2016-11-01 11:17:36\ntags: tools\n---\n\n## Mock.js实现的功能\n1. 基于** 数据模板 **生成数据\n2. 基于** HTML模板 **生成数据\n3. 拦截并模拟** Ajax请求**\n## 用法\n------\n浏览器：\n```javascript\n<!-- （必选）加载 Mock -->\n<script src=\"http://mockjs.com/dist/mock.js\"></script>\n<script>\n// 使用 Mock\nvar data = Mock.mock({\n    'list|1-10': [{\n        'id|+1': 1\n    }]\n});\n$('<pre>').text(JSON.stringify(data, null, 4))\n.appendTo('body')\n</script>\n```\n返回值:\n```javascript\n{\n\"list\": [\n    {\n        \"id\": 1\n    },\n    {\n        \"id\": 2\n    },\n    {\n        \"id\": 3\n    }\n    ]\n}\n```\n----\n### JQuery：\n配置模拟数据：\n```javascript\nMock.mock('http://g.cn', {\n    'name'     : '@name',\n    'age|1-100': 100,\n    'color'    : '@color'\n});\n```\n发送Ajax请求：\n```javascript\n$.ajax({\n    url: 'http://g.cn',\n    dataType:'json'\n    }).done(function(data, status, xhr){\n    console.log(\n    JSON.stringify(data, null, 4)\n    )    \n})；\n```\n返回数据：\n```javascript\n// 结果1\n{\n\"name\": \"Elizabeth Hall\",\n\"age\": 91,\n\"color\": \"#0e64ea\"\n}\n\n// 结果2\n{\n\"name\": \"Michael Taylor\",\n\"age\": 61,\n\"color\": \"#081086\"\n}\n```\n---\nNode.js：\n```javascript\n// 安装\nnpm install mockjs\n\n// 使用\nvar Mock = require('mockjs');\nvar data = Mock.mock({\n    'list|1-10': [{\n        'id|+1': 1\n    }]\n});\n\nconsole.log(JSON.stringify(data, null, 4))\n```\n\nmock数据mockData.js:\n```javascript\nMock.mock('http://www.baidu.com', {\n    'name': '@name()',\n    'age|1-100': 100,\n    'color': '@color'\n});\n```\n---\n<!--more-->\n## 语法\nMock.js 的语法规范包括两部分：\n\n1. 数据模板定义（Data Temaplte Definition，DTD）\n2. 数据占位符定义（Data Placeholder Definition，DPD）\n\n### 数据模板定义 DTD\n数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：\n```javascript\n// 属性名   name\n// 生成规则 rule\n// 属性值   value\n'name|rule': value\n```\n注意：\n\n- 属性名 和 生成规则 之间用 | 分隔。\n- 生成规则 是可选的。\n- 生成规则 有 7 种格式：\n  1. ``'name|min-max': value``\n  2. ``'name|count': value``\n  3. ``'name|min-max.dmin-dmax': value``\n  4. ``'name|min-max.dcount': value``\n  5. ``'name|count.dmin-dmax': value``\n  6. ``'name|count.dcount': value``\n  7. ``'name|+step': value``\n\n- 生成规则含需要依赖**属性值 **才能确定。\n- 属性值 中可以含有 ``@占位符``。\n- 属性值 还指定了最终值的初始值和类型。\n\n#### 生成规则和示例：\n\n1. 属性值是字符串 String\n  1. 'name|min-max': 'value' 通过重复 'value' 生成一个字符串，重复次数大于等于 min，小于等于 max。\n  2. 'name|count': 'value' 通过重复 'value' 生成一个字符串，重复次数等于 count。\n  \n2. 属性值是数字 Number\n\n  1. 'name|+1': 100 属性值自动加 1，初始值为 100\n  2. 'name|1-100': 100 生成一个大于等于 1、小于等于 100 的整数，属性值 100 只用来确定类型。\n  3. 'name|1-100.1-10': 100 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。\n```javascript\n    {\n    'number1|1-100.1-10': 1,\n    'number2|123.1-10': 1,\n    'number3|123.3': 1,\n    'number4|123.10': 1.123\n    }\n    // =>\n    {\n    \"number1\": 12.92,\n    \"number2\": 123.51,\n    \"number3\": 123.777,\n    \"number4\": 123.1231091814\n    }\n```\n3. 属性值是布尔型 Boolean\n\n  1. 'name|1': value 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2。\n  2. 'name|min-max': value 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。\n4. 属性值是对象 Object\n\n  1. 'name|min-max': {} 从属性值 {} 中随机选取 min 到 max 个属性。\n  2. 'name|count': {} 从属性值 {} 中随机选取 count 个属性。\n5. 属性值是数组 Array\n\n  1. 'name|1': [{}, {} ...] 从属性值 [{}, {} ...] 中随机选取 1 个元素，作为最终值。\n  2. 'name|min-max': [{}, {} ...] 通过重复属性值 [{}, {} ...] 生成一个新数组，重复次数大于等于 min，小于等于 max。\n  3. 'name|count': [{}, {} ...] 通过重复属性值 [{}, {} ...] 生成一个新数组，重复次数为 count。\n6. 属性值是数组 Function\n\n'name': function(){} 执行函数 function(){}，取其返回值作为最终的属性值，上下文为 'name' 所在的对象。\n\n## 数据占位符定义 DPD\n占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为：\n```\n@占位符\n@占位符(参数 [, 参数])\n```\n注意：\n\n1. 用 @ 来标识其后的字符串是 占位符。\n2. 占位符 引用的是 Mock.Random 中的方法。\n3. 通过 Mock.Random.extend() 来扩展自定义占位符。\n4. 占位符 也可以引用 **数据模板**中的属性。\n5. 占位符 会优先引用 **数据模板**中的属性\n```javascript\n{\n name: {\n first: '@FIRST',\n middle: '@FIRST',\n last: '@LAST',\n full: '@first @middle @last'\n    }\n}\n// =>\n{\n \"name\": {\n \"first\": \"Charles\",\n \"middle\": \"Brenda\",\n \"last\": \"Lopez\",\n \"full\": \"Charles Brenda Lopez\"\n    }\n}\n```\n---\n## 常用方法\n### Mock.mock( rurl?, rtype?, template|function(options) )\n根据数据模板生成模拟数据。\n\n**参数的含义和默认值**如下所示：\n\n - 参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\\/domain\\/list.json/、'/domian/list.json'。\n - 参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。\n - 参数 template：可选。表示数据模板，可以是对象或字符串。例如 { 'data|1-10':[{}] }、'@EMAIL'。\n - 参数 function(options)：可选。表示用于生成响应数据的函数。\n - 参数 options：指向本次请求的 Ajax 选项集。\n\n### Mock.mockjax(library)\n覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。\n\n### Mock.Random\nMock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 。\n\n### Mock.tpl(input, options, helpers, partials)\n基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。\n\n方法使用详情请参考[mock.js文档](http://mockjs.com/#mock)","slug":"使用MockJs进行独立于后端的前端开发","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfe4001wzk4ok9fv838v","content":"<h2 id=\"Mock-js实现的功能\"><a href=\"#Mock-js实现的功能\" class=\"headerlink\" title=\"Mock.js实现的功能\"></a>Mock.js实现的功能</h2><ol>\n<li>基于<strong> 数据模板 </strong>生成数据</li>\n<li>基于<strong> HTML模板 </strong>生成数据</li>\n<li>拦截并模拟<strong> Ajax请求</strong><h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2></li>\n</ol>\n<hr>\n<p>浏览器：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- （必选）加载 Mock --&gt;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://mockjs.com/dist/mock.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\"><span class=\"comment\">// 使用 Mock</span></div><div class=\"line\"><span class=\"keyword\">var</span> data = Mock.mock(&#123;</div><div class=\"line\">    <span class=\"string\">'list|1-10'</span>: [&#123;</div><div class=\"line\">        <span class=\"string\">'id|+1'</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;);</div><div class=\"line\">$(<span class=\"string\">'&lt;pre&gt;'</span>).text(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>))</div><div class=\"line\">.appendTo(<span class=\"string\">'body'</span>)</div><div class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></div></pre></td></tr></table></figure></p>\n<p>返回值:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">\"list\"</span>: [</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"id\"</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"id\"</span>: <span class=\"number\">2</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"id\"</span>: <span class=\"number\">3</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"JQuery：\"><a href=\"#JQuery：\" class=\"headerlink\" title=\"JQuery：\"></a>JQuery：</h3><p>配置模拟数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mock.mock(<span class=\"string\">'http://g.cn'</span>, &#123;</div><div class=\"line\">    <span class=\"string\">'name'</span>     : <span class=\"string\">'@name'</span>,</div><div class=\"line\">    <span class=\"string\">'age|1-100'</span>: <span class=\"number\">100</span>,</div><div class=\"line\">    <span class=\"string\">'color'</span>    : <span class=\"string\">'@color'</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>发送Ajax请求：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">'http://g.cn'</span>,</div><div class=\"line\">    <span class=\"attr\">dataType</span>:<span class=\"string\">'json'</span></div><div class=\"line\">    &#125;).done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, status, xhr</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(</div><div class=\"line\">    <span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)</div><div class=\"line\">    )    </div><div class=\"line\">&#125;)；</div></pre></td></tr></table></figure></p>\n<p>返回数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结果1</span></div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">\"name\"</span>: <span class=\"string\">\"Elizabeth Hall\"</span>,</div><div class=\"line\"><span class=\"string\">\"age\"</span>: <span class=\"number\">91</span>,</div><div class=\"line\"><span class=\"string\">\"color\"</span>: <span class=\"string\">\"#0e64ea\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 结果2</span></div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">\"name\"</span>: <span class=\"string\">\"Michael Taylor\"</span>,</div><div class=\"line\"><span class=\"string\">\"age\"</span>: <span class=\"number\">61</span>,</div><div class=\"line\"><span class=\"string\">\"color\"</span>: <span class=\"string\">\"#081086\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>Node.js：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 安装</span></div><div class=\"line\">npm install mockjs</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用</span></div><div class=\"line\"><span class=\"keyword\">var</span> Mock = <span class=\"built_in\">require</span>(<span class=\"string\">'mockjs'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> data = Mock.mock(&#123;</div><div class=\"line\">    <span class=\"string\">'list|1-10'</span>: [&#123;</div><div class=\"line\">        <span class=\"string\">'id|+1'</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>))</div></pre></td></tr></table></figure></p>\n<p>mock数据mockData.js:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mock.mock(<span class=\"string\">'http://www.baidu.com'</span>, &#123;</div><div class=\"line\">    <span class=\"string\">'name'</span>: <span class=\"string\">'@name()'</span>,</div><div class=\"line\">    <span class=\"string\">'age|1-100'</span>: <span class=\"number\">100</span>,</div><div class=\"line\">    <span class=\"string\">'color'</span>: <span class=\"string\">'@color'</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<hr>\n<a id=\"more\"></a>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>Mock.js 的语法规范包括两部分：</p>\n<ol>\n<li>数据模板定义（Data Temaplte Definition，DTD）</li>\n<li>数据占位符定义（Data Placeholder Definition，DPD）</li>\n</ol>\n<h3 id=\"数据模板定义-DTD\"><a href=\"#数据模板定义-DTD\" class=\"headerlink\" title=\"数据模板定义 DTD\"></a>数据模板定义 DTD</h3><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 属性名   name</span></div><div class=\"line\"><span class=\"comment\">// 生成规则 rule</span></div><div class=\"line\"><span class=\"comment\">// 属性值   value</span></div><div class=\"line\"><span class=\"string\">'name|rule'</span>: value</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ul>\n<li>属性名 和 生成规则 之间用 | 分隔。</li>\n<li>生成规则 是可选的。</li>\n<li><p>生成规则 有 7 种格式：</p>\n<ol>\n<li><code>&#39;name|min-max&#39;: value</code></li>\n<li><code>&#39;name|count&#39;: value</code></li>\n<li><code>&#39;name|min-max.dmin-dmax&#39;: value</code></li>\n<li><code>&#39;name|min-max.dcount&#39;: value</code></li>\n<li><code>&#39;name|count.dmin-dmax&#39;: value</code></li>\n<li><code>&#39;name|count.dcount&#39;: value</code></li>\n<li><code>&#39;name|+step&#39;: value</code></li>\n</ol>\n</li>\n<li><p>生成规则含需要依赖<strong>属性值 </strong>才能确定。</p>\n</li>\n<li>属性值 中可以含有 <code>@占位符</code>。</li>\n<li>属性值 还指定了最终值的初始值和类型。</li>\n</ul>\n<h4 id=\"生成规则和示例：\"><a href=\"#生成规则和示例：\" class=\"headerlink\" title=\"生成规则和示例：\"></a>生成规则和示例：</h4><ol>\n<li><p>属性值是字符串 String</p>\n<ol>\n<li>‘name|min-max’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数大于等于 min，小于等于 max。</li>\n<li>‘name|count’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数等于 count。</li>\n</ol>\n</li>\n<li><p>属性值是数字 Number</p>\n<ol>\n<li>‘name|+1’: 100 属性值自动加 1，初始值为 100</li>\n<li>‘name|1-100’: 100 生成一个大于等于 1、小于等于 100 的整数，属性值 100 只用来确定类型。</li>\n<li>‘name|1-100.1-10’: 100 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">'number1|1-100.1-10'</span>: <span class=\"number\">1</span>,</div><div class=\"line\"><span class=\"string\">'number2|123.1-10'</span>: <span class=\"number\">1</span>,</div><div class=\"line\"><span class=\"string\">'number3|123.3'</span>: <span class=\"number\">1</span>,</div><div class=\"line\"><span class=\"string\">'number4|123.10'</span>: <span class=\"number\">1.123</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// =&gt;</span></div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">\"number1\"</span>: <span class=\"number\">12.92</span>,</div><div class=\"line\"><span class=\"string\">\"number2\"</span>: <span class=\"number\">123.51</span>,</div><div class=\"line\"><span class=\"string\">\"number3\"</span>: <span class=\"number\">123.777</span>,</div><div class=\"line\"><span class=\"string\">\"number4\"</span>: <span class=\"number\">123.1231091814</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>属性值是布尔型 Boolean</p>\n<ol>\n<li>‘name|1’: value 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2。</li>\n<li>‘name|min-max’: value 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。</li>\n</ol>\n</li>\n<li><p>属性值是对象 Object</p>\n<ol>\n<li>‘name|min-max’: {} 从属性值 {} 中随机选取 min 到 max 个属性。</li>\n<li>‘name|count’: {} 从属性值 {} 中随机选取 count 个属性。</li>\n</ol>\n</li>\n<li><p>属性值是数组 Array</p>\n<ol>\n<li>‘name|1’: [{}, {} …] 从属性值 [{}, {} …] 中随机选取 1 个元素，作为最终值。</li>\n<li>‘name|min-max’: [{}, {} …] 通过重复属性值 [{}, {} …] 生成一个新数组，重复次数大于等于 min，小于等于 max。</li>\n<li>‘name|count’: [{}, {} …] 通过重复属性值 [{}, {} …] 生成一个新数组，重复次数为 count。</li>\n</ol>\n</li>\n<li>属性值是数组 Function</li>\n</ol>\n<p>‘name’: function(){} 执行函数 function(){}，取其返回值作为最终的属性值，上下文为 ‘name’ 所在的对象。</p>\n<h2 id=\"数据占位符定义-DPD\"><a href=\"#数据占位符定义-DPD\" class=\"headerlink\" title=\"数据占位符定义 DPD\"></a>数据占位符定义 DPD</h2><p>占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@占位符</div><div class=\"line\">@占位符(参数 [, 参数])</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>用 @ 来标识其后的字符串是 占位符。</li>\n<li>占位符 引用的是 Mock.Random 中的方法。</li>\n<li>通过 Mock.Random.extend() 来扩展自定义占位符。</li>\n<li>占位符 也可以引用 <strong>数据模板</strong>中的属性。</li>\n<li>占位符 会优先引用 <strong>数据模板</strong>中的属性<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"attr\">name</span>: &#123;</div><div class=\"line\"> <span class=\"attr\">first</span>: <span class=\"string\">'@FIRST'</span>,</div><div class=\"line\"> <span class=\"attr\">middle</span>: <span class=\"string\">'@FIRST'</span>,</div><div class=\"line\"> <span class=\"attr\">last</span>: <span class=\"string\">'@LAST'</span>,</div><div class=\"line\"> <span class=\"attr\">full</span>: <span class=\"string\">'@first @middle @last'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// =&gt;</span></div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"string\">\"name\"</span>: &#123;</div><div class=\"line\"> <span class=\"string\">\"first\"</span>: <span class=\"string\">\"Charles\"</span>,</div><div class=\"line\"> <span class=\"string\">\"middle\"</span>: <span class=\"string\">\"Brenda\"</span>,</div><div class=\"line\"> <span class=\"string\">\"last\"</span>: <span class=\"string\">\"Lopez\"</span>,</div><div class=\"line\"> <span class=\"string\">\"full\"</span>: <span class=\"string\">\"Charles Brenda Lopez\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"Mock-mock-rurl-rtype-template-function-options\"><a href=\"#Mock-mock-rurl-rtype-template-function-options\" class=\"headerlink\" title=\"Mock.mock( rurl?, rtype?, template|function(options) )\"></a>Mock.mock( rurl?, rtype?, template|function(options) )</h3><p>根据数据模板生成模拟数据。</p>\n<p><strong>参数的含义和默认值</strong>如下所示：</p>\n<ul>\n<li>参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\\/domain\\/list.json/、’/domian/list.json’。</li>\n<li>参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。</li>\n<li>参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、’@EMAIL’。</li>\n<li>参数 function(options)：可选。表示用于生成响应数据的函数。</li>\n<li>参数 options：指向本次请求的 Ajax 选项集。</li>\n</ul>\n<h3 id=\"Mock-mockjax-library\"><a href=\"#Mock-mockjax-library\" class=\"headerlink\" title=\"Mock.mockjax(library)\"></a>Mock.mockjax(library)</h3><p>覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。</p>\n<h3 id=\"Mock-Random\"><a href=\"#Mock-Random\" class=\"headerlink\" title=\"Mock.Random\"></a>Mock.Random</h3><p>Mock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 。</p>\n<h3 id=\"Mock-tpl-input-options-helpers-partials\"><a href=\"#Mock-tpl-input-options-helpers-partials\" class=\"headerlink\" title=\"Mock.tpl(input, options, helpers, partials)\"></a>Mock.tpl(input, options, helpers, partials)</h3><p>基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。</p>\n<p>方法使用详情请参考<a href=\"http://mockjs.com/#mock\" target=\"_blank\" rel=\"external\">mock.js文档</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Mock-js实现的功能\"><a href=\"#Mock-js实现的功能\" class=\"headerlink\" title=\"Mock.js实现的功能\"></a>Mock.js实现的功能</h2><ol>\n<li>基于<strong> 数据模板 </strong>生成数据</li>\n<li>基于<strong> HTML模板 </strong>生成数据</li>\n<li>拦截并模拟<strong> Ajax请求</strong><h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2></li>\n</ol>\n<hr>\n<p>浏览器：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- （必选）加载 Mock --&gt;</div><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://mockjs.com/dist/mock.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div><div class=\"line\">&lt;script&gt;</div><div class=\"line\"><span class=\"comment\">// 使用 Mock</span></div><div class=\"line\"><span class=\"keyword\">var</span> data = Mock.mock(&#123;</div><div class=\"line\">    <span class=\"string\">'list|1-10'</span>: [&#123;</div><div class=\"line\">        <span class=\"string\">'id|+1'</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;);</div><div class=\"line\">$(<span class=\"string\">'&lt;pre&gt;'</span>).text(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>))</div><div class=\"line\">.appendTo(<span class=\"string\">'body'</span>)</div><div class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></div></pre></td></tr></table></figure></p>\n<p>返回值:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">\"list\"</span>: [</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"id\"</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"id\"</span>: <span class=\"number\">2</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"string\">\"id\"</span>: <span class=\"number\">3</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"JQuery：\"><a href=\"#JQuery：\" class=\"headerlink\" title=\"JQuery：\"></a>JQuery：</h3><p>配置模拟数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mock.mock(<span class=\"string\">'http://g.cn'</span>, &#123;</div><div class=\"line\">    <span class=\"string\">'name'</span>     : <span class=\"string\">'@name'</span>,</div><div class=\"line\">    <span class=\"string\">'age|1-100'</span>: <span class=\"number\">100</span>,</div><div class=\"line\">    <span class=\"string\">'color'</span>    : <span class=\"string\">'@color'</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>发送Ajax请求：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">    <span class=\"attr\">url</span>: <span class=\"string\">'http://g.cn'</span>,</div><div class=\"line\">    <span class=\"attr\">dataType</span>:<span class=\"string\">'json'</span></div><div class=\"line\">    &#125;).done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data, status, xhr</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(</div><div class=\"line\">    <span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>)</div><div class=\"line\">    )    </div><div class=\"line\">&#125;)；</div></pre></td></tr></table></figure></p>\n<p>返回数据：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结果1</span></div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">\"name\"</span>: <span class=\"string\">\"Elizabeth Hall\"</span>,</div><div class=\"line\"><span class=\"string\">\"age\"</span>: <span class=\"number\">91</span>,</div><div class=\"line\"><span class=\"string\">\"color\"</span>: <span class=\"string\">\"#0e64ea\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 结果2</span></div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">\"name\"</span>: <span class=\"string\">\"Michael Taylor\"</span>,</div><div class=\"line\"><span class=\"string\">\"age\"</span>: <span class=\"number\">61</span>,</div><div class=\"line\"><span class=\"string\">\"color\"</span>: <span class=\"string\">\"#081086\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<hr>\n<p>Node.js：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 安装</span></div><div class=\"line\">npm install mockjs</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用</span></div><div class=\"line\"><span class=\"keyword\">var</span> Mock = <span class=\"built_in\">require</span>(<span class=\"string\">'mockjs'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> data = Mock.mock(&#123;</div><div class=\"line\">    <span class=\"string\">'list|1-10'</span>: [&#123;</div><div class=\"line\">        <span class=\"string\">'id|+1'</span>: <span class=\"number\">1</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data, <span class=\"literal\">null</span>, <span class=\"number\">4</span>))</div></pre></td></tr></table></figure></p>\n<p>mock数据mockData.js:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mock.mock(<span class=\"string\">'http://www.baidu.com'</span>, &#123;</div><div class=\"line\">    <span class=\"string\">'name'</span>: <span class=\"string\">'@name()'</span>,</div><div class=\"line\">    <span class=\"string\">'age|1-100'</span>: <span class=\"number\">100</span>,</div><div class=\"line\">    <span class=\"string\">'color'</span>: <span class=\"string\">'@color'</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<hr>","more":"<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><p>Mock.js 的语法规范包括两部分：</p>\n<ol>\n<li>数据模板定义（Data Temaplte Definition，DTD）</li>\n<li>数据占位符定义（Data Placeholder Definition，DPD）</li>\n</ol>\n<h3 id=\"数据模板定义-DTD\"><a href=\"#数据模板定义-DTD\" class=\"headerlink\" title=\"数据模板定义 DTD\"></a>数据模板定义 DTD</h3><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 属性名   name</span></div><div class=\"line\"><span class=\"comment\">// 生成规则 rule</span></div><div class=\"line\"><span class=\"comment\">// 属性值   value</span></div><div class=\"line\"><span class=\"string\">'name|rule'</span>: value</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ul>\n<li>属性名 和 生成规则 之间用 | 分隔。</li>\n<li>生成规则 是可选的。</li>\n<li><p>生成规则 有 7 种格式：</p>\n<ol>\n<li><code>&#39;name|min-max&#39;: value</code></li>\n<li><code>&#39;name|count&#39;: value</code></li>\n<li><code>&#39;name|min-max.dmin-dmax&#39;: value</code></li>\n<li><code>&#39;name|min-max.dcount&#39;: value</code></li>\n<li><code>&#39;name|count.dmin-dmax&#39;: value</code></li>\n<li><code>&#39;name|count.dcount&#39;: value</code></li>\n<li><code>&#39;name|+step&#39;: value</code></li>\n</ol>\n</li>\n<li><p>生成规则含需要依赖<strong>属性值 </strong>才能确定。</p>\n</li>\n<li>属性值 中可以含有 <code>@占位符</code>。</li>\n<li>属性值 还指定了最终值的初始值和类型。</li>\n</ul>\n<h4 id=\"生成规则和示例：\"><a href=\"#生成规则和示例：\" class=\"headerlink\" title=\"生成规则和示例：\"></a>生成规则和示例：</h4><ol>\n<li><p>属性值是字符串 String</p>\n<ol>\n<li>‘name|min-max’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数大于等于 min，小于等于 max。</li>\n<li>‘name|count’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数等于 count。</li>\n</ol>\n</li>\n<li><p>属性值是数字 Number</p>\n<ol>\n<li>‘name|+1’: 100 属性值自动加 1，初始值为 100</li>\n<li>‘name|1-100’: 100 生成一个大于等于 1、小于等于 100 的整数，属性值 100 只用来确定类型。</li>\n<li>‘name|1-100.1-10’: 100 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">'number1|1-100.1-10'</span>: <span class=\"number\">1</span>,</div><div class=\"line\"><span class=\"string\">'number2|123.1-10'</span>: <span class=\"number\">1</span>,</div><div class=\"line\"><span class=\"string\">'number3|123.3'</span>: <span class=\"number\">1</span>,</div><div class=\"line\"><span class=\"string\">'number4|123.10'</span>: <span class=\"number\">1.123</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// =&gt;</span></div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"string\">\"number1\"</span>: <span class=\"number\">12.92</span>,</div><div class=\"line\"><span class=\"string\">\"number2\"</span>: <span class=\"number\">123.51</span>,</div><div class=\"line\"><span class=\"string\">\"number3\"</span>: <span class=\"number\">123.777</span>,</div><div class=\"line\"><span class=\"string\">\"number4\"</span>: <span class=\"number\">123.1231091814</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>属性值是布尔型 Boolean</p>\n<ol>\n<li>‘name|1’: value 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2。</li>\n<li>‘name|min-max’: value 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。</li>\n</ol>\n</li>\n<li><p>属性值是对象 Object</p>\n<ol>\n<li>‘name|min-max’: {} 从属性值 {} 中随机选取 min 到 max 个属性。</li>\n<li>‘name|count’: {} 从属性值 {} 中随机选取 count 个属性。</li>\n</ol>\n</li>\n<li><p>属性值是数组 Array</p>\n<ol>\n<li>‘name|1’: [{}, {} …] 从属性值 [{}, {} …] 中随机选取 1 个元素，作为最终值。</li>\n<li>‘name|min-max’: [{}, {} …] 通过重复属性值 [{}, {} …] 生成一个新数组，重复次数大于等于 min，小于等于 max。</li>\n<li>‘name|count’: [{}, {} …] 通过重复属性值 [{}, {} …] 生成一个新数组，重复次数为 count。</li>\n</ol>\n</li>\n<li>属性值是数组 Function</li>\n</ol>\n<p>‘name’: function(){} 执行函数 function(){}，取其返回值作为最终的属性值，上下文为 ‘name’ 所在的对象。</p>\n<h2 id=\"数据占位符定义-DPD\"><a href=\"#数据占位符定义-DPD\" class=\"headerlink\" title=\"数据占位符定义 DPD\"></a>数据占位符定义 DPD</h2><p>占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">@占位符</div><div class=\"line\">@占位符(参数 [, 参数])</div></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<ol>\n<li>用 @ 来标识其后的字符串是 占位符。</li>\n<li>占位符 引用的是 Mock.Random 中的方法。</li>\n<li>通过 Mock.Random.extend() 来扩展自定义占位符。</li>\n<li>占位符 也可以引用 <strong>数据模板</strong>中的属性。</li>\n<li>占位符 会优先引用 <strong>数据模板</strong>中的属性<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"attr\">name</span>: &#123;</div><div class=\"line\"> <span class=\"attr\">first</span>: <span class=\"string\">'@FIRST'</span>,</div><div class=\"line\"> <span class=\"attr\">middle</span>: <span class=\"string\">'@FIRST'</span>,</div><div class=\"line\"> <span class=\"attr\">last</span>: <span class=\"string\">'@LAST'</span>,</div><div class=\"line\"> <span class=\"attr\">full</span>: <span class=\"string\">'@first @middle @last'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// =&gt;</span></div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"string\">\"name\"</span>: &#123;</div><div class=\"line\"> <span class=\"string\">\"first\"</span>: <span class=\"string\">\"Charles\"</span>,</div><div class=\"line\"> <span class=\"string\">\"middle\"</span>: <span class=\"string\">\"Brenda\"</span>,</div><div class=\"line\"> <span class=\"string\">\"last\"</span>: <span class=\"string\">\"Lopez\"</span>,</div><div class=\"line\"> <span class=\"string\">\"full\"</span>: <span class=\"string\">\"Charles Brenda Lopez\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><h3 id=\"Mock-mock-rurl-rtype-template-function-options\"><a href=\"#Mock-mock-rurl-rtype-template-function-options\" class=\"headerlink\" title=\"Mock.mock( rurl?, rtype?, template|function(options) )\"></a>Mock.mock( rurl?, rtype?, template|function(options) )</h3><p>根据数据模板生成模拟数据。</p>\n<p><strong>参数的含义和默认值</strong>如下所示：</p>\n<ul>\n<li>参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\\/domain\\/list.json/、’/domian/list.json’。</li>\n<li>参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。</li>\n<li>参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、’@EMAIL’。</li>\n<li>参数 function(options)：可选。表示用于生成响应数据的函数。</li>\n<li>参数 options：指向本次请求的 Ajax 选项集。</li>\n</ul>\n<h3 id=\"Mock-mockjax-library\"><a href=\"#Mock-mockjax-library\" class=\"headerlink\" title=\"Mock.mockjax(library)\"></a>Mock.mockjax(library)</h3><p>覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。</p>\n<h3 id=\"Mock-Random\"><a href=\"#Mock-Random\" class=\"headerlink\" title=\"Mock.Random\"></a>Mock.Random</h3><p>Mock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 。</p>\n<h3 id=\"Mock-tpl-input-options-helpers-partials\"><a href=\"#Mock-tpl-input-options-helpers-partials\" class=\"headerlink\" title=\"Mock.tpl(input, options, helpers, partials)\"></a>Mock.tpl(input, options, helpers, partials)</h3><p>基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。</p>\n<p>方法使用详情请参考<a href=\"http://mockjs.com/#mock\" target=\"_blank\" rel=\"external\">mock.js文档</a></p>"},{"title":"使用nvm安装node","date":"2016-10-10T03:08:25.000Z","thumbnail":"https://nodejs.org/static/images/logo-header.png","_content":"如果你想长期做 node 开发, 或者想快速更新 node 版本, 或者想快速切换 node 版本,\n那么在非 Windows(如 osx, linux) 环境下, 请使用 nvm 来安装你的 node 开发环境, 保持系统的干净.\n如果你使用 Windows 做开发, 那么你可以使用 nvmw 来替代 nvm\n### git clone nvm\n\n直接从 github clone nvm 到本地, 这里假设大家都使用 ~/git 目录存放 git 项目:\n``\n$ cd ~/git\n$ git clone https://github.com/creationix/nvm.git\n``\n\n配置终端启动时自动执行 source ~/git/nvm/nvm.sh,\n在 ~/.zshrc 文件添加以下命令:\n``source ~/git/nvm/nvm.sh``\n重新打开你的终端, 输入 nvm\n```\n$ nvm\nNode Version Manager\n...\n```\n\n### 通过 nvm 安装任意版本的 node\n\nnvm 默认是从 http://nodejs.org/dist/ 下载的, 国外服务器, 必然很慢,\n好在 nvm 以及支持从镜像服务器下载包, 于是我们可以方便地从七牛的 node dist 镜像下载:\n```\n$ NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm ls-remote\n```\n就可以看到远程服务器上的node版本，选择一个进行安装``nvm install v4.6.0(nodevesion)``即可。\n于是你就会看到一段非常快速进度条:\n```\n######################################################################## 100.0%\nNow using node v4.6.0\n```\n如果你不想每次都输入环境变量 NVM_NODEJS_ORG_MIRROR, 那么我建议你加入到 .zshrc 文件中:\n```\n# nvm\nexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node\nsource ~/git/nvm/nvm.sh\n```\n然后你可以继续非常方便地安装各个版本的 node 了, 你可以查看一下你当前已经安装的版本:\n\n$ nvm ls\n         nvm\n     v0.8.26\n    v0.10.26\n    v0.11.11\n->  v4.3.2","source":"_posts/使用nvm安装node.md","raw":"---\ntitle: 使用nvm安装node\ndate: 2016-10-10 11:08:25\nthumbnail: https://nodejs.org/static/images/logo-header.png\ntags: \n  - ubuntu\n  - node\n---\n如果你想长期做 node 开发, 或者想快速更新 node 版本, 或者想快速切换 node 版本,\n那么在非 Windows(如 osx, linux) 环境下, 请使用 nvm 来安装你的 node 开发环境, 保持系统的干净.\n如果你使用 Windows 做开发, 那么你可以使用 nvmw 来替代 nvm\n### git clone nvm\n\n直接从 github clone nvm 到本地, 这里假设大家都使用 ~/git 目录存放 git 项目:\n``\n$ cd ~/git\n$ git clone https://github.com/creationix/nvm.git\n``\n\n配置终端启动时自动执行 source ~/git/nvm/nvm.sh,\n在 ~/.zshrc 文件添加以下命令:\n``source ~/git/nvm/nvm.sh``\n重新打开你的终端, 输入 nvm\n```\n$ nvm\nNode Version Manager\n...\n```\n\n### 通过 nvm 安装任意版本的 node\n\nnvm 默认是从 http://nodejs.org/dist/ 下载的, 国外服务器, 必然很慢,\n好在 nvm 以及支持从镜像服务器下载包, 于是我们可以方便地从七牛的 node dist 镜像下载:\n```\n$ NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm ls-remote\n```\n就可以看到远程服务器上的node版本，选择一个进行安装``nvm install v4.6.0(nodevesion)``即可。\n于是你就会看到一段非常快速进度条:\n```\n######################################################################## 100.0%\nNow using node v4.6.0\n```\n如果你不想每次都输入环境变量 NVM_NODEJS_ORG_MIRROR, 那么我建议你加入到 .zshrc 文件中:\n```\n# nvm\nexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node\nsource ~/git/nvm/nvm.sh\n```\n然后你可以继续非常方便地安装各个版本的 node 了, 你可以查看一下你当前已经安装的版本:\n\n$ nvm ls\n         nvm\n     v0.8.26\n    v0.10.26\n    v0.11.11\n->  v4.3.2","slug":"使用nvm安装node","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfe6001yzk4obiiers20","content":"<p>如果你想长期做 node 开发, 或者想快速更新 node 版本, 或者想快速切换 node 版本,<br>那么在非 Windows(如 osx, linux) 环境下, 请使用 nvm 来安装你的 node 开发环境, 保持系统的干净.<br>如果你使用 Windows 做开发, 那么你可以使用 nvmw 来替代 nvm</p>\n<h3 id=\"git-clone-nvm\"><a href=\"#git-clone-nvm\" class=\"headerlink\" title=\"git clone nvm\"></a>git clone nvm</h3><p>直接从 github clone nvm 到本地, 这里假设大家都使用 ~/git 目录存放 git 项目:<br><code>$ cd ~/git\n$ git clone https://github.com/creationix/nvm.git</code></p>\n<p>配置终端启动时自动执行 source ~/git/nvm/nvm.sh,<br>在 ~/.zshrc 文件添加以下命令:<br><code>source ~/git/nvm/nvm.sh</code><br>重新打开你的终端, 输入 nvm<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm</div><div class=\"line\">Node Version Manager</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h3 id=\"通过-nvm-安装任意版本的-node\"><a href=\"#通过-nvm-安装任意版本的-node\" class=\"headerlink\" title=\"通过 nvm 安装任意版本的 node\"></a>通过 nvm 安装任意版本的 node</h3><p>nvm 默认是从 <a href=\"http://nodejs.org/dist/\" target=\"_blank\" rel=\"external\">http://nodejs.org/dist/</a> 下载的, 国外服务器, 必然很慢,<br>好在 nvm 以及支持从镜像服务器下载包, 于是我们可以方便地从七牛的 node dist 镜像下载:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm ls-remote</div></pre></td></tr></table></figure></p>\n<p>就可以看到远程服务器上的node版本，选择一个进行安装<code>nvm install v4.6.0(nodevesion)</code>即可。<br>于是你就会看到一段非常快速进度条:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">######################################################################## 100.0%</div><div class=\"line\">Now using node v4.6.0</div></pre></td></tr></table></figure></p>\n<p>如果你不想每次都输入环境变量 NVM_NODEJS_ORG_MIRROR, 那么我建议你加入到 .zshrc 文件中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># nvm</div><div class=\"line\">export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</div><div class=\"line\">source ~/git/nvm/nvm.sh</div></pre></td></tr></table></figure></p>\n<p>然后你可以继续非常方便地安装各个版本的 node 了, 你可以查看一下你当前已经安装的版本:</p>\n<p>$ nvm ls<br>         nvm<br>     v0.8.26<br>    v0.10.26<br>    v0.11.11<br>-&gt;  v4.3.2</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果你想长期做 node 开发, 或者想快速更新 node 版本, 或者想快速切换 node 版本,<br>那么在非 Windows(如 osx, linux) 环境下, 请使用 nvm 来安装你的 node 开发环境, 保持系统的干净.<br>如果你使用 Windows 做开发, 那么你可以使用 nvmw 来替代 nvm</p>\n<h3 id=\"git-clone-nvm\"><a href=\"#git-clone-nvm\" class=\"headerlink\" title=\"git clone nvm\"></a>git clone nvm</h3><p>直接从 github clone nvm 到本地, 这里假设大家都使用 ~/git 目录存放 git 项目:<br><code>$ cd ~/git\n$ git clone https://github.com/creationix/nvm.git</code></p>\n<p>配置终端启动时自动执行 source ~/git/nvm/nvm.sh,<br>在 ~/.zshrc 文件添加以下命令:<br><code>source ~/git/nvm/nvm.sh</code><br>重新打开你的终端, 输入 nvm<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nvm</div><div class=\"line\">Node Version Manager</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<h3 id=\"通过-nvm-安装任意版本的-node\"><a href=\"#通过-nvm-安装任意版本的-node\" class=\"headerlink\" title=\"通过 nvm 安装任意版本的 node\"></a>通过 nvm 安装任意版本的 node</h3><p>nvm 默认是从 <a href=\"http://nodejs.org/dist/\" target=\"_blank\" rel=\"external\">http://nodejs.org/dist/</a> 下载的, 国外服务器, 必然很慢,<br>好在 nvm 以及支持从镜像服务器下载包, 于是我们可以方便地从七牛的 node dist 镜像下载:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm ls-remote</div></pre></td></tr></table></figure></p>\n<p>就可以看到远程服务器上的node版本，选择一个进行安装<code>nvm install v4.6.0(nodevesion)</code>即可。<br>于是你就会看到一段非常快速进度条:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">######################################################################## 100.0%</div><div class=\"line\">Now using node v4.6.0</div></pre></td></tr></table></figure></p>\n<p>如果你不想每次都输入环境变量 NVM_NODEJS_ORG_MIRROR, 那么我建议你加入到 .zshrc 文件中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># nvm</div><div class=\"line\">export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</div><div class=\"line\">source ~/git/nvm/nvm.sh</div></pre></td></tr></table></figure></p>\n<p>然后你可以继续非常方便地安装各个版本的 node 了, 你可以查看一下你当前已经安装的版本:</p>\n<p>$ nvm ls<br>         nvm<br>     v0.8.26<br>    v0.10.26<br>    v0.11.11<br>-&gt;  v4.3.2</p>\n"},{"title":"使用webpack压缩图片中遇到的问题","date":"2016-10-10T07:50:08.000Z","_content":"\n> 因为换了笔记本，所以开发环境从mac变成了linux。从svn把代码拉下来后遇到的问题记录在此。\n\n代码基本运行良好，但是在使用**image-webpack-loader**时，编译出错...\n大意如此：png-bin/gifs-bin等等出错。\n在so上爬贴，终于找到了解决方案，这个问题看起来是常出现的，随手记录。\n[原贴在这里](https://github.com/gruntjs/grunt-contrib-imagemin/issues/96)\n\n解决办法也很简单：\n```\nI can say the cause is pngquant-bin module. \nI couldn't track it down to a submodule because after specifying a version, it's auto-fixed:\n\n{\n    \"pngquant-bin\": \"0.1.6\",\n    \"gifsicle\": \"0.1.4\",\n    \"jpegtran-bin\": \"0.2.3\",\n    \"optipng-bin\": \"0.3.1\",\n    \"pngquant-bin\": \"0.1.6\"    \n}\n\nThis in my package.json fixed the issue\nImportant note: specify those in your package.json, CLEAN node_modules \ndirectory (completely, even .bin directory), restart your computer, \nI think it's an issue with environment or a link to an exe that doesn't \nexist, I don't know, but I didn't want to track it down so restarting \nwas ok (one time). After restart, run npm install and it should work.\n```\n把{\n    \"pngquant-bin\": \"0.1.6\",\n    \"gifsicle\": \"0.1.4\",\n    \"jpegtran-bin\": \"0.2.3\",\n    \"optipng-bin\": \"0.3.1\",\n    \"pngquant-bin\": \"0.1.6\"    \n}\n加入package.json中，删掉node_modules文件夹，重启，重装依赖，重启。","source":"_posts/使用webpack压缩图片遇到的问题.md","raw":"---\ntitle: 使用webpack压缩图片中遇到的问题\ndate: 2016-10-10 15:50:08\ntags: \n  - webpack\n  - javascript\n---\n\n> 因为换了笔记本，所以开发环境从mac变成了linux。从svn把代码拉下来后遇到的问题记录在此。\n\n代码基本运行良好，但是在使用**image-webpack-loader**时，编译出错...\n大意如此：png-bin/gifs-bin等等出错。\n在so上爬贴，终于找到了解决方案，这个问题看起来是常出现的，随手记录。\n[原贴在这里](https://github.com/gruntjs/grunt-contrib-imagemin/issues/96)\n\n解决办法也很简单：\n```\nI can say the cause is pngquant-bin module. \nI couldn't track it down to a submodule because after specifying a version, it's auto-fixed:\n\n{\n    \"pngquant-bin\": \"0.1.6\",\n    \"gifsicle\": \"0.1.4\",\n    \"jpegtran-bin\": \"0.2.3\",\n    \"optipng-bin\": \"0.3.1\",\n    \"pngquant-bin\": \"0.1.6\"    \n}\n\nThis in my package.json fixed the issue\nImportant note: specify those in your package.json, CLEAN node_modules \ndirectory (completely, even .bin directory), restart your computer, \nI think it's an issue with environment or a link to an exe that doesn't \nexist, I don't know, but I didn't want to track it down so restarting \nwas ok (one time). After restart, run npm install and it should work.\n```\n把{\n    \"pngquant-bin\": \"0.1.6\",\n    \"gifsicle\": \"0.1.4\",\n    \"jpegtran-bin\": \"0.2.3\",\n    \"optipng-bin\": \"0.3.1\",\n    \"pngquant-bin\": \"0.1.6\"    \n}\n加入package.json中，删掉node_modules文件夹，重启，重装依赖，重启。","slug":"使用webpack压缩图片遇到的问题","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfe70021zk4oyl6wko24","content":"<blockquote>\n<p>因为换了笔记本，所以开发环境从mac变成了linux。从svn把代码拉下来后遇到的问题记录在此。</p>\n</blockquote>\n<p>代码基本运行良好，但是在使用<strong>image-webpack-loader</strong>时，编译出错…<br>大意如此：png-bin/gifs-bin等等出错。<br>在so上爬贴，终于找到了解决方案，这个问题看起来是常出现的，随手记录。<br><a href=\"https://github.com/gruntjs/grunt-contrib-imagemin/issues/96\" target=\"_blank\" rel=\"external\">原贴在这里</a></p>\n<p>解决办法也很简单：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">I can say the cause is pngquant-bin module. </div><div class=\"line\">I couldn&apos;t track it down to a submodule because after specifying a version, it&apos;s auto-fixed:</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;pngquant-bin&quot;: &quot;0.1.6&quot;,</div><div class=\"line\">    &quot;gifsicle&quot;: &quot;0.1.4&quot;,</div><div class=\"line\">    &quot;jpegtran-bin&quot;: &quot;0.2.3&quot;,</div><div class=\"line\">    &quot;optipng-bin&quot;: &quot;0.3.1&quot;,</div><div class=\"line\">    &quot;pngquant-bin&quot;: &quot;0.1.6&quot;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">This in my package.json fixed the issue</div><div class=\"line\">Important note: specify those in your package.json, CLEAN node_modules </div><div class=\"line\">directory (completely, even .bin directory), restart your computer, </div><div class=\"line\">I think it&apos;s an issue with environment or a link to an exe that doesn&apos;t </div><div class=\"line\">exist, I don&apos;t know, but I didn&apos;t want to track it down so restarting </div><div class=\"line\">was ok (one time). After restart, run npm install and it should work.</div></pre></td></tr></table></figure></p>\n<p>把{<br>    “pngquant-bin”: “0.1.6”,<br>    “gifsicle”: “0.1.4”,<br>    “jpegtran-bin”: “0.2.3”,<br>    “optipng-bin”: “0.3.1”,<br>    “pngquant-bin”: “0.1.6”<br>}<br>加入package.json中，删掉node_modules文件夹，重启，重装依赖，重启。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>因为换了笔记本，所以开发环境从mac变成了linux。从svn把代码拉下来后遇到的问题记录在此。</p>\n</blockquote>\n<p>代码基本运行良好，但是在使用<strong>image-webpack-loader</strong>时，编译出错…<br>大意如此：png-bin/gifs-bin等等出错。<br>在so上爬贴，终于找到了解决方案，这个问题看起来是常出现的，随手记录。<br><a href=\"https://github.com/gruntjs/grunt-contrib-imagemin/issues/96\" target=\"_blank\" rel=\"external\">原贴在这里</a></p>\n<p>解决办法也很简单：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">I can say the cause is pngquant-bin module. </div><div class=\"line\">I couldn&apos;t track it down to a submodule because after specifying a version, it&apos;s auto-fixed:</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;pngquant-bin&quot;: &quot;0.1.6&quot;,</div><div class=\"line\">    &quot;gifsicle&quot;: &quot;0.1.4&quot;,</div><div class=\"line\">    &quot;jpegtran-bin&quot;: &quot;0.2.3&quot;,</div><div class=\"line\">    &quot;optipng-bin&quot;: &quot;0.3.1&quot;,</div><div class=\"line\">    &quot;pngquant-bin&quot;: &quot;0.1.6&quot;    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">This in my package.json fixed the issue</div><div class=\"line\">Important note: specify those in your package.json, CLEAN node_modules </div><div class=\"line\">directory (completely, even .bin directory), restart your computer, </div><div class=\"line\">I think it&apos;s an issue with environment or a link to an exe that doesn&apos;t </div><div class=\"line\">exist, I don&apos;t know, but I didn&apos;t want to track it down so restarting </div><div class=\"line\">was ok (one time). After restart, run npm install and it should work.</div></pre></td></tr></table></figure></p>\n<p>把{<br>    “pngquant-bin”: “0.1.6”,<br>    “gifsicle”: “0.1.4”,<br>    “jpegtran-bin”: “0.2.3”,<br>    “optipng-bin”: “0.3.1”,<br>    “pngquant-bin”: “0.1.6”<br>}<br>加入package.json中，删掉node_modules文件夹，重启，重装依赖，重启。</p>\n"},{"title":"如何避免打开谷歌自动跳转香港GOOGLE.COM.HK","date":"2016-10-11T02:24:05.000Z","_content":"> 谷歌搜索是每个程序员必用都工具，但是在国内我们经常打开谷歌就会自动跳到.HK, 如何避免打开谷歌自动跳转到香港GOOGLE.COM.HK\n\n### 防止谷歌自动跳转到香港google.com.hk**解决办法**：\n```\n原理：只要告诉Google.com不要进行区域重定向（No Country Redirection, 简称 NCR）。\n具体做法：在网址栏打入http://www.google.com/ncr，然后回车即可。如果清理了Cookies缓存，还是出现自动跳转现象，重新再在网址栏打入http://www.google.com/ncr输入，回车就行。\n如果打不开，可能是因为google因触及相关敏感关键词因素，访问受限，过段时间再试，或者通过VPN, Goagent等代理工具进行“番羽土啬”。\n```\n**知识补充**：\n谷歌自动跳转到香港google.com.hk的原因：\n谷歌(Google)是目前全球最强的搜索引擎，几乎在全球每个国家和地区都有独立搜索网站（如中国有g.cn 和 google.cn，退出中国市场后，跳转至google.com.hk）全球搜索市场占有率超过75%，为了提升各国google用户有更好的本地搜索体验，google.com根据用户IP进行了区域重定向（或者叫国家重定向）（英文 country Redirection）向这样的设置，这是造成中国大陆&香港用户打开google.com时，自动跳转到google.com.hk的原因。即使选择Google.com.hk首页右下角的英文google.com按钮也不济于事，还是google.com.hk的网址。\n\n### 谷歌自动跳转到香港google.com.hk造成的不便：\n对于身处中国大陆的人士，想搜索更多国外有价值信息而言，google.com明显比google.com.hk更能胜任。这种区域重定向显然给这部分人士带来了诸多不便。\n##### 小提醒：\n在中国访问google.com的搜索结果，还是和在美国本地访问搜索结果有所不同。这也同样涉及到Google排名算法的本地优先原则。\n","source":"_posts/如何避免打开谷歌自动跳转-香港GOOGLE-COM-HK.md","raw":"---\ntitle: 如何避免打开谷歌自动跳转香港GOOGLE.COM.HK\ndate: 2016-10-11 10:24:05\ntags: google\n---\n> 谷歌搜索是每个程序员必用都工具，但是在国内我们经常打开谷歌就会自动跳到.HK, 如何避免打开谷歌自动跳转到香港GOOGLE.COM.HK\n\n### 防止谷歌自动跳转到香港google.com.hk**解决办法**：\n```\n原理：只要告诉Google.com不要进行区域重定向（No Country Redirection, 简称 NCR）。\n具体做法：在网址栏打入http://www.google.com/ncr，然后回车即可。如果清理了Cookies缓存，还是出现自动跳转现象，重新再在网址栏打入http://www.google.com/ncr输入，回车就行。\n如果打不开，可能是因为google因触及相关敏感关键词因素，访问受限，过段时间再试，或者通过VPN, Goagent等代理工具进行“番羽土啬”。\n```\n**知识补充**：\n谷歌自动跳转到香港google.com.hk的原因：\n谷歌(Google)是目前全球最强的搜索引擎，几乎在全球每个国家和地区都有独立搜索网站（如中国有g.cn 和 google.cn，退出中国市场后，跳转至google.com.hk）全球搜索市场占有率超过75%，为了提升各国google用户有更好的本地搜索体验，google.com根据用户IP进行了区域重定向（或者叫国家重定向）（英文 country Redirection）向这样的设置，这是造成中国大陆&香港用户打开google.com时，自动跳转到google.com.hk的原因。即使选择Google.com.hk首页右下角的英文google.com按钮也不济于事，还是google.com.hk的网址。\n\n### 谷歌自动跳转到香港google.com.hk造成的不便：\n对于身处中国大陆的人士，想搜索更多国外有价值信息而言，google.com明显比google.com.hk更能胜任。这种区域重定向显然给这部分人士带来了诸多不便。\n##### 小提醒：\n在中国访问google.com的搜索结果，还是和在美国本地访问搜索结果有所不同。这也同样涉及到Google排名算法的本地优先原则。\n","slug":"如何避免打开谷歌自动跳转-香港GOOGLE-COM-HK","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfe80022zk4ow89o7gsy","content":"<blockquote>\n<p>谷歌搜索是每个程序员必用都工具，但是在国内我们经常打开谷歌就会自动跳到.HK, 如何避免打开谷歌自动跳转到香港GOOGLE.COM.HK</p>\n</blockquote>\n<h3 id=\"防止谷歌自动跳转到香港google-com-hk解决办法：\"><a href=\"#防止谷歌自动跳转到香港google-com-hk解决办法：\" class=\"headerlink\" title=\"防止谷歌自动跳转到香港google.com.hk解决办法：\"></a>防止谷歌自动跳转到香港google.com.hk<strong>解决办法</strong>：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">原理：只要告诉Google.com不要进行区域重定向（No Country Redirection, 简称 NCR）。</div><div class=\"line\">具体做法：在网址栏打入http://www.google.com/ncr，然后回车即可。如果清理了Cookies缓存，还是出现自动跳转现象，重新再在网址栏打入http://www.google.com/ncr输入，回车就行。</div><div class=\"line\">如果打不开，可能是因为google因触及相关敏感关键词因素，访问受限，过段时间再试，或者通过VPN, Goagent等代理工具进行“番羽土啬”。</div></pre></td></tr></table></figure>\n<p><strong>知识补充</strong>：<br>谷歌自动跳转到香港google.com.hk的原因：<br>谷歌(Google)是目前全球最强的搜索引擎，几乎在全球每个国家和地区都有独立搜索网站（如中国有g.cn 和 google.cn，退出中国市场后，跳转至google.com.hk）全球搜索市场占有率超过75%，为了提升各国google用户有更好的本地搜索体验，google.com根据用户IP进行了区域重定向（或者叫国家重定向）（英文 country Redirection）向这样的设置，这是造成中国大陆&amp;香港用户打开google.com时，自动跳转到google.com.hk的原因。即使选择Google.com.hk首页右下角的英文google.com按钮也不济于事，还是google.com.hk的网址。</p>\n<h3 id=\"谷歌自动跳转到香港google-com-hk造成的不便：\"><a href=\"#谷歌自动跳转到香港google-com-hk造成的不便：\" class=\"headerlink\" title=\"谷歌自动跳转到香港google.com.hk造成的不便：\"></a>谷歌自动跳转到香港google.com.hk造成的不便：</h3><p>对于身处中国大陆的人士，想搜索更多国外有价值信息而言，google.com明显比google.com.hk更能胜任。这种区域重定向显然给这部分人士带来了诸多不便。</p>\n<h5 id=\"小提醒：\"><a href=\"#小提醒：\" class=\"headerlink\" title=\"小提醒：\"></a>小提醒：</h5><p>在中国访问google.com的搜索结果，还是和在美国本地访问搜索结果有所不同。这也同样涉及到Google排名算法的本地优先原则。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>谷歌搜索是每个程序员必用都工具，但是在国内我们经常打开谷歌就会自动跳到.HK, 如何避免打开谷歌自动跳转到香港GOOGLE.COM.HK</p>\n</blockquote>\n<h3 id=\"防止谷歌自动跳转到香港google-com-hk解决办法：\"><a href=\"#防止谷歌自动跳转到香港google-com-hk解决办法：\" class=\"headerlink\" title=\"防止谷歌自动跳转到香港google.com.hk解决办法：\"></a>防止谷歌自动跳转到香港google.com.hk<strong>解决办法</strong>：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">原理：只要告诉Google.com不要进行区域重定向（No Country Redirection, 简称 NCR）。</div><div class=\"line\">具体做法：在网址栏打入http://www.google.com/ncr，然后回车即可。如果清理了Cookies缓存，还是出现自动跳转现象，重新再在网址栏打入http://www.google.com/ncr输入，回车就行。</div><div class=\"line\">如果打不开，可能是因为google因触及相关敏感关键词因素，访问受限，过段时间再试，或者通过VPN, Goagent等代理工具进行“番羽土啬”。</div></pre></td></tr></table></figure>\n<p><strong>知识补充</strong>：<br>谷歌自动跳转到香港google.com.hk的原因：<br>谷歌(Google)是目前全球最强的搜索引擎，几乎在全球每个国家和地区都有独立搜索网站（如中国有g.cn 和 google.cn，退出中国市场后，跳转至google.com.hk）全球搜索市场占有率超过75%，为了提升各国google用户有更好的本地搜索体验，google.com根据用户IP进行了区域重定向（或者叫国家重定向）（英文 country Redirection）向这样的设置，这是造成中国大陆&amp;香港用户打开google.com时，自动跳转到google.com.hk的原因。即使选择Google.com.hk首页右下角的英文google.com按钮也不济于事，还是google.com.hk的网址。</p>\n<h3 id=\"谷歌自动跳转到香港google-com-hk造成的不便：\"><a href=\"#谷歌自动跳转到香港google-com-hk造成的不便：\" class=\"headerlink\" title=\"谷歌自动跳转到香港google.com.hk造成的不便：\"></a>谷歌自动跳转到香港google.com.hk造成的不便：</h3><p>对于身处中国大陆的人士，想搜索更多国外有价值信息而言，google.com明显比google.com.hk更能胜任。这种区域重定向显然给这部分人士带来了诸多不便。</p>\n<h5 id=\"小提醒：\"><a href=\"#小提醒：\" class=\"headerlink\" title=\"小提醒：\"></a>小提醒：</h5><p>在中国访问google.com的搜索结果，还是和在美国本地访问搜索结果有所不同。这也同样涉及到Google排名算法的本地优先原则。</p>\n"},{"title":"在ubuntu上安装apache2及mysql","date":"2016-10-09T07:12:20.000Z","_content":"## 安装Apache\n``sudo apt-get install apache2``\nApache安装完成后，默认的网站根目录是\"/var/www/html\"，在终端窗口中输入``ls /var/www/html``,在网站根目录下有一个\"index.html\"文件,在浏览器中输入\"localhost\",就可以打开该页面。\n##### 修改网站的根目录\n1. 在终端窗口中输入``sudo vi /etc/apache2/apache2.conf``,找到**<Directory /var/www/>**的位置,更改\"/var/www/\"为新的根目录\"/var/Sites/\"就可以了。\n2. 在终端窗口中输入``sudo vi /etc/apache2/sites-available/000-default.conf``,**DocumentRoot /var/www/html**的位置,更改\"/var/www/html\"为新的根目录就可以了，这里我把它更改为\"/var/Sites/\"。\n\n## 安装mysql\n``sudo apt-get install mysql-server``","source":"_posts/在ubuntu上安装apache2及mysql.md","raw":"---\ntitle: 在ubuntu上安装apache2及mysql\ndate: 2016-10-09 15:12:20\ntags: ubuntu\n---\n## 安装Apache\n``sudo apt-get install apache2``\nApache安装完成后，默认的网站根目录是\"/var/www/html\"，在终端窗口中输入``ls /var/www/html``,在网站根目录下有一个\"index.html\"文件,在浏览器中输入\"localhost\",就可以打开该页面。\n##### 修改网站的根目录\n1. 在终端窗口中输入``sudo vi /etc/apache2/apache2.conf``,找到**<Directory /var/www/>**的位置,更改\"/var/www/\"为新的根目录\"/var/Sites/\"就可以了。\n2. 在终端窗口中输入``sudo vi /etc/apache2/sites-available/000-default.conf``,**DocumentRoot /var/www/html**的位置,更改\"/var/www/html\"为新的根目录就可以了，这里我把它更改为\"/var/Sites/\"。\n\n## 安装mysql\n``sudo apt-get install mysql-server``","slug":"在ubuntu上安装apache2及mysql","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfe90024zk4okr4e6jgt","content":"<h2 id=\"安装Apache\"><a href=\"#安装Apache\" class=\"headerlink\" title=\"安装Apache\"></a>安装Apache</h2><p><code>sudo apt-get install apache2</code><br>Apache安装完成后，默认的网站根目录是”/var/www/html”，在终端窗口中输入<code>ls /var/www/html</code>,在网站根目录下有一个”index.html”文件,在浏览器中输入”localhost”,就可以打开该页面。</p>\n<h5 id=\"修改网站的根目录\"><a href=\"#修改网站的根目录\" class=\"headerlink\" title=\"修改网站的根目录\"></a>修改网站的根目录</h5><ol>\n<li>在终端窗口中输入<code>sudo vi /etc/apache2/apache2.conf</code>,找到<strong><directory var=\"\" www=\"\"></directory></strong>的位置,更改”/var/www/“为新的根目录”/var/Sites/“就可以了。</li>\n<li>在终端窗口中输入<code>sudo vi /etc/apache2/sites-available/000-default.conf</code>,<strong>DocumentRoot /var/www/html</strong>的位置,更改”/var/www/html”为新的根目录就可以了，这里我把它更改为”/var/Sites/“。</li>\n</ol>\n<h2 id=\"安装mysql\"><a href=\"#安装mysql\" class=\"headerlink\" title=\"安装mysql\"></a>安装mysql</h2><p><code>sudo apt-get install mysql-server</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装Apache\"><a href=\"#安装Apache\" class=\"headerlink\" title=\"安装Apache\"></a>安装Apache</h2><p><code>sudo apt-get install apache2</code><br>Apache安装完成后，默认的网站根目录是”/var/www/html”，在终端窗口中输入<code>ls /var/www/html</code>,在网站根目录下有一个”index.html”文件,在浏览器中输入”localhost”,就可以打开该页面。</p>\n<h5 id=\"修改网站的根目录\"><a href=\"#修改网站的根目录\" class=\"headerlink\" title=\"修改网站的根目录\"></a>修改网站的根目录</h5><ol>\n<li>在终端窗口中输入<code>sudo vi /etc/apache2/apache2.conf</code>,找到<strong><directory var=\"\" www=\"\"></directory></strong>的位置,更改”/var/www/“为新的根目录”/var/Sites/“就可以了。</li>\n<li>在终端窗口中输入<code>sudo vi /etc/apache2/sites-available/000-default.conf</code>,<strong>DocumentRoot /var/www/html</strong>的位置,更改”/var/www/html”为新的根目录就可以了，这里我把它更改为”/var/Sites/“。</li>\n</ol>\n<h2 id=\"安装mysql\"><a href=\"#安装mysql\" class=\"headerlink\" title=\"安装mysql\"></a>安装mysql</h2><p><code>sudo apt-get install mysql-server</code></p>\n"},{"title":"安装ubuntu后要做的几件事","date":"2016-10-08T05:19:10.000Z","thumbnail":"http://baike.baidu.com/pic/ubuntu/155795/0/024f78f0f736afc31a149928b119ebc4b7451266?fr=lemma&ct=single#aid=0&pic=024f78f0f736afc31a149928b119ebc4b7451266","_content":">   这几天自己的笔记本坏了，屏幕闪现，几个按键也失灵了...这次上船的姿势可能不对，哎...\n\n闲话少说，换了公司的备用机，重装ubuntu，之后还有很多事要做，记录在此。\n1. 更换安装源。国外的源一是特别慢，第二就是大家都懂得～打开System Setting-> Software & Update,在**Ubuntu Software**tab下\"Download from\"选择阿里云的源。\n2. 挂载NTFS磁盘。现在基本默认自动挂载，但有时也会出错，比如我这次。解决也很简单：\n - 检查ntfs-3g 是否已经安装    locate ntfs-3g  若是有一大堆反馈，那么就是已经安装了，要是没有安装，输入下面代码\n    ``sudo apt install ntfs-3g``\n - 挂载的错误。可能一般都是这个吧，除非你一直都不可以访问\n    ```sudo ntfsfix /dev/sda5```\n   不同的分区，记得更换位置与名称，我的是上图中的sda5\n3. 挂载ExFat格式U盘。fat格式不支持~~大文件~~，ntfs或者hfs~~日志格式~~不适合U盘，只好使用exfat咯。支持大文件，并且不是日志式。不过ubuntu默认不支持，需要下载软件支持，一句话解决：\n    ``sudo apt install exfat-utils``\n4. 安装flash。这个就是纯粹娱乐了，直接去[adobe官网](https://get.adobe.com/flashplayer/?loc=cn),选择APT方式下载就好了。\n\n5. 安装pip3。现在的linux发行版基本都支持python了，人生苦短，我用python~\n    ``sudo apt-get install python3-pip``\n6. 安装windows字体。好多文件和网页由于字体不全都不怎么好看，那我们直接把windows的字体拷过来就好了。windows字体文件在C:\\windows\\fonts目录下，cp到/usr/share/fonts目录新建winfonts文件夹中，然后:\n 1. mkfontscale\n 2. mkfontdir\n 3. fc-cache\n7. 换ubuntu了，markdown用什么写呢？\n    ``sudo apt install retext``\n ","source":"_posts/安装ubuntu后要做的几件事.md","raw":"---\ntitle: 安装ubuntu后要做的几件事\ndate: 2016-10-08 13:19:10\nthumbnail: http://baike.baidu.com/pic/ubuntu/155795/0/024f78f0f736afc31a149928b119ebc4b7451266?fr=lemma&ct=single#aid=0&pic=024f78f0f736afc31a149928b119ebc4b7451266\ntags: ubuntu\n---\n>   这几天自己的笔记本坏了，屏幕闪现，几个按键也失灵了...这次上船的姿势可能不对，哎...\n\n闲话少说，换了公司的备用机，重装ubuntu，之后还有很多事要做，记录在此。\n1. 更换安装源。国外的源一是特别慢，第二就是大家都懂得～打开System Setting-> Software & Update,在**Ubuntu Software**tab下\"Download from\"选择阿里云的源。\n2. 挂载NTFS磁盘。现在基本默认自动挂载，但有时也会出错，比如我这次。解决也很简单：\n - 检查ntfs-3g 是否已经安装    locate ntfs-3g  若是有一大堆反馈，那么就是已经安装了，要是没有安装，输入下面代码\n    ``sudo apt install ntfs-3g``\n - 挂载的错误。可能一般都是这个吧，除非你一直都不可以访问\n    ```sudo ntfsfix /dev/sda5```\n   不同的分区，记得更换位置与名称，我的是上图中的sda5\n3. 挂载ExFat格式U盘。fat格式不支持~~大文件~~，ntfs或者hfs~~日志格式~~不适合U盘，只好使用exfat咯。支持大文件，并且不是日志式。不过ubuntu默认不支持，需要下载软件支持，一句话解决：\n    ``sudo apt install exfat-utils``\n4. 安装flash。这个就是纯粹娱乐了，直接去[adobe官网](https://get.adobe.com/flashplayer/?loc=cn),选择APT方式下载就好了。\n\n5. 安装pip3。现在的linux发行版基本都支持python了，人生苦短，我用python~\n    ``sudo apt-get install python3-pip``\n6. 安装windows字体。好多文件和网页由于字体不全都不怎么好看，那我们直接把windows的字体拷过来就好了。windows字体文件在C:\\windows\\fonts目录下，cp到/usr/share/fonts目录新建winfonts文件夹中，然后:\n 1. mkfontscale\n 2. mkfontdir\n 3. fc-cache\n7. 换ubuntu了，markdown用什么写呢？\n    ``sudo apt install retext``\n ","slug":"安装ubuntu后要做的几件事","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfeb0026zk4os0hic6y5","content":"<blockquote>\n<p>  这几天自己的笔记本坏了，屏幕闪现，几个按键也失灵了…这次上船的姿势可能不对，哎…</p>\n</blockquote>\n<p>闲话少说，换了公司的备用机，重装ubuntu，之后还有很多事要做，记录在此。</p>\n<ol>\n<li>更换安装源。国外的源一是特别慢，第二就是大家都懂得～打开System Setting-&gt; Software &amp; Update,在<strong>Ubuntu Software</strong>tab下”Download from”选择阿里云的源。</li>\n<li>挂载NTFS磁盘。现在基本默认自动挂载，但有时也会出错，比如我这次。解决也很简单：<ul>\n<li>检查ntfs-3g 是否已经安装    locate ntfs-3g  若是有一大堆反馈，那么就是已经安装了，要是没有安装，输入下面代码<br><code>sudo apt install ntfs-3g</code></li>\n<li>挂载的错误。可能一般都是这个吧，除非你一直都不可以访问<br><code>sudo ntfsfix /dev/sda5</code><br>不同的分区，记得更换位置与名称，我的是上图中的sda5</li>\n</ul>\n</li>\n<li>挂载ExFat格式U盘。fat格式不支持<del>大文件</del>，ntfs或者hfs<del>日志格式</del>不适合U盘，只好使用exfat咯。支持大文件，并且不是日志式。不过ubuntu默认不支持，需要下载软件支持，一句话解决：<br> <code>sudo apt install exfat-utils</code></li>\n<li><p>安装flash。这个就是纯粹娱乐了，直接去<a href=\"https://get.adobe.com/flashplayer/?loc=cn\" target=\"_blank\" rel=\"external\">adobe官网</a>,选择APT方式下载就好了。</p>\n</li>\n<li><p>安装pip3。现在的linux发行版基本都支持python了，人生苦短，我用python~<br> <code>sudo apt-get install python3-pip</code></p>\n</li>\n<li>安装windows字体。好多文件和网页由于字体不全都不怎么好看，那我们直接把windows的字体拷过来就好了。windows字体文件在C:\\windows\\fonts目录下，cp到/usr/share/fonts目录新建winfonts文件夹中，然后:<ol>\n<li>mkfontscale</li>\n<li>mkfontdir</li>\n<li>fc-cache</li>\n</ol>\n</li>\n<li>换ubuntu了，markdown用什么写呢？<br> <code>sudo apt install retext</code></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>  这几天自己的笔记本坏了，屏幕闪现，几个按键也失灵了…这次上船的姿势可能不对，哎…</p>\n</blockquote>\n<p>闲话少说，换了公司的备用机，重装ubuntu，之后还有很多事要做，记录在此。</p>\n<ol>\n<li>更换安装源。国外的源一是特别慢，第二就是大家都懂得～打开System Setting-&gt; Software &amp; Update,在<strong>Ubuntu Software</strong>tab下”Download from”选择阿里云的源。</li>\n<li>挂载NTFS磁盘。现在基本默认自动挂载，但有时也会出错，比如我这次。解决也很简单：<ul>\n<li>检查ntfs-3g 是否已经安装    locate ntfs-3g  若是有一大堆反馈，那么就是已经安装了，要是没有安装，输入下面代码<br><code>sudo apt install ntfs-3g</code></li>\n<li>挂载的错误。可能一般都是这个吧，除非你一直都不可以访问<br><code>sudo ntfsfix /dev/sda5</code><br>不同的分区，记得更换位置与名称，我的是上图中的sda5</li>\n</ul>\n</li>\n<li>挂载ExFat格式U盘。fat格式不支持<del>大文件</del>，ntfs或者hfs<del>日志格式</del>不适合U盘，只好使用exfat咯。支持大文件，并且不是日志式。不过ubuntu默认不支持，需要下载软件支持，一句话解决：<br> <code>sudo apt install exfat-utils</code></li>\n<li><p>安装flash。这个就是纯粹娱乐了，直接去<a href=\"https://get.adobe.com/flashplayer/?loc=cn\" target=\"_blank\" rel=\"external\">adobe官网</a>,选择APT方式下载就好了。</p>\n</li>\n<li><p>安装pip3。现在的linux发行版基本都支持python了，人生苦短，我用python~<br> <code>sudo apt-get install python3-pip</code></p>\n</li>\n<li>安装windows字体。好多文件和网页由于字体不全都不怎么好看，那我们直接把windows的字体拷过来就好了。windows字体文件在C:\\windows\\fonts目录下，cp到/usr/share/fonts目录新建winfonts文件夹中，然后:<ol>\n<li>mkfontscale</li>\n<li>mkfontdir</li>\n<li>fc-cache</li>\n</ol>\n</li>\n<li>换ubuntu了，markdown用什么写呢？<br> <code>sudo apt install retext</code></li>\n</ol>\n"},{"title":"调试手机端微信X5浏览器","date":"2016-11-15T03:22:04.000Z","_content":"### 移动调试\n移动端网页的表现，通常和桌面浏览器上有所区别，包括样式的呈现、脚本的逻辑等等，这会给开发者带来一定的困扰。现在，微信安卓客户端 webview 已经开始全面升级至 **X5 Blink** 内核，新的内核无论在渲染能力、API 支持还是在开发辅助上都有很大进步。通过**微信 web 开发者工具**中的远程调试功能，实时映射手机屏幕到微信 web 开发者工具上，将帮助开发者更高效地调试 X5 Blink 内核的网页，具体步骤如下：\n1. 准备工作\n 1. 安装0.5.0或以上版本的微信 web 开发者工具\n 2. 确认移动设备是否支持远程调试功能\n  打开微信 web 开发者工具，选择“移动调试”tab，点击验证移动设备是否支持。随后使用移动设备扫描弹出的二维码，在设备上即可获得支持信息。\n 3. 打开移动设备中的 USB 调试功能\n  1. 打开移动设备，进入“设置”->“开发人员选项”\n  2. 勾选“USB 调试功能”\n  ![usb调试](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4ia39RvTaqRBxuI3A756YjtCoByQQKyHtib7DDPl4UsCTIVeo3iarTcOs6A/0?wx_fmt=jpeg)\n  需要注意的是，Android 4.2 之后的设备，开发人员选项默认是隐藏的，通过以下步骤可以打开：\n   1. 打开移动设备，进入“设置”->“关于手机”\n   2. 找到并单击“内部版本号”7次\n 4. 安装移动设备 USB 驱动\n 5. 打开 X5 Blink 内核的 inspector 功能\n   打开微信 web 开发者工具，选择“移动调试”tab ，使用设备扫描“调试步骤”中的二维码。\n   如下图，勾选“是否打开 TBS 内核 Inspector 调试功能”，并重启微信。\n  ![微信设置](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iayIjGCiaY8Fj4kcmickmFjoWoPbicICk9xjNStOmSBsDkRAoYTRjeXHRdQ/0?wx_fmt=jpeg)\n<!--more-->\n2. 开始调试\n使用 USB 数据线连接移动设备与 PC 或者 Mac 后，点击打开微信 web 开发者工具“移动调试”tab，选择 X5 Blink 调试功能，将会打开一个新窗口，在微信中访问任意网页即可开始调试。关于 X5 Blink 内核更多信息，可以查看[官网介绍](http://x5.tencent.com/guide?id=4000)。\n在所有准备工作都完成的情况下，窗口中可以看到当前设备的基本信息：\n![微信打开页面，启动调试](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaUgGafLxWM42m0ax3Ccf5p1aZh6BpGb0cXfdREicyiaD61ibFZk0Oqmf2g/0?wx_fmt=jpeg)\n点击任意页面的“inspect”，打开新窗口，开发者会看到熟悉的调试界面：\n![调试](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iatJNE7NSspCWCAm3NP0niaJuIUs9tYwGv9KVtFtR7l9ibJNbOicdjtW50w/0?wx_fmt=png)\n点击上图右上角的“手机”图标，将启用屏幕映射功能：\n![映射](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaIsXD9S02yz9j5dYaMAAsXxnK8FSzS39bpickcG7UHyry4UkiaCbtM9Dw/0?wx_fmt=png)","source":"_posts/调试手机端微信X5浏览器.md","raw":"---\ntitle: 调试手机端微信X5浏览器\ndate: 2016-11-15 11:22:04\ntags: 微信\n---\n### 移动调试\n移动端网页的表现，通常和桌面浏览器上有所区别，包括样式的呈现、脚本的逻辑等等，这会给开发者带来一定的困扰。现在，微信安卓客户端 webview 已经开始全面升级至 **X5 Blink** 内核，新的内核无论在渲染能力、API 支持还是在开发辅助上都有很大进步。通过**微信 web 开发者工具**中的远程调试功能，实时映射手机屏幕到微信 web 开发者工具上，将帮助开发者更高效地调试 X5 Blink 内核的网页，具体步骤如下：\n1. 准备工作\n 1. 安装0.5.0或以上版本的微信 web 开发者工具\n 2. 确认移动设备是否支持远程调试功能\n  打开微信 web 开发者工具，选择“移动调试”tab，点击验证移动设备是否支持。随后使用移动设备扫描弹出的二维码，在设备上即可获得支持信息。\n 3. 打开移动设备中的 USB 调试功能\n  1. 打开移动设备，进入“设置”->“开发人员选项”\n  2. 勾选“USB 调试功能”\n  ![usb调试](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4ia39RvTaqRBxuI3A756YjtCoByQQKyHtib7DDPl4UsCTIVeo3iarTcOs6A/0?wx_fmt=jpeg)\n  需要注意的是，Android 4.2 之后的设备，开发人员选项默认是隐藏的，通过以下步骤可以打开：\n   1. 打开移动设备，进入“设置”->“关于手机”\n   2. 找到并单击“内部版本号”7次\n 4. 安装移动设备 USB 驱动\n 5. 打开 X5 Blink 内核的 inspector 功能\n   打开微信 web 开发者工具，选择“移动调试”tab ，使用设备扫描“调试步骤”中的二维码。\n   如下图，勾选“是否打开 TBS 内核 Inspector 调试功能”，并重启微信。\n  ![微信设置](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iayIjGCiaY8Fj4kcmickmFjoWoPbicICk9xjNStOmSBsDkRAoYTRjeXHRdQ/0?wx_fmt=jpeg)\n<!--more-->\n2. 开始调试\n使用 USB 数据线连接移动设备与 PC 或者 Mac 后，点击打开微信 web 开发者工具“移动调试”tab，选择 X5 Blink 调试功能，将会打开一个新窗口，在微信中访问任意网页即可开始调试。关于 X5 Blink 内核更多信息，可以查看[官网介绍](http://x5.tencent.com/guide?id=4000)。\n在所有准备工作都完成的情况下，窗口中可以看到当前设备的基本信息：\n![微信打开页面，启动调试](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaUgGafLxWM42m0ax3Ccf5p1aZh6BpGb0cXfdREicyiaD61ibFZk0Oqmf2g/0?wx_fmt=jpeg)\n点击任意页面的“inspect”，打开新窗口，开发者会看到熟悉的调试界面：\n![调试](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iatJNE7NSspCWCAm3NP0niaJuIUs9tYwGv9KVtFtR7l9ibJNbOicdjtW50w/0?wx_fmt=png)\n点击上图右上角的“手机”图标，将启用屏幕映射功能：\n![映射](http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaIsXD9S02yz9j5dYaMAAsXxnK8FSzS39bpickcG7UHyry4UkiaCbtM9Dw/0?wx_fmt=png)","slug":"调试手机端微信X5浏览器","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfec0029zk4ojohd9tdn","content":"<h3 id=\"移动调试\"><a href=\"#移动调试\" class=\"headerlink\" title=\"移动调试\"></a>移动调试</h3><p>移动端网页的表现，通常和桌面浏览器上有所区别，包括样式的呈现、脚本的逻辑等等，这会给开发者带来一定的困扰。现在，微信安卓客户端 webview 已经开始全面升级至 <strong>X5 Blink</strong> 内核，新的内核无论在渲染能力、API 支持还是在开发辅助上都有很大进步。通过<strong>微信 web 开发者工具</strong>中的远程调试功能，实时映射手机屏幕到微信 web 开发者工具上，将帮助开发者更高效地调试 X5 Blink 内核的网页，具体步骤如下：</p>\n<ol>\n<li>准备工作<ol>\n<li>安装0.5.0或以上版本的微信 web 开发者工具</li>\n<li>确认移动设备是否支持远程调试功能<br>打开微信 web 开发者工具，选择“移动调试”tab，点击验证移动设备是否支持。随后使用移动设备扫描弹出的二维码，在设备上即可获得支持信息。</li>\n<li>打开移动设备中的 USB 调试功能</li>\n<li>打开移动设备，进入“设置”-&gt;“开发人员选项”</li>\n<li>勾选“USB 调试功能”<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4ia39RvTaqRBxuI3A756YjtCoByQQKyHtib7DDPl4UsCTIVeo3iarTcOs6A/0?wx_fmt=jpeg\" alt=\"usb调试\"><br>需要注意的是，Android 4.2 之后的设备，开发人员选项默认是隐藏的，通过以下步骤可以打开：</li>\n<li>打开移动设备，进入“设置”-&gt;“关于手机”</li>\n<li>找到并单击“内部版本号”7次</li>\n<li>安装移动设备 USB 驱动</li>\n<li>打开 X5 Blink 内核的 inspector 功能<br>打开微信 web 开发者工具，选择“移动调试”tab ，使用设备扫描“调试步骤”中的二维码。<br>如下图，勾选“是否打开 TBS 内核 Inspector 调试功能”，并重启微信。<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iayIjGCiaY8Fj4kcmickmFjoWoPbicICk9xjNStOmSBsDkRAoYTRjeXHRdQ/0?wx_fmt=jpeg\" alt=\"微信设置\"><a id=\"more\"></a></li>\n</ol>\n</li>\n<li>开始调试<br>使用 USB 数据线连接移动设备与 PC 或者 Mac 后，点击打开微信 web 开发者工具“移动调试”tab，选择 X5 Blink 调试功能，将会打开一个新窗口，在微信中访问任意网页即可开始调试。关于 X5 Blink 内核更多信息，可以查看<a href=\"http://x5.tencent.com/guide?id=4000\" target=\"_blank\" rel=\"external\">官网介绍</a>。<br>在所有准备工作都完成的情况下，窗口中可以看到当前设备的基本信息：<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaUgGafLxWM42m0ax3Ccf5p1aZh6BpGb0cXfdREicyiaD61ibFZk0Oqmf2g/0?wx_fmt=jpeg\" alt=\"微信打开页面，启动调试\"><br>点击任意页面的“inspect”，打开新窗口，开发者会看到熟悉的调试界面：<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iatJNE7NSspCWCAm3NP0niaJuIUs9tYwGv9KVtFtR7l9ibJNbOicdjtW50w/0?wx_fmt=png\" alt=\"调试\"><br>点击上图右上角的“手机”图标，将启用屏幕映射功能：<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaIsXD9S02yz9j5dYaMAAsXxnK8FSzS39bpickcG7UHyry4UkiaCbtM9Dw/0?wx_fmt=png\" alt=\"映射\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"移动调试\"><a href=\"#移动调试\" class=\"headerlink\" title=\"移动调试\"></a>移动调试</h3><p>移动端网页的表现，通常和桌面浏览器上有所区别，包括样式的呈现、脚本的逻辑等等，这会给开发者带来一定的困扰。现在，微信安卓客户端 webview 已经开始全面升级至 <strong>X5 Blink</strong> 内核，新的内核无论在渲染能力、API 支持还是在开发辅助上都有很大进步。通过<strong>微信 web 开发者工具</strong>中的远程调试功能，实时映射手机屏幕到微信 web 开发者工具上，将帮助开发者更高效地调试 X5 Blink 内核的网页，具体步骤如下：</p>\n<ol>\n<li>准备工作<ol>\n<li>安装0.5.0或以上版本的微信 web 开发者工具</li>\n<li>确认移动设备是否支持远程调试功能<br>打开微信 web 开发者工具，选择“移动调试”tab，点击验证移动设备是否支持。随后使用移动设备扫描弹出的二维码，在设备上即可获得支持信息。</li>\n<li>打开移动设备中的 USB 调试功能</li>\n<li>打开移动设备，进入“设置”-&gt;“开发人员选项”</li>\n<li>勾选“USB 调试功能”<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4ia39RvTaqRBxuI3A756YjtCoByQQKyHtib7DDPl4UsCTIVeo3iarTcOs6A/0?wx_fmt=jpeg\" alt=\"usb调试\"><br>需要注意的是，Android 4.2 之后的设备，开发人员选项默认是隐藏的，通过以下步骤可以打开：</li>\n<li>打开移动设备，进入“设置”-&gt;“关于手机”</li>\n<li>找到并单击“内部版本号”7次</li>\n<li>安装移动设备 USB 驱动</li>\n<li>打开 X5 Blink 内核的 inspector 功能<br>打开微信 web 开发者工具，选择“移动调试”tab ，使用设备扫描“调试步骤”中的二维码。<br>如下图，勾选“是否打开 TBS 内核 Inspector 调试功能”，并重启微信。<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iayIjGCiaY8Fj4kcmickmFjoWoPbicICk9xjNStOmSBsDkRAoYTRjeXHRdQ/0?wx_fmt=jpeg\" alt=\"微信设置\">","more":"</li>\n</ol>\n</li>\n<li>开始调试<br>使用 USB 数据线连接移动设备与 PC 或者 Mac 后，点击打开微信 web 开发者工具“移动调试”tab，选择 X5 Blink 调试功能，将会打开一个新窗口，在微信中访问任意网页即可开始调试。关于 X5 Blink 内核更多信息，可以查看<a href=\"http://x5.tencent.com/guide?id=4000\" target=\"_blank\" rel=\"external\">官网介绍</a>。<br>在所有准备工作都完成的情况下，窗口中可以看到当前设备的基本信息：<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaUgGafLxWM42m0ax3Ccf5p1aZh6BpGb0cXfdREicyiaD61ibFZk0Oqmf2g/0?wx_fmt=jpeg\" alt=\"微信打开页面，启动调试\"><br>点击任意页面的“inspect”，打开新窗口，开发者会看到熟悉的调试界面：<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iatJNE7NSspCWCAm3NP0niaJuIUs9tYwGv9KVtFtR7l9ibJNbOicdjtW50w/0?wx_fmt=png\" alt=\"调试\"><br>点击上图右上角的“手机”图标，将启用屏幕映射功能：<br><img src=\"http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaIsXD9S02yz9j5dYaMAAsXxnK8FSzS39bpickcG7UHyry4UkiaCbtM9Dw/0?wx_fmt=png\" alt=\"映射\"></li>\n</ol>"},{"title":"使用requestAnimationFrame做动画控制","date":"2016-10-12T03:04:45.000Z","_content":"### requestAnimationFrame是什么？\n\n在浏览器动画程序中，我们通常使用一个定时器来循环每隔几毫秒移动目标物体一次，来让它动起来。如今有一个好消息，浏览器开发商们决定：“嗨，为什么我们不在浏览器里提供这样一个API呢，这样一来我们可以为用户优化他们的动画。”所以，这个requestAnimationFrame()函数就是针对动画效果的API，你可以把它用在DOM上的风格变化或画布动画或WebGL中。\n\n### 使用requestAnimationFrame有什么好处？\n\n浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。\n**requestAnimationFrame的用法**\n{% codeblock requestAnimationFrame lang:javascript %}\n// usage:\n// instead of setInterval(render, 16) ....\nvar out = document.querySelector('#out'),\n    inner = document.querySelector('#inner'),\n    count=0,width=0,inCre;\nfunction changeBackground() {\n    inner.style.width = width+'%';\n    width++;\n    if(width<=100){\n        inCre = requestAnimationFrame(changeBackground);\n    }else{\n        cancelAnimationFrame(inCre)\n    }\n}\ninCre=requestAnimationFrame(changeBackground)\n{% endcodeblock %}\n<!--more-->\n### 对requestAnimationFrame更牢靠的封装\n\nOpera浏览器的技术师**Erik Möller** 把这个函数进行了封装，使得它能更好的兼容各种浏览器。你可以读一读这篇文章，但基本上他的代码就是判断使用4ms还是16ms的延迟，来最佳匹配60fps。下面就是这段代码，你可以使用它，但请注意，这段代码里使用的是标准函数，我给它加上了兼容各种浏览器引擎前缀。\n{% codeblock requestAnimationFrame lang:javascript %}\n(function() {\n    var lastTime = 0;\n    var vendors = ['webkit', 'moz'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n        window.cancelAnimationFrame =\n          window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n\n    if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n              timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n\n    if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n}());\n{% endcodeblock %}\n\n### requestAnimationFrame API\n``\nwindow.requestAnimationFrame(function(/* time */ time){\n  // time ~= +new Date // the unix time\n});``\n回调函数里的参数可以传入时间。\n\n### 各种浏览器对requestAnimationFrame的支持情况\n[caniuse](http://caniuse.com/#search=requestAnimationFrame)\n谷歌浏览器，火狐浏览器，IE10+都实现了这个函数，即使你的浏览器很古老，上面的对requestAnimationFrame封装也能让这个方法在IE8/9上不出错。","source":"_posts/使用requestAnimationFrame做动画控制.md","raw":"---\ntitle: 使用requestAnimationFrame做动画控制\ndate: 2016-10-12 11:04:45\ntags: html5\n---\n### requestAnimationFrame是什么？\n\n在浏览器动画程序中，我们通常使用一个定时器来循环每隔几毫秒移动目标物体一次，来让它动起来。如今有一个好消息，浏览器开发商们决定：“嗨，为什么我们不在浏览器里提供这样一个API呢，这样一来我们可以为用户优化他们的动画。”所以，这个requestAnimationFrame()函数就是针对动画效果的API，你可以把它用在DOM上的风格变化或画布动画或WebGL中。\n\n### 使用requestAnimationFrame有什么好处？\n\n浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。\n**requestAnimationFrame的用法**\n{% codeblock requestAnimationFrame lang:javascript %}\n// usage:\n// instead of setInterval(render, 16) ....\nvar out = document.querySelector('#out'),\n    inner = document.querySelector('#inner'),\n    count=0,width=0,inCre;\nfunction changeBackground() {\n    inner.style.width = width+'%';\n    width++;\n    if(width<=100){\n        inCre = requestAnimationFrame(changeBackground);\n    }else{\n        cancelAnimationFrame(inCre)\n    }\n}\ninCre=requestAnimationFrame(changeBackground)\n{% endcodeblock %}\n<!--more-->\n### 对requestAnimationFrame更牢靠的封装\n\nOpera浏览器的技术师**Erik Möller** 把这个函数进行了封装，使得它能更好的兼容各种浏览器。你可以读一读这篇文章，但基本上他的代码就是判断使用4ms还是16ms的延迟，来最佳匹配60fps。下面就是这段代码，你可以使用它，但请注意，这段代码里使用的是标准函数，我给它加上了兼容各种浏览器引擎前缀。\n{% codeblock requestAnimationFrame lang:javascript %}\n(function() {\n    var lastTime = 0;\n    var vendors = ['webkit', 'moz'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n        window.cancelAnimationFrame =\n          window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n\n    if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n              timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n\n    if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n}());\n{% endcodeblock %}\n\n### requestAnimationFrame API\n``\nwindow.requestAnimationFrame(function(/* time */ time){\n  // time ~= +new Date // the unix time\n});``\n回调函数里的参数可以传入时间。\n\n### 各种浏览器对requestAnimationFrame的支持情况\n[caniuse](http://caniuse.com/#search=requestAnimationFrame)\n谷歌浏览器，火狐浏览器，IE10+都实现了这个函数，即使你的浏览器很古老，上面的对requestAnimationFrame封装也能让这个方法在IE8/9上不出错。","slug":"使用requestAnimationFrame做动画控制","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfed002bzk4o1xlasikd","content":"<h3 id=\"requestAnimationFrame是什么？\"><a href=\"#requestAnimationFrame是什么？\" class=\"headerlink\" title=\"requestAnimationFrame是什么？\"></a>requestAnimationFrame是什么？</h3><p>在浏览器动画程序中，我们通常使用一个定时器来循环每隔几毫秒移动目标物体一次，来让它动起来。如今有一个好消息，浏览器开发商们决定：“嗨，为什么我们不在浏览器里提供这样一个API呢，这样一来我们可以为用户优化他们的动画。”所以，这个requestAnimationFrame()函数就是针对动画效果的API，你可以把它用在DOM上的风格变化或画布动画或WebGL中。</p>\n<h3 id=\"使用requestAnimationFrame有什么好处？\"><a href=\"#使用requestAnimationFrame有什么好处？\" class=\"headerlink\" title=\"使用requestAnimationFrame有什么好处？\"></a>使用requestAnimationFrame有什么好处？</h3><p>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。<br><strong>requestAnimationFrame的用法</strong><br><figure class=\"highlight javascript\"><figcaption><span>requestAnimationFrame</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// usage:</span></div><div class=\"line\"><span class=\"comment\">// instead of setInterval(render, 16) ....</span></div><div class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#out'</span>),</div><div class=\"line\">    inner = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#inner'</span>),</div><div class=\"line\">    count=<span class=\"number\">0</span>,width=<span class=\"number\">0</span>,inCre;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeBackground</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    inner.style.width = width+<span class=\"string\">'%'</span>;</div><div class=\"line\">    width++;</div><div class=\"line\">    <span class=\"keyword\">if</span>(width&lt;=<span class=\"number\">100</span>)&#123;</div><div class=\"line\">        inCre = requestAnimationFrame(changeBackground);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        cancelAnimationFrame(inCre)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">inCre=requestAnimationFrame(changeBackground)</div></pre></td></tr></table></figure><br><a id=\"more\"></a></p>\n<h3 id=\"对requestAnimationFrame更牢靠的封装\"><a href=\"#对requestAnimationFrame更牢靠的封装\" class=\"headerlink\" title=\"对requestAnimationFrame更牢靠的封装\"></a>对requestAnimationFrame更牢靠的封装</h3><p>Opera浏览器的技术师<strong>Erik Möller</strong> 把这个函数进行了封装，使得它能更好的兼容各种浏览器。你可以读一读这篇文章，但基本上他的代码就是判断使用4ms还是16ms的延迟，来最佳匹配60fps。下面就是这段代码，你可以使用它，但请注意，这段代码里使用的是标准函数，我给它加上了兼容各种浏览器引擎前缀。<br><figure class=\"highlight javascript\"><figcaption><span>requestAnimationFrame</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastTime = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> vendors = [<span class=\"string\">'webkit'</span>, <span class=\"string\">'moz'</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> x = <span class=\"number\">0</span>; x &lt; vendors.length &amp;&amp; !<span class=\"built_in\">window</span>.requestAnimationFrame; ++x) &#123;</div><div class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame = <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'RequestAnimationFrame'</span>];</div><div class=\"line\">        <span class=\"built_in\">window</span>.cancelAnimationFrame =</div><div class=\"line\">          <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'CancelAnimationFrame'</span>] || <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'CancelRequestAnimationFrame'</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">window</span>.requestAnimationFrame)</div><div class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback, element</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> currTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</div><div class=\"line\">            <span class=\"keyword\">var</span> timeToCall = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>, <span class=\"number\">16</span> - (currTime - lastTime));</div><div class=\"line\">            <span class=\"keyword\">var</span> id = <span class=\"built_in\">window</span>.setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; callback(currTime + timeToCall); &#125;,</div><div class=\"line\">              timeToCall);</div><div class=\"line\">            lastTime = currTime + timeToCall;</div><div class=\"line\">            <span class=\"keyword\">return</span> id;</div><div class=\"line\">        &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">window</span>.cancelAnimationFrame)</div><div class=\"line\">        <span class=\"built_in\">window</span>.cancelAnimationFrame = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">            clearTimeout(id);</div><div class=\"line\">        &#125;;</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure></p>\n<h3 id=\"requestAnimationFrame-API\"><a href=\"#requestAnimationFrame-API\" class=\"headerlink\" title=\"requestAnimationFrame API\"></a>requestAnimationFrame API</h3><p><code>window.requestAnimationFrame(function(/* time */ time){\n  // time ~= +new Date // the unix time\n});</code><br>回调函数里的参数可以传入时间。</p>\n<h3 id=\"各种浏览器对requestAnimationFrame的支持情况\"><a href=\"#各种浏览器对requestAnimationFrame的支持情况\" class=\"headerlink\" title=\"各种浏览器对requestAnimationFrame的支持情况\"></a>各种浏览器对requestAnimationFrame的支持情况</h3><p><a href=\"http://caniuse.com/#search=requestAnimationFrame\" target=\"_blank\" rel=\"external\">caniuse</a><br>谷歌浏览器，火狐浏览器，IE10+都实现了这个函数，即使你的浏览器很古老，上面的对requestAnimationFrame封装也能让这个方法在IE8/9上不出错。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"requestAnimationFrame是什么？\"><a href=\"#requestAnimationFrame是什么？\" class=\"headerlink\" title=\"requestAnimationFrame是什么？\"></a>requestAnimationFrame是什么？</h3><p>在浏览器动画程序中，我们通常使用一个定时器来循环每隔几毫秒移动目标物体一次，来让它动起来。如今有一个好消息，浏览器开发商们决定：“嗨，为什么我们不在浏览器里提供这样一个API呢，这样一来我们可以为用户优化他们的动画。”所以，这个requestAnimationFrame()函数就是针对动画效果的API，你可以把它用在DOM上的风格变化或画布动画或WebGL中。</p>\n<h3 id=\"使用requestAnimationFrame有什么好处？\"><a href=\"#使用requestAnimationFrame有什么好处？\" class=\"headerlink\" title=\"使用requestAnimationFrame有什么好处？\"></a>使用requestAnimationFrame有什么好处？</h3><p>浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。<br><strong>requestAnimationFrame的用法</strong><br><figure class=\"highlight javascript\"><figcaption><span>requestAnimationFrame</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// usage:</span></div><div class=\"line\"><span class=\"comment\">// instead of setInterval(render, 16) ....</span></div><div class=\"line\"><span class=\"keyword\">var</span> out = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#out'</span>),</div><div class=\"line\">    inner = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#inner'</span>),</div><div class=\"line\">    count=<span class=\"number\">0</span>,width=<span class=\"number\">0</span>,inCre;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeBackground</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    inner.style.width = width+<span class=\"string\">'%'</span>;</div><div class=\"line\">    width++;</div><div class=\"line\">    <span class=\"keyword\">if</span>(width&lt;=<span class=\"number\">100</span>)&#123;</div><div class=\"line\">        inCre = requestAnimationFrame(changeBackground);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        cancelAnimationFrame(inCre)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">inCre=requestAnimationFrame(changeBackground)</div></pre></td></tr></table></figure><br>","more":"</p>\n<h3 id=\"对requestAnimationFrame更牢靠的封装\"><a href=\"#对requestAnimationFrame更牢靠的封装\" class=\"headerlink\" title=\"对requestAnimationFrame更牢靠的封装\"></a>对requestAnimationFrame更牢靠的封装</h3><p>Opera浏览器的技术师<strong>Erik Möller</strong> 把这个函数进行了封装，使得它能更好的兼容各种浏览器。你可以读一读这篇文章，但基本上他的代码就是判断使用4ms还是16ms的延迟，来最佳匹配60fps。下面就是这段代码，你可以使用它，但请注意，这段代码里使用的是标准函数，我给它加上了兼容各种浏览器引擎前缀。<br><figure class=\"highlight javascript\"><figcaption><span>requestAnimationFrame</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastTime = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> vendors = [<span class=\"string\">'webkit'</span>, <span class=\"string\">'moz'</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> x = <span class=\"number\">0</span>; x &lt; vendors.length &amp;&amp; !<span class=\"built_in\">window</span>.requestAnimationFrame; ++x) &#123;</div><div class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame = <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'RequestAnimationFrame'</span>];</div><div class=\"line\">        <span class=\"built_in\">window</span>.cancelAnimationFrame =</div><div class=\"line\">          <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'CancelAnimationFrame'</span>] || <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'CancelRequestAnimationFrame'</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">window</span>.requestAnimationFrame)</div><div class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback, element</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> currTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</div><div class=\"line\">            <span class=\"keyword\">var</span> timeToCall = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>, <span class=\"number\">16</span> - (currTime - lastTime));</div><div class=\"line\">            <span class=\"keyword\">var</span> id = <span class=\"built_in\">window</span>.setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; callback(currTime + timeToCall); &#125;,</div><div class=\"line\">              timeToCall);</div><div class=\"line\">            lastTime = currTime + timeToCall;</div><div class=\"line\">            <span class=\"keyword\">return</span> id;</div><div class=\"line\">        &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">window</span>.cancelAnimationFrame)</div><div class=\"line\">        <span class=\"built_in\">window</span>.cancelAnimationFrame = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">            clearTimeout(id);</div><div class=\"line\">        &#125;;</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure></p>\n<h3 id=\"requestAnimationFrame-API\"><a href=\"#requestAnimationFrame-API\" class=\"headerlink\" title=\"requestAnimationFrame API\"></a>requestAnimationFrame API</h3><p><code>window.requestAnimationFrame(function(/* time */ time){\n  // time ~= +new Date // the unix time\n});</code><br>回调函数里的参数可以传入时间。</p>\n<h3 id=\"各种浏览器对requestAnimationFrame的支持情况\"><a href=\"#各种浏览器对requestAnimationFrame的支持情况\" class=\"headerlink\" title=\"各种浏览器对requestAnimationFrame的支持情况\"></a>各种浏览器对requestAnimationFrame的支持情况</h3><p><a href=\"http://caniuse.com/#search=requestAnimationFrame\" target=\"_blank\" rel=\"external\">caniuse</a><br>谷歌浏览器，火狐浏览器，IE10+都实现了这个函数，即使你的浏览器很古老，上面的对requestAnimationFrame封装也能让这个方法在IE8/9上不出错。</p>"},{"title":"网易云音乐官方linux版！","date":"2016-10-08T06:43:34.000Z","_content":"记得以前用的还是开源版本的一个网易云音乐，今天去找，居然发现官方版粗现了~~~[网易云](http://music.163.com/#/download)果然是良心。\n安装方法：\n``\ndpkg -i *.deb\n``","source":"_posts/网易云音乐官方linux版！.md","raw":"---\ntitle: 网易云音乐官方linux版！\ndate: 2016-10-08 14:43:34\ntags: software\n---\n记得以前用的还是开源版本的一个网易云音乐，今天去找，居然发现官方版粗现了~~~[网易云](http://music.163.com/#/download)果然是良心。\n安装方法：\n``\ndpkg -i *.deb\n``","slug":"网易云音乐官方linux版！","published":1,"updated":"2017-05-31T10:44:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3dvkfee002ezk4okezhfdrm","content":"<p>记得以前用的还是开源版本的一个网易云音乐，今天去找，居然发现官方版粗现了~~~<a href=\"http://music.163.com/#/download\" target=\"_blank\" rel=\"external\">网易云</a>果然是良心。<br>安装方法：<br><code>dpkg -i *.deb</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>记得以前用的还是开源版本的一个网易云音乐，今天去找，居然发现官方版粗现了~~~<a href=\"http://music.163.com/#/download\" target=\"_blank\" rel=\"external\">网易云</a>果然是良心。<br>安装方法：<br><code>dpkg -i *.deb</code></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj3dvkfbk0004zk4o31975zfm","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfbr0007zk4o44mjzjsv"},{"post_id":"cj3dvkfb40000zk4owcydopda","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfbs0009zk4oy6pfij02"},{"post_id":"cj3dvkfbo0005zk4oilf5m9wf","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfbw000czk4oaakdjhgd"},{"post_id":"cj3dvkfbr0008zk4owdii00ay","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfbx000ezk4o1ezlq7yl"},{"post_id":"cj3dvkfba0001zk4oskurn0dr","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfby000fzk4ozgc2vgzy"},{"post_id":"cj3dvkfbt000azk4ot8r186i5","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfby000gzk4o6xs23o6w"},{"post_id":"cj3dvkfbw000dzk4opx3bzg1d","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfby000hzk4opkkg5auf"},{"post_id":"cj3dvkfbh0003zk4oykt5y2vz","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfby000izk4od74wqx24"},{"post_id":"cj3dvkfcd000jzk4o1zuzztjm","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfcg000lzk4osixrneaz"},{"post_id":"cj3dvkfce000kzk4obsbifanh","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfch000nzk4olki0unnz"},{"post_id":"cj3dvkfcg000mzk4oy44x0h8t","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfcj000pzk4o63079xyy"},{"post_id":"cj3dvkfch000ozk4o5kgmv3y9","tag_id":"cj3dvkfbf0002zk4oq6fu3bln","_id":"cj3dvkfck000rzk4o2ci29auy"},{"post_id":"cj3dvkfco000vzk4oqb8az1vu","tag_id":"cj3dvkfcn000tzk4olfx7zm3w","_id":"cj3dvkfcr000xzk4ov5yofzks"},{"post_id":"cj3dvkfcj000qzk4ocd9mtgjr","tag_id":"cj3dvkfcn000tzk4olfx7zm3w","_id":"cj3dvkfcr000yzk4ovlasvuhw"},{"post_id":"cj3dvkfcl000szk4ol8q47ob1","tag_id":"cj3dvkfcq000wzk4otyu1t3c5","_id":"cj3dvkfcs0010zk4o6xcltnna"},{"post_id":"cj3dvkfcn000uzk4o6uiaf51s","tag_id":"cj3dvkfcr000zzk4os1qgtu19","_id":"cj3dvkfcs0012zk4o4im29f7z"},{"post_id":"cj3dvkfcn000uzk4o6uiaf51s","tag_id":"cj3dvkfcs0011zk4owitdzs9a","_id":"cj3dvkfct0013zk4ohfj5u151"},{"post_id":"cj3dvkfdq0019zk4o8eczpe6y","tag_id":"cj3dvkfdo0017zk4ou35hr0q7","_id":"cj3dvkfdt001czk4oev1w359j"},{"post_id":"cj3dvkfdk0014zk4on2o4d1hi","tag_id":"cj3dvkfdo0017zk4ou35hr0q7","_id":"cj3dvkfdu001ezk4orsvtotyr"},{"post_id":"cj3dvkfdm0016zk4o6p1njw0j","tag_id":"cj3dvkfds001bzk4ogo33yxrq","_id":"cj3dvkfdy001lzk4ok9knnz16"},{"post_id":"cj3dvkfdm0016zk4o6p1njw0j","tag_id":"cj3dvkfdv001gzk4om7s4oj90","_id":"cj3dvkfe0001nzk4o5w6nn3ao"},{"post_id":"cj3dvkfdx001kzk4ofc0vgw60","tag_id":"cj3dvkfcn000tzk4olfx7zm3w","_id":"cj3dvkfe1001qzk4o9j9s0gcb"},{"post_id":"cj3dvkfe0001pzk4oglcp0v1a","tag_id":"cj3dvkfcn000tzk4olfx7zm3w","_id":"cj3dvkfe2001szk4ox3vzuqd6"},{"post_id":"cj3dvkfdo0018zk4ojvlo25zi","tag_id":"cj3dvkfds001bzk4ogo33yxrq","_id":"cj3dvkfe4001vzk4okj7a8czr"},{"post_id":"cj3dvkfdo0018zk4ojvlo25zi","tag_id":"cj3dvkfe0001ozk4or9ft9h72","_id":"cj3dvkfe6001xzk4ocilqph1i"},{"post_id":"cj3dvkfdr001azk4obxbogjg9","tag_id":"cj3dvkfe2001tzk4oxffep3mz","_id":"cj3dvkfe70020zk4ovd16nkpm"},{"post_id":"cj3dvkfdt001dzk4oz9x4obi0","tag_id":"cj3dvkfe7001zzk4o5vlzk9e4","_id":"cj3dvkfe90025zk4ollfc5iqg"},{"post_id":"cj3dvkfe90024zk4okr4e6jgt","tag_id":"cj3dvkfe7001zzk4o5vlzk9e4","_id":"cj3dvkfec0028zk4o92xtyc4e"},{"post_id":"cj3dvkfdu001fzk4ovm03468h","tag_id":"cj3dvkfe90023zk4o9k06esgx","_id":"cj3dvkfed002azk4om2xo1q8l"},{"post_id":"cj3dvkfeb0026zk4os0hic6y5","tag_id":"cj3dvkfe7001zzk4o5vlzk9e4","_id":"cj3dvkfee002dzk4o5vaky8zg"},{"post_id":"cj3dvkfdv001hzk4oj3d9sdkj","tag_id":"cj3dvkfe7001zzk4o5vlzk9e4","_id":"cj3dvkfee002fzk4ohanoz5jm"},{"post_id":"cj3dvkfdw001izk4op8dpl228","tag_id":"cj3dvkfe7001zzk4o5vlzk9e4","_id":"cj3dvkfeg002izk4o6pkry9i2"},{"post_id":"cj3dvkfdw001izk4op8dpl228","tag_id":"cj3dvkfef002gzk4on7hloedu","_id":"cj3dvkfeg002jzk4onaf3s19z"},{"post_id":"cj3dvkfdy001mzk4oeq66wqkx","tag_id":"cj3dvkfe7001zzk4o5vlzk9e4","_id":"cj3dvkfen002mzk4or5le878d"},{"post_id":"cj3dvkfdy001mzk4oeq66wqkx","tag_id":"cj3dvkfe2001tzk4oxffep3mz","_id":"cj3dvkfeo002nzk4oup8odi1o"},{"post_id":"cj3dvkfe1001rzk4od0pqg6vp","tag_id":"cj3dvkfen002lzk4oo60t5a7v","_id":"cj3dvkfeo002qzk4osja6aw87"},{"post_id":"cj3dvkfe1001rzk4od0pqg6vp","tag_id":"cj3dvkfeo002ozk4odaydejyr","_id":"cj3dvkfeo002rzk4ovgw60z5s"},{"post_id":"cj3dvkfe3001uzk4ov2kobfbv","tag_id":"cj3dvkfeo002pzk4ocs0628iy","_id":"cj3dvkfeo002tzk4ox7gs25sn"},{"post_id":"cj3dvkfe4001wzk4ok9fv838v","tag_id":"cj3dvkfeo002szk4objrwpmrv","_id":"cj3dvkfeo002vzk4ol6qwclxx"},{"post_id":"cj3dvkfe6001yzk4obiiers20","tag_id":"cj3dvkfe7001zzk4o5vlzk9e4","_id":"cj3dvkfep002yzk4oae3x7jim"},{"post_id":"cj3dvkfe6001yzk4obiiers20","tag_id":"cj3dvkfep002wzk4o9p1ds35z","_id":"cj3dvkfep002zzk4o6ofryjfw"},{"post_id":"cj3dvkfe70021zk4oyl6wko24","tag_id":"cj3dvkfep002xzk4oroxl40uc","_id":"cj3dvkfep0032zk4osslqatyy"},{"post_id":"cj3dvkfe70021zk4oyl6wko24","tag_id":"cj3dvkfen002lzk4oo60t5a7v","_id":"cj3dvkfeq0033zk4ossvr4tyd"},{"post_id":"cj3dvkfe80022zk4ow89o7gsy","tag_id":"cj3dvkfep0031zk4o6wh7qm6k","_id":"cj3dvkfeq0035zk4oj2vrtiby"},{"post_id":"cj3dvkfec0029zk4ojohd9tdn","tag_id":"cj3dvkfeq0034zk4o5we0rmkz","_id":"cj3dvkfeq0037zk4ozi6c7j1i"},{"post_id":"cj3dvkfed002bzk4o1xlasikd","tag_id":"cj3dvkfeq0036zk4oh8m2h4sq","_id":"cj3dvkfeq0039zk4o3gyi7rr4"},{"post_id":"cj3dvkfee002ezk4okezhfdrm","tag_id":"cj3dvkfef002gzk4on7hloedu","_id":"cj3dvkfeq003azk4o499ggqw8"}],"Tag":[{"name":"ES2015","_id":"cj3dvkfbf0002zk4oq6fu3bln"},{"name":"Vue","_id":"cj3dvkfcn000tzk4olfx7zm3w"},{"name":"Html5","_id":"cj3dvkfcq000wzk4otyu1t3c5"},{"name":"ci","_id":"cj3dvkfcr000zzk4os1qgtu19"},{"name":"hexo","_id":"cj3dvkfcs0011zk4owitdzs9a"},{"name":"css3","_id":"cj3dvkfdo0017zk4ou35hr0q7"},{"name":"Javascript","_id":"cj3dvkfds001bzk4ogo33yxrq"},{"name":"队列","_id":"cj3dvkfdv001gzk4om7s4oj90"},{"name":"栈","_id":"cj3dvkfe0001ozk4or9ft9h72"},{"name":"git","_id":"cj3dvkfe2001tzk4oxffep3mz"},{"name":"ubuntu","_id":"cj3dvkfe7001zzk4o5vlzk9e4"},{"name":"react","_id":"cj3dvkfe90023zk4o9k06esgx"},{"name":"software","_id":"cj3dvkfef002gzk4on7hloedu"},{"name":"javascript","_id":"cj3dvkfen002lzk4oo60t5a7v"},{"name":"jQuery","_id":"cj3dvkfeo002ozk4odaydejyr"},{"name":"webpack babel","_id":"cj3dvkfeo002pzk4ocs0628iy"},{"name":"tools","_id":"cj3dvkfeo002szk4objrwpmrv"},{"name":"node","_id":"cj3dvkfep002wzk4o9p1ds35z"},{"name":"webpack","_id":"cj3dvkfep002xzk4oroxl40uc"},{"name":"google","_id":"cj3dvkfep0031zk4o6wh7qm6k"},{"name":"微信","_id":"cj3dvkfeq0034zk4o5we0rmkz"},{"name":"html5","_id":"cj3dvkfeq0036zk4oh8m2h4sq"}]}}