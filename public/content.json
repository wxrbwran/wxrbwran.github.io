{"meta":{"title":"晓然的自留地","subtitle":"路漫漫，上下而求索","description":"前端工程师的自我修养","author":"织幻z","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2016-09-06T07:59:27.000Z","updated":"2018-07-12T06:47:06.428Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"将git项目使用推送到多个地址","slug":"将git项目使用推送到多个地址","date":"2018-07-12T03:53:45.000Z","updated":"2018-07-12T06:47:06.426Z","comments":true,"path":"2018/07/12/将git项目使用推送到多个地址/","link":"","permalink":"http://yoursite.com/2018/07/12/将git项目使用推送到多个地址/","excerpt":"","text":"git设置公司开发项目迁移，中间大约一周左右的测试期，两边地址都要上传，那么如何方便快捷的把代码托管到多个平台呢？例如我有下面两个仓库：12https://gitlab.com/***/doctor.git https://github.com/***/doctor.git 先添加第一个仓库：1git remote add origin https://gitlab.com/***/doctor.git 再添加第二个仓库：1git remote set-url --add origin https://github.com/***/doctor.git 如果还有其他，则可以像添加第二个一样继续添加其他仓库。 然后使用下面命令提交：123git push origin --all或者特定分支git push origin [branch] 打开.git/config，可以看到这样的配置：1234[remote &quot;origin&quot;] url = https://github.com/***/doctor.git fetch = +refs/heads/*:refs/remotes/origin/* url = https://gitlab.com/***/doctor.git 刚才的命令其实就是添加了这些配置。如果不想用命令行，可以直接编辑该文件，添加对应的url即可。如果两个地址的账号还不一样呢？ 多账号ssh设置首先生成另一个ssh公钥， 比如id_rsa_doctor,id_rsa_doctor.pub，然后配置.ssh文件夹下的config文件，没有的话建立。123456789Host default HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa#second 第二个账号Host second HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_doctor 这样的话就可以一次操作后，提交到两个仓库地址了。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"代码分割结合 Prefetch 完美优化单页应用加载性能","slug":"代码分割结合-Prefetch-完美优化单页应用加载性能","date":"2017-10-11T09:26:46.000Z","updated":"2018-07-12T06:47:06.421Z","comments":true,"path":"2017/10/11/代码分割结合-Prefetch-完美优化单页应用加载性能/","link":"","permalink":"http://yoursite.com/2017/10/11/代码分割结合-Prefetch-完美优化单页应用加载性能/","excerpt":"单页应用性能的最大痛点就是 bundle 体积大导致首屏时间过长。使用 webpack 的 code splitting（代码分割）功能可以将 bundle 分片，加速首屏，但之后的交互势必会受到影响,页面变得不再流畅，稍有卡顿，所以放弃了分片，但是现在发现有webpack插件解决JS文件后加载响应慢的问题，所以记了下来。","text":"单页应用性能的最大痛点就是 bundle 体积大导致首屏时间过长。使用 webpack 的 code splitting（代码分割）功能可以将 bundle 分片，加速首屏，但之后的交互势必会受到影响,页面变得不再流畅，稍有卡顿，所以放弃了分片，但是现在发现有webpack插件解决JS文件后加载响应慢的问题，所以记了下来。 先说结论：比较理想的解决方案是code split + prefetch 方式，对于不支持prefetch的safari浏览器另做preload处理。 preloadpreload 是较新的 web 标准。他可以声明式的告诉浏览器去获取某个资源，并且可以为资源设置优先级。1&lt;link rel=\"preload\" href=\"font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin&gt; preload 加载资源后并不会执行，可以安全的预加载 JavaScript。我们一般使用 preload 来主动通知浏览器获取本页的关键资源。现在浏览器都有 Preloader，可以尽早发现大多数基于标记语言的资源，但依然存在一些隐藏在 CSS 和 JavaScript 中的资源，例如字体文件，其为首屏关键资源又隐藏在 CSS 中。这种场景适合使用 preload 进行声明，尽早进行资源加载，避免页面渲染延迟。preload 的更多细节可参考文章 Preload: What Is It Good For?，它适合用来预加载被隐藏的首屏关键资源。preload 的兼容性并不理想，目前只有最新版的 chrome 和 safari 才支持。 prefetch使用 prefetch 声明的资源是对浏览器的提示，暗示该资源可能『未来』会被用到，适用于对可能跳转到的其他路由页面进行资源缓存。被 prefetch 的资源的加载时机由浏览器决定，一般来说优先级较低，会在浏览器『空闲』时进行下载。1234&lt;link rel=\"prefetch\" href=\"//example.com/industry-qualification-audit/js/common-main.550d4.chunk.js\"&gt;&lt;link rel=\"prefetch\" href=\"//example.com/industry-qualification-audit/js/Food.86661.chunk.js\"&gt;&lt;link rel=\"prefetch\" href=\"//example.com/industry-qualification-audit/js/Pub.9045b.chunk.js\"&gt;&lt;link rel=\"prefetch\" href=\"//example.com/industry-qualification-audit/js/Screencast.1eb1a.chunk.js\"&gt; 由于关键资源 main.js 已被切分，体积小加载快，prefetch 的资源也未发生抢占带宽的现象，实际效果还是比较符合期望的。prefetch 的兼容性稍好，chrome、firefox、edge、android 4.4+ 都支持，但 safari、IE11-、iOS safari 始终未支持。 3. 结论经过分析，资源加载方式简单总结如下：首屏关键资源：优先级高，使用阻塞方式载入，若有隐藏在 CSS、JavaScript 内部的关键资源（如字体），可使用 preload 声明提前开始加载。首屏非关键资源（第三方插件，如广告、评论、统计、分享）：优先级低，若无执行顺序要求，可使用 async 进行异步加载，但应警惕 onload 事件延迟现象（很多插件和业务逻辑都依赖 onload 事件），若产生了性能问题最好在 onload 事件后手动加载。非首屏资源（如其他路由的分片 thunk）：优先级最低，可使用 prefetch 声明进行预加载。在 safari、iOS 等不支持 prefetch 的浏览器上，在 onload 事件后手动进行加载。单页应用的分片 thunk 为非首屏资源，可以采用 prefetch + onload 手动加载的方式实现全平台的预加载。prefetch 可以使用 preload-webpack-plugin 插件自动打入，preload可以使用prefetch-polyfill-webpack-plugin,可以自动生成在 onload 事件触发时执行的 prefetch polyfill 函数，由于其身份是作为 prefetch 的补足，所以仅在 IE、safari、iOS 上执行，可选择使用 image 或者 async模式 对分片 thunk 做预加载。12345678910111213new HtmlWebpackPlugin(&#123; template: path.join(__dirname, 'src/index.html'), filename: 'index.html', title: 'index', minify: false, inject: 'body', &#125;), new PreloadWebpackPlugin(&#123; rel: 'prefetch', &#125;), new PrefetchPolyfillPlugin(&#123; mode: 'async', &#125;), 经过这样细致的优化，就可以保证我们的单页应用既有快速的首屏响应时间，又能享受流畅的交互体验了。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[]},{"title":"使用babel-preset-env替代babel-preset-es2015","slug":"使用babel-preset-env替代babel-preset-es2015","date":"2017-10-02T11:12:01.000Z","updated":"2018-07-12T06:47:06.423Z","comments":true,"path":"2017/10/02/使用babel-preset-env替代babel-preset-es2015/","link":"","permalink":"http://yoursite.com/2017/10/02/使用babel-preset-env替代babel-preset-es2015/","excerpt":"Babel 是每个 FEer/Node.js 的使用者都会使用的一个代码转(bian)换(yi)器，它可以把 ES6、ES7 等语法转换成 ES5 的语法，使其能在更多环境下运行。 但是随着浏览器和 Node.js 的版本迭代，他们对新语法的支持也越来越好。但是非常尴尬的是，我们总是使用 Babel 把所有代码一股脑转换成 ES5。这意味着我们抛弃了性能优秀的 let、const 关键字，放弃了简短的代码，而选择了又长又丑像坨屎的经过变换后的代码。 即使仅仅将代码跑在对 ES5 支持度在 99% 的 Node 6，一旦使用了 import 关键字，你就得用 Babel 对代码进行转换，一般还是全部转换为 ES5，辣鸡 Node.js 竟然还不支持 import 和 export。 那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的 polyfill 呢？","text":"Babel 是每个 FEer/Node.js 的使用者都会使用的一个代码转(bian)换(yi)器，它可以把 ES6、ES7 等语法转换成 ES5 的语法，使其能在更多环境下运行。 但是随着浏览器和 Node.js 的版本迭代，他们对新语法的支持也越来越好。但是非常尴尬的是，我们总是使用 Babel 把所有代码一股脑转换成 ES5。这意味着我们抛弃了性能优秀的 let、const 关键字，放弃了简短的代码，而选择了又长又丑像坨屎的经过变换后的代码。 即使仅仅将代码跑在对 ES5 支持度在 99% 的 Node 6，一旦使用了 import 关键字，你就得用 Babel 对代码进行转换，一般还是全部转换为 ES5，辣鸡 Node.js 竟然还不支持 import 和 export。 那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的 polyfill 呢？ 还真有，而且是 Babel 官方提供的，一个名为 babel-preset-env 的插件。它不需要你自行添加任何 preset，比如我们最常用的 es2015，它能根据设置智能转换代码。 具体的配置方法自行看文档，很容易能看懂，这里就提一下值得特别注意的部分。 如果在 .babelrc 中仅仅使用下面的设置的话，那 babel-preset-env 会执行与 babel-preset-latest 一样的转换。 123&#123; \"presets\": [\"env\"]&#125; targets.browsers 需要使用 browserslist 的配置方法，但是其设置会被 targets.[chrome, opera, edge, firefox, safari, ie, ios, android, node, electron] 覆盖。 targets.node 设置为 true 或 “current” 可以根据当前 Node.js 版本进行动态转换。也可以设置为具体的数字表示需要支持的最低的 Node.js 版本。 targets.uglify 会把代码完全转换为 ES5 以支持压缩 JS 代码。 include 和 exclude 可以当作是白名单和黑名单，分别表示一定会执行的转换和一定不会执行的转换，其项是数组。 useBuiltIns 可以根据之前的配置自行添加 polyfill，默认不开启。安装 babel-polyfill 后只要引入一次就行： 1import \"babel-polyfill\"; 干货作为一个仅仅使用 Node 执行的项目，你可以用下面的 .babelrc 文件： 12345678910&#123; \"presets\": [ [\"env\", &#123; \"targets\": &#123; \"node\": \"current\" &#125;, \"useBuiltIns\": \"usage\" &#125;] ]&#125; 前端项目：12345678910111213141516&#123; \"presets\":[ [\"env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125; &#125;], \"stage-2\", \"react-app\" ], \"comments\": false, \"plugins\": [ \"transform-runtime\" ]&#125; 最后，别忘了安装 babel-cli，毕竟你还需要使用 babel-node 来执行代码。","categories":[],"tags":[{"name":"babel","slug":"babel","permalink":"http://yoursite.com/tags/babel/"}],"keywords":[]},{"title":"create-react-app和express共同组建的开发环境","slug":"create-react-app和express共同组建的开发环境","date":"2017-07-20T08:55:32.000Z","updated":"2018-07-12T06:47:06.416Z","comments":true,"path":"2017/07/20/create-react-app和express共同组建的开发环境/","link":"","permalink":"http://yoursite.com/2017/07/20/create-react-app和express共同组建的开发环境/","excerpt":"脚手架介绍 在这个环境下，Facebook 提供了一套不需要配置的 React 开发方案，即create-react-app。这个脚手架已经做好了基础 webpack 配置，带有自动更新，错误提示等等功能，仅仅需要创建，启动就可以快速开发。 这时也不得不提前端社区的另一个崛起者：yarn。","text":"脚手架介绍 在这个环境下，Facebook 提供了一套不需要配置的 React 开发方案，即create-react-app。这个脚手架已经做好了基础 webpack 配置，带有自动更新，错误提示等等功能，仅仅需要创建，启动就可以快速开发。 这时也不得不提前端社区的另一个崛起者：yarn。Yarn与 npm 一样，是一款 NodeJS 包管理工具。 为何要选择使用 yarn 呢？官网的描述是： Yarn 会缓存它下载的每个包，所以不需要重复下载。它还能并行化操作以最大化资源利用率，所以安装速度之快前所未有。 Yarn 在每个安装包的代码执行前使用校验码验证包的完整性。 Yarn 使用一个格式详尽但简洁的 lockfile 和一个精确的算法来安装，能够保证在一个系统上的运行的安装过程也会以同样的方式运行在其他系统上。选用 Yarn 的原因也是因为他的速度提升比npm 要快，使用yarn add ，yarn remove 增删 node 包（对应npm install和npm uninstall）. 另一点是，yarn 在更新之后，集成了create, 通过yarn create，可以快速启动一个项目。 123yarn create react-app my-appyarn create react-native-app my-appyarn create next-app my-app 如何使用假设我们需要创建一个demo-app项目： 创建目录yarn create react-app demo-app稍等片刻，yarn 会为我们创建一个目录，拉取依赖，wepack 的配置通过 yarn 来调用，可以看到目录结构很干净 开始开发：cd demo-app &amp;&amp; yarn start这时会启动一个默认端口为3000的页面，如果端口冲突，会提示你是否选用另一个端口进入src目录开始开发即可 开发完成后需要发布时，运行yarn build进行编译，发布build目录创建完成会自动生成build文件夹，将 js,css 文件放入 static 目录中,发布build目录即可 三部曲完成，中间省略了非常多配置问题，给需要快速构建项目带来了极大的便利性。当然，默认配置也许不能够满足所有需求，create-react-app也提供了 抛出所有配置项的yarn eject供给开发者使用，如果需要到调整 webpack 的内容，就需要使用到这个命令。不过这样也会导致不能再回滚。官方的更新比较快，如果不是必要的情况建议直接使用内置的行为。 配合 Express 构建 server 端应用如果在项目开发过程中需要 express 构建server 端应用，那么开发模式就需要有小调整。 首先创建一个叫server的文件夹和初始化 package.json文件：1mkdir server &amp;&amp; cd server &amp;&amp; yarn init 增加依赖包1yarn add express body-parser nodemon babel-cli babel-preset-es2015 主要用到express, body-parser, nodemon（检测node.js 改动并自动重启，适用于开发阶段）,babel-cli和babel-preset-es2015(以便使用 es6开发)修改package.json，增加npm scripts1234567&#123; &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;nodemon --exec babel-node -- ./server.js&quot;, &quot;build&quot;: &quot;babel ./server.js --out-file server-compiled.js&quot;, &quot;serve&quot;: &quot;node server-compiled.js&quot; &#125; &#125; 这里使用nodemon在开发阶段检测node.js 改动并自动重启发布build的时候则通过 babel编译成 es5的文件create-react-app会启动一个静态资源服务器，那么同时需要进行 server 端的时候需要怎么做呢？ 我们回过头来去修改一下demo-app目录下的package.json。 create-react-app会默认添加好3段scripts:12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &#125; 我们需要对 start和build做调整，以便可以同时启动前端开发页面以及后端服务。在这里引入concurrently这个包来执行两条命令：1yarn add concurrently package.json: 123456&quot;scripts&quot;: &#123; &quot;react-start&quot;: &quot;react-scripts start&quot;, &quot;start&quot;: &quot;concurrently &apos;yarn react-start&apos; &apos;cd server &amp;&amp; yarn start&apos;&quot;, &quot;react-build&quot;: &quot;react-scripts build&quot;, &quot;build&quot;: &quot;concurrently &apos;yarn react-build&apos; &apos;cd server &amp;&amp; yarn build&apos;&quot;, &#125;, 这样，我们只要执行yarn start会同步启动 webpack 以及 server文件夹下的 nodeman. Proxy如果我们在前端页面用使用fetch(/api/data)这样 请求，默认是会发送到create-react-app 启动的 localhost:3000/api/data去的，无法达到目的。为了指向 server 端，需要指定proxy: 假设 server 端 express 启动了5000端口，则需要在package.json中增加：1&quot;proxy&quot;: &quot;http://127.0.0.1:5000&quot; 这时当你使用fetch(/api/data)请求，则会指向到localhost:5000/api/data 轻松的开始开发吧~","categories":[],"tags":[{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"}],"keywords":[]},{"title":"ES7 and ES8 特性","slug":"ES7-and-ES8-特性","date":"2017-07-18T05:56:47.000Z","updated":"2018-07-12T06:47:06.413Z","comments":true,"path":"2017/07/18/ES7-and-ES8-特性/","link":"","permalink":"http://yoursite.com/2017/07/18/ES7-and-ES8-特性/","excerpt":"ES8 was Released 虽然现在开发已经都在用es6，一个不注意，都到了es8了。记录一下新增加的常用功能，方便查阅。 ES7 特性： Array.prototype.includes Exponentiation Operator(求冥运算) ES8 特性 Object.values/Object.entries String padding(字符串填充) Object.getOwnPropertyDescriptors 函数参数列表和调用中的尾逗号（Trailing commas） 异步函数（Async Functions）","text":"ES8 was Released 虽然现在开发已经都在用es6，一个不注意，都到了es8了。记录一下新增加的常用功能，方便查阅。 ES7 特性： Array.prototype.includes Exponentiation Operator(求冥运算) ES8 特性 Object.values/Object.entries String padding(字符串填充) Object.getOwnPropertyDescriptors 函数参数列表和调用中的尾逗号（Trailing commas） 异步函数（Async Functions） Array.prototype.includesArray.prototype.includes用法都容易和简单。它是一个替代indexOf，开发人员用来检查数组中是否存在值，indexOf是一种尴尬的使用，因为它返回一个元素在数组中的位置或者-1当这样的元素不能被找到的情况下。所以它返回一个数字，而不是一个布尔值。开发人员需要实施额外的检查。在ES6，要检查是否存在值你需要做一些如下所示小技巧，因为他们没有匹配到值，Array.prototype.indexOf返回-1变成了true（转换成true），但是当匹配的元素为0位置时候，该数组包含元素，却变成了false123456789let arr = ['react', 'angular', 'vue']// WRONGif (arr.indexOf('react')) &#123; // 0 -&gt; evaluates to false, definitely as we expected console.log('Can use React') // this line would never be executed&#125;// Correctif (arr.indexOf('react') !== -1) &#123; console.log('Can use React')&#125; 或者使用一点点hack 位运算符 ~ 使代码更加紧凑一些，因为~（位异或）对任何数字相当于-(a + 1):12345let arr = ['react', 'angular', 'vue']// Correctif (~arr.indexOf('react')) &#123; console.log('Can use React')&#125; 在ES7中使用includes代码如下:1234567891011let arr = ['react', 'angular', 'vue']// Correctif (arr.includes('react')) &#123; console.log('Can use React')&#125;// 开发者还能在字符串中使用includes:let str = 'React Quickly'// Correctif (str.toLowerCase().includes('react')) &#123; // true console.log('Found \"react\"') &#125; Exponentiation Operator(求冥运算)求冥运算大多数是为开发者做一些数学计算，对于3D，VR，SVG还有数据可视化非常有用。在ES6或者早些版本，你不得不创建一个循环，创建一个递归函数或者使用Math.pow,如果你忘记了什么是指数,当你有相同数字（基数）自相相乘多次（指数）。例如，7的3次方是777 现在在ES7 /ES2016，以数学向导的开发者可以使用更短的语法:1234567891011let a = 7 ** 12let b = 2 ** 7console.log(a === Math.pow(7,12)) // trueconsole.log(b === Math.pow(2,7)) // true// 开发者还可以操作结果:let a = 7a **= 12let b = 2b **= 7console.log(a === Math.pow(7,12)) // trueconsole.log(b === Math.pow(2,7)) // true Object.values/Object.entriesObject.entries 和 Object.values是在ES2017规格中，它和Object.keys类似，返回数组类型，其序号和Object.keys序号对应。 Object.entries,Object.values和Object.keys各自项返回是数组，相对应包括key,value或者可枚举特定对象property/attribute 在ES8 /ES2017之前，Javascript开发者需要迭代一个对象的自身属性时候不得不用Object.keys，通过迭代且使用obj[key]获取value值返回一个数组：1234let obj = &#123;a: 1, b: 2, c: 3&#125;Object.keys(obj).forEach((key, index)=&gt;&#123; console.log(key, obj[key])&#125;) 而使用ES6/ES2015 中for/of稍微好点：1234let obj = &#123;a: 1, b: 2, c: 3&#125;for (let key of Object.keys(obj)) &#123; console.log(key, obj[key])&#125; 你使用老方式for/in(ES5)也许用的非常好。但是他会迭代所有可以枚举属性（像原型中的带名字的-see MDN）,不仅仅自己的属性，会意外的破坏那些 像prototype和tostring得到意想不到的值。Object.values返回对象自身可以迭代属性值（values）为数组类型。我们最好使用Array.prototype.forEach迭代它，结合ES6的箭头函数隐形返回值：12let obj = &#123;a: 1, b: 2, c: 3&#125;Object.values(obj).forEach(value=&gt;console.log(value)) // 1, 2, 3 或者使用for/of:12let obj = &#123;a: 1, b: 2, c: 3&#125;Object.values(obj).forEach(value=&gt;console.log(value)) // 1, 2, 3 Object.entries，在另一方面，将会返回对象自身可迭代属性key-value对数组（作为一个数组），他们（key-value）分别以数组存放数组中。123let obj = &#123;a: 1, b: 2, c: 3&#125;JSON.stringify(Object.entries(obj))\"[[\"a\",1],[\"b\",2],[\"c\",3]]\" 我们可以使用ES6/ES2015解构（需要深入了解解构请点击这篇文章和课程）,从这嵌套数组中分别声明key和value12345let obj = &#123;a: 1, b: 2, c: 3&#125;Object.entries(obj).forEach(([key, value]) =&gt; &#123; console.log(`$&#123;key&#125; is $&#123;value&#125;`)&#125;)// a is 1, b is 2, c is 3 你可以猜一猜，我们同样使用ES6for/of（毕竟全部都是数组）遍历Object.entries返回来的结果值。12345let obj = &#123;a: 1, b: 2, c: 3&#125;for (let [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125; is $&#123;value&#125;`)&#125;// a is 1, b is 2, c is 3 现在从对象中提取values和key-value pairs 变得非常容易了。Object.values和Object.entries这种方式不想之前 Object.keys(自身属性key+顺序相同)结合for/of(ES6)一起，我们不仅仅可以提取他们还可以迭代他们。 字符填充函数padStart 和 padEndString.prototype.padStart 和 String.prototype.padEnd在javascript字符操作是一个不错的体验，帮助避免依赖而外的库。padStart()在开始部位填充，返回一个给出长度的字符串，填充物给定字符串，把字符串填充到期望的长度。从字符串的左边开始（至少大部分西方语言），一个经典例子是使用空格创建列：12console.log('react'.padStart(10).length) // \" react\" is 10console.log('backbone'.padStart(10).length) // \" backbone\" is 10 它对于财务方面非常有用：1234567console.log('0.00'.padStart(20)) console.log('10,000.00'.padStart(20)) console.log('250,000.00'.padStart(20))// 这结果作为一个会计总账格式非常漂亮： 0.00 10,000.00 250,000.00 第二个参数，让我们放一些其他的填充字符替代空字符串，一个字符串填充：12console.log('react'.padStart(10, '_')) // \"_____react\"console.log('backbone'.padStart(10, '*')) // \"**backbone\" padEnd顾名思义就是从字符串的尾端右边开始填充。第二个参数，你能实际上用一个任何长度的字符串。例如：12console.log('react'.padEnd(10, ':-)')) // \"react:-):-\" is 10console.log('backbone'.padEnd(10, '*')) // \"backbone**\" is 10 Object.getOwnPropertyDescriptors这新的 Object.getOwnPropertyDescriptors返回对象obj所有自身属性描述。这是一个多参数版本的Object.getOwnPropertyDescriptors(obj,propName)将会返回obj中propName属性的一个单独描述。在我们日常不可变编程（immutable programming）时代中，有了这个方法很方便（记住,Javascript中对象是引用传递）在ES5中，开发者要使用Object.assign()来拷贝对象, Object.assign()分配属性只有copy和定义新的属性。当我们使用更加复杂对象和类原型，这可能会出问题。Object.getOwnPropertyDescriptors允许创建真实的对象浅副本并创建子类,它通过给开发者描述符来做到这一点.在Object.create(prototype, object)放入描述符后，返回一个真正的浅拷贝1234Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 或者你可以合并两个对象target和source如下：1234Object.defineProperties( target, Object.getOwnPropertyDescriptors(source)) 以上是Object.getOwnPropertyDesciptors用法。但是什么是描述符(descriptor)呢？就是一个对象的描述，废话！好吧！好吧，让我们挖掘一下描述符一点点多信息。这里有两种描述符号类型： 数据描述符（Data descriptor） 存取器描述符（Accessor descriptor）存取描述符有必须属性：get 或者set或者get和set两个就是如你所想的getter和setter函数，然后存取描述符还有可选属性configurable和enumerable12345678let azatsBooks = &#123; books: ['React Quickly'], get latest () &#123; let numberOfBooks = this.books.length if (numberOfBooks == 0) return undefined return this.books[numberOfBooks - 1] &#125;&#125; 这个例子数据描述符books由Object.getOwnPropertyDescriptor(azatsBooks, ‘books’)产生结果如下：123456Object configurable: true enumerable: true value: Array[1] writable: true __proto__: Object 同样的，Object.getOwnPropertyDescriptor(azatsBooks, ‘latest’)将会展现latest的描述符，这个latest（get）存取器描述符展现如下：123456Object configurable: truee numerable: true get: latest() set: undefined __proto__: Object 现在我们调用新方法获取所有的描述符：1console.log(Object.getOwnPropertyDescriptors(azatsBooks)) 它会给出这个对象两个描述符books和latest：1234567891011121314Object books: Object configurable: true enumerable: true value: Array[1] writable: true __proto__: Object latest: Object configurable: true enumerable: true get: latest() set: undefined __proto__: Object __proto__: Object 函数参数列表和调用中的尾逗号尾逗号在函数定义中只是一个纯粹语法变化，在ES5中，将会非法语法，在函数参数后面应该是没有逗号的：12345678var f = function(a, b, c, d) &#123; // NO COMMA! // ... console.log(d)&#125;f(1,2,3,'this') 在ES8中，这种尾逗号是没有问题的：123456789var f = function(a, b, c, d,) &#123; // COMMA? OK! // ... console.log(d)&#125;f(1,2,3,'this') 现在，函数中尾逗号是向数组（ES3）中和字面量对象（ES5）中尾逗号看齐。12345678var arr = [1, // Length == 3 2, 3,] // &lt;--- oklet obj = &#123;a: 1, // Only 3 properties b: 2, c: 3,&#125; // &lt;--- ok 更不用说他是无用友好的。尾逗号主要有用在使用多行参数风格（典型的是那些很长的参数名），开发者终于可以忘记逗号放在第一位这种奇怪的写法。自从逗号bugs主要原因就是使用他们。而现在你可以到处使用逗号，甚至最后参数都可以。 异步函数异步函数（或者async/await）特性操作是Promise最重要的功能。所以你大概进一步阅读他们或者看一个进修视频课程来。这种想法是为了在写异步代码中简化它，因为人类大脑最讨厌这种平行非序号思维了。它只是不会演变这种方式。对于我个人来说，我不喜欢Promise，就仅仅相比callback显得特别冗余。幸运的是，在ES8，异步函数是那么给力。开发者定义一个asyc函数里面不包含或者包含await 基于Promise异步操作。在这引擎之下一个异步函数返回一个Promise，无论无何你在任何地方不会看到这样的一个词（注：Promise）(当然了，你非的自己使用)。例如，在ES6中我们可以使用Promise，Axios库向GraphQL服务器发送一个请求：123456axios.get(`/q?query=$&#123;query&#125;`) .then(response =&gt; response.data) .then(data =&gt; &#123; this.props.processfetchedData(data) // Defined somewhere else &#125;) .catch(error =&gt; console.log(error)) 任何一个Promise库都能兼容新的异步函数，我们可以使用同步try/catch做错误处理。123456789async fetchData(url) =&gt; &#123; try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data this.props.processfetchedData(data) &#125; catch (error) &#123; console.log(error) &#125;&#125; 异步函数返回一个Promise，所以我们像下面可以继续执行流程:123456789101112async fetchData(query) =&gt; &#123; try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data return data &#125; catch (error) &#123; console.log(error) &#125;&#125;fetchData(query).then(data =&gt; &#123; this.props.processfetchedData(data)&#125;) 你可以看到这段代码在(Babel REPL)生效。请注意，这个例子中，Axios库被代替的，是通过模拟来做相同功能，而HTTP请求通过setTimout代替：123456789101112131415161718192021let axios = &#123; // mocks get: function(x) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;data: x&#125;) &#125;, 2000) &#125;)&#125;&#125;let query = 'mangos'async function fetchData(query) &#123; try &#123; const response = await axios.get(`/q?query=$&#123;query&#125;`) const data = response.data return data &#125; catch (error) &#123; console.log(error) &#125;&#125;fetchData(query).then(data =&gt; &#123; console.log(data) // Got data 2s later... Can use data!&#125;) 有了 async/await,我们的代码执行异步看起来像执行同步一样。可以从头到尾读起来非常简单和易懂，因为出现结果顺序和函数题中从头到尾顺序一样.","categories":[],"tags":[{"name":"es7","slug":"es7","permalink":"http://yoursite.com/tags/es7/"},{"name":"es8","slug":"es8","permalink":"http://yoursite.com/tags/es8/"}],"keywords":[]},{"title":"Express 模板传值对象app.locals、res.locals","slug":"Express-模板传值对象app-locals、res-locals","date":"2017-07-12T07:30:07.000Z","updated":"2018-07-12T06:47:06.413Z","comments":true,"path":"2017/07/12/Express-模板传值对象app-locals、res-locals/","link":"","permalink":"http://yoursite.com/2017/07/12/Express-模板传值对象app-locals、res-locals/","excerpt":"locals是Express应用中 Application(app)对象和Response(res)对象中的属性，该属性是一个对象。该对象的主要作用是，将值传递到所渲染的模板中。","text":"locals是Express应用中 Application(app)对象和Response(res)对象中的属性，该属性是一个对象。该对象的主要作用是，将值传递到所渲染的模板中。 locals对象locals对象用于将数据传递至所渲染的模板中。对于如下一个ejs模板：12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= name %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;a href=\"&lt;%= url %&gt;\"&gt;&lt;%= name %&gt;&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;&lt;%= introduce %&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 我们可以像下面这样渲染页面，并向页面传递name、url、introduce三个变量的值：12345678910router.get('/', function(req, res) &#123; res.render('index', &#123;name:'IT', url:'http://itbilu.com', introduce:'学习'&#125;); // 也可以使用 res.locals 变量 // res.locals = &#123; // name:'IT', // url:'http://it.com', // introduce:'学习' // &#125;; // res.render('index');&#125;); 渲染后的页面HTML：12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;IT&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;a href=\"http://it.com\"&gt;IT&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;学习&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; locals对象会被传递到页面，在模板中可以直接引用该对象的属性，也可以通过该对象引用。如：&lt;%= name %&gt;属性同样可以通过&lt;%= locals.name %&gt;来引用。 app.locals与res.locals locals可能存在于app对象中即：app.locals； 也可能存在于res对象中，即：res.locals。两者都会将该对象传递至所渲染的页面中。不同的是，app.locals会在整个生命周期中起作用；而res.locals只会有当前请求中起作用。由于app.locals在当前应用所有的渲染模中访问，这样我们就可以在该对象中定义一些顶级/全局的数据，并在渲染模板中使用。 在中间件中使用我们常利用Expres的中间件将复杂的问题拆解成多个简单的问题，实现复杂的问题简单化。locals对象中样也可以应用中间件或路由中间件中引用，该对象和app、req、res一样可以依次传递，添加或修改其属性值后，会在后面的处理中体现出来。 如，在app中使用locals：1234567var app = express();app.locals.name = '这是一个APP'; // 定义可以应用整个生命周期中使用的变量app.use(function(req, res, next) &#123; app.locals.name = '新名称'; // 修改 res.locals.url = 'http://it.com' next(err);&#125;); 在路由中间件中使用locals：1234567router.get('/', urlAndIntroduce, function(req, res) &#123; res.render('index', &#123;name:'IT'&#125;);&#125;);function urlAndIntroduce(req, res, next) &#123; res.locals = &#123; url:'http://it.com', introduce:'学习'&#125;;&#125;","categories":[],"tags":[{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"}],"keywords":[]},{"title":"MongoDB常用语句","slug":"MongoDB常用语句","date":"2017-07-11T09:35:27.000Z","updated":"2018-07-12T06:47:06.414Z","comments":true,"path":"2017/07/11/MongoDB常用语句/","link":"","permalink":"http://yoursite.com/2017/07/11/MongoDB常用语句/","excerpt":"记录一下MongoDB常用语句，顺带与SQL做个简单的对比. 查询(find)（1）查询所有结果12select * from articledb.article.find() （2）指定返回哪些键12select title, author from articledb.article.find(&#123;&#125;, &#123;\"title\": 1, \"author\": 1&#125;) （3）where条件12select * from article where title = \"mongodb\"db.article.find(&#123;\"title\": \"mongodb\"&#125;) （4）and条件12select * from article where title = \"mongodb\" and author = \"god\"db.article.find(&#123;\"title\": \"mongodb\", \"author\": \"god\"&#125;)","text":"记录一下MongoDB常用语句，顺带与SQL做个简单的对比. 查询(find)（1）查询所有结果12select * from articledb.article.find() （2）指定返回哪些键12select title, author from articledb.article.find(&#123;&#125;, &#123;\"title\": 1, \"author\": 1&#125;) （3）where条件12select * from article where title = \"mongodb\"db.article.find(&#123;\"title\": \"mongodb\"&#125;) （4）and条件12select * from article where title = \"mongodb\" and author = \"god\"db.article.find(&#123;\"title\": \"mongodb\", \"author\": \"god\"&#125;) （5）or条件12select * from article where title = \"mongodb\" or author = \"god\"db.article.find(&#123;\"$or\": [&#123;\"title\": \"mongodb\"&#125;, &#123;\"author\": \"god\"&#125;]&#125;) （6）比较条件12345select * from article where read &gt;= 100;db.article.find(&#123;\"read\": &#123;\"$gt\": 100&#125;&#125;)$gt(&gt;)、$gte(&gt;=)、$lt(&lt;)、$lte(&lt;=)select * from article where read &gt;= 100 and read &lt;= 200db.article.find(&#123;\"read\": &#123;\"$gte\": 100, \"lte\": 200&#125;&#125;) （7）in条件12select * from article where author in (\"a\", \"b\", \"c\")db.article.find(&#123;\"author\": &#123;\"$in\": [\"a\", \"b\", \"c\"]&#125;&#125;) （8）like12select * from article where title like \"%mongodb%\"db.article.find(&#123;\"title\": /mongodb/&#125;) （9）count12select count(*) from articledb.article.count() （10）不等于12select * from article where author != \"a\"db.article.find(&#123; \"author\": &#123; \"$ne\": \"a\" &#125;&#125;) （11）排序升序：12select * from article where type = \"mongodb\" order by read descdb.article.find(&#123;\"type\": \"mongodb\"&#125;).sort(&#123;\"read\": -1&#125;) 降序：12select * from article where type = \"mongodb\" order by read ascdb.article.find(&#123;\"type\": \"mongodb\"&#125;).sort(&#123;\"read\": 1&#125;) findOne()：除了只返回一个查询结果外，使用方法与find()一样。 创建（insert）12insert into article(title, author, content) values(\"mongodb\", \"tg\", \"haha\")db.article.insert(&#123;\"title\": \"mongodb\", \"author\": \"tg\", \"content\": \"haha\"&#125;) 更新（update）update()语法：1db.collecion.update(query, update[, options] ) query : 必选，查询条件，类似find中的查询条件。update : 必选，update的对象和一些更新的操作符（如$,$inc…）等options：可选，一些更新配置的对象。upsert：可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。multi：可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。writeConcern：可选，抛出异常的级别。 简单更新：12update article set title = \"mongodb\" where read &gt; 100db.article.update(&#123;\"read\": &#123;\"$gt\": 100&#125;&#125;, &#123;\"$set\": &#123; \"title\": \"mongodb\"&#125;&#125;) save()1db.article.save(&#123;_id: 123, title: \"mongodb\"&#125;) 执行上面的语句，如果集合中已经存在一个_id为123的文档，则更新对应字段;否则插入。注：如果更新对象不存在_id，系统会自动生成并作为新的文档插入。 更新操作符MongoDB提供一些强大的更新操作符。 更新特定字段（$set）：12update game set count = 10000 where _id = 123db.game.update(&#123;\"_id\": 123&#125;, &#123; \"$set\": &#123;\"count\": 10000&#125;&#125;) 删除特定字段（$unset）：1db.game.update(&#123;\"_id\":123&#125;, &#123;\"$unset\": &#123;\"author\":1&#125;&#125;) 注：$unset指定字段的值只需是任意合法值即可。 递增或递减（$inc）1db.game.update(&#123;\"_id\": 123&#125;, &#123; \"$inc\": &#123;\"count\": 10&#125;&#125;) // 每次count都加10 注意：$inc对应的字段必须是数字，而且递增或递减的值也必须是数字。 数组追加（$push）：1db.game.update(&#123;\"_id\": 123&#125;, &#123; \"$push\": &#123;\"score\": 123&#125;&#125;) 还可以一次追加多个元素：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$push\": &#123;\"score\": [12,123]&#125;&#125;) 注：追加字段必须是数组。如果数组字段不存在，则自动新增，然后追加。 一次追加多个元素（$pushAll）：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pushAll\": &#123;\"score\": [12,123]&#125;&#125;) 追加不重复元素（$addToSet）：$addToSet类似集合Set，只有当这个值不在元素内时才增加：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$addToSet\": &#123;\"score\": 123&#125;&#125;) 删除元素（$pop）：12db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pop\": &#123;\"score\": 1&#125;&#125;) // 删除最后一个元素db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pop\": &#123;\"score\": -1&#125;&#125;) // 删除第一个元素 注：$pop每次只能删除数组中的一个元素，1表示删除最后一个，-1表示删除第一个。 删除特定元素（$pull）：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pull\": &#123;\"score\": 123&#125;&#125;) 上面的语句表示删除数组score内值等于123的元素。 删除多个特定元素（$pullAll）：1db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$pullAll\": &#123;score: [123,12]&#125;&#125;) 上面的语句表示删除数组内值等于123或12的元素。 更新嵌套数组的值：使用数组下标（从0开始）：1234&#123; address: [&#123;place: \"nanji\", tel: 123&#125;, &#123;place: \"dongbei\", tel: 321&#125;]&#125;db.game.update(&#123;\"_id\": 123&#125;, &#123;\"$set\": &#123;\"address.0.tel\": 213&#125;&#125;) 如果你不知道要更新数组哪项，我们可以使用$操作符（ $表示自身，也就是按查询条件找出的数组里面的项自身，而且只会应用找到的第一条数组项）：1db.game.update(&#123;\"address.place\": \"nanji\"&#125;, &#123;\"$set\": &#123;\"address.$.tel\": 123&#125;&#125;) 在上面的语句中，$就是查询条件{“address.place”: “nanji”}的查询结果，也就是{place: “nanji”, tel: 123}，所以{“address.$.tel”: 123}也就是{“address.{place: “nanji”, tel: 123}.tel”: 123} 删除（remove）删除所有文档：12delete from articledb.article.remove(&#123;&#125;) 删除指定文档：12delete from article where title = \"mongodb\"db.article.remove(&#123;title: \"mongodb\"&#125;) MongoDB特有的语句数组查询数组的普通查询假如type是[“mongodb”, “javascript”]：1db.article.find(&#123;\"type\": \"mongodb\"&#125;) 上面的语句可以匹配成功。 多个元素的查询1db.article.find(&#123;\"type\": &#123;\"$all\": [\"mongodb\", \"javascript\"]&#125;&#125;) 只有type数组同时存在mongodb和javascript才会匹配。 限制数组长度查询1db.article.find(&#123;\"type\": &#123;\"$size\": 2&#125;&#125;) 只有数组的长度是2才会匹配注：type必须是数组 返回特定数量当$slice的参数是一个时，表示返回的数量;当是一个数组时，第一个参数表示偏移量，第二个表示返回的数量：123db.article.find(&#123;\"type\": &#123;\"$slice\": 1&#125;&#125;) // 返回第1个db.article.find(&#123;\"type\": &#123;\"$slice\": -1&#125;&#125;) // 返回最后一个db.article.find(&#123;\"type\": &#123;\"$slice\": [20, 10]&#125;&#125;) // 从第21个开始，返回10个，也就是21～30 注：$slice针对的是数组 元素匹配如果文档中有一个字段的值是数组，可以使用$elemMatch来匹配数组内的元素：1234&#123; kown: [&#123; a: 2, b: 4&#125;, 10, &#123; a: 4&#125;, &#123;b:10&#125;]&#125;db.article.find(&#123;\"kown\": &#123; \"$elemMatch\": &#123;a: 1, b: &#123;\"$gt\": 2&#125;&#125;&#125;&#125;) 只有a=1且b&gt;2才会匹配。 取模（$mod）比如我们要匹配 read % 5 == 1：1db.article.find(&#123;\"read\": &#123;$mod: [5, 1]&#125;&#125;) 是否存在（$exists)如果我们要判断love字段是否存在，可以这样：1db.article.find(&#123;\"love\": &#123;\"$exists\": true&#125;&#125;) // 如果存在字段love，就返回 我们也可以判断不存在：1db.article.find(&#123;\"love\": &#123;\"$exists\": false&#125;&#125;) // 如果不存在字段love，就返回 正则表达式mongodb支持正则表达式，使用方法与正则字面量一样：1db.article.find(&#123;\"title\": /mongodb/i&#125;) // i是忽略大小写 类型查询我们可以根据字段类型来返回数据：1db.article.find(&#123;\"comments\": &#123;\"$type\": 4&#125;&#125;) 只有当comments的类型是数组才匹配注：更多类型的数值可以参考这里：mongodb $type 内嵌文档mongodb是允许内嵌文档的，而且要查询内嵌文档也很简单（使用点语法）：1234&#123; address: &#123; name: \"nanji\" &#125;&#125;db.article.find(&#123;\"address.name\": \"nanji\"&#125;) 上面的语句是查询comments中的author。数组也可以采取点语法:1234&#123; comments: [&#123;title: \"mongodb\"&#125;, &#123;title: \"javascript\"&#125;]&#125;db.article.find(&#123;\"comments.title\": \"mongodb\"&#125;) 取反$not是元语句，即可以用在任何其他条件之上：1db.article.find(&#123;\"author\": &#123;\"$not\": /mongodb/i&#125;&#125;) 只要使用$not操作符，就表示取反。 MongoDB常用方法控制返回数量（limit）1db.article.find().limit(10) 返回10条数据 略过数量1db.article.find().skip(5) 略过前5条数据，也就是从第6条开始返回。可以结合limit()和skip()来达到分页效果：12select * from article limit 10, 20db.article.find().skip(10).limit(20) 统计返回匹配数据的长度：1db.article.find().count() 格式化pretty()方法可以以格式化的方式显示所有文档：1db.article.find().pretty() 删除集合当你要删除一个集合中的所有文档时，直接删除一个集合效率会更高：1db.article.drop()","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}],"keywords":[]},{"title":"Mongodb之mongoose入门","slug":"Mongodb之mongoose入门","date":"2017-07-11T08:51:46.000Z","updated":"2018-07-12T06:47:06.414Z","comments":true,"path":"2017/07/11/Mongodb之mongoose入门/","link":"","permalink":"http://yoursite.com/2017/07/11/Mongodb之mongoose入门/","excerpt":"最近一直在看node，先从简单的express学起，其他的还好说，主要是和数据库的连接。既然是js，那就先从mongodb开始吧，我们使用mongoose中间件连接mongodb。 基本操作关于mongoose的基本操作其实网上很多教程，按照mongoose官网的quick start guide，很快就能有个大概的了解。123$ npm install mongoose --savevar mongoose = require('mongoose')mongoose.connect('mongodb://ip:port/database')","text":"最近一直在看node，先从简单的express学起，其他的还好说，主要是和数据库的连接。既然是js，那就先从mongodb开始吧，我们使用mongoose中间件连接mongodb。 基本操作关于mongoose的基本操作其实网上很多教程，按照mongoose官网的quick start guide，很快就能有个大概的了解。123$ npm install mongoose --savevar mongoose = require('mongoose')mongoose.connect('mongodb://ip:port/database') 这里注意，很多教程都没有详细说明对于有权限的数据库的连接方式，也让我在刚接触时郁闷了很久，数据库加密是防止数据库发生损失的第一道锁，如下(在数据库中操作)123456789101112$ use database$ db.createUser(&#123; user: user, pwd: pwd, roles:[ &#123; role: \"readWrite ...\", // 具体的权限 db: \"\" //datebase &#125; ]&#125;)$ db.auth(\"userName\",\"password\") 注意，在服务器上，如果要直接操作数据库，可以先连接，再通过db.auth()来验证权限，可是如果在node中该怎么做呢？ example：我的数据库账号是admin,密码为password,需要连接的database为test，数据库地址是111.222.333.444:1024那么再连接的时候就可以直接指定连接的地址为1mongoose.connect('mongodb://admin:password@111.222.333.444:1024/test') 这样就不会出现由于权限的问题而无法连接了，但是要注意，在mongodb的admin下建的账户，在子数据库中是不能直接验证的，同时也为了安全，应该在每个数据库下都建立不同权限的账户1234$ use admin //切换到admin$ db.system.users.find().pretty() //查看系统下所有的账户$ use test //切换到test$ show users //查询test下的账户 连接数据库在成功连接了数据库并通过正好验证以后，就该对数据库进行增删改查了，很多关于mongoose的入门的教程都是寥寥几句，尤其对于最核心的Schema和Model，并没有过多的深入，而官方文档对于刚接触不深的我来说，也是比较吃力，下面是个人在学习过程中的一些小小的总结 Schema是mongoose的一种模式，这是比较抽象的一个东西，它对应的是数据库中的collection,比如，db.collection.find({})的数据是这样的12345&#123; name: 'Jack', age: '25', date: '2017-05-25'&#125; 那么对应的这个Schema就是这样的：12345&#123; name: &#123;type: String&#125;, age: &#123;type: Number&#125;, date: &#123;type: Date&#125;&#125; Schema定义了一个集合中数据的基本格式，但控制数据的，其实是model,关于model稍后再细谈。 好了，现在就可以进行下一步了：12345678910111213var Schema = mongoose.Schema;var newSchema = new Schema( &#123; name: &#123;type: String&#125;, age: &#123;type: Number&#125;, date: &#123;type: Date&#125; &#125;, &#123; collection: \"\" // 这个是什么？？？ &#125;)module.exports = mongoose.model(\"User\", newSchema) 在这一步里，我们成功的创造了一个Schema的实例，也就是一个新的模式，并通过mongoose.model()生成了一个model，而具体操作数据库的，就是这个model,比如这里的User，下面就插入一条数据：123456789101112// 先require()到刚才的文件var user = new User(&#123; name: 'jesse', age: 25, date: new Date()&#125;)user.save(function(err, res)&#123;...&#125;我们可以查看一下这个数据User.find(function(err, res)&#123; console.log(res)&#125;) 可以成功打印出刚插入数据的数据库里已经有了这条数据 看一下服务器：1234567$ show collectionsusers$ db.users.find()............ //具体的数据 也没有问题，可是，这个users是怎么来的呢？还有刚刚在定义Schema时，那个collection是干什么的？我们怎么从已有的数据库中取数据呢？带着这三个问题，我们继续探索！ 继续探索刚才，我们定义了数据的模式，生成了model，并成功的插入了一条数据，可是我们并没有定义这个collection的名字呀，怎么多出来了一个users，经过网上的搜索，应该是mongoose在生成数据时，自动在User等Schema的后面加上了s，并转换为小写，作为collection的默认名字，但如果想要自定义这个名字该怎么做呢? 可以这样1mongoose.model(\"User\", newSchema,\"userseseseses...\") 也就是model()的第三个参数，也可以这样12345var newSchema = new Schema(&#123; ...&#125;,&#123; collection: \"collectionName\"&#125;) 即Schema({},{})的第二个参数.","categories":[],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}],"keywords":[]},{"title":"react-router实现按需加载","slug":"react-router实现按需加载","date":"2017-07-08T13:56:09.000Z","updated":"2018-07-12T06:47:06.419Z","comments":true,"path":"2017/07/08/react-router实现按需加载/","link":"","permalink":"http://yoursite.com/2017/07/08/react-router实现按需加载/","excerpt":"本文使用的 react-router 版本为3.0 React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。 Webpack 配置首先在 webpack.config.js 的 output 内加上 chunkFilename1234567output: &#123; path: path.join(__dirname, '/../dist/assets'), filename: 'app.js', publicPath: defaultSettings.publicPath, // 添加 chunkFilename chunkFilename: '[name].[chunkhash:5].chunk.js',&#125;, name 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。","text":"本文使用的 react-router 版本为3.0 React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。 Webpack 配置首先在 webpack.config.js 的 output 内加上 chunkFilename1234567output: &#123; path: path.join(__dirname, '/../dist/assets'), filename: 'app.js', publicPath: defaultSettings.publicPath, // 添加 chunkFilename chunkFilename: '[name].[chunkhash:5].chunk.js',&#125;, name 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。chunkhash 是文件的 hash 码，这里只使用前五位。 添加首页以前你的路由大概应该是这样的：（作为需要按需加载的大型应用，路由肯定是相当复杂，这里只列举部分路由举例）1234567891011121314151617181920212223ReactDOM.render( ( &lt;Router history=&#123;browserHistory&#125;&gt; &#123;/* 主页 */&#125; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &#123;/* 默认 */&#125; &lt;IndexRoute component=&#123;HomePage&#125; /&gt; &#123;/* baidu */&#125; &lt;Route path=\"/baidu\" component=&#123;BaiduPage&#125;&gt; &lt;Route path=\"result\" component=&#123;BaiduResultPage&#125; /&gt; &lt;Route path=\"frequency\" component=&#123;BaiduFrequencyPage&#125; /&gt; &lt;/Route&gt; &#123;/* 404 */&#125; &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt; &#123;/* 其他重定向到 404 */&#125; &lt;Redirect from='*' to='/404' /&gt; &lt;/Route&gt; &lt;/Router&gt; ), document.getElementById('app')); 按需加载之后，我们需要让路由动态加载组件，需要将 component 换成 getComponent。首先将路由拆出来（因为路由庞大之后全部写在一起会很难看），创建一个根路由 rootRoute：1234567891011121314151617181920212223242526272829const rootRoute = &#123; path: '/', indexRoute: &#123; getComponent(nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; cb(null, require('components/layer/HomePage')) &#125;, 'HomePage') &#125;, &#125;, getComponent(nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; cb(null, require('components/Main')) &#125;, 'Main') &#125;, childRoutes: [ require('./routes/baidu'), require('./routes/404'), require('./routes/redirect') ]&#125;ReactDOM.render( ( &lt;Router history=&#123;browserHistory&#125; routes=&#123;rootRoute&#125; /&gt; ), document.getElementById('app')); history 不变，在 Router 中添加 routes 属性，将创建的路由传递进去。这里有四个属性： path将匹配的路由，也就是以前的 path。 getComponent对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。这里面有个 require.ensure 方法 require.ensure(dependencies, callback, chunkName)这是 webpack 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 chunkName，用来指定这个 chunk file 的 name。如果需要返回多个子组件，则使用 getComponents 方法，将多个组件作为一个对象的属性通过 cb 返回出去即可。这个在官方示例也有，但是我们这里并不需要，而且根组件是不能返回多个子组件的，所以使用 getComponent。 indexRoute用来设置主页，对应于以前的 。注意这里的 indexRoute 写法， 这是个对象，在对象里面使用 getComponent。 childRoutes这里面放置的就是子路由的配置，对应于以前的子路由们。我们将以前的 /baidu、/404 和 * 都拆了出来，接下来将分别为他们创建路由配置。 路由控制上面的childRoutes 里面，我们 require 了三个子路由，在目录下创建 routes 目录，将这三个路由放置进去。routes/├── 404│ └── index.js├── baidu│ ├── index.js│ └── routes│ ├── frequency│ │ └── index.js│ └── result│ └── index.js└── redirect └── index.js和 rootRoute 类似，里面的每个 index.js 都是一个路由对象：1234567891011121314151617181920212223242526272829303132333435/404/index.jsmodule.exports = &#123; path: '404', getComponent(nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; cb(null, require('components/layer/NotFoundPage')) &#125;, 'NotFoundPage') &#125;&#125;/baidu/index.jsmodule.exports = &#123; path: 'baidu', getChildRoutes(partialNextState, cb) &#123; require.ensure([], (require) =&gt; &#123; cb(null, [ require('./routes/result'), require('./routes/frequency') ]) &#125;) &#125;, getComponent(nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; cb(null, require('components/layer/BaiduPage')) &#125;, 'BaiduPage') &#125;&#125;/baidu/routes/frequency/index.jsmodule.exports = &#123; path: 'frequency', getComponent(nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; cb(null, require('components/layer/BaiduFrequencyPage')) &#125;, 'BaiduFrequencyPage') &#125;&#125; 举这几个例子应该就差不多了，其他都是一样的，稍微有点特别的是 redirect。 设置 Redirect之前我们在根路由下是这么设置重定向的：123456789101112131415&lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;App&#125;&gt; &#123;/* home */&#125; &lt;IndexRoute component=&#123;HomePage&#125; /&gt; &lt;Route path=\"/baidu\" component=&#123;BaiduPage&#125;&gt; &lt;Route path=\"result\" component=&#123;BaiduResultPage&#125; /&gt; &lt;Route path=\"frequency\" component=&#123;BaiduFrequencyPage&#125; /&gt; &lt;/Route&gt; &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt; &#123;/* 如果都不匹配，重定向到 404 */&#125; &lt;Redirect from='*' to='/404' /&gt; &lt;/Route&gt; &lt;/Router&gt; 当改写之后，我们需要把这个重定向的路由单独拆出来，也就是 * 这个路由，我们上面已经为他创建了一个 redirect 目录。这里使用到 onEnter 方法，然后在这个方法里改变路由状态，调到另外的路由，实现 redirect ：12345/redirect/index.jsmodule.exports = &#123; path: '*', onEnter: (_, replaceState) =&gt; replaceState(null, \"/404\")&#125; The root route must render a single element跟着官方示例和上面码出来之后，可能页面并没有渲染出来，而是报 The root route must render a single element 这个异常，这是因为 module.exports 和 ES6 里的 export default 有区别。 如果你是使用 es6 的写法，也就是你的组件都是通过 export default 导出的，那么在 getComponent 方法里面需要加入 .default。123456getComponent(nextState, cb) &#123; require.ensure([], (require) =&gt; &#123; // 在后面加 .default cb(null, require('components/layer/ReportPage')).default &#125;, 'ReportPage')&#125; 如果你是使用 CommonJS 的写法，也就是通过 module.exports 导出的，那就无须加 .default 了。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}],"keywords":[]},{"title":"express的上传中间件multer","slug":"express的上传中间件multer","date":"2017-06-10T03:46:22.000Z","updated":"2018-07-12T06:47:06.416Z","comments":true,"path":"2017/06/10/express的上传中间件multer/","link":"","permalink":"http://yoursite.com/2017/06/10/express的上传中间件multer/","excerpt":"Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据, 它主要用于上传文件. 它是写在 busboy 之上非常高效。 注意: Multer 不会处理任何非 multipart/form-data 类型的表单数据. 安装1npm install --save multer 使用","text":"Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据, 它主要用于上传文件. 它是写在 busboy 之上非常高效。 注意: Multer 不会处理任何非 multipart/form-data 类型的表单数据. 安装1npm install --save multer 使用 Multer 会添加一个 body 对象 以及 file 或 files 对象 到 request 对象中. body 对象包含表单的文本域信息, file 或 files 对象包含对象表单上传的文件信息.基本使用方法:1234567891011121314151617181920212223242526var express = require('express')var multer = require('multer')var upload = multer(&#123; dest: 'uploads/' &#125;)var app = express()app.post('/profile', upload.single('avatar'), function (req, res, next) &#123; // req.file 是 `avatar` 文件的信息 // req.body 将具有文本域数据, 如果存在的话&#125;)app.post('/photos/upload', upload.array('photos', 12), function (req, res, next) &#123; // req.files 是 `photos` 文件数组的信息 // req.body 将具有文本域数据, 如果存在的话&#125;)var cpUpload = upload.fields([&#123; name: 'avatar', maxCount: 1 &#125;, &#123; name: 'gallery', maxCount: 8 &#125;])app.post('/cool-profile', cpUpload, function (req, res, next) &#123; // req.files 是一个对象 (String -&gt; Array) 键是文件名, 值是文件数组 // // 例如： // req.files['avatar'][0] -&gt; File // req.files['gallery'] -&gt; Array // // req.body 将具有文本域数据, 如果存在的话&#125;) #API multer(opts)Multer 接受一个 options 对象, 其中最基本的是 dest 属性, 这将告诉 Multer 将上传文件保存在哪. 如果你省略 options 对象, 这些文件将保存在内存中，永远不会写入磁盘。 为了避免命名冲突, Multer 会修改上传的文件名. 这个重命名功能可以根据您的需要定制。 以下是可以传递给Multer的选项.&gt; Key Description dest or storage 在哪里存储文件 fileFilter 文件过滤器，控制哪些文件可以被接受 limits 限制上传的数据 通常, 只需要设置 dest 属性 像这样：1var upload = multer(&#123; dest: &apos;uploads/&apos; &#125;) 如果你想在上传时进行更多的控制, 你可以使用storage选项替代dest. Multer 具有 DiskStorage 和 MemoryStorage 两个存储引擎; 另外还可以从第三方获得更多可用的引擎. .single(fieldname)接受一个以 fieldname 命名的文件. 这个文件的信息保存在 req.file. .array(fieldname[, maxCount])接受一个以 fieldname 命名的文件数组. 可以配置 maxCount 来限制上传的最大数量. 这些文件的信息保存在 req.files. .fields(fields)接受指定 fields 的混合文件. 这些文件的信息保存在 req.files.fields 应该是一个对象数组，应该具有 name 和可选的 maxCount属性. Example:[ { name: ‘avatar’, maxCount: 1 }, { name: ‘gallery’, maxCount: 8 }] .none()只接受文本域. 如果任何文件上传到这个模式, 将发生 “LIMIT_UNEXPECTED_FILE” 错误. 这和 upload.fields([]) 的效果一样. .any()接受一切. 文件数组将保存在 req.files.警告: 确保你总是处理了用户的文件上传. 永远不要将multer作为全局中间件使用，因为恶意用户可以上传文件到一个你没有预料到的路由，应该只在你需要处理上传文件的路由上使用. storageDiskStorage磁盘存储引擎可以让你控制文件的存储.12345678910var storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, '/tmp/my-uploads') &#125;, filename: function (req, file, cb) &#123; cb(null, file.fieldname + '-' + Date.now()) &#125;&#125;)var upload = multer(&#123; storage: storage &#125;) destination 是用来确定上传的文件应该存储在哪个文件夹中. 也可以提供一个 string (例如 ‘/tmp/uploads’). 如果没有设置 destination , 则使用操作默认的临时文件夹.filename 用于确定文件夹中的文件名的确定。 如果没有设置filename , 每个文件将设置为一个随机文件名，并且是没有扩展名的注意: Multer 不会为你添加任何扩展名, 你的程序应该返回一个完整的文件名.此时就可以在file.originName中获取扩展名。 limits可以使用下面这些: Key Description DefaultfieldNameSize field 名字最大长度 100 bytesfieldSize field 值的最大长度 1MBfields 非文件 field 的最大数量 无限fileSize 在multipart表单中, 文件最大长度 (字节单位) 无限files 在multipart表单中, 文件最大数量 无限parts 在multipart表单中, part传输的最大数量(fields + files) 无限headerPairs For multipart forms, the max number of header key=&gt;value pairs to parse 2000 fileFilter设置一个函数来控制什么文件可以上传以及什么文件应该跳过，这个函数应该看起来像这样：123456789101112131415function fileFilter (req, file, cb) &#123; // 这个函数应该调用 `cb` 用boolean值来 // 指示是否应接受该文件 // 拒绝这个文件，使用`false`, 像这样: cb(null, false) // 接受这个文件，使用`true`, 像这样: cb(null, true) // 如果有问题，你可以总是这样发送一个错误: cb(new Error('I don\\'t have a clue!'))&#125;","categories":[],"tags":[{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"}],"keywords":[]},{"title":"使用Travis将Hexo同时部署到Coding.net","slug":"使用Travis将Hexo同时部署到Coding-net","date":"2017-06-02T15:57:18.000Z","updated":"2018-07-12T06:47:06.423Z","comments":true,"path":"2017/06/02/使用Travis将Hexo同时部署到Coding-net/","link":"","permalink":"http://yoursite.com/2017/06/02/使用Travis将Hexo同时部署到Coding-net/","excerpt":"","text":"既然使用了Travis在push后发不到github，那就再加点东西，发布到coding.net的Pages服务上，理论上国内服务应该快一点点。 同时搭建的教程可以看看这里 修改.travis文件夹下的ssh_config,添加coding.net 12345678910Host github.com User git StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa IdentitiesOnly yesHost git.coding.net User git StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes 修改hexo的配置文件_config.yml 12345deploy: type: git repo: coding: git@git.coding.net:wxrbw/wxrbw.coding.me.git,master github: git@github.com:wxrbwran/wxrbwran.github.io.git,master 再push到github就可以自动发布到两个Pages了。","categories":[],"tags":[{"name":"travis","slug":"travis","permalink":"http://yoursite.com/tags/travis/"}],"keywords":[]},{"title":"在express中使用es2015的新特性","slug":"在express中使用es2015的新特性","date":"2017-06-01T10:20:55.000Z","updated":"2018-07-12T06:47:06.425Z","comments":true,"path":"2017/06/01/在express中使用es2015的新特性/","link":"","permalink":"http://yoursite.com/2017/06/01/在express中使用es2015的新特性/","excerpt":"","text":"在前端开发中使用es2015及正在stage中的js特性已经屡见不鲜，但是在express中使用还是第一次尝试，稍微配置下也是可以的。有没有坑，等使用后再补齐。 安装babel123&quot;babel-cli&quot;: &quot;^6.24.1&quot;,&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,&quot;babel-preset-stage-2&quot;: &quot;^6.24.1&quot;, ###根目录下创建.babelrc文件1234&#123; &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;], &quot;plugins&quot;: []&#125; 安装nodemon不使用supervisor是因为配合不了babel1npm install nodemon -g 修改package.json123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;nodemon ./bin/www.js --exec babel-node&quot; &#125;, 之后就可以使用es新的语法特性了~","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"},{"name":"express","slug":"express","permalink":"http://yoursite.com/tags/express/"}],"keywords":[]},{"title":"hexo＋Travis-ci＋github构建自动化博客","slug":"hexo＋Travis-ci＋github构建自动化博客","date":"2017-06-01T02:08:52.000Z","updated":"2018-07-12T06:47:06.417Z","comments":true,"path":"2017/06/01/hexo＋Travis-ci＋github构建自动化博客/","link":"","permalink":"http://yoursite.com/2017/06/01/hexo＋Travis-ci＋github构建自动化博客/","excerpt":"Travis CI：是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清晰。 tarvis－ci是远端服务器构建，跟jenkins 不一样，不用自己搭建一个jenkins服务器。tarvis－ci是用的远端官方提供的服务器。用hexo 搭建博客，然后将博客源码提交到 Git上，用travis－ci 编译git 上的源码，然后将编译后的文件，推送到Github.io仓库下，达到自动化编译构建。 构建自动化博客的步骤由于需要搭建hexo 和本地搭建Travis 所以本地需要有ruby 和 node 环境。本地搭建Travis 是为了和Travis－ci 服务器进行加密解密获得密匙，获得一次即可。 安装rubu 和node.js 搭建hexo 安装 travis 配置git 的ssh key 配置Travis 验证","text":"Travis CI：是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清晰。 tarvis－ci是远端服务器构建，跟jenkins 不一样，不用自己搭建一个jenkins服务器。tarvis－ci是用的远端官方提供的服务器。用hexo 搭建博客，然后将博客源码提交到 Git上，用travis－ci 编译git 上的源码，然后将编译后的文件，推送到Github.io仓库下，达到自动化编译构建。 构建自动化博客的步骤由于需要搭建hexo 和本地搭建Travis 所以本地需要有ruby 和 node 环境。本地搭建Travis 是为了和Travis－ci 服务器进行加密解密获得密匙，获得一次即可。 安装rubu 和node.js 搭建hexo 安装 travis 配置git 的ssh key 配置Travis 验证 安装ruby和node略 搭建hexo搭建过程略注意的是：博客搭建成功后在github 的your_blog_name.github.io 仓库下新建travis分支，并将博客源码（未编译过的代码）提交到该分支，用于以后Travis-ci编译使用。 安装 travis1gem install travis 配置git 的ssh key将本机ssh_key 添加github中。 配置Travis 进入travis官网Travis 官网传送门用github账号登陆Travis CI 在右上角你的账户名点击进入 account，在Repositories tab页点击Sync now同步你的github项目。选中项目将默认的off改变为on开启项目的持续集成。 在你项目的根目录建立一个.travis文件夹 12$ cd 博客项目文件夹根目录$ mkdir .travis 复制id_rsa 和 创建 ssh_config文件 12$ cd 博客项目文件夹根目录/.travis$ cp ~/.ssh/id_rsa ./ 创建 ssh_config 文件 12$ cd 博客项目文件夹根目录/.travis$ touch ssh_config 编辑 ssh_config ,输入以下信息 Host github.comUser gitStrictHostKeyChecking noIdentityFile ~/.ssh/id_rsaIdentitiesOnly yes travis 登陆12$ cd 博客项目文件夹根目录/.travis$ travis login --auto 需要填写github的用户名和密码。 加密操作在博客项目文件夹下对ssh的私钥进行加密12$ cd 博客项目文件夹根目录/.travis$ travis encrypt-file id_rsa --add 此操作会生成加密之后的秘钥文件 id_rsa.enc，删除id_rsa密钥文件(私钥不能随便泄露)。你的travis 目前上已经出现了下面加密解密key :(点击第2步图中的仓库名可进入下图界面，点击setting可看到加密) 在你项目的根目录建立一个.travis.yml文件，内容为：此步是在我your_blog_name.github.io仓库的travis 分支下编译源码。（用第7步中Travis 生成的 encrypted_xxxxxxxxx_key -iv 和encrypted_xxxxxxxxx_iv 替换travis.yml 中openssl的 key 和 -iv） 12345678910111213141516171819202122232425262728language: node_jsnode_js:- '7'branches: only: - traviscache: directories: - node_modulesbefore_install:- openssl aes-256-cbc -K $encrypted_xxxxxxxxx_key -iv $encrypted_xxxxxxxxx_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d- chmod 600 ~/.ssh/id_rsa- eval $(ssh-agent)- ssh-add ~/.ssh/id_rsa- cp .travis/ssh_config ~/.ssh/config- git config --global user.name \"527515025\"- git config --global user.email \"527515025@qq.com\"install:- npm install hexo-cli -g- npm install hexo-deployer-git --save- npm installscript:- hexo clean- hexo gafter_success:- hexo deploy 在travis分支中，操作一下，push到分支上就可以自动构建并发布了~","categories":[],"tags":[{"name":"ci","slug":"ci","permalink":"http://yoursite.com/tags/ci/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[]},{"title":"react中context的使用","slug":"react中context的使用","date":"2017-05-27T06:29:39.000Z","updated":"2018-07-12T06:47:06.419Z","comments":true,"path":"2017/05/27/react中context的使用/","link":"","permalink":"http://yoursite.com/2017/05/27/react中context的使用/","excerpt":"使用 Context 的原因为了有时候想传递数据通过组件树，但是不想给每一层级的组件手动传递属性，那么 context 就能帮你 “越级” 传递数据到组件树中你想传递到的深层次组件。","text":"使用 Context 的原因为了有时候想传递数据通过组件树，但是不想给每一层级的组件手动传递属性，那么 context 就能帮你 “越级” 传递数据到组件树中你想传递到的深层次组件。 有时候 A组件 为了给 B组件 中的 C组件 传递一个 prop ，而需要把参数在组件中传递两次才能最终将 A组件 中的 prop 传递给 C组件 。 官方文档的示例代码如下1234567891011121314151617181920212223242526272829var Button = React.createClass(&#123; render: function() &#123; return ( &lt;button style=&#123;&#123;background: this.props.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ); &#125;&#125;);var Message = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button color=&#123;this.props.color&#125;&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;);var MessageList = React.createClass(&#123; render: function() &#123; var color = \"purple\"; var children = this.props.messages.map(function(message) &#123; return &lt;Message text=&#123;message.text&#125; color=&#123;color&#125; /&gt;; &#125;); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125;); 使用 context 改进数据传递现在我们使用 context 来完成参数的传递试试123456789101112131415161718192021222324252627282930313233343536373839var Button = React.createClass(&#123; // 必须指定context的数据类型 contextTypes: &#123; color: React.PropTypes.string &#125;, render: function() &#123; return ( &lt;button style=&#123;&#123;background: this.context.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ); &#125;&#125;);var Message = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;);var MessageList = React.createClass(&#123; // childContextTypes: &#123; color: React.PropTypes.string &#125;, getChildContext: function() &#123; return &#123;color: \"purple\"&#125;; &#125;, render: function() &#123; var children = this.props.messages.map(function(message) &#123; return &lt;Message text=&#123;message.text&#125; /&gt;; &#125;); return &lt;div&gt;&#123;children&#125;&lt;/div&gt;; &#125;&#125;); 示例代码中通过添加 childContextTypes 和getChildContext() 到 MessageList （ context 的提供者），React 自动向下传递数据然后在组件树中的任意组件（也就是说任意子组件，在此示例代码中也就是 Button ）都能通过定义 contextTypes 访问 context 中的数据。 总结 指定数据并要将数据传递下去的父组件要定义 childContextTypes 和 getChildContext()； 想要接收到数据的子组件 必须定义 contextTypes 来使用传递过来的 context 。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}],"keywords":[]},{"title":"使用ES2015全局对象--webpack下添加polyfill","slug":"使用ES2015全局对象--webpack下添加polyfill","date":"2017-01-22T08:32:07.000Z","updated":"2018-07-12T06:47:06.422Z","comments":true,"path":"2017/01/22/使用ES2015全局对象--webpack下添加polyfill/","link":"","permalink":"http://yoursite.com/2017/01/22/使用ES2015全局对象--webpack下添加polyfill/","excerpt":"公司使用的技术栈是react全家桶，使用axios进行ajax通信,axios使用的基于Promise实现。在现代浏览器上使用并没有什么问题，但是IE全系列不支持Promise，包括IE11… 本来想着使用babel后，将代码转换为es5，应该在IE10以上兼容运行，但是实际运行时，报错，没有Promise…orz 长话短说，解决方案：babel-polyfill","text":"公司使用的技术栈是react全家桶，使用axios进行ajax通信,axios使用的基于Promise实现。在现代浏览器上使用并没有什么问题，但是IE全系列不支持Promise，包括IE11… 本来想着使用babel后，将代码转换为es5，应该在IE10以上兼容运行，但是实际运行时，报错，没有Promise…orz 长话短说，解决方案：babel-polyfill 原来在.babelrc里面添加的是 babel-plugin-transform-runtime，但是在这里并不管用，究竟是为什么呢？ babel-polyfill 使用场景 Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。 babel-runtime 使用场景 Babel 转译后的代码要实现源代码同样的功能需要借助一些帮助函数，例如，{ [name]: ‘JavaScript’ } 转译后的代码如下所示：123456789101112131415'use strict';function _defineProperty(obj, key, value) &#123; if (key in obj) &#123; Object.defineProperty(obj, key, &#123; value: value, enumerable: true, configurable: true, writable: true &#125;); &#125; else &#123; obj[key] = value; &#125; return obj;&#125;var obj = _defineProperty(&#123;&#125;, 'name', 'JavaScript'); 类似上面的帮助函数 _defineProperty 可能会重复出现在一些模块里，导致编译后的代码体积变大。Babel 为了解决这个问题，提供了单独的包 babel-runtime 供编译模块复用工具函数。 启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数，转译代码如下：123456'use strict';// 之前的 _defineProperty 函数已经作为公共模块 `babel-runtime/helpers/defineProperty` 使用var _defineProperty2 = require('babel-runtime/helpers/defineProperty');var _defineProperty3 = _interopRequireDefault(_defineProperty2);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var obj = (0, _defineProperty3.default)(&#123;&#125;, 'name', 'JavaScript');","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[]},{"title":"调试手机端微信X5浏览器","slug":"调试手机端微信X5浏览器","date":"2016-11-15T03:22:04.000Z","updated":"2018-07-12T06:47:06.427Z","comments":true,"path":"2016/11/15/调试手机端微信X5浏览器/","link":"","permalink":"http://yoursite.com/2016/11/15/调试手机端微信X5浏览器/","excerpt":"移动调试移动端网页的表现，通常和桌面浏览器上有所区别，包括样式的呈现、脚本的逻辑等等，这会给开发者带来一定的困扰。现在，微信安卓客户端 webview 已经开始全面升级至 X5 Blink 内核，新的内核无论在渲染能力、API 支持还是在开发辅助上都有很大进步。通过微信 web 开发者工具中的远程调试功能，实时映射手机屏幕到微信 web 开发者工具上，将帮助开发者更高效地调试 X5 Blink 内核的网页，具体步骤如下： 准备工作 安装0.5.0或以上版本的微信 web 开发者工具 确认移动设备是否支持远程调试功能打开微信 web 开发者工具，选择“移动调试”tab，点击验证移动设备是否支持。随后使用移动设备扫描弹出的二维码，在设备上即可获得支持信息。 打开移动设备中的 USB 调试功能 打开移动设备，进入“设置”-&gt;“开发人员选项” 勾选“USB 调试功能”需要注意的是，Android 4.2 之后的设备，开发人员选项默认是隐藏的，通过以下步骤可以打开： 打开移动设备，进入“设置”-&gt;“关于手机” 找到并单击“内部版本号”7次 安装移动设备 USB 驱动 打开 X5 Blink 内核的 inspector 功能打开微信 web 开发者工具，选择“移动调试”tab ，使用设备扫描“调试步骤”中的二维码。如下图，勾选“是否打开 TBS 内核 Inspector 调试功能”，并重启微信。","text":"移动调试移动端网页的表现，通常和桌面浏览器上有所区别，包括样式的呈现、脚本的逻辑等等，这会给开发者带来一定的困扰。现在，微信安卓客户端 webview 已经开始全面升级至 X5 Blink 内核，新的内核无论在渲染能力、API 支持还是在开发辅助上都有很大进步。通过微信 web 开发者工具中的远程调试功能，实时映射手机屏幕到微信 web 开发者工具上，将帮助开发者更高效地调试 X5 Blink 内核的网页，具体步骤如下： 准备工作 安装0.5.0或以上版本的微信 web 开发者工具 确认移动设备是否支持远程调试功能打开微信 web 开发者工具，选择“移动调试”tab，点击验证移动设备是否支持。随后使用移动设备扫描弹出的二维码，在设备上即可获得支持信息。 打开移动设备中的 USB 调试功能 打开移动设备，进入“设置”-&gt;“开发人员选项” 勾选“USB 调试功能”需要注意的是，Android 4.2 之后的设备，开发人员选项默认是隐藏的，通过以下步骤可以打开： 打开移动设备，进入“设置”-&gt;“关于手机” 找到并单击“内部版本号”7次 安装移动设备 USB 驱动 打开 X5 Blink 内核的 inspector 功能打开微信 web 开发者工具，选择“移动调试”tab ，使用设备扫描“调试步骤”中的二维码。如下图，勾选“是否打开 TBS 内核 Inspector 调试功能”，并重启微信。 开始调试使用 USB 数据线连接移动设备与 PC 或者 Mac 后，点击打开微信 web 开发者工具“移动调试”tab，选择 X5 Blink 调试功能，将会打开一个新窗口，在微信中访问任意网页即可开始调试。关于 X5 Blink 内核更多信息，可以查看官网介绍。在所有准备工作都完成的情况下，窗口中可以看到当前设备的基本信息：点击任意页面的“inspect”，打开新窗口，开发者会看到熟悉的调试界面：点击上图右上角的“手机”图标，将启用屏幕映射功能：","categories":[],"tags":[{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"}],"keywords":[]},{"title":"ES2015的模块化","slug":"ES2015的模块化","date":"2016-11-09T02:26:59.000Z","updated":"2018-07-12T06:47:06.412Z","comments":true,"path":"2016/11/09/ES2015的模块化/","link":"","permalink":"http://yoursite.com/2016/11/09/ES2015的模块化/","excerpt":"ModuleES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。 历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连CSS都有@import，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。 123456// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。 由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 浏览器使用ES6模块的语法如下。 1&lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt; 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个ES6模块。 Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。 ES6的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。","text":"ModuleES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。 历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连CSS都有@import，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。 123456// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。 由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 浏览器使用ES6模块的语法如下。 1&lt;script type=\"module\" src=\"foo.js\"&gt;&lt;/script&gt; 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个ES6模块。 Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。 ES6的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。 export命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。 1234// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 上面代码是profile.js文件，保存了用户信息。ES6将其视为一个模块，里面用export命令对外部输出了三个变量。 export的写法，除了像上面这样，还有另外一种。 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export命令除了输出变量，还可以输出函数或类（class）。 123export function multiply(x, y) &#123; return x * y;&#125;; 上面代码对外输出一个函数multiply。 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 123456// 报错export 1;// 报错var m = 1;export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。正确的写法是下面这样。 12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; 上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。 同样的，function和class的输出，也必须遵守这样的写法。 12345678910// 报错function f() &#123;&#125;export f;// 正确export function f() &#123;&#125;;// 正确function f() &#123;&#125;export &#123;f&#125;; 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 上面代码输出变量foo，值为bar，500毫秒之后变成baz。 这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。 最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。 1234function foo() &#123; export default 'bar' // SyntaxError&#125;foo() 上面代码中，export语句放在函数之中，结果报错。 import命令使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。 1234567// main.jsimport &#123;firstName, lastName, year&#125; from './profile';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 上面代码的import命令，就用于加载profile.js文件，并从中输入变量。import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 1import &#123; lastName as surname &#125; from './profile'; 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import &#123; foo &#125; from 'my_module'; 上面的代码不会报错，因为import的执行早于foo的调用。 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 12345export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6; 上面代码中，export和import语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，而应该采用标准写法。 另外，ES7有一个提案，简化先输入后输出的写法，拿掉输出时的大括号。 12345// 提案的写法export v from 'mod';// 现行的写法export &#123;v&#125; from 'mod'; import语句会执行所加载的模块，因此可以有下面的写法。 1import 'lodash'; 上面代码仅仅执行lodash模块，但是不输入任何值。 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法area和circumference。 123456789// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125; 现在，加载这个模块。 123456// main.jsimport &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14)); 上面写法是逐一指定要加载的方法，整体加载的写法如下。 1234import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); export default命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 1234// export-default.jsexport default function () &#123; console.log('foo');&#125; 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 123// import-default.jsimport customName from './export-default';customName(); // 'foo' 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。 export default命令用在非匿名函数前，也是可以的。 123456789101112// export-default.jsexport default function foo() &#123; console.log('foo');&#125;// 或者写成function foo() &#123; console.log('foo');&#125;export default foo; 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。 下面比较一下默认输出和正常输出。 12345678910111213// 输出export default function crc32() &#123; // ...&#125;// 输入import crc32 from 'crc32';// 输出export function crc32() &#123; // ...&#125;;// 输入import &#123;crc32&#125; from 'crc32'; 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export deault命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 123456789101112// modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as xxx &#125; from 'modules';// 等同于// import xxx from 'modules'; 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。 123456789// 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1; 上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。 有了export default命令，输入模块时就非常直观了，以输入jQuery模块为例。 1import $ from 'jquery'; 如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。 1import customName, &#123; otherMethod &#125; from './export-default'; 如果要输出默认的值，只需将值跟在export default之后即可。 1export default 42; export default也可以用来输出类。 123456// MyClass.jsexport default class &#123; ... &#125;// main.jsimport MyClass from 'MyClass';let o = new MyClass(); 模块的继承模块之间也可以继承。 假设有一个circleplus模块，继承了circle模块。 1234567// circleplus.jsexport * from 'circle';export var e = 2.71828182846;export default function(x) &#123; return Math.exp(x);&#125; 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 这时，也可以将circle的属性或方法，改名后再输出。 123// circleplus.jsexport &#123; area as circleArea &#125; from 'circle'; 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。 加载上面模块的写法如下。 12345// main.jsimport * as math from 'circleplus';import exp from 'circleplus';console.log(exp(math.e)); 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。 ES6模块加载的实质ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。 CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。 123456789// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。 123456// main.jsvar mod = require('./lib');console.log(mod.counter); // 3mod.incCounter();console.log(mod.counter); // 3 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。 1234567891011// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; get counter() &#123; return counter &#125;, incCounter: incCounter,&#125;; 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。 123$ node main.js34 ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 还是举上面的例子。 1234567891011// lib.jsexport let counter = 3;export function incCounter() &#123; counter++;&#125;// main.jsimport &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 上面代码说明，ES6模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。 再举一个出现在export一节中的例子。 12345678// m1.jsexport var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500);// m2.jsimport &#123;foo&#125; from './m1.js';console.log(foo);setTimeout(() =&gt; console.log(foo), 500); 上面代码中，m1.js的变量foo，在刚加载时等于bar，过了500毫秒，又变为等于baz。 让我们看看，m2.js能否正确读取这个变化。 1234$ babel-node m2.jsbarbaz 上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。 由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。 12345678// lib.jsexport let obj = &#123;&#125;;// main.jsimport &#123; obj &#125; from './lib';obj.prop = 123; // OKobj = &#123;&#125;; // TypeError 上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。 最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。 123456789101112// mod.jsfunction C() &#123; this.sum = 0; this.add = function () &#123; this.sum += 1; &#125;; this.show = function () &#123; console.log(this.sum); &#125;;&#125;export let c = new C(); 上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。 1234567891011// x.jsimport &#123;c&#125; from './mod';c.add();// y.jsimport &#123;c&#125; from './mod';c.show();// main.jsimport './x';import './y'; 现在执行main.js，输出的是1。 12$ babel-node main.js1 这就证明了x.js和y.js加载的都是C的同一个实例。","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"ES2015之Class","slug":"ES2015之Class","date":"2016-11-07T09:51:37.000Z","updated":"2018-07-12T06:47:06.410Z","comments":true,"path":"2016/11/07/ES2015之Class/","link":"","permalink":"http://yoursite.com/2016/11/07/ES2015之Class/","excerpt":"Class基本语法概述JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 12345678class Bar &#123; doStuff() &#123; console.log('stuff'); &#125;&#125;var b = new Bar();b.doStuff() // \"stuff\" 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。在类的实例上面调用方法，其实就是调用原型上的方法。 1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 12345678910class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。 1Point.prototype.constructor === Point // true 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 1234567891011121314class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。 123456789101112var Point = function (x, y) &#123; // ...&#125;;Point.prototype.toString = function() &#123; // ...&#125;;Object.keys(Point.prototype)// [\"toString\"]Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 上面代码采用ES5的写法，toString方法就是可枚举的。","text":"Class基本语法概述JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 12345678class Bar &#123; doStuff() &#123; console.log('stuff'); &#125;&#125;var b = new Bar();b.doStuff() // \"stuff\" 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。在类的实例上面调用方法，其实就是调用原型上的方法。 1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 12345678910class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。 1Point.prototype.constructor === Point // true 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 1234567891011121314class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。 123456789101112var Point = function (x, y) &#123; // ...&#125;;Point.prototype.toString = function() &#123; // ...&#125;;Object.keys(Point.prototype)// [\"toString\"]Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 上面代码采用ES5的写法，toString方法就是可枚举的。 constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 1constructor() &#123;&#125; constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without 'new' 类的实例对象生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。 12345// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。 与ES5一样，类的所有实例共享一个原型对象。 12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point，所以__proto__属性是相等的。 这也意味着，可以通过实例的__proto__属性为Class添加方法。 12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return 'Oops' &#125;;p1.printName() // \"Oops\"p2.printName() // \"Oops\"var p3 = new Point(4,2);p3.printName() // \"Oops\" 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。 不存在变量提升Class不存在变量提升（hoist），这一点与ES5完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 12345&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; &#125;&#125; 上面的代码不会报错，因为class继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致class继承Foo的时候，Foo还没有定义。 Class表达式与函数一样，类也可以使用表达式的形式定义。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在Class内部有定义。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 1const MyClass = class &#123; /* ... */ &#125;; 采用Class表达式，可以写出立即执行的Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;('张三');person.sayName(); // \"张三\" 上面代码中，person是一个立即执行的类的实例。 私有方法私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 1234567891011121314151617const bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。 123456789class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; name属性由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 12class Point &#123;&#125;Point.name // \"Point\" name属性总是返回紧跟在class关键字后面的类名。 Class的继承基本用法Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 1class ColorPoint extends Point &#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 12345678class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。 ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 123constructor(...args) &#123; super(...args);&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。 1234let cp = new ColorPoint(25, 8, 'green');cp instanceof ColorPoint // truecp instanceof Point // true 上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。 类的prototype属性和__proto__属性大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。 123Object.create(A.prototype);// 等同于B.prototype.__proto__ = A.prototype; Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。 12Object.getPrototypeOf(ColorPoint) === Point// true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 super关键字super这个关键字，有两种用法，含义不同。 （1）作为函数调用时（即super(...args)），super代表父类的构造函数。 （2）作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super既可以引用父类实例的属性和方法，也可以引用父类的静态方法。 12345678class B extends A &#123; get m() &#123; return this._p * super._p; &#125; set m() &#123; throw new Error('该属性只读'); &#125;&#125; 上面代码中，子类通过super关键字，调用父类实例的_p属性。 由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 1234567var obj = &#123; toString() &#123; return \"MyObject: \" + super.toString(); &#125;&#125;;obj.toString(); // MyObject: [object Object] Class的取值函数（getter）和存值函数（setter）与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。 存值函数和取值函数是设置在属性的descriptor对象上的。 123456789101112131415161718class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, \"html\");\"get\" in descriptor // true\"set\" in descriptor // true 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。 Class的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 父类的静态方法，可以被子类继承。 12345678910class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod(); // 'hello' 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod(); Class的静态属性和实例属性静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。 12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined ES7有一个静态属性的提案，目前Babel转码器支持。 这个提案对实例属性和静态属性，都规定了新的写法。 （1）类的实例属性 类的实例属性可以用等式，写入类的定义之中。 1234567class MyClass &#123; myProp = 42; constructor() &#123; console.log(this.myProp); // 42 &#125;&#125; 上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。 以前，我们定义实例属性，只能写在类的constructor方法里面。 12345678class ReactCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125;&#125; 上面代码中，构造方法constructor里面，定义了this.state属性。 有了新的写法以后，可以不在constructor方法里面定义。 12345class ReactCounter extends React.Component &#123; state = &#123; count: 0 &#125;;&#125; 这种写法比以前更清晰。 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。 123456789class ReactCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; state;&#125; （2）类的静态属性 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。 1234567class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myProp); // 42 &#125;&#125; 同样的，这个新写法大大方便了静态属性的表达。 123456789// 老写法class Foo &#123;&#125;Foo.prop = 1;// 新写法class Foo &#123; static prop = 1;&#125; 上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。 new.target属性new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用new生成实例'); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用new生成实例'); &#125;&#125;var person = new Person('张三'); // 正确var notAPerson = Person.call(person, '张三'); // 报错 上面代码确保构造函数只能通过new命令调用。 Class内部调用new.target，返回当前Class。 123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。 1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // 输出 false 上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error('本类不能实例化'); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"ES2015第七种数据结构Symbols","slug":"ES2015第七种数据结构Symbols","date":"2016-11-02T15:39:29.000Z","updated":"2018-07-12T06:47:06.413Z","comments":true,"path":"2016/11/02/ES2015第七种数据结构Symbols/","link":"","permalink":"http://yoursite.com/2016/11/02/ES2015第七种数据结构Symbols/","excerpt":"","text":"1997年JavaScript首次被标准化，那时只有六种原始类型，在ES6以前，JS程序中使用的每一个值都是以下几种类型之一： Undefined 未定义 Null 空值 Boolean 布尔类型 Number 数字类型 String 字符串类型 Object 对象类型 每种类型都是多个值的集合，前五个集合是有限的。布尔类型只有两个值，true和false，不会再创造第三种布尔值；数字类型和字符串类型的值更多。然而，对象类型值的集合是无限的。每一个对象都像珍贵的雪花一样独一无二，每一次你打开一个Web页面，都会创建一堆对象。 ES6新特性中的symbol也是值，但它不是字符串，也不是对象，而是是全新的——第七种类型的原始值。Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 让我们一起探讨一下symbol的实际应用场景。 从一个简单的布尔类型出发有时候你可以非常轻松地将别人的外部数据存储到一个JavaScript对象中。 举 个例子，假设你正在写一个JS库，可以通过CSS transitions使DOM元素在屏幕上移动。你可能会注意到，当你尝试在一个div元素上同时应用多重CSS transitions时并不会生效。实际效果是丑陋而又不连续的“跳闪”。你认为可以修复这个问题，但前提是你需要一种发现给定元素是否已经移动过的方 法。 应当如何解决这个问题呢？一种方法是，用CSS API来告诉浏览器元素是否正在移动，但这样简直小题大做。在元素移动的第一时间内你的库就应该记录下移动的状态，所以它自然知道元素正在移动。 你真正想要的是一种持续跟踪某个元素正在移动的方法。你可以维护一个数组，记录所有正在移动的元素，每当你的库被调用来移动某个元素时，你可以检索数组来查看元素是否已经存在，亦即它是否正在移动中。 当然，如果数组非常大的话，线性搜索将会非常缓慢。 实际上你只想为元素设置一个标记：1234if (element.isMoving) &#123; smoothAnimations(element);&#125;element.isMoving = true; 这样也会有一些潜在的问题，事实上，你的代码很可能不是唯一一段操作DOM的代码。 你创建的属性很可能影响到其它使用了for-in或Object.keys()的代码。 一些聪明的库作者可能已经考虑并使用了这项技术，这样一来你的库就会与已有的库产生某些冲突 当然，很可能你比他们更聪明，你先采用了这项技术，但是他们的库仍然无法与你的库默契配合。 标准委员会可能决定为所有的元素增加一个.isMoving()方法，到那时你需要重写相关逻辑，必定会有深深的挫败感。当然你可以选择一个乏味而愚蠢的命名（其他人根本不会想用的那些名称）来解决最后的三个问题：1234if (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) &#123; smoothAnimations(element);&#125;element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true; 这只会造成无畏的眼疲劳。为什么这个问题如此困难？我们只想要一个小小的布尔值啊！ symbol是最终的解决方案symbol是程序创建并且可以用作属性键的值，并且它能避免命名冲突的风险。 var mySymbol = Symbol();调用Symbol()创建一个新的symbol，它的值与其它任何值皆不相等。 字符串或数字可以作为属性的键，symbol也可以，它不等同于任何字符串，因而这个以symbol为键的属性可以保证不与任何其它属性产生冲突。12obj[mySymbol] = \"ok!\"; // 保证不会冲突console.log(obj[mySymbol]); // ok! 想要在上述讨论的场景中使用symbol，你可以这样做：1234567// 创建一个独一无二的symbolvar isMoving = Symbol(\"isMoving\");...if (element[isMoving]) &#123; smoothAnimations(element);&#125;element[isMoving] = true; 有关这段代码的一些解释： Symbol(“isMoving”)中的isMoving被称作描述。你可以通过console.log()将它打印出来，对调试非常有帮助；你也可以用.toString()方法将它转换为字符串呈现；它也可以被用在错误信息中。 element[isMoving]被称作一个以symbol为键（symbol-keyed）的属性。简而言之，它的名字是symbol而不是一个字符串。除此之外，它与一个普通的属性没有什么区别。 以symbol为键的属性属性与数组元素类似，不能被类似obj.name的点号法访问，你必须使用方括号访问这些属性。 如果你已经得到了symbol，那么访问一个以symbol为键的属性同样简单，以上的示例很好地展示了如何获取element[isMoving]的值以及如何为它赋值。如果我们需要，可以查看属性是否存在：if (isMoving in element)，也可以删除属性：delete element[isMoving]。 另一方面，只有当isMoving在当前作用域中时才会生效。这是symbol的弱封装机制：模块创建了几个symbol，可以在任意对象上使用，无须担心与其它代码创建的属性产生冲突。 symbol键的设计初衷是避免冲突，因此JavaScript中最常见的对象检查的特性会忽略symbol键。例如，for-in循环只会遍历对象的字符串键，symbol键直接跳过，Object.keys(obj)和Object.getOwnPropertyNames(obj)也是一样。但是symbols也不完全是私有的：用新的APIObject.getOwnPropertySymbols(obj)就可以列出对象的symbol键。另一个新的API，Reflect.ownKeys(obj)，会同时返回字符串键和symbol键。（我们将在随后的文章中讲解Reflect(反射) API）。 慢慢地我们会发现，越来越多的库和框架将大量使用symbol，语言本身也会将symbol应用于广泛的用途。 但是，到底什么是symbol呢？12&gt; typeof Symbol()\"symbol\" 确切地说，symbol与其它类型并不完全相像。 symbol被创建后就不可变更，你不能为它设置属性（在严格模式下尝试设置属性会得到TypeError的错误）。他们可以用作属性名称，这些性质与字符串类似。 另一方面，每一个symbol都独一无二，不与其它symbol等同，即使二者有相同的描述也不相等；你可以轻松地创建一个新的symbol。这些性质与对象类似。 ES6中的symbol与Lisp和Ruby这些语言中更传统的symbol类似，但不像它们集成得那么紧密。在Lisp中，所有的标识符都是symbol；在JS中，标识符和大多数的属性键仍然是字符串，symbol只是一个额外的选项。 关于symbol的忠告：symbol不能被自动转换为字符串，这和语言中的其它类型不同。尝试拼接symbol与字符串将得到TypeError错误。12345&gt; var sym = Symbol(\"&lt;3\");&gt; \"your symbol is \" + sym// TypeError: can't convert symbol to string&gt; `your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 通过String(sym)或sym.toString()可以显示地将symbol转换为一个字符串，从而回避这个问题。 获取symbol的三种方法 有三种获取symbol的方法。 调用Symbol()。正如我们上文中所讨论的，这种方式每次调用都会返回一个新的唯一symbol。 调用Symbol.for(string)。这种方式会访问symbol注册表，其中存储了已经存在的一系列symbol。这种方式与通过Symbol()定义的独立symbol不同，symbol注册表中的symbol是共享的。如果你连续三十次调用Symbol.for(“cat”)，每次都会返回相同的symbol。注册表非常有用，在多个web页面或同一个web页面的多个模块中经常需要共享一个symbol。 使用标准定义的symbol，例如：Symbol.iterator。标准根据一些特殊用途定义了少许的几个symbol。","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"ES2015新的数据结构Set和Map","slug":"ES2015新的数据结构Set和Map","date":"2016-11-02T08:38:05.000Z","updated":"2018-07-12T06:47:06.411Z","comments":true,"path":"2016/11/02/ES2015新的数据结构Set和Map/","link":"","permalink":"http://yoursite.com/2016/11/02/ES2015新的数据结构Set和Map/","excerpt":"Set基本用法ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构。 12345678var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向Set结构加入成员，结果表明Set结构不会添加重复的值。 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 1234567891011121314151617181920// 例一var set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;var set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。 上面代码中，也展示了一种去除数组重复成员的方法。 12// 去除数组的重复成员[...new Set(array)] 向Set加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125; 上面代码向Set实例添加了两个NaN，但是只能加入一个。这表明，在Set内部，两个NaN是相等。 另外，两个对象总是不相等的。 1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 Set实例的属性和方法Set结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。","text":"Set基本用法ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构。 12345678var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向Set结构加入成员，结果表明Set结构不会添加重复的值。 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 1234567891011121314151617181920// 例一var set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;var set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。 上面代码中，也展示了一种去除数组重复成员的方法。 12// 去除数组的重复成员[...new Set(array)] 向Set加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125; 上面代码向Set实例添加了两个NaN，但是只能加入一个。这表明，在Set内部，两个NaN是相等。 另外，两个对象总是不相等的。 1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 Set实例的属性和方法Set结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 上面这些属性和方法的实例如下。 1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false 下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。 12345678910111213141516171819// 对象的写法var properties = &#123; 'width': 1, 'height': 1&#125;;if (properties[someName]) &#123; // do something&#125;// Set的写法var properties = new Set();properties.add('width');properties.add('height');if (properties.has(someName)) &#123; // do something&#125; Array.from方法可以将Set结构转为数组。 12var items = new Set([1, 2, 3, 4, 5]);var array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。 12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作Set结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。 （1）keys()，values()，entries() key方法、value方法、entries方法返回的都是遍历器对象（详见《Iterator对象》一章）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。 12Set.prototype[Symbol.iterator] === Set.prototype.values// true 这意味着，可以省略values方法，直接用for...of循环遍历Set。 12345678let set = new Set(['red', 'green', 'blue']);for (let x of set) &#123; console.log(x);&#125;// red// green// blue （2）forEach() Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。 12345let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6 上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，forEach方法还可以有第二个参数，表示绑定的this对象。 （3）遍历的应用 扩展运算符（...）内部使用for...of循环，所以也可以用于Set结构。 123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 扩展运算符和Set结构相结合，就可以去除数组的重复成员。 123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 而且，数组的map和filter方法也可以用于Set了。 1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; 因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用Array.from方法。 123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。 WeakSetWeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。 首先，WeakSet的成员只能是对象，而不能是其他类型的值。 其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 12345var ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set 上面代码试图向WeakSet添加一个数值和Symbol值，结果报错，因为WeakSet只能放置对象。 WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。 1var ws = new WeakSet(); 作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。 12var a = [[1,2], [3,4]];var ws = new WeakSet(a); 上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。 注意，是a数组的成员成为WeakSet的成员，而不是a数组本身。这意味着，数组的成员只能是对象。 123var b = [3, 4];var ws = new WeakSet(b);// Uncaught TypeError: Invalid value used in weak set(…) 上面代码中，数组b的成员不是对象，加入WeaKSet就会报错。 WeakSet结构有以下三个方法。 WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。 WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。 下面是一个例子。 123456789101112var ws = new WeakSet();var obj = &#123;&#125;;var foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false WeakSet没有size属性，没有办法遍历它的成员。 12345ws.size // undefinedws.forEach // undefinedws.forEach(function(item)&#123; console.log('WeakSet has ' + item)&#125;)// TypeError: undefined is not a function 上面代码试图获取size和forEach属性，结果都不能成功。 WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 下面是WeakSet的另一个例子。 1234567891011const foos = new WeakSet()class Foo &#123; constructor() &#123; foos.add(this) &#125; method () &#123; if (!foos.has(this)) &#123; throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！'); &#125; &#125;&#125; 上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。 MapMap结构的目的和基本用法JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 12345var data = &#123;&#125;;var element = document.getElementById('myDiv');data[element] = 'metadata';data['[object HTMLDivElement]'] // \"metadata\" 上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。 为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。 123456789var m = new Map();var o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false 上面代码使用set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。 作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910var map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\" 上面代码在新建Map实例时，就指定了两个键name和title。 Map构造函数接受数组作为参数，实际上执行的是下面的算法。 123456var items = [ ['name', '张三'], ['title', 'Author']];var map = new Map();items.forEach(([key, value]) =&gt; map.set(key, value)); 下面的例子中，字符串true和布尔值true是两个不同的键。 1234567var m = new Map([ [true, 'foo'], ['true', 'bar']]);m.get(true) // 'foo'm.get('true') // 'bar' 如果对同一个键多次赋值，后面的值将覆盖前面的值。 1234567let map = new Map();map.set(1, 'aaa').set(1, 'bbb');map.get(1) // \"bbb\" 上面代码对键1连续赋值两次，后一次的值覆盖前一次的值。 如果读取一个未知的键，则返回undefined。 12new Map().get('asfddfsasadf')// undefined 注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。 1234var map = new Map();map.set(['a'], 555);map.get(['a']) // undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。 同理，同样的值的两个实例，在Map结构中被视为两个键。 1234567891011var map = new Map();var k1 = ['a'];var k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222 上面代码中，变量k1和k2的值是一样的，但是它们在Map结构中被视为两个键。 由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。 1234567let map = new Map();map.set(NaN, 123);map.get(NaN) // 123map.set(-0, 123);map.get(+0) // 123 实例的属性和操作方法Map结构的实例有以下属性和操作方法。 （1）size属性 size属性返回Map结构的成员总数。 12345let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 （2）set(key, value) set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。 12345var m = new Map();m.set(\"edition\", 6) // 键是字符串m.set(262, \"standard\") // 键是数值m.set(undefined, \"nah\") // 键是undefined set方法返回的是Map本身，因此可以采用链式写法。 1234let map = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c'); （3）get(key) get方法读取key对应的键值，如果找不到key，返回undefined。 123456var m = new Map();var hello = function() &#123;console.log(\"hello\");&#125;m.set(hello, \"Hello ES6!\") // 键是函数m.get(hello) // Hello ES6! （4）has(key) has方法返回一个布尔值，表示某个键是否在Map数据结构中。 12345678910var m = new Map();m.set(\"edition\", 6);m.set(262, \"standard\");m.set(undefined, \"nah\");m.has(\"edition\") // truem.has(\"years\") // falsem.has(262) // truem.has(undefined) // true （5）delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。 123456var m = new Map();m.set(undefined, \"nah\");m.has(undefined) // truem.delete(undefined)m.has(undefined) // false （6）clear() clear方法清除所有成员，没有返回值。 1234567let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0 遍历方法Map原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Map的所有成员。 需要特别注意的是，Map的遍历顺序就是插入顺序。 下面是使用实例。 1234567891011121314151617181920212223242526272829303132let map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// \"F\"// \"T\"for (let value of map.values()) &#123; console.log(value);&#125;// \"no\"// \"yes\"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125; 上面代码最后的那个例子，表示Map结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。 12map[Symbol.iterator] === map.entries// true Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（...）。 1234567891011121314151617let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。 1234567891011121314let map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');let map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;let map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; 此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。 123map.forEach(function(value, key, map) &#123; console.log(\"Key: %s, Value: %s\", key, value);&#125;); forEach方法还可以接受第二个参数，用来绑定this。 123456789var reporter = &#123; report: function(key, value) &#123; console.log(\"Key: %s, Value: %s\", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 上面代码中，forEach方法的回调函数的this，就指向reporter。 与其他数据结构的互相转换（1）Map转为数组 前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。 123let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] （2）数组转为Map 将数组转入Map构造函数，就可以转为Map。 12new Map([[true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; （3）Map转为对象 如果所有Map的键都是字符串，它可以转为对象。 1234567891011function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; （4）对象转为Map 12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// [ [ 'yes', true ], [ 'no', false ] ] WeakMapWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。 12345var map = new WeakMap()map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map key 上面代码中，如果将1和Symbol作为WeakMap的键名，都会报错。 WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 下面是WeakMap结构的一个例子，可以看到用法上与Map几乎一样。 123456789var wm = new WeakMap();var element = document.querySelector(\".element\");wm.set(element, \"Original\");wm.get(element) // \"Original\"element.parentNode.removeChild(element);element = null;wm.get(element) // undefined 上面代码中，变量wm是一个WeakMap实例，我们将一个DOM节点element作为键名，然后销毁这个节点，element对应的键就自动消失了，再引用这个键名就返回undefined。 WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 1234567var wm = new WeakMap();wm.size// undefinedwm.forEach// undefined 前文说过，WeakMap应用的典型场合就是DOM节点作为键名。下面是一个例子。 12345678910let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++; myWeakmap.set(myElement, logoData);&#125;, false); 上面代码中，myElement是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是myElement。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。 WeakMap的另一个用处是部署私有属性。 123456789101112131415161718192021222324let _counter = new WeakMap();let _action = new WeakMap();class Countdown &#123; constructor(counter, action) &#123; _counter.set(this, counter); _action.set(this, action); &#125; dec() &#123; let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) &#123; _action.get(this)(); &#125; &#125;&#125;let c = new Countdown(2, () =&gt; console.log('DONE'));c.dec()c.dec()// DONE 上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"ES2015的尾调用优化","slug":"ES2015的尾调用优化","date":"2016-11-01T08:56:50.000Z","updated":"2018-07-12T06:47:06.412Z","comments":true,"path":"2016/11/01/ES2015的尾调用优化/","link":"","permalink":"http://yoursite.com/2016/11/01/ES2015的尾调用优化/","excerpt":"尾调用优化什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 123456789101112131415// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; 上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。 1234function f(x)&#123; g(x); return undefined;&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。","text":"尾调用优化什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 123456789101112131415// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; 上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。 1234function f(x)&#123; g(x); return undefined;&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性 如果是非尾递归的fibonacci 递归方法 12345678910function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10); // 89// Fibonacci(100)// Fibonacci(500)// 堆栈溢出了 如果我们使用尾递归优化过的fibonacci 递归算法 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。 递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 12345678910function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5) // 120 上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。 第二种方法就简单多了，就是采用ES6的函数默认值。 123456function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120 上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。 严格模式ES6的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 123456function restricted() &#123; \"use strict\"; restricted.caller; // 报错 restricted.arguments; // 报错&#125;restricted(); 尾递归优化的实现尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 12345678910function sum(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;sum(1, 100000)// Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归100000次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。 123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 1234567function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125; 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。 12trampoline(sum(1, 100000))// 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。 1234567891011121314151617181920212223242526272829function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000)// 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"ES2015中的箭头函数","slug":"ES2015中的箭头函数","date":"2016-11-01T08:23:40.000Z","updated":"2018-07-12T06:47:06.409Z","comments":true,"path":"2016/11/01/ES2015中的箭头函数/","link":"","permalink":"http://yoursite.com/2016/11/01/ES2015中的箭头函数/","excerpt":"箭头函数基本用法ES6允许使用“箭头”（=&gt;）定义函数。 1var f = v =&gt; v; 上面的箭头函数等同于： 123var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 1var getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n; 上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 另一个例子是 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是rest参数与箭头函数结合的例子。 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]]","text":"箭头函数基本用法ES6允许使用“箭头”（=&gt;）定义函数。 1var f = v =&gt; v; 上面的箭头函数等同于： 123var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 1var getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n; 上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 另一个例子是 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是rest参数与箭头函数结合的例子。 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。 123456789101112var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成ES5的代码如下。 123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。在ES6中，不需要再hackthis了，但你需要遵循以下规则： 通过object.method()语法调用的方法使用非箭头函数定义，这些函数需要从调用者的作用域中获取一个有意义的this值。 其它情况全都使用箭头函数。 12345678// ES6&#123; ... addAll: function addAll(pieces) &#123; _.each(pieces, piece =&gt; this.add(piece)); &#125;, ... &#125; 在ES6的版本中，注意addAll方法从它的调用者处获取了this值，内部函数是一个箭头函数，所以它继承了外围作用域的this值。 超赞的是，在ES6中你可以用更简洁的方式编写对象字面量中的方法，所以上面这段代码可以简化成：12345678// ES6的方法语法&#123; ... addAll(pieces) &#123; _.each(pieces, piece =&gt; this.add(piece)); &#125;, ...&#125; 在方法和箭头函数之间，我再也不会错写functoin了，这真是一个绝妙的设计思想！ 请问下面的代码之中有几个this？ 123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: 'inner' &#125;)() ];&#125;).call(&#123; x: 'outer' &#125;);// ['outer'] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 嵌套的箭头函数下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。 123456789const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;const addThenMult = pipeline(plus1, mult2);addThenMult(5)// 12 如果觉得上面的写法可读性比较差，也可以采用下面的写法。 12345const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;mult2(plus1(5))// 12","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"ES2015函数默认值,rest参数及扩展运算符","slug":"ES2015函数默认值,rest参数及扩展运算符","date":"2016-11-01T08:22:10.000Z","updated":"2018-07-12T06:47:06.411Z","comments":true,"path":"2016/11/01/ES2015函数默认值,rest参数及扩展运算符/","link":"","permalink":"http://yoursite.com/2016/11/01/ES2015函数默认值,rest参数及扩展运算符/","excerpt":"函数参数的默认值基本用法在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 123if (typeof y === 'undefined') &#123; y = 'World';&#125; ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;var p = new Point();p // &#123; x: 0, y: 0 &#125; 除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。","text":"函数参数的默认值基本用法在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 123if (typeof y === 'undefined') &#123; y = 'World';&#125; ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;var p = new Point();p // &#123; x: 0, y: 0 &#125; 除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。 与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5foo(&#123;x: 1&#125;) // 1, 5foo(&#123;x: 1, y: 2&#125;) // 1, 2foo() // TypeError: Cannot read property 'x' of undefined 上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。如果参数对象没有y属性，y的默认值5才会生效。 下面是另一个对象的解构赋值默认值的例子。 123456789function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125;) &#123; console.log(method);&#125;fetch('http://example.com', &#123;&#125;)// \"GET\"fetch('http://example.com')// 报错 上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。 上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。 123456function fetch(url, &#123; method = 'GET' &#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch('http://example.com')// \"GET\" 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。 再请问下面两种写法有什么差别？ 123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x和y都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x有值，y无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x和y都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 参数默认值的位置 尽量放在参数最后通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 123456function foo(x = 5, y = 6) &#123; console.log(x, y);&#125;foo(undefined, null)// 5 null 上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。 函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了3个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性。 1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 作用域一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。 1234567var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 2 上面代码中，参数y的默认值等于x。调用时，由于函数作用域内部的变量x已经生成，所以y等于参数x，而不是全局变量x。 如果调用时，函数作用域内部的变量x没有生成，结果就会不一样。 12345678let x = 1;function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // 1 上面代码中，函数调用时，y的默认值变量x尚未在函数内部生成，所以x指向全局变量。 如果此时，全局变量x不存在，就会报错。 123456function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // ReferenceError: x is not defined 下面这样写，也会报错。 1234567var x = 1;function foo(x = x) &#123; // ...&#125;foo() // ReferenceError: x is not defined 上面代码中，函数foo的参数x的默认值也是x。这时，默认值x的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量x，但是默认值在x赋值之前先执行了，所以这时属于暂时性死区（参见《let和const命令》一章），任何对x的操作都会报错。 如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。 12345678let foo = 'outer';function bar(func = x =&gt; foo) &#123; let foo = 'inner'; console.log(func()); // outer&#125;bar(); 上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。这个匿名函数声明时，bar函数的作用域还没有形成，所以匿名函数里面的foo指向外层作用域的foo，输出outer。 如果写成下面这样，就会报错。 123456function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar() // ReferenceError: foo is not defined 上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明foo，所以就报错了。 rest参数ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数。 下面是一个rest参数代替arguments变量的例子。 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 上面代码的两种写法，比较后可以发现，rest参数的写法更自然也更简洁。 rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push方法的例子。 123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 函数的length属性，不包括rest参数。 123(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 扩展运算符含义扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用。 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers) // 42 上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。 扩展运算符与正常的函数参数可以结合使用，非常灵活。 123function f(v, w, x, y, z) &#123; &#125;var args = [0, 1];f(-1, ...args, 2, ...[3]); 替代数组的apply方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 12345678910111213// ES5的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f(...args); 下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。 12345678// ES5的写法Math.max.apply(null, [14, 3, 77])// ES6的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。 123456789// ES5的写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6的写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2); 上面代码的ES5写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 下面是另外一个例子。 1234// ES5new (Date.bind.apply(Date, [null, 2015, 1, 1]))// ES6new Date(...[2015, 1, 1]); 扩展运算符的应用（1）合并数组 扩展运算符提供了数组合并的新写法。 12345678910111213141516// ES5[1, 2].concat(more)// ES6[1, 2, ...more]var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] （2）与解构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 下面是另外一些例子。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []:const [first, ...rest] = [\"foo\"];first // \"foo\"rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 （3）函数的返回值 JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。 12var dateFields = readDateFields(database);var d = new Date(...dateFields); 上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。 （4）字符串 扩展运算符还可以将字符串转为真正的数组。 12[...'hello']// [ \"h\", \"e\", \"l\", \"l\", \"o\" ] （5）实现了Iterator接口的对象 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。 12var nodeList = document.querySelectorAll('div');var array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator接口。 对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 123456789let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map和Set结构，Generator函数 扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。 1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] 如果对没有iterator接口的对象，使用扩展运算符，将会报错。 12var obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object 严格模式从ES5开始，函数内部可以设定为严格模式。 1234function doSomething(a, b) &#123; 'use strict'; // code&#125; 《ECMAScript 2016标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; 'use strict'; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; 'use strict'; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; 'use strict'; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; 'use strict'; // code &#125;&#125;; 这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。 12345// 报错function doSomething(value = 070) &#123; 'use strict'; return value;&#125; 上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。 虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 12345'use strict';function doSomething(a, b = a) &#123; // code&#125; 第二种是把函数包在一个无参数的立即执行函数里面。 123456const doSomething = (function () &#123; 'use strict'; return function(value = 42) &#123; return value; &#125;;&#125;());","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"Es2015中的数组扩展","slug":"ES2015中的数组扩展","date":"2016-11-01T06:57:43.000Z","updated":"2018-07-12T06:47:06.409Z","comments":true,"path":"2016/11/01/ES2015中的数组扩展/","link":"","permalink":"http://yoursite.com/2016/11/01/ES2015中的数组扩展/","excerpt":"Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用forEach方法。 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。 12345Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 上面代码中，字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。深复制。 12Array.from([1, 2, 3])// [1, 2, 3] 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。 1234567// arguments对象function foo() &#123; var args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 下面的例子是取出一组DOM节点的文本内容。 1234567let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) 下面的例子将数组中布尔值为false的成员转为0。 12Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] 另一个例子是返回各种数据的类型。 12345function typesOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;typesOf(null, [], NaN)// ['object', 'object', 'number'] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。 12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\\uFFFF的Unicode字符，算作两个字符的bug。 123function countSymbols(string) &#123; return Array.from(string).length;&#125;","text":"Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用forEach方法。 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。 12345Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 上面代码中，字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。深复制。 12Array.from([1, 2, 3])// [1, 2, 3] 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。 1234567// arguments对象function foo() &#123; var args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 下面的例子是取出一组DOM节点的文本内容。 1234567let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) 下面的例子将数组中布尔值为false的成员转为0。 12Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] 另一个例子是返回各种数据的类型。 12345function typesOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;typesOf(null, [], NaN)// ['object', 'object', 'number'] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。 12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\\uFFFF的Unicode字符，算作两个字符的bug。 123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。 123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 上面代码找出数组中第一个小于0的成员。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。 12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 数组实例的fill()fill方法使用给定值，填充一个数组。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 上面代码表示，fill方法从1号位开始，向原数组填充7，到2号位之前结束。 数组实例的entries()，keys()和values()ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。 12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] Array.values()目前chrome/ff等浏览器均未支持！循环时直接使用for(let i of arr)就可以了 数组实例的includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。 123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。 12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。 12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains([\"foo\", \"bar\"], \"baz\"); // =&gt; false 另外，Map和Set数据结构有一个has方法，需要注意与includes区分。 Map结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 数组实例的copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。 下面是更多例子。 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 上面代码中，Array(3)返回一个具有3个空位的数组。 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false 上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。 ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 1234567891011121314151617181920// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // \"#a##\"// toString方法[,'a',undefined,null].toString() // \",a,,\" ES6则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 12Array.from(['a',,'b'])// [ \"a\", undefined, \"b\" ] 扩展运算符（...）也会将空位转为undefined。 12[...['a',,'b']]// [ \"a\", undefined, \"b\" ] copyWithin()会连空位一起拷贝。 1[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"] fill()会将空位视为正常的数组位置。 1new Array(3).fill('a') // [\"a\",\"a\",\"a\"] for...of循环也会遍历空位。 123456let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,\"a\"]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"使用MockJs进行独立于后端的前端开发","slug":"使用MockJs进行独立于后端的前端开发","date":"2016-11-01T03:17:36.000Z","updated":"2018-07-12T06:47:06.422Z","comments":true,"path":"2016/11/01/使用MockJs进行独立于后端的前端开发/","link":"","permalink":"http://yoursite.com/2016/11/01/使用MockJs进行独立于后端的前端开发/","excerpt":"Mock.js实现的功能 基于 数据模板 生成数据 基于 HTML模板 生成数据 拦截并模拟 Ajax请求用法 浏览器：123456789101112&lt;!-- （必选）加载 Mock --&gt;&lt;script src=\"http://mockjs.com/dist/mock.js\"&gt;&lt;/script&gt;&lt;script&gt;// 使用 Mockvar data = Mock.mock(&#123; 'list|1-10': [&#123; 'id|+1': 1 &#125;]&#125;);$('&lt;pre&gt;').text(JSON.stringify(data, null, 4)).appendTo('body')&lt;/script&gt; 返回值:12345678910111213&#123;\"list\": [ &#123; \"id\": 1 &#125;, &#123; \"id\": 2 &#125;, &#123; \"id\": 3 &#125; ]&#125; JQuery：配置模拟数据：12345Mock.mock('http://g.cn', &#123; 'name' : '@name', 'age|1-100': 100, 'color' : '@color'&#125;); 发送Ajax请求：12345678$.ajax(&#123; url: 'http://g.cn', dataType:'json' &#125;).done(function(data, status, xhr)&#123; console.log( JSON.stringify(data, null, 4) ) &#125;)； 返回数据：12345678910111213// 结果1&#123;\"name\": \"Elizabeth Hall\",\"age\": 91,\"color\": \"#0e64ea\"&#125;// 结果2&#123;\"name\": \"Michael Taylor\",\"age\": 61,\"color\": \"#081086\"&#125; Node.js：123456789101112// 安装npm install mockjs// 使用var Mock = require('mockjs');var data = Mock.mock(&#123; 'list|1-10': [&#123; 'id|+1': 1 &#125;]&#125;);console.log(JSON.stringify(data, null, 4)) mock数据mockData.js:12345Mock.mock('http://www.baidu.com', &#123; 'name': '@name()', 'age|1-100': 100, 'color': '@color'&#125;);","text":"Mock.js实现的功能 基于 数据模板 生成数据 基于 HTML模板 生成数据 拦截并模拟 Ajax请求用法 浏览器：123456789101112&lt;!-- （必选）加载 Mock --&gt;&lt;script src=\"http://mockjs.com/dist/mock.js\"&gt;&lt;/script&gt;&lt;script&gt;// 使用 Mockvar data = Mock.mock(&#123; 'list|1-10': [&#123; 'id|+1': 1 &#125;]&#125;);$('&lt;pre&gt;').text(JSON.stringify(data, null, 4)).appendTo('body')&lt;/script&gt; 返回值:12345678910111213&#123;\"list\": [ &#123; \"id\": 1 &#125;, &#123; \"id\": 2 &#125;, &#123; \"id\": 3 &#125; ]&#125; JQuery：配置模拟数据：12345Mock.mock('http://g.cn', &#123; 'name' : '@name', 'age|1-100': 100, 'color' : '@color'&#125;); 发送Ajax请求：12345678$.ajax(&#123; url: 'http://g.cn', dataType:'json' &#125;).done(function(data, status, xhr)&#123; console.log( JSON.stringify(data, null, 4) ) &#125;)； 返回数据：12345678910111213// 结果1&#123;\"name\": \"Elizabeth Hall\",\"age\": 91,\"color\": \"#0e64ea\"&#125;// 结果2&#123;\"name\": \"Michael Taylor\",\"age\": 61,\"color\": \"#081086\"&#125; Node.js：123456789101112// 安装npm install mockjs// 使用var Mock = require('mockjs');var data = Mock.mock(&#123; 'list|1-10': [&#123; 'id|+1': 1 &#125;]&#125;);console.log(JSON.stringify(data, null, 4)) mock数据mockData.js:12345Mock.mock('http://www.baidu.com', &#123; 'name': '@name()', 'age|1-100': 100, 'color': '@color'&#125;); 语法Mock.js 的语法规范包括两部分： 数据模板定义（Data Temaplte Definition，DTD） 数据占位符定义（Data Placeholder Definition，DPD） 数据模板定义 DTD数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：1234// 属性名 name// 生成规则 rule// 属性值 value'name|rule': value 注意： 属性名 和 生成规则 之间用 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： &#39;name|min-max&#39;: value &#39;name|count&#39;: value &#39;name|min-max.dmin-dmax&#39;: value &#39;name|min-max.dcount&#39;: value &#39;name|count.dmin-dmax&#39;: value &#39;name|count.dcount&#39;: value &#39;name|+step&#39;: value 生成规则含需要依赖属性值 才能确定。 属性值 中可以含有 @占位符。 属性值 还指定了最终值的初始值和类型。 生成规则和示例： 属性值是字符串 String ‘name|min-max’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数大于等于 min，小于等于 max。 ‘name|count’: ‘value’ 通过重复 ‘value’ 生成一个字符串，重复次数等于 count。 属性值是数字 Number ‘name|+1’: 100 属性值自动加 1，初始值为 100 ‘name|1-100’: 100 生成一个大于等于 1、小于等于 100 的整数，属性值 100 只用来确定类型。 ‘name|1-100.1-10’: 100 生成一个浮点数，整数部分大于等于 1、小于等于 100，小数部分保留 1 到 10 位。12345678910111213&#123;'number1|1-100.1-10': 1,'number2|123.1-10': 1,'number3|123.3': 1,'number4|123.10': 1.123&#125;// =&gt;&#123;\"number1\": 12.92,\"number2\": 123.51,\"number3\": 123.777,\"number4\": 123.1231091814&#125; 属性值是布尔型 Boolean ‘name|1’: value 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2。 ‘name|min-max’: value 随机生成一个布尔值，值为 value 的概率是 min / (min + max)，值为 !value 的概率是 max / (min + max)。 属性值是对象 Object ‘name|min-max’: {} 从属性值 {} 中随机选取 min 到 max 个属性。 ‘name|count’: {} 从属性值 {} 中随机选取 count 个属性。 属性值是数组 Array ‘name|1’: [{}, {} …] 从属性值 [{}, {} …] 中随机选取 1 个元素，作为最终值。 ‘name|min-max’: [{}, {} …] 通过重复属性值 [{}, {} …] 生成一个新数组，重复次数大于等于 min，小于等于 max。 ‘name|count’: [{}, {} …] 通过重复属性值 [{}, {} …] 生成一个新数组，重复次数为 count。 属性值是数组 Function ‘name’: function(){} 执行函数 function(){}，取其返回值作为最终的属性值，上下文为 ‘name’ 所在的对象。 数据占位符定义 DPD占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。占位符 的格式为：12@占位符@占位符(参数 [, 参数]) 注意： 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板中的属性。 占位符 会优先引用 数据模板中的属性1234567891011121314151617&#123; name: &#123; first: '@FIRST', middle: '@FIRST', last: '@LAST', full: '@first @middle @last' &#125;&#125;// =&gt;&#123; \"name\": &#123; \"first\": \"Charles\", \"middle\": \"Brenda\", \"last\": \"Lopez\", \"full\": \"Charles Brenda Lopez\" &#125;&#125; 常用方法Mock.mock( rurl?, rtype?, template|function(options) )根据数据模板生成模拟数据。 参数的含义和默认值如下所示： 参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\\/domain\\/list.json/、’/domian/list.json’。 参数 rtype：可选。表示需要拦截的 Ajax 请求类型。例如 GET、POST、PUT、DELETE 等。 参数 template：可选。表示数据模板，可以是对象或字符串。例如 { ‘data|1-10’:[{}] }、’@EMAIL’。 参数 function(options)：可选。表示用于生成响应数据的函数。 参数 options：指向本次请求的 Ajax 选项集。 Mock.mockjax(library)覆盖（拦截） Ajax 请求，目前内置支持 jQuery、Zepto、KISSY。 Mock.RandomMock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 。 Mock.tpl(input, options, helpers, partials)基于 Handlebars、Mustache 的 HTML 模板生成模拟数据。 方法使用详情请参考mock.js文档","categories":[],"tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"}],"keywords":[]},{"title":"Es2015的数值扩展","slug":"ES2015的数值扩展","date":"2016-10-31T15:10:03.000Z","updated":"2018-07-12T06:47:06.412Z","comments":true,"path":"2016/10/31/ES2015的数值扩展/","link":"","permalink":"http://yoursite.com/2016/10/31/ES2015的数值扩展/","excerpt":"数值的扩展Number.isFinite(), Number.isNaN()ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite）。 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false ES5可以通过下面的代码，部署Number.isFinite方法。 123456789101112(function (global) &#123; var global_isFinite = global.isFinite; Object.defineProperty(Number, 'isFinite', &#123; value: function isFinite(value) &#123; return typeof value === 'number' &amp;&amp; global_isFinite(value); &#125;, configurable: true, enumerable: false, writable: true &#125;);&#125;)(this); Number.isNaN()用来检查一个值是否为NaN。 1234567Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true'/0) // trueNumber.isNaN('true'/'true') // true ES5通过下面的代码，部署Number.isNaN()。 123456789101112(function (global) &#123; var global_isNaN = global.isNaN; Object.defineProperty(Number, 'isNaN', &#123; value: function isNaN(value) &#123; return typeof value === 'number' &amp;&amp; global_isNaN(value); &#125;, configurable: true, enumerable: false, writable: true &#125;);&#125;)(this); 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。 123456789isFinite(25) // trueisFinite(\"25\") // trueNumber.isFinite(25) // trueNumber.isFinite(\"25\") // falseisNaN(NaN) // trueisNaN(\"NaN\") // trueNumber.isNaN(NaN) // trueNumber.isNaN(\"NaN\") // false Number.parseInt(), Number.parseFloat()ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true","text":"数值的扩展Number.isFinite(), Number.isNaN()ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite）。 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false ES5可以通过下面的代码，部署Number.isFinite方法。 123456789101112(function (global) &#123; var global_isFinite = global.isFinite; Object.defineProperty(Number, 'isFinite', &#123; value: function isFinite(value) &#123; return typeof value === 'number' &amp;&amp; global_isFinite(value); &#125;, configurable: true, enumerable: false, writable: true &#125;);&#125;)(this); Number.isNaN()用来检查一个值是否为NaN。 1234567Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true'/0) // trueNumber.isNaN('true'/'true') // true ES5通过下面的代码，部署Number.isNaN()。 123456789101112(function (global) &#123; var global_isNaN = global.isNaN; Object.defineProperty(Number, 'isNaN', &#123; value: function isNaN(value) &#123; return typeof value === 'number' &amp;&amp; global_isNaN(value); &#125;, configurable: true, enumerable: false, writable: true &#125;);&#125;)(this); 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。 123456789isFinite(25) // trueisFinite(\"25\") // trueNumber.isFinite(25) // trueNumber.isFinite(\"25\") // falseisNaN(NaN) // trueisNaN(\"NaN\") // trueNumber.isNaN(NaN) // trueNumber.isNaN(\"NaN\") // false Number.parseInt(), Number.parseFloat()ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true Number.isInteger()Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。 12345Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger(\"15\") // falseNumber.isInteger(true) // false Number.EPSILONES6在Number对象上面，新增一个极小的常量Number.EPSILON。 1234Number.EPSILON// 2.220446049250313e-16Number.EPSILON.toFixed(20)// '0.00000000000000022204' 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20)// '0.00000000000000005551' 但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。 125.551115123125783e-17 &lt; Number.EPSILON// true 因此，Number.EPSILON的实质是一个可以接受的误差范围。 1234567function withinErrorMargin (left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON;&#125;withinErrorMargin(0.1 + 0.2, 0.3)// truewithinErrorMargin(0.2 + 0.2, 0.3)// false 上面的代码为浮点数运算，部署了一个误差检查函数。 安全整数和Number.isSafeInteger()JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 1234567Math.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1// true 上面代码中，超出2的53次方之后，一个数就不精确了。 ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true 上面代码中，可以看到JavaScript能够精确表示的极限。 Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 123456789101112131415Number.isSafeInteger('a') // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false 这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。 123456Number.isSafeInteger = function (n) &#123; return (typeof n === 'number' &amp;&amp; Math.round(n) === n &amp;&amp; Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp; n &lt;= Number.MAX_SAFE_INTEGER);&#125; 实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。如果只验证运算结果是否为安全整数，很可能得到错误结果。 指数运算符ES7新增了一个指数运算符（**），目前Babel转码器已经支持。 122 ** 2 // 42 ** 3 // 8 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 1234567let a = 2;a **= 2;// 等同于 a = a * a;let b = 3;b **= 3;// 等同于 b = b * b * b; Math对象的扩展ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。 Math.trunc()Math.trunc方法用于去除一个数的小数部分，返回整数部分。 12345Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。 12Math.trunc('123.456')// 123 对于空值和无法截取整数的值，返回NaN。 123Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.trunc = Math.trunc || function(x) &#123; return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;; Math.sign()Math.sign方法用来判断一个数到底是正数、负数、还是零。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 1234567Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaNMath.sign('foo'); // NaNMath.sign(); // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 1234567Math.sign = Math.sign || function(x) &#123; x = +x; // convert to a number if (x === 0 || isNaN(x)) &#123; return x; &#125; return x &gt; 0 ? 1 : -1;&#125;; Math.cbrt()Math.cbrt方法用于计算一个数的立方根。 1234Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。 12Math.cbrt('8') // 2Math.cbrt('hello') // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 1234Math.cbrt = Math.cbrt || function(x) &#123; var y = Math.pow(Math.abs(x), 1/3); return x &lt; 0 ? -y : y;&#125;; Math.hypot()Math.hypot方法返回所有参数的平方和的平方根。 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(3, 4, '5'); // 7.0710678118654755Math.hypot(-3); // 3 上面代码中，3的平方加上4的平方，等于5的平方。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。 三角函数方法ES6新增了6个三角函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"Es2015字符串扩展","slug":"ES2015字符串扩展","date":"2016-10-31T07:00:05.000Z","updated":"2018-07-12T06:47:06.411Z","comments":true,"path":"2016/10/31/ES2015字符串扩展/","link":"","permalink":"http://yoursite.com/2016/10/31/ES2015字符串扩展/","excerpt":"includes(), startsWith(), endsWith()传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 12345var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345var s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\" 参数如果是小数，会被取整。 1'na'.repeat(2.9) // \"nana\" 如果repeat的参数是负数或者Infinity，会报错。 1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。 1'na'.repeat(-0.9) // \"\" 参数NaN等同于0。 1'na'.repeat(NaN) // \"\" 如果repeat的参数是字符串，则会先转换成数字。 12'na'.repeat('na') // \"\"'na'.repeat('3') // \"nanana\"","text":"includes(), startsWith(), endsWith()传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 12345var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345var s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\" 参数如果是小数，会被取整。 1'na'.repeat(2.9) // \"nana\" 如果repeat的参数是负数或者Infinity，会报错。 1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。 1'na'.repeat(-0.9) // \"\" 参数NaN等同于0。 1'na'.repeat(NaN) // \"\" 如果repeat的参数是字符串，则会先转换成数字。 12'na'.repeat('na') // \"\"'na'.repeat('3') // \"nanana\" 模板字符串传统的JavaScript语言，输出模板通常是这样写的。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量var name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1var greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。 123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 123456789101112var x = 1;var y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// \"1 + 2 = 3\"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// \"1 + 4 = 5\"var obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// 3 模板字符串之中还能调用函数。 123456function fn() &#123; return \"Hello World\";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 123// 变量place没有声明var msg = `Hello, $&#123;place&#125;`;// 报错 由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。 12`Hello $&#123;'World'&#125;`// \"Hello World\" 模板字符串甚至还能嵌套。 12345678const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。 123456789101112131415const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。 123456789// 写法一let str = 'return ' + '`Hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack') // \"Hello Jack!\"// 写法二let str = '(name) =&gt; `Hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack') // \"Hello Jack!\" String.raw()ES6还为原生的String对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 12345String.raw`Hi\\n$&#123;2+3&#125;!`;// \"Hi\\\\n5!\"String.raw`Hi\\u000A!`;// 'Hi\\\\u000A!' 如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。 12String.raw`Hi\\\\n`// \"Hi\\\\n\" String.raw的代码基本如下。 123456789String.raw = function (strings, ...values) &#123; var output = \"\"; for (var index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2);","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"ES2015中的解构","slug":"ES2015中的解构","date":"2016-10-30T15:37:17.000Z","updated":"2018-07-12T06:47:06.410Z","comments":true,"path":"2016/10/30/ES2015中的解构/","link":"","permalink":"http://yoursite.com/2016/10/30/ES2015中的解构/","excerpt":"数组/对象/字符串都可以进行解构，尤其是对Json格式的返回值。解构可以进行嵌套，赋默认值(和 undefined 进行‘===’严格比较)。奇奇怪怪的用法就忽略吧… 数组的解构赋值基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样。 1var [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。 12var [foo] = [];var [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。 解构赋值不仅适用于var命令，也适用于let和const命令。 123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array; 对于Set结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set([\"a\", \"b\", \"c\"]);x // \"a\" 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。 1234567891011function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。","text":"数组/对象/字符串都可以进行解构，尤其是对Json格式的返回值。解构可以进行嵌套，赋默认值(和 undefined 进行‘===’严格比较)。奇奇怪怪的用法就忽略吧… 数组的解构赋值基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样。 1var [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。 12var [foo] = [];var [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。 解构赋值不仅适用于var命令，也适用于let和const命令。 123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array; 对于Set结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set([\"a\", \"b\", \"c\"]);x // \"a\" 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。 1234567891011function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。 默认值解构赋值允许指定默认值。 12345var [foo = true] = [];foo // true[x, y = 'b'] = ['a']; // x='a', y='b'[x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 12345var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。 123var &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456var &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"var &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。 1234567var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。 1var &#123; foo: foo, bar: bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123var &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined 上面代码中，真正被赋值的是变量baz，而不是模式foo。 注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。 12345let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration \"foo\"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration \"baz\" 上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。 12345let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。 和数组一样，解构也可以用于嵌套结构的对象。 12345678910var obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;var &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 注意，这时p是模式，不是变量，因此不会被赋值。 12345678910111213var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined 上面代码中，只有line是变量，loc和start都是模式，不会被赋值。 下面是嵌套赋值的例子。 1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 对象的解构也可以指定默认值。 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // \"Something went wrong\" 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。 如果解构失败，变量的值等于undefined。 12var &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 12// 报错var &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; 上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。 12var _tmp = &#123;baz: 'baz'&#125;;_tmp.foo.bar // 报错 如果要将一个已经声明的变量用于解构赋值，必须非常小心。 1234// 错误的写法var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。 12// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;); 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 1let &#123; log, sin, cos &#125; = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234var arr = [1, 2, 3];var &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = 'hello';len // 5 函数参数的解构赋值函数的参数也可以使用解构赋值。 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] undefined就会触发函数参数的默认值。 12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。 （1）变量声明语句中，不能带有圆括号。 123456789// 全部报错var [(a)] = [1];var &#123;x: (c)&#125; = &#123;&#125;;var (&#123;x: c&#125;) = &#123;&#125;;var &#123;(x: c)&#125; = &#123;&#125;;var &#123;(x): c&#125; = &#123;&#125;;var &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数中，模式不能带有圆括号。 函数参数也属于变量声明，因此不能带有圆括号。 12// 报错function f([(z)]) &#123; return z; &#125; （3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将嵌套模式的一层，放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多。 （1）交换变量的值 1[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。 12345678910var jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 上面代码可以快速提取JSON数据的值。 （5）函数参数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 （6）遍历Map结构 任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\");","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"ES2015之let 和 const","slug":"ES2015之let-和-const","date":"2016-10-29T03:45:52.000Z","updated":"2018-07-12T06:47:06.410Z","comments":true,"path":"2016/10/29/ES2015之let-和-const/","link":"","permalink":"http://yoursite.com/2016/10/29/ES2015之let-和-const/","excerpt":"let命令基本用法ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 1234for (let i = 0; i &lt; 10; i++) &#123;&#125;console.log(i);//ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。 不存在变量提升let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。 12345console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。","text":"let命令基本用法ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 1234for (let i = 0; i &lt; 10; i++) &#123;&#125;console.log(i);//ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。 不存在变量提升let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。 12345console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // \"undefined\" 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域为什么需要块级作用域？ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = \"hello world\"; &#125;&#125;f(); // undefined 上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6的块级作用域let实际上为JavaScript新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。 ES6允许块级作用域的任意嵌套。 1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。 1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。 1234567891011// IIFE写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。 ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 12345678910// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123;&#125; 上面代码的两种函数声明，根据ES5的规定都是非法的。 但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。 123456// ES5严格模式'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错 ES6引入了块级作用域，明确允许在块级作用域之中声明函数。 123456// ES6严格模式'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 不报错 并且ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 123456789function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在ES5中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 12345678// ES5版本function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); ES6的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。 12345// ES6版本function f() &#123; console.log('I am outside!'); &#125;(function () &#123; f();&#125;()); 很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 前面那段代码，在Chrome环境下运行会报错。 1234567891011// ES6的浏览器环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 上面的代码报错，是因为实际运行的是下面的代码。 1234567891011// ES6的浏览器环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 123456789101112131415// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125; 另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125; const命令const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = \"Hello!\";let age = 25;// 以下两行都会报错const message = \"Goodbye!\";const age = 30; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 1234567const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 顶层对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但Node和Web Worker没有window。 浏览器和Web Worker里面，self也指向顶层对象，但是Node没有self。 Node里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。 12345// CommonJS的写法require('system.global/shim')();// ES6模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS的写法var global = require('system.global')();// ES6模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。","categories":[],"tags":[{"name":"es2015","slug":"es2015","permalink":"http://yoursite.com/tags/es2015/"}],"keywords":[]},{"title":"vuex2 的一些变化","slug":"vuex2-的一些变化","date":"2016-10-28T09:46:15.000Z","updated":"2018-07-12T06:47:06.421Z","comments":true,"path":"2016/10/28/vuex2-的一些变化/","link":"","permalink":"http://yoursite.com/2016/10/28/vuex2-的一些变化/","excerpt":"$store.state.count可以直接获取Store中的状态参数，但是getters可以返回对参数进行处理后的结果。mutations可以直接使用，但必须为同步方法。如果想使用异步方法，请使用actions，actions异步同步方法都可以。import { mapGetters, mapActions,mapMutations } from &#39;vuex&#39;提供了使用方法的简便模式Store12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// root state object.// each Vuex instance is just a single state tree.const state = &#123; count: 0&#125;// mutations are operations that actually mutates the state.// each mutation handler gets the entire state tree as the// first argument, followed by additional payload arguments.// mutations must be synchronous and can be recorded by plugins// for debugging purposes.必须为同步方法const mutations = &#123; increment (state) &#123; state.count++ &#125;, decrement (state,amount) &#123; state.count-= amount &#125;&#125;// actions are functions that causes side effects and can involve// asynchronous operations. 可以加入异步方法const actions = &#123; // increment: (&#123; commit &#125;) =&gt; commit('increment'), // decrement: (&#123; commit &#125;) =&gt; commit('decrement'), incrementIfOdd (&#123; commit, state &#125;) &#123; if ((state.count + 1) % 2 === 0) &#123; commit('increment') &#125; &#125;, incrementAsync (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('increment') resolve() &#125;, 1000) &#125;) &#125;&#125;// getters are functionsconst getters = &#123; evenOrOdd: state =&gt; state.count % 2 === 0 ? 'even' : 'odd'&#125;// A Vuex instance is created by combining the state, mutations, actions,// and getters.export default new Vuex.Store(&#123; state, getters, actions, mutations&#125;)","text":"$store.state.count可以直接获取Store中的状态参数，但是getters可以返回对参数进行处理后的结果。mutations可以直接使用，但必须为同步方法。如果想使用异步方法，请使用actions，actions异步同步方法都可以。import { mapGetters, mapActions,mapMutations } from &#39;vuex&#39;提供了使用方法的简便模式Store12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// root state object.// each Vuex instance is just a single state tree.const state = &#123; count: 0&#125;// mutations are operations that actually mutates the state.// each mutation handler gets the entire state tree as the// first argument, followed by additional payload arguments.// mutations must be synchronous and can be recorded by plugins// for debugging purposes.必须为同步方法const mutations = &#123; increment (state) &#123; state.count++ &#125;, decrement (state,amount) &#123; state.count-= amount &#125;&#125;// actions are functions that causes side effects and can involve// asynchronous operations. 可以加入异步方法const actions = &#123; // increment: (&#123; commit &#125;) =&gt; commit('increment'), // decrement: (&#123; commit &#125;) =&gt; commit('decrement'), incrementIfOdd (&#123; commit, state &#125;) &#123; if ((state.count + 1) % 2 === 0) &#123; commit('increment') &#125; &#125;, incrementAsync (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('increment') resolve() &#125;, 1000) &#125;) &#125;&#125;// getters are functionsconst getters = &#123; evenOrOdd: state =&gt; state.count % 2 === 0 ? 'even' : 'odd'&#125;// A Vuex instance is created by combining the state, mutations, actions,// and getters.export default new Vuex.Store(&#123; state, getters, actions, mutations&#125;)Vue组件123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id=\"app\"&gt; \\为转义字符，请忽略 Clicked: \\&#123;\\&#123; $store.state.count \\&#125;\\&#125; times, count is \\&#123;\\&#123; evenOrOdd \\&#125;\\&#125;. &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement(2)\"&gt;-&lt;/button&gt; &lt;button @click=\"incrementIfOdd\"&gt;Increment if odd&lt;/button&gt; &lt;button @click=\"incrementAsync\"&gt;Increment async&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters, mapActions,mapMutations &#125; from 'vuex'export default &#123; computed: mapGetters([ 'evenOrOdd' ]), methods: &#123; ...mapMutations([ 'increment', 'decrement', ]), ...mapActions([ 'incrementIfOdd', 'incrementAsync' ]) &#125;&#125;&lt;/script&gt;Vue实例12345678910import Vue from 'vue'import Counter from './Counter.vue'import store from './store'new Vue(&#123; el: '#app', store, render: h =&gt; h(Counter)&#125;);","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"vue-router2的一些变化","slug":"vue-router2的一些变化","date":"2016-10-28T09:23:32.000Z","updated":"2018-07-12T06:47:06.420Z","comments":true,"path":"2016/10/28/vue-router2的一些变化/","link":"","permalink":"http://yoursite.com/2016/10/28/vue-router2的一些变化/","excerpt":"vue-router2详细文档v-link由router-link替换，router-view 的name属性，可以匹配多个路由component(s)hashbang 弃用router.map,router.start,router.redirect，saveScrollPosition等都变为router的实例属性router.go()-&gt;router.push()router123456789101112131415&lt;p style=\"display: flex;justify-content:space-around; align-items:center;flex-flow:row wrap;align-content:flex-start;\"&gt; &lt;router-link to=\"/foo\"&gt;go to foo&lt;/router-link&gt; &lt;router-link to=\"/bar\"&gt;go to bar&lt;/router-link&gt; &lt;router-link to=\"/user/dxf\"&gt;go to user:dxf&lt;/router-link&gt; &lt;router-link to=\"/user/wxr/profile\"&gt;go to wxr profile&lt;/router-link&gt; &lt;router-link to=\"/user/wxr/posts\"&gt;go to wxr posts&lt;/router-link&gt; &lt;router-link to=\"/multi\"&gt;go to multi&lt;/router-link&gt; &lt;/p&gt; &lt;transition name=\"fade\" mode=\"out-in\"&gt; &lt;keep-alive&gt; &lt;router-view name=\"default\"&gt;&lt;/router-view&gt; &lt;router-view name=\"r2\"&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/transition&gt;","text":"vue-router2详细文档v-link由router-link替换，router-view 的name属性，可以匹配多个路由component(s)hashbang 弃用router.map,router.start,router.redirect，saveScrollPosition等都变为router的实例属性router.go()-&gt;router.push()router123456789101112131415&lt;p style=\"display: flex;justify-content:space-around; align-items:center;flex-flow:row wrap;align-content:flex-start;\"&gt; &lt;router-link to=\"/foo\"&gt;go to foo&lt;/router-link&gt; &lt;router-link to=\"/bar\"&gt;go to bar&lt;/router-link&gt; &lt;router-link to=\"/user/dxf\"&gt;go to user:dxf&lt;/router-link&gt; &lt;router-link to=\"/user/wxr/profile\"&gt;go to wxr profile&lt;/router-link&gt; &lt;router-link to=\"/user/wxr/posts\"&gt;go to wxr posts&lt;/router-link&gt; &lt;router-link to=\"/multi\"&gt;go to multi&lt;/router-link&gt; &lt;/p&gt; &lt;transition name=\"fade\" mode=\"out-in\"&gt; &lt;keep-alive&gt; &lt;router-view name=\"default\"&gt;&lt;/router-view&gt; &lt;router-view name=\"r2\"&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/transition&gt;router123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import vueRouter from 'vue-router'import &#123;mapState&#125; from 'vuex'import &#123;mapGetters&#125; from 'vuex'import &#123;mapActions&#125; from 'vuex'const Foo = resolve =&gt; &#123; // require.ensure 是 Webpack 的特殊语法，用来设置 code-split point // （代码分块） require.ensure(['../components/Foo.vue'], () =&gt; &#123; resolve(require('../components/Foo.vue')) &#125;)&#125;;const Bar = resolve =&gt; &#123; require.ensure(['../components/Bar.vue'], () =&gt; &#123; resolve(require('../components/Bar.vue')) &#125;)&#125;;const User = &#123; template: `&lt;section&gt; &lt;h3&gt; is &lt;/h3&gt; &lt;div @click=\"increment\"&gt;User:&lt;/div&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/section&gt;`, computed: mapGetters([ 'evenOrOdd' ]), methods: mapActions([ 'increment' ])&#125;const Profile = &#123; template: '&lt;div @click=\"increment\"&gt;profiles,and num is &lt;/div&gt;', methods: mapActions([ 'increment' ])&#125;const UserPosts = &#123;template: '&lt;div @click=\"alertCount\"&gt;posts&lt;/div&gt;', methods:mapActions([ 'alertCount' ])&#125;const UserHome = &#123;template: '&lt;div&gt;homePage&lt;/div&gt;'&#125;const router = new vueRouter(&#123; mode: 'hash',//history routes:[ &#123;path: '/foo', component: Foo&#125;, &#123;path: '/bar', component: Bar&#125;, &#123; path: '/multi', components: &#123; default: Foo, r2: Bar &#125; &#125;, &#123; path: '/user/:name', component: User, name: 'user', children: [ &#123; path: '', component: UserHome, beforeEnter: (to, from, next) =&gt; &#123; console.log('enter user homepage'); next() &#125; &#125;, &#123; path: 'profile', component: Profile, beforeEnter: (to, from, next) =&gt; &#123; console.log('enter user profile'); next() &#125; &#125;, &#123;path: 'posts', component: UserPosts&#125;, &#123;path: 'post',redirect: 'posts'&#125; ] &#125;, ], linkActiveClass: 'current'&#125;);export default routerVue实例12345678910111213141516171819202122232425262728293031import Vue from 'vue'import vueRouter from 'vue-router'import Vuex from 'vuex'import store from './vuex/store'import router from './route/routers'Vue.use(vueRouter);Vue.use(Vuex);//异步懒加载const app = new Vue(&#123; router, store, mounted: function () &#123; console.log('mounted...') console.log(this.$router) &#125;, watch: &#123; '$route' (to, from) &#123; // 对路由变化作出响应... console.log('to', to) console.log('from', from) &#125; &#125;&#125;).$mount('#app');router.beforeEach((to, from, next) =&gt; &#123; console.log('before each') next()&#125;);router.push('/user/sss/posts');","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"Vue中的过渡效果","slug":"Vue中的过渡效果","date":"2016-10-26T03:10:31.000Z","updated":"2018-07-12T06:47:06.415Z","comments":true,"path":"2016/10/26/Vue中的过渡效果/","link":"","permalink":"http://yoursite.com/2016/10/26/Vue中的过渡效果/","excerpt":"这里只写由css实现的简单过渡，js用到在做记录。 过渡效果概述Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点这里是一个典型的例子：1234567891011121314151617181920&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;).fade-enter-active, .fade-leave-active &#123; transition: opacity .5s&#125;.fade-enter, .fade-leave-active &#123; opacity: 0&#125; 元素封装成过渡组件之后，在遇到插入或删除时，Vue 将自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。 如果过渡组件设置了过渡的 JavaScript 钩子函数，会在相应的阶段调用钩子函数。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 nextTick 概念不同) 过渡的-CSS-类名会有 4 个(CSS)类名在 enter/leave 的过渡中切换 v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。 v-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。 v-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。 对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 &lt;name=”my-transition&gt;” 可以重置前缀，比如 v-enter 替换为 my-transition-enter。 v-enter-active 和 v-leave-active 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。 CSS 过渡常用的过渡都是使用 CSS 过渡。 下面是一个简单例子：1234567891011121314151617181920212223242526&lt;div id=\"example-1\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"slide-fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: '#example-1', data: &#123; show: true &#125;&#125;)/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-active &#123; padding-left: 10px; opacity: 0;&#125; CSS 动画CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。 示例： (省略了兼容性前缀)12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"example-2\"&gt; &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt; &lt;transition name=\"bounce\"&gt; &lt;p v-if=\"show\"&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: '#example-2', data: &#123; show: true &#125;&#125;).bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-out .5s;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;@keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125;&#125; 自定义过渡类名我们可以通过以下特性来自定义过渡类名： enter-classenter-active-classleave-classleave-active-class他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。 示例：12345678910111213141516171819&lt;link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;div id=\"example-3\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"custom-classes-transition\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: '#example-3', data: &#123; show: true &#125;&#125;)","text":"这里只写由css实现的简单过渡，js用到在做记录。 过渡效果概述Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡 条件渲染 （使用 v-if） 条件展示 （使用 v-show） 动态组件 组件根节点这里是一个典型的例子：1234567891011121314151617181920&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;).fade-enter-active, .fade-leave-active &#123; transition: opacity .5s&#125;.fade-enter, .fade-leave-active &#123; opacity: 0&#125; 元素封装成过渡组件之后，在遇到插入或删除时，Vue 将自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。 如果过渡组件设置了过渡的 JavaScript 钩子函数，会在相应的阶段调用钩子函数。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 nextTick 概念不同) 过渡的-CSS-类名会有 4 个(CSS)类名在 enter/leave 的过渡中切换 v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。 v-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。 v-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。 对于这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 &lt;name=”my-transition&gt;” 可以重置前缀，比如 v-enter 替换为 my-transition-enter。 v-enter-active 和 v-leave-active 可以控制 进入/离开 过渡的不同阶段，在下面章节会有个示例说明。 CSS 过渡常用的过渡都是使用 CSS 过渡。 下面是一个简单例子：1234567891011121314151617181920212223242526&lt;div id=\"example-1\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"slide-fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: '#example-1', data: &#123; show: true &#125;&#125;)/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-active &#123; padding-left: 10px; opacity: 0;&#125; CSS 动画CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。 示例： (省略了兼容性前缀)12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"example-2\"&gt; &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt; &lt;transition name=\"bounce\"&gt; &lt;p v-if=\"show\"&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: '#example-2', data: &#123; show: true &#125;&#125;).bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-out .5s;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;@keyframes bounce-out &#123; 0% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(0); &#125;&#125; 自定义过渡类名我们可以通过以下特性来自定义过渡类名： enter-classenter-active-classleave-classleave-active-class他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。 示例：12345678910111213141516171819&lt;link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;div id=\"example-3\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"custom-classes-transition\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: '#example-3', data: &#123; show: true &#125;&#125;) 同时使用 Transitions 和 AnimationsVue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。 初始渲染的过渡可以通过 appear 特性设置节点的在初始渲染的过渡123&lt;transition appear&gt;&lt;/transition&gt; 这里默认和进入和离开过渡一样，同样也可以自定义 CSS 类名。1234567&lt;transition appear appear-class=\"custom-appear-class\" appear-active-class=\"custom-appear-active-class\"&gt;&lt;/transition&gt; 多个元素的过渡我们之后讨论 多个组件的过渡, 对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：123456&lt;transition&gt; &lt;table v-if=&quot;items.length &gt; 0&quot;&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 可以这样使用，但是有一点需要注意： 当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 组件中的多个元素设置 key 是一个更好的实践。 示例:12345678&lt;transition&gt; &lt;button v-if=&quot;isEditing&quot; key=&quot;save&quot;&gt; Save &lt;/button&gt; &lt;button v-else key=&quot;edit&quot;&gt; Edit &lt;/button&gt;&lt;/transition&gt; 在一些场景中，也可以给通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为：12345&lt;transition&gt; &lt;button v-bind:key=&quot;isEditing&quot;&gt; &#123;&#123; isEditing ? &apos;Save&apos; : &apos;Edit&apos; &#125;&#125; &lt;/button&gt;&lt;/transition&gt; 使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。 例如：1234567891011&lt;transition&gt; &lt;button v-if=&quot;docState === &apos;saved&apos;&quot; key=&quot;saved&quot;&gt; Edit &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;edited&apos;&quot; key=&quot;edited&quot;&gt; Save &lt;/button&gt; &lt;button v-if=&quot;docState === &apos;editing&apos;&quot; key=&quot;editing&quot;&gt; Cancel &lt;/button&gt;&lt;/transition&gt; 可以重写为：123456789101112131415&lt;transition&gt; &lt;button v-bind:key=&quot;docState&quot;&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt;computed: &#123; buttonMessage: function () &#123; switch (docState) &#123; case &apos;saved&apos;: return &apos;Edit&apos; case &apos;edited&apos;: return &apos;Save&apos; case &apos;editing&apos;: return &apos;Cancel&apos; &#125; &#125;&#125; 过渡模式同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 过渡模式 in-out: 新元素先进行过渡，完成之后当前元素过渡离开。 out-in: 当前元素先进行过渡，完成之后新元素过渡进入。 用 out-in 重写之前的开关按钮过渡：1&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;&lt;/transition&gt; 只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。in-out 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。 多个组件的过渡多个组件的过渡很简单很多,我们不需要使用 key 特性。相反，我们只需要使用动态组件: 关于动态组件 多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 元素，动态地绑定到它的 is 特性：12345678910111213141516171819202122232425var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; currentView: &apos;home&apos; &#125;, components: &#123; home: &#123; /* ... */ &#125;, posts: &#123; /* ... */ &#125;, archive: &#123; /* ... */ &#125; &#125;&#125;)&lt;component v-bind:is=&quot;currentView&quot;&gt; &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;&lt;/component&gt;也可以直接绑定到组件对象上：var Home = &#123; template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;&#125;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; currentView: Home &#125;&#125;) 使用动态组件实现过渡1234567891011121314151617181920212223&lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt; &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/transition&gt;new Vue(&#123; el: &apos;#transition-components-demo&apos;, data: &#123; view: &apos;v-a&apos; &#125;, components: &#123; &apos;v-a&apos;: &#123; template: &apos;&lt;div&gt;Component A&lt;/div&gt;&apos; &#125;, &apos;v-b&apos;: &#123; template: &apos;&lt;div&gt;Component B&lt;/div&gt;&apos; &#125; &#125;&#125;).component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-active &#123; opacity: 0;&#125; 更多动画效果请参考这里","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"Vue2 中的生命周期","slug":"Vue2-中的生命周期","date":"2016-10-25T08:56:34.000Z","updated":"2018-07-12T06:47:06.415Z","comments":true,"path":"2016/10/25/Vue2-中的生命周期/","link":"","permalink":"http://yoursite.com/2016/10/25/Vue2-中的生命周期/","excerpt":"","text":"项目从Vue1升级到Vue2，记录常见的改动。 生命周期图示下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"Html5的file API","slug":"Html5的file-API","date":"2016-10-21T15:54:13.000Z","updated":"2018-07-12T06:47:06.414Z","comments":true,"path":"2016/10/21/Html5的file-API/","link":"","permalink":"http://yoursite.com/2016/10/21/Html5的file-API/","excerpt":"在html4的年代，我们如果要在网页上呈现一张用户本地的图片，需要用户先把图片上传到服务器，再根据服务器提供的图片地址把图片下载下来，才能把图片在网页上呈现出来。这一来二往，起码已经费了两倍于这张图片的流量了，更别说服务器为了存储这张图片所花费的资源以及用户上传错了图片的冤枉成本（因为在html4时代，用户选择好图片后，往往只能看到图片的文件名，而无法通过预览图来进一步确认这张图片是否就是自己想要上传的）。html5提供了新玩法，光靠浏览器，就可以对本地的（其实也可以是远程的）文件（主要是图片）进行呈现、读取、处理等操作，而这一切，则是通过html5 file api来实现的。 首先是数据结构，html5定义了一个file对象类型来表示文件，每个file对象对应一个文件。file对象有3个属性：name、size、type。name是不包含路径的文件名，size是以字节为单位的文件体积大小，type则是文件的MIME（例如image/jpg）。 file对象不单独存在，而是以数组形式，存在一个名为FileList的数组中。那么，如何拿到这个FileList数组呢？目前，html5有两个途径可以拿到FileList，一是通过file类型的input，二是通过拖放操作的drop事件。 通过file类型的input获取FileList&lt;input id=&quot;file-input&quot; type=&quot;file&quot; /&gt;或html5新增的可进行文件多选的multiple属性： &lt;input id=&quot;file-input&quot; type=&quot;file&quot; multiple /&gt;一般，我们都是给input:file绑上一个onchange事件，以便在用户选定文件后，马上进行读取文件等下一步操作：1234567891011//原生jsvar inputElement = document.getElementById(\"file-input\");inputElement.addEventListener(\"change\", handleFiles, false);function handleFiles() &#123; var fileList = this.files; &#125;//jquery版$('#file-input').on('change', function() &#123; var fileList = this.files;&#125;); 通过拖放操作drop事件首先要设定一个可供拖放的区域：&lt;div id=&quot;dropbox&quot; style=&quot;width: 200px;height: 200px;&quot;&gt;&lt;/div&gt;另外，为了能触发drop事件，我们必须阻止dragenter和dragover事件的默认行为：1234567891011121314var dropbox;dropbox = document.getElementById(\"dropbox\");dropbox.addEventListener(\"dragenter\", dragenter, false);dropbox.addEventListener(\"dragover\", dragover, false);dropbox.addEventListener(\"drop\", drop, false);function dragenter(e) &#123; e.stopPropagation(); e.preventDefault();&#125;function dragover(e) &#123; e.stopPropagation(); e.preventDefault();&#125;然后，我们就可以在drop事件的callback中，获取到fileList：123456789function drop(e) &#123; e.stopPropagation(); e.preventDefault(); var dt = e.dataTransfer; var files = dt.files; handleFiles(files);&#125;","text":"在html4的年代，我们如果要在网页上呈现一张用户本地的图片，需要用户先把图片上传到服务器，再根据服务器提供的图片地址把图片下载下来，才能把图片在网页上呈现出来。这一来二往，起码已经费了两倍于这张图片的流量了，更别说服务器为了存储这张图片所花费的资源以及用户上传错了图片的冤枉成本（因为在html4时代，用户选择好图片后，往往只能看到图片的文件名，而无法通过预览图来进一步确认这张图片是否就是自己想要上传的）。html5提供了新玩法，光靠浏览器，就可以对本地的（其实也可以是远程的）文件（主要是图片）进行呈现、读取、处理等操作，而这一切，则是通过html5 file api来实现的。 首先是数据结构，html5定义了一个file对象类型来表示文件，每个file对象对应一个文件。file对象有3个属性：name、size、type。name是不包含路径的文件名，size是以字节为单位的文件体积大小，type则是文件的MIME（例如image/jpg）。 file对象不单独存在，而是以数组形式，存在一个名为FileList的数组中。那么，如何拿到这个FileList数组呢？目前，html5有两个途径可以拿到FileList，一是通过file类型的input，二是通过拖放操作的drop事件。 通过file类型的input获取FileList&lt;input id=&quot;file-input&quot; type=&quot;file&quot; /&gt;或html5新增的可进行文件多选的multiple属性： &lt;input id=&quot;file-input&quot; type=&quot;file&quot; multiple /&gt;一般，我们都是给input:file绑上一个onchange事件，以便在用户选定文件后，马上进行读取文件等下一步操作：1234567891011//原生jsvar inputElement = document.getElementById(\"file-input\");inputElement.addEventListener(\"change\", handleFiles, false);function handleFiles() &#123; var fileList = this.files; &#125;//jquery版$('#file-input').on('change', function() &#123; var fileList = this.files;&#125;); 通过拖放操作drop事件首先要设定一个可供拖放的区域：&lt;div id=&quot;dropbox&quot; style=&quot;width: 200px;height: 200px;&quot;&gt;&lt;/div&gt;另外，为了能触发drop事件，我们必须阻止dragenter和dragover事件的默认行为：1234567891011121314var dropbox;dropbox = document.getElementById(\"dropbox\");dropbox.addEventListener(\"dragenter\", dragenter, false);dropbox.addEventListener(\"dragover\", dragover, false);dropbox.addEventListener(\"drop\", drop, false);function dragenter(e) &#123; e.stopPropagation(); e.preventDefault();&#125;function dragover(e) &#123; e.stopPropagation(); e.preventDefault();&#125;然后，我们就可以在drop事件的callback中，获取到fileList：123456789function drop(e) &#123; e.stopPropagation(); e.preventDefault(); var dt = e.dataTransfer; var files = dt.files; handleFiles(files);&#125; 怎么读取或利用file对象呢？html5提供了两个方案：FileReader和ObjectUrl。 使用FileReader读取file对象首先需要实例化FileReader对象：var reader = new FileReader();利用FileReader读取file对象是一个异步的过程，我们需要先为FileReader设置好load事件的callback，告知FileReader在读取到file对象的数据后应该进行什么进一步的操作：reader.onload = function(e) { document.getElementById(&quot;image&quot;).src = e.target.result; }上面这段代码的意思是，FileReader读取到图片的数据后，把数据（DataUrl）放到的src属性里。最后，就是通过FileReader不同的方法，来决定读取file对象数据后用什么数据格式来存放，并实施读取： readAsArrayBuffer(file) ：读取file对象并存放为ArrayBuffer对象（ArrayBuffer对象是什么我暂时没有搞清，应该是一种为了高效存取数据而产生的数据结构）。 readAsText(file [, ‘UTF-8’]) ：以一般文本模式读取file对象，值得注意的是，利用第二个参数（可选）可指定字符编码。 readAsDataURL(file) ：读取file对象并存放为data: URL格式的字符串。 利用ObjectURLObjectURL相当于文件的一个临时路径，此临时路径可随时生成、随时释放，在本地浏览器使用起来时，与普通的url无异。以把一张本地图片显示在页面上为例：var img = document.createElement(&quot;img&quot;); img.src = window.URL.createObjectURL(file);此时，src形如：blob:http://test.local.com/e03e8bbf-66ce-4fea-a8c8-772f9fdb4d40用这个src就能让浏览器从本地读取图片。这种方案相对用FileReader生成图片的base64编码并放到的src里来说，性能有了很大的提升。 比较这两种读取File对象的方案，FileReader适合用来上传文件，而ObjectURL则适合直接在浏览器进行操作，然后操作后再把处理后的数据进行上传，例如利用canvas截图或进行图片压缩等。当然，这一切都是要考虑兼容性的。","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}],"keywords":[]},{"title":"flex","slug":"flex","date":"2016-10-17T12:56:08.000Z","updated":"2018-07-12T06:47:06.417Z","comments":true,"path":"2016/10/17/flex/","link":"","permalink":"http://yoursite.com/2016/10/17/flex/","excerpt":"转载自阮一峰的网络日志-Flex 布局教程：语法篇 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。.box{ display: flex; }行内元素也可以使用Flex布局。.box{ display: inline-flex; }Webkit内核的浏览器，必须加上-webkit前缀。.box{ display: -webkit-flex; /* Safari */ display: flex; }注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content","text":"转载自阮一峰的网络日志-Flex 布局教程：语法篇 一、Flex布局是什么？Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。.box{ display: flex; }行内元素也可以使用Flex布局。.box{ display: inline-flex; }Webkit内核的浏览器，必须加上-webkit前缀。.box{ display: -webkit-flex; /* Safari */ display: flex; }注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。.box { flex-direction: row | row-reverse | column | column-reverse; }它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。.box{ flex-wrap: nowrap | wrap | wrap-reverse; }它可能取三个值。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。warap-reverse3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; }3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。.box { justify-content: flex-start | flex-end | center | space-between | space-around; }它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。3.5 align-items属性align-item.s属性定义项目在交叉轴上如何对齐。.box { align-items: flex-start | flex-end | center | baseline | stretch; }它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; }该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。.item { order: &lt;integer&gt;; }4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。.item { flex-grow: &lt;number&gt;; /* default 0 */ }如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。.item { flex-shrink: &lt;number&gt;; /* default 1 */ }如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。.item { flex-basis: &lt;length&gt; | auto; /* default auto */ }它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。.item { flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] }该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。.item { align-self: auto | flex-start | flex-end | center | baseline | stretch; }该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","categories":[],"tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}],"keywords":[]},{"title":"css3笔记","slug":"css3笔记","date":"2016-10-14T07:26:35.000Z","updated":"2018-07-12T06:47:06.416Z","comments":true,"path":"2016/10/14/css3笔记/","link":"","permalink":"http://yoursite.com/2016/10/14/css3笔记/","excerpt":"仅记录一些常用的css3属性 边框border-radius向元素添加圆角边框。border-radius: 5px 4px 3px 2px; / 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 / box-shadow向盒子添加阴影,支持添加一个或者多个。box-shadow:X轴偏移 Y轴偏移 阴影模糊半径 阴影扩展半径 阴影颜色 投影方式; 阴影模糊半径与阴影扩展半径的区别阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小； X轴偏移量和Y轴偏移量值可以设置为负数颜色Gradient渐变色彩CSS3 Gradient 分为线性渐变(linear)和径向渐变(radial)。由于不同的渲染引擎实现渐变的语法不同，这里我们只针对线性渐变的 W3C 标准语法来分析其用法，其余大家可以查阅相关资料。W3C 语法已经得到了 IE10+、Firefox19.0+、Chrome26.0+ 和 Opera12.1+等浏览器的支持。linear-gradient:(to top,#fff,#999) 第一个参数省略时，默认为“180deg”，等同于“to bottom”。 第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。","text":"仅记录一些常用的css3属性 边框border-radius向元素添加圆角边框。border-radius: 5px 4px 3px 2px; / 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 / box-shadow向盒子添加阴影,支持添加一个或者多个。box-shadow:X轴偏移 Y轴偏移 阴影模糊半径 阴影扩展半径 阴影颜色 投影方式; 阴影模糊半径与阴影扩展半径的区别阴影模糊半径：此参数可选，其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊；阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小； X轴偏移量和Y轴偏移量值可以设置为负数颜色Gradient渐变色彩CSS3 Gradient 分为线性渐变(linear)和径向渐变(radial)。由于不同的渲染引擎实现渐变的语法不同，这里我们只针对线性渐变的 W3C 标准语法来分析其用法，其余大家可以查阅相关资料。W3C 语法已经得到了 IE10+、Firefox19.0+、Chrome26.0+ 和 Opera12.1+等浏览器的支持。linear-gradient:(to top,#fff,#999) 第一个参数省略时，默认为“180deg”，等同于“to bottom”。 第二个和第三个参数，表示颜色的起始点和结束点，可以有多个颜色值。 字体text-overflow用来设置是否使用一个省略标记（…）标示对象内文本的溢出。但是text-overflow只是用来说明文字溢出时用什么方式显示，要实现溢出时产生省略号的效果，还须定义强制文本在一行内显示（white-space:nowrap）及溢出内容为隐藏（overflow:hidden），只有这样才能实现溢出文本显示省略号的效果，代码如下：123text-overflow:ellipsis; overflow:hidden; white-space:nowrap; word-wrap也可以用来设置文本行为，当前行超过指定容器的边界时是否断开转行word-wrap:normal|| break-word text-shadow可以用来设置文本的阴影效果。text-shadow: X-Offset Y-Offset blur color; 背景background-origin设置元素背景图片的原始起始位置。语法：background-origin ： border-box | padding-box | content-box;参数分别表示背景图片是从边框，还是内边距（默认值），或者是内容区域开始显示。需要注意的是，如果背景不是no-repeat，这个属性无效，它会从边框开始显示。 background-size设置背景图片的大小，以长度值或百分比显示，还可以通过cover和contain来对图片进行伸缩。语法：background-size: auto | &lt;长度值&gt; | &lt;百分比&gt; | cover | contain取值说明： auto：默认值，不改变背景图片的原始高度和宽度； &lt;长度值&gt;：成对出现如200px 50px，将背景图片宽高依次设置为前面两个值，当设置一个值时，将其作为图片宽度值来等比缩放； &lt;百分比&gt;：0％~100％之间的任何值，将背景图片宽高依次设置为所在元素宽高乘以前面百分比得出的数值，当设置一个值时同上； cover：顾名思义为覆盖，即将背景图片等比缩放以填满整个容器； contain：容纳，即将背景图片等比缩放至某一边紧贴容器边缘为止。 选择器属性选择器HTML123&lt;a href=\"xxx.pdf\"&gt;我链接的是PDF文件&lt;/a&gt;&lt;a href=\"#\" class=\"icon\"&gt;我类名是icon&lt;/a&gt;&lt;a href=\"#\" title=\"我的title是more\"&gt;我的title是more&lt;/a&gt; CSS12345678910111213 a[class^=icon]&#123; background: green; color:#fff;&#125;a[href$=pdf]&#123; background: orange; color: #fff;&#125;a[title*=more]&#123; background: blue; color: #fff;&#125; 结构性伪类选择器—root:root选择器，从字面上我们就可以很清楚的理解是根选择器，他的意思就是匹配元素E所在文档的根元素。在HTML文档中，根元素始终是。 结构性伪类选择器—not:not选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。 结构性伪类选择器—empty:empty选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。 结构性伪类选择器—target:target选择器称为目标选择器，用来匹配文档(页面)的url的某个标志符的目标元素。多个url（多个target）处理：就像上面的例子，#brand与后面的id=”brand”是对应的，当同一个页面上有很多的url的时候你可以取不同的名字，只要#号后对的名称与id=””中的名称对应就可以了。 结构性伪类选择器—first-child“:first-child”选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。ol &gt; li:first-child{ color: red; } 结构性伪类选择器—last-child“:last-child”选择器与“:first-child”选择器作用类似，不同的是“:last-child”选择器选择的是元素的最后一个子元素。例如，需要改变的是列表中的最后一个“li”的背景色，就可以使用这个选择器.ul&gt;li:last-child{background:blue;} 结构性伪类选择器—nth-child(n)“:nth-child(n)”选择器用来定位某个父元素的一个或多个特定的子元素。其中“n”是其参数，而且可以是整数值(1,2,3,4)，也可以是表达式(2n+1、-n+5)和关键词(odd、even)，但参数n的起始值始终是1，而不是0。也就是说，参数n的值为0时，选择器将选择不到任何匹配的元素。经验与技巧:当“:nth-child(n)”选择器中的n为一个表达式时，其中n是从0开始计算，当表达式的值为0或小于0的时候，不选择任何匹配的元素。ol &gt; li:nth-child(2n){ background: orange; } 结构性伪类选择器—nth-last-child(n)“:nth-last-child(n)”选择器和前面的“:nth-child(n)”选择器非常的相似，只是这里多了一个“last”，所起的作用和“:nth-child(n)”选择器有所区别，从某父元素的最后一个子元素开始计算，来选择特定的元素。 first-of-type选择器“:first-of-type”选择器类似于“:first-child”选择器，不同之处就是指定了元素的类型,其主要用来定位一个父元素下的某个类型的第一个子元素。我要改变第一个段落的背景为橙色.wrapper &gt; p:first-of-type { background: orange; }通过“:first-of-type”选择器，定位div容器中的第一个p元素（p不一定是容器中的第一个子元素），并设置其背景色为橙色。 nth-of-type(n)选择器“:nth-of-type(n)”选择器和“:nth-child(n)”选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。当某个元素中的子元素不单单是同一种类型的子元素时，使用“:nth-of-type(n)”选择器来定位于父元素中某种类型的子元素是非常方便和有用的。在“:nth-of-type(n)”选择器中的“n”和“:nth-child(n)”选择器中的“n”参数也一样，可以是具体的整数，也可以是表达式，还可以是关键词。 last-of-type选择器“:last-of-type”选择器和“:first-of-type”选择器功能是一样的，不同的是他选择是父元素下的某个类型的最后一个子元素。 nth-last-of-type(n)选择器“:nth-last-of-type(n)”选择器和“:nth-of-type(n)”选择器是一样的，选择父元素中指定的某种子元素类型，但它的起始方向是从最后一个子元素开始，而且它的使用方法类似于上节中介绍的“:nth-last-child(n)”选择器一样。 only-child选择器“:only-child”选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。 only-of-type选择器“:only-of-type”选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。“:only-of-type”是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用“:only-of-type”选择器就可以选中这个元素中的唯一一个类型子元素。 :enabled选择器在Web的表单中，有些表单元素有可用（“:enabled”）和不可用（“:disabled”）状态，比如输入框，密码框，复选框等。在默认情况之下，这些表单元素都处在可用状态。那么我们可以通过伪选择器“:enabled”对这些表单元素设置样式。input[type=&quot;text&quot;]:enabled { background: #ccc; border: 2px solid red; }通过“:enabled”选择器，修改文本输入框的边框为2像素的红色边框，并设置它的背景为灰色。 #####:disabled选择器“:disabled”选择器刚好与“:enabled”选择器相反，用来选择不可用表单元素。要正常使用“:disabled”选择器，需要在表单元素的HTML中设置“disabled”属性。input[type=&quot;text&quot;]:disabled { background: rgba(0,0,0,.15); border: 1px solid rgba(0,0,0,.15); color: rgba(0,0,0,.15); }通过“:disabled”选择器，给不可用输入框设置明显的样式。 :checked选择器在表单元素中，单选按钮和复选按钮都具有选中和未选中状态。（大家都知道，要覆写这两个按钮默认样式比较困难）。在CSS3中，我们可以通过状态选择器“:checked”配合其他标签实现自定义样式。而“:checked”表示的是选中状态。input[type=&quot;checkbox&quot;]:checked + span { opacity: 1; } ::selection选择器“::selection”伪元素是用来匹配突出显示的文本(用鼠标选择文本时的文本)。浏览器默认情况下，用鼠标选择网页文本是以“深蓝的背景，白色的字体”显示.有的时候设计要求,不使用上图那种浏览器默认的突出文本效果，需要一个与众不同的效果，此时“::selection”伪元素就非常的实用。不过在Firefox浏览器还需要添加前缀。::-moz-selection { background: red; color: green; } ::selection { background: red; color: green; }:read-only选择器“:read-only”伪类选择器用来指定处于只读状态元素的样式。简单点理解就是，元素中设置了“readonly=’readonly’”input[type=&quot;text&quot;]:read-only{ border-color: #ccc; }通过“:read-only”选择器来设置地址文本框的样式。 :read-write选择器“:read-write”选择器刚好与“:read-only”选择器相反，主要用来指定当元素处于非只读状态时的样式。input[type=&quot;text&quot;]:read-write{ border-color: #f36; }使用“:read-write”选择器来设置不是只读控件的文本框样式。 ::before和::after::before和::after这两个主要用来给元素的前面或后面插入内容，这两个常和”content”配合使用，使用的场景最多的就是清除浮动。123456789.clearfix::before,.clearfix::after &#123; content: \".\"; display: block; height: 0; visibility: hidden;&#125;.clearfix:after &#123;clear: both;&#125;.clearfix &#123;zoom: 1;&#125;当然可以利用他们制作出其他更好的效果，比如右侧中的阴影效果，也是通过这个来实现的。 关键代码分析：1234567891011121314.effect::before, .effect::after&#123; content:\"\"; position:absolute; z-index:-1; -webkit-box-shadow:0 0 20px rgba(0,0,0,0.8); -moz-box-shadow:0 0 20px rgba(0,0,0,0.8); box-shadow:0 0 20px rgba(0,0,0,0.8); top:50%; bottom:0; left:10px; right:10px; -moz-border-radius:100px / 10px; border-radius:100px / 10px;&#125;上面代码作用在class名叫.effect上的div的前（before）后(after)都添加一个空元素，然后为这两个空元素添加阴影特效。 变形与动画 transform变形–旋转 rotate()旋转rotate()函数通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负值，元素相对原点中心逆时针旋转。1234567.wrapper div &#123; width: 200px; height: 200px; background: orange; -webkit-transform: rotate(45deg); transform: rotate(45deg);&#125; 变形–扭曲 skew()扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。这与rotate()函数的旋转不同，rotate()函数只是旋转，而不会改变元素的形状。skew()函数不会旋转，而只会改变元素的形状。Skew()具有三种情况： skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。 skewX(x)仅使元素在水平方向扭曲变形（X轴扭曲变形）； skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形）变形–缩放 scale()缩放 scale()函数 让元素根据中心原点对对象进行缩放。缩放 scale 具有三种情况： scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）div:hover { -webkit-transform: scale(1.5,0.5); -moz-transform:scale(1.5,0.5) transform: scale(1.5,0.5); }注意：Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。 scaleX(x)元素仅水平方向缩放（X轴缩放） scaleY(y)元素仅垂直方向缩放（Y轴缩放）变形–位移 translate()translate()函数可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。translate我们分为三种情况：1、translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动），一个参数时仅X位移。2、translateX(x)仅水平方向移动（X轴移动）3、translateY(Y)仅垂直方向移动（Y轴移动）变形–矩阵 matrix()matrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果需要深入了解，需要对数学矩阵有一定的知识。示例演示：通过matrix()函数来模拟transform中translate()位移的效果。123&lt;div class=\"wrapper\"&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.wrapper &#123; width: 300px; height: 200px; border: 2px dotted red; margin: 40px auto;&#125;.wrapper div &#123; width:300px; height: 200px; background: orange; -webkit-transform: matrix(1,0,0,1,50,50); -moz-transform:matrix(1,0,0,1,50,50); transform: matrix(1,0,0,1,50,50);&#125; 演示结果： matrix(scaleX(),skewX(),skewY(),scaleY(),translateX(),translateY()); 动画–过渡属性 transition早期在Web中要实现动画效果，都是依赖于JavaScript或Flash来完成。但在CSS3中新增加了一个新的模块transition，它可以通过一些简单的CSS事件来触发元素的外观变化，让效果显得更加细腻。简单点说，就是通过鼠标的单击、获得焦点，被点击或对元素任何改变中触发，并平滑地以动画效果改变CSS的属性值。 在CSS中创建简单的过渡效果可以从以下几个步骤来实现： 在默认样式中声明元素的初始状态样式； 声明过渡元素最终状态样式，比如悬浮状态； 在默认样式中通过添加过渡函数，添加一些不同的样式。 CSS3的过度transition属性是一个复合属性，主要包括以下几个子属性： transition-property:指定过渡或动态模拟的CSS属性(width,height,transform…)transition-duration:指定完成过渡所需的时间transition-timing-function:指定过渡函数(ease,ease-in,ease-out,ease-in-out,linear…)transition-delay:指定开始出现的延迟时间先来看transition-property属性 transition-property用来指定过渡动画的CSS属性名称，而这个过渡属性只有具备一个中点值的属性（需要产生动画的属性）才能具备过渡效果,特别注意：当“transition-property”属性设置为all时，表示的是所有中点值的属性。用一个简单的例子来说明这个问题： 假设你的初始状态设置了样式“width”,“height”,“background”,当你在终始状态都改变了这三个属性，那么all代表的就是“width”、“height”和“background”。如果你的终始状态只改变了“width”和“height”时，那么all代表的就是“width”和“height”。 动画–animationKeyframes介绍Keyframes被称为关键帧，其类似于Flash中的关键帧。在CSS3中其主要以“@keyframes”开头，后面紧跟着是动画名称加上一对花括号“{…}”，括号中就是一些不同时间段样式规则。12345678@keyframes changecolor&#123; 0%&#123; background: red; &#125; 100%&#123; background: green; &#125;&#125; 在一个“@keyframes”中的样式规则可以由多个百分比构成的，如在“0%”到“100%”之间创建更多个百分比，分别给每个百分比中给需要有动画效果的元素加上不同的样式，从而达到一种在不断变化的效果。经验与技巧：在@keyframes中定义动画名称时，其中0%和100%还可以使用关键词from和to来代表，其中0%对应的是from，100%对应的是to。案例演示通过“@keyframes”声明一个名叫“wobble”的动画，从“0%”开始到“100%”结束，同时还经历了一个“40%”和“60%”两个过程。“wobble”动画在“0%”时元素定位到left为100px，背景色为green，然后在“40%”时元素过渡到left为150px,背景色为orange,接着在“60%”时元素过渡到left为75px，背景色为blue，最后“100%”时结束动画，元素又回到起点left为100px处，背景色变为red。animation: wobble 5s ease .1s;后三个参数与transition相同。1234567891011121314151617181920212223242526272829303132HTML:&lt;div&gt;鼠标放到我身上&lt;/div&gt;CSS:@keyframes wobble &#123; 0% &#123; margin-left: 100px; background:green; &#125; 40% &#123; margin-left:150px; background:orange; &#125; 60% &#123; margin-left: 75px; background: blue; &#125; 100% &#123; margin-left: 100px; background: red; &#125;&#125;div &#123; width: 100px; height: 100px; background:red; color: #fff;&#125;div:hover&#123; animation: wobble 5s ease .1s;&#125; animation-iteration-count属性主要用来定义动画的播放次数。语法规则：animation-iteration-count: infinite | [, infinite | ]* 其值通常为整数，但也可以使用带有小数的数字，其默认值为1，这意味着动画将从开始到结束只播放一次。 如果取值为infinite，动画将会无限次的播放。设置动画播放方向animation-direction属性主要用来设置动画播放方向，其语法规则如下：animation-direction:normal | alternate [, normal | alternate]*其主要有两个值：normal、alternate normal是默认值，如果设置为normal时，动画的每次循环都是向前播放； 另一个值是alternate，他的作用是，动画播放在第偶数次向前播放，第奇数次向反方向播放。例如：通过animation-direction属性，将move动画播放动画方向设置为alternate，代码为：animation-direction:alternate;设置动画的播放状态animation-play-state属性主要用来控制元素动画的播放状态。参数：其主要有两个值：running和paused。 其中running是其默认值，主要作用就是类似于音乐播放器一样，可以通过paused将正在播放的动画停下来，也可以通过running将暂停的动画重新播放，这里的重新播放不一定是从元素动画的开始播放，而是从暂停的那个位置开始播放。另外如果暂停了动画的播放，元素的样式将回到最原始设置状态。例如，页面加载时，动画不播放。代码如下：animation-play-state:paused; 设置动画时间外属性animation-fill-mode属性定义在动画开始之前和结束之后发生的操作。主要具有四个属性值：none、forwards、backwords和both。其四个属性值对应效果如下： 属性值 效果 none 默认值，表示动画将按预期进行和结束，在动画完成其最后一帧时,动画会反转到初始帧处 forwards 表示动画在结束后继续应用最后的关键帧的位置 backwards 会在向元素应用动画样式时迅速应用动画的初始帧 both 元素动画同时具有forwards和backwards效果 在默认情况之下，动画不会影响它的关键帧之外的属性，使用animation-fill-mode属性可以修改动画的默认行为。简单的说就是告诉动画在第一关键帧上等待动画开始，或者在动画结束时停在最后一个关键帧上而不回到动画的第一帧上。或者同时具有这两个效果。例如：让动画停在最一帧处。代码如下：animation-fill-mode:forwards;","categories":[],"tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}],"keywords":[]},{"title":"linux 交换alt和ctrl按键","slug":"linux-交换alt和ctrl按键","date":"2016-10-14T03:49:11.000Z","updated":"2018-07-12T06:47:06.418Z","comments":true,"path":"2016/10/14/linux-交换alt和ctrl按键/","link":"","permalink":"http://yoursite.com/2016/10/14/linux-交换alt和ctrl按键/","excerpt":"","text":"为什么要交换alt键和ctrl键呢?珍爱小拇指,远离ctrl, ctrl键每次按时都要移动整个手掌, 而且还要看一眼键盘,实在是不爽啊alt键就好了只要大拇指稍微移一下就可以按到了.方法:在home目录建一个文件 .Xmodmap然后在文件中写入下面几句:123456remove control = Control_L remove mod1 = Alt_Lkeysym Control_L = Alt_Lkeysym Alt_L = Control_Ladd control = Control_Ladd mod1 = Alt_L 然后logout再登录就好了.上面的代码一定要写在 .Xmodmap 文件中才行.","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}],"keywords":[]},{"title":"使用requestAnimationFrame做动画控制","slug":"使用requestAnimationFrame做动画控制","date":"2016-10-12T03:04:45.000Z","updated":"2018-07-12T06:47:06.424Z","comments":true,"path":"2016/10/12/使用requestAnimationFrame做动画控制/","link":"","permalink":"http://yoursite.com/2016/10/12/使用requestAnimationFrame做动画控制/","excerpt":"requestAnimationFrame是什么？在浏览器动画程序中，我们通常使用一个定时器来循环每隔几毫秒移动目标物体一次，来让它动起来。如今有一个好消息，浏览器开发商们决定：“嗨，为什么我们不在浏览器里提供这样一个API呢，这样一来我们可以为用户优化他们的动画。”所以，这个requestAnimationFrame()函数就是针对动画效果的API，你可以把它用在DOM上的风格变化或画布动画或WebGL中。 使用requestAnimationFrame有什么好处？浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。requestAnimationFrame的用法requestAnimationFrame123456789101112131415// usage:// instead of setInterval(render, 16) ....var out = document.querySelector('#out'), inner = document.querySelector('#inner'), count=0,width=0,inCre;function changeBackground() &#123; inner.style.width = width+'%'; width++; if(width&lt;=100)&#123; inCre = requestAnimationFrame(changeBackground); &#125;else&#123; cancelAnimationFrame(inCre) &#125;&#125;inCre=requestAnimationFrame(changeBackground)","text":"requestAnimationFrame是什么？在浏览器动画程序中，我们通常使用一个定时器来循环每隔几毫秒移动目标物体一次，来让它动起来。如今有一个好消息，浏览器开发商们决定：“嗨，为什么我们不在浏览器里提供这样一个API呢，这样一来我们可以为用户优化他们的动画。”所以，这个requestAnimationFrame()函数就是针对动画效果的API，你可以把它用在DOM上的风格变化或画布动画或WebGL中。 使用requestAnimationFrame有什么好处？浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。requestAnimationFrame的用法requestAnimationFrame123456789101112131415// usage:// instead of setInterval(render, 16) ....var out = document.querySelector('#out'), inner = document.querySelector('#inner'), count=0,width=0,inCre;function changeBackground() &#123; inner.style.width = width+'%'; width++; if(width&lt;=100)&#123; inCre = requestAnimationFrame(changeBackground); &#125;else&#123; cancelAnimationFrame(inCre) &#125;&#125;inCre=requestAnimationFrame(changeBackground) 对requestAnimationFrame更牢靠的封装Opera浏览器的技术师Erik Möller 把这个函数进行了封装，使得它能更好的兼容各种浏览器。你可以读一读这篇文章，但基本上他的代码就是判断使用4ms还是16ms的延迟，来最佳匹配60fps。下面就是这段代码，你可以使用它，但请注意，这段代码里使用的是标准函数，我给它加上了兼容各种浏览器引擎前缀。requestAnimationFrame123456789101112131415161718192021222324(function() &#123; var lastTime = 0; var vendors = ['webkit', 'moz']; for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame']; &#125; if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); lastTime = currTime + timeToCall; return id; &#125;; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;;&#125;()); requestAnimationFrame APIwindow.requestAnimationFrame(function(/* time */ time){ // time ~= +new Date // the unix time });回调函数里的参数可以传入时间。 各种浏览器对requestAnimationFrame的支持情况caniuse谷歌浏览器，火狐浏览器，IE10+都实现了这个函数，即使你的浏览器很古老，上面的对requestAnimationFrame封装也能让这个方法在IE8/9上不出错。","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}],"keywords":[]},{"title":"你可能并不需要jQuery","slug":"你可能并不需要jQuery","date":"2016-10-11T02:54:55.000Z","updated":"2018-07-12T06:47:06.422Z","comments":true,"path":"2016/10/11/你可能并不需要jQuery/","link":"","permalink":"http://yoursite.com/2016/10/11/你可能并不需要jQuery/","excerpt":"jQuery是非常优秀的工具，它能让我们开发项目时变得更容易，但如果你想从零开始开发一个全新的项目，你应该考虑一下你的项目是否真的需要引入jQuery。 也许你只需要几行技巧性的代码就能解决问题。如果你的项目是面向最新的现代浏览器，你真的可以考虑其它的一些简单的技术来代替jQuery。 浏览器的进步给我们带来了很多先进的JavaScript特征，新出现的原生内置(native)JavaScript功能可以很大程度的实现jQuery提供的功能。如果你能了解这些JavaScript新技术，就能在很多地方用纯JavaScript实现以前需要jQuery才能实现的技术。 新的mvvm框架的出现，数据驱动的方式解决了项目数据交互量大的时候，操作dom的代码混乱的问题。元素操作addClassjQuery$(el).addClass(className);谷歌浏览器，火狐浏览器，IE8+1234if (el.classList) el.classList.add(className);else el.className += &apos; &apos; + className; 谷歌浏览器，火狐浏览器，IE10+el.classList.add(className); AfterjQuery$(el).after(htmlString);谷歌浏览器，火狐浏览器，IE8+el.insertAdjacentHTML(&#39;afterend&#39;, htmlString); AppendjQuery$(parent).append(el);谷歌浏览器，火狐浏览器，IE8+parent.appendChild(el); BeforejQuery$(el).before(htmlString);谷歌浏览器，火狐浏览器，IE8+el.insertAdjacentHTML(&#39;beforebegin&#39;, htmlString); ChildrenjQuery$(el).children();谷歌浏览器，火狐浏览器，IE8+123456var children = [];for (var i = el.children.length; i--;) &#123; // Skip comment nodes on IE8 if (el.children[i].nodeType != 8) children.unshift(el.children[i]);&#125; 谷歌浏览器，火狐浏览器，IE9+el.children","text":"jQuery是非常优秀的工具，它能让我们开发项目时变得更容易，但如果你想从零开始开发一个全新的项目，你应该考虑一下你的项目是否真的需要引入jQuery。 也许你只需要几行技巧性的代码就能解决问题。如果你的项目是面向最新的现代浏览器，你真的可以考虑其它的一些简单的技术来代替jQuery。 浏览器的进步给我们带来了很多先进的JavaScript特征，新出现的原生内置(native)JavaScript功能可以很大程度的实现jQuery提供的功能。如果你能了解这些JavaScript新技术，就能在很多地方用纯JavaScript实现以前需要jQuery才能实现的技术。 新的mvvm框架的出现，数据驱动的方式解决了项目数据交互量大的时候，操作dom的代码混乱的问题。元素操作addClassjQuery$(el).addClass(className);谷歌浏览器，火狐浏览器，IE8+1234if (el.classList) el.classList.add(className);else el.className += &apos; &apos; + className; 谷歌浏览器，火狐浏览器，IE10+el.classList.add(className); AfterjQuery$(el).after(htmlString);谷歌浏览器，火狐浏览器，IE8+el.insertAdjacentHTML(&#39;afterend&#39;, htmlString); AppendjQuery$(parent).append(el);谷歌浏览器，火狐浏览器，IE8+parent.appendChild(el); BeforejQuery$(el).before(htmlString);谷歌浏览器，火狐浏览器，IE8+el.insertAdjacentHTML(&#39;beforebegin&#39;, htmlString); ChildrenjQuery$(el).children();谷歌浏览器，火狐浏览器，IE8+123456var children = [];for (var i = el.children.length; i--;) &#123; // Skip comment nodes on IE8 if (el.children[i].nodeType != 8) children.unshift(el.children[i]);&#125; 谷歌浏览器，火狐浏览器，IE9+el.children ClonejQuery$(el).clone();谷歌浏览器，火狐浏览器，IE8+`el.cloneNode(true);`` ContainsjQuery$.contains(el, child);谷歌浏览器，火狐浏览器，IE8+el !== child &amp;&amp; el.contains(child); Contains SelectorjQuery$(el).find(selector).length;谷歌浏览器，火狐浏览器，IE8+el.querySelector(selector) !== null EachjQuery$(selector).each(function(i, el){});谷歌浏览器，火狐浏览器，IE8+123456function forEachElement(selector, fn) &#123; var elements = document.querySelectorAll(selector); for (var i = 0; i &lt; elements.length; i++) fn(elements[i], i);&#125;forEachElement(selector, function(el, i)&#123;&#125;); 谷歌浏览器，火狐浏览器，IE9+12var elements = document.querySelectorAll(selector);Array.prototype.forEach.call(elements, function(el, i)&#123;&#125;); EmptyjQuery$(el).empty();谷歌浏览器，火狐浏览器，IE8+12while(el.firstChild) el.removeChild(el.firstChild); 谷歌浏览器，火狐浏览器，IE9+el.innerHTML = &#39;&#39;; 过滤jQuery$(selector).filter(filterFn);谷歌浏览器，火狐浏览器，IE8+123456789101112function filter(selector, filterFn) &#123; var elements = document.querySelectorAll(selector); var out = []; for (var i = elements.length; i--;) &#123; if (filterFn(elements[i]))&#123; out.unshift(elements[i]); &#125; &#125; &#125; return out;&#125;filter(selector, filterFn); 谷歌浏览器，火狐浏览器，IE9+Array.prototype.filter.call(document.querySelectorAll(selector), filterFn); 查找子元素jQuery$(el).find(selector);谷歌浏览器，火狐浏览器，IE8+el.querySelectorAll(selector); 查找jQuery$(&#39;.my #awesome selector&#39;);谷歌浏览器，火狐浏览器，IE8+document.querySelectorAll(&#39;.my #awesome selector&#39;); 获取属性值jQuery$(el).attr(&#39;tabindex&#39;);谷歌浏览器，火狐浏览器，IE8+el.getAttribute(&#39;tabindex&#39;); 获取Html内容jQuery$(el).html();谷歌浏览器，火狐浏览器，IE8+el.innerHTML 获取外层Html内容jQuery$(&#39;&lt;div&gt;&#39;).append($(el).clone()).html();谷歌浏览器，火狐浏览器，IE8+el.outerHTML 获取CSS样式jQuery$(el).css(ruleName);谷歌浏览器，火狐浏览器，IE8+// Varies based on the properties being retrieved, some can be retrieved from el.currentStyle// https://github.com/jonathantneal/Polyfills-for-IE8/blob/master/ getComputedStyle.js谷歌浏览器，火狐浏览器，IE9+getComputedStyle(el)[ruleName]; 获取文本内容jQuery$(el).text();谷歌浏览器，火狐浏览器，IE8+el.textContent || el.innerText谷歌浏览器，火狐浏览器，IE9+el.textContent Has ClassjQuery$(el).hasClass(className);谷歌浏览器，火狐浏览器，IE8+123456if (el.classList)&#123; el.classList.contains(className);&#125;else&#123; new RegExp(&apos;(^| )&apos; + className + &apos;( |$)&apos;, &apos;gi&apos;).test(el.className);&#125; 谷歌浏览器，火狐浏览器，IE10+el.classList.contains(className); 元素比较jQuery$(el).is($(otherEl));谷歌浏览器，火狐浏览器，IE8+el === otherEl 比较类名jQuery$(el).is(&#39;.my-class&#39;);谷歌浏览器，火狐浏览器，IE8+1234567891011121314var matches = function(el, selector) &#123; var _matches = (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector); if (_matches) &#123; return _matches.call(el, selector); &#125; else &#123; var nodes = el.parentNode.querySelectorAll(selector); for (var i = nodes.length; i--;) &#123; if (nodes[i] === el) return true; &#125; return false; &#125;&#125;;matches(el, &apos;.my-class&apos;); 谷歌浏览器，火狐浏览器，IE9+1234var matches = function(el, selector) &#123; return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);&#125;;matches(el, &apos;.my-class&apos;); NextjQuery$(el).next();谷歌浏览器，火狐浏览器，IE8+// nextSibling can include text nodes12345function nextElementSibling(el) &#123; do &#123; el = el.nextSibling; &#125; while ( el &amp;&amp; el.nodeType !== 1 ); return el;&#125;el.nextElementSibling || nextElementSibling(el); 谷歌浏览器，火狐浏览器，IE9+el.nextElementSibling OffsetjQuery$(el).offset();谷歌浏览器，火狐浏览器，IE8+12345var rect = el.getBoundingClientRect()&#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft&#125; Offset ParentjQuery$(el).offsetParent();谷歌浏览器，火狐浏览器，IE8+el.offsetParent || el Outer HeightjQuery$(el).outerHeight();谷歌浏览器，火狐浏览器，IE8+el.offsetHeight Outer Height With MarginjQuery$(el).outerHeight(true);谷歌浏览器，火狐浏览器，IE8+12345678function outerHeight(el) &#123; var height = el.offsetHeight; var style = el.currentStyle || getComputedStyle(el); height += parseInt(style.marginTop) + parseInt(style.marginBottom); return height;&#125;outerHeight(el); 谷歌浏览器，火狐浏览器，IE9+12345678function outerHeight(el) &#123; var height = el.offsetHeight; var style = getComputedStyle(el); height += parseInt(style.marginTop) + parseInt(style.marginBottom); return height;&#125;outerHeight(el); Outer Width With MarginjQuery$(el).outerWidth(true);谷歌浏览器，火狐浏览器，IE8+12345678function outerWidth(el) &#123; var width = el.offsetWidth; var style = el.currentStyle || getComputedStyle(el); width += parseInt(style.marginLeft) + parseInt(style.marginRight); return width;&#125;outerWidth(el); 谷歌浏览器，火狐浏览器，IE9+12345678function outerWidth(el) &#123; var width = el.offsetWidth; var style = getComputedStyle(el); width += parseInt(style.marginLeft) + parseInt(style.marginRight); return width;&#125;outerWidth(el); Outer WidthjQuery$(el).outerWidth();谷歌浏览器，火狐浏览器，IE8+el.offsetWidth ParentjQuery$(el).parent();谷歌浏览器，火狐浏览器，IE8+el.parentNode PositionjQuery$(el).position();谷歌浏览器，火狐浏览器，IE8+{left: el.offsetLeft, top: el.offsetTop} Position Relative To ViewportjQuery12345var offset = el.offset();&#123; top: offset.top - document.body.scrollTop, left: offset.left - document.body.scrollLeft&#125; 谷歌浏览器，火狐浏览器，IE8+el.getBoundingClientRect() PrependjQuery$(parent).prepend(el);谷歌浏览器，火狐浏览器，IE8+parent.insertBefore(el, parent.firstChild); PrevjQuery$(el).prev();谷歌浏览器，火狐浏览器，IE8+// prevSibling can include text nodes12345function previousElementSibling(el) &#123; do &#123; el = el.previousSibling; &#125; while ( el &amp;&amp; el.nodeType !== 1 ); return el;&#125;el.previousElementSibling || previousElementSibling(el); 谷歌浏览器，火狐浏览器，IE9+el.previousElementSibling RemovejQuery$(el).remove();谷歌浏览器，火狐浏览器，IE8+el.parentNode.removeChild(el); Remove ClassjQuery$(el).removeClass(className);谷歌浏览器，火狐浏览器，IE8+1234if (el.classList) el.classList.remove(className);else el.className = el.className.replace(new RegExp(&apos;(^|\\\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\\\b|$)&apos;, &apos;gi&apos;), &apos; &apos;); 谷歌浏览器，火狐浏览器，IE10+el.classList.remove(className); Replace From HtmljQuery$(el).replaceWith(string);谷歌浏览器，火狐浏览器，IE8+el.outerHTML = string; Set AttributesjQuery$(el).attr(&#39;tabindex&#39;, 3);谷歌浏览器，火狐浏览器，IE8+el.setAttribute(&#39;tabindex&#39;, 3); Set HtmljQuery$(el).html(string);谷歌浏览器，火狐浏览器，IE8+el.innerHTML = string; Set StylejQuery$(el).css(&#39;border-width&#39;, &#39;20px&#39;);谷歌浏览器，火狐浏览器，IE8+// Use a class if possibleel.style.borderWidth = &#39;20px&#39;; Set TextjQuery$(el).text(string);谷歌浏览器，火狐浏览器，IE8+1234if (el.textContent !== undefined) el.textContent = string;else el.innerText = string; 谷歌浏览器，火狐浏览器，IE9+el.textContent = string; SiblingsjQuery$(el).siblings();谷歌浏览器，火狐浏览器，IE8+1234567var siblings = Array.prototype.slice.call(el.parentNode.children);for (var i = siblings.length; i--;) &#123; if (siblings[i] === el) &#123; siblings.splice(i, 1); break; &#125;&#125; 谷歌浏览器，火狐浏览器，IE9+Array.prototype.filter.call(el.parentNode.children, function(child){ return child !== el; }); Toggle ClassjQuery$(el).toggleClass(className);谷歌浏览器，火狐浏览器，IE8+123456789101112131415if (el.classList) &#123; el.classList.toggle(className);&#125; else &#123; var classes = el.className.split(&apos; &apos;); var existingIndex = -1; for (var i = classes.length; i--;) &#123; if (classes[i] === className) existingIndex = i; &#125; if (existingIndex &gt;= 0) classes.splice(existingIndex, 1); else classes.push(className); el.className = classes.join(&apos; &apos;);&#125; 谷歌浏览器，火狐浏览器，IE9+1234567891011if (el.classList) &#123; el.classList.toggle(className);&#125; else &#123; var classes = el.className.split(&apos; &apos;); var existingIndex = classes.indexOf(className); if (existingIndex &gt;= 0) classes.splice(existingIndex, 1); else classes.push(className); el.className = classes.join(&apos; &apos;);&#125; 谷歌浏览器，火狐浏览器，IE10+el.classList.toggle(className); 事件#### OffjQuery$(el).off(eventName, eventHandler);谷歌浏览器，火狐浏览器，IE8+1234567function removeEventListener(el, eventName, handler) &#123; if (el.removeEventListener) el.removeEventListener(eventName, handler); else el.detachEvent(&apos;on&apos; + eventName, handler);&#125;removeEventListener(el, eventName, handler); 谷歌浏览器，火狐浏览器，IE9+el.removeEventListener(eventName, eventHandler); OnjQuery$(el).on(eventName, eventHandler);谷歌浏览器，火狐浏览器，IE8+12345678910function addEventListener(el, eventName, handler) &#123; if (el.addEventListener) &#123; el.addEventListener(eventName, handler); &#125; else &#123; el.attachEvent(&apos;on&apos; + eventName, function()&#123; handler.call(el); &#125;); &#125;&#125;addEventListener(el, eventName, handler); 谷歌浏览器，火狐浏览器，IE9+el.addEventListener(eventName, eventHandler); ReadyjQuery$(document).ready(function(){});谷歌浏览器，火狐浏览器，IE8+123456789101112function ready(fn) &#123; if (document.readyState != &apos;loading&apos;)&#123; fn(); &#125; else if (document.addEventListener) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, fn); &#125; else &#123; document.attachEvent(&apos;onreadystatechange&apos;, function() &#123; if (document.readyState != &apos;loading&apos;) fn(); &#125;); &#125;&#125; 谷歌浏览器，火狐浏览器，IE9+1234567function ready(fn) &#123; if (document.readyState != &apos;loading&apos;)&#123; fn(); &#125; else &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, fn); &#125;&#125; 指定事件触发jQuery$(el).trigger(&#39;my-event&#39;, {some: &#39;data&#39;});谷歌浏览器，火狐浏览器，IE8+// Custom events are not natively supported, so you have to hijack a rndomevent.// Just use jQuery.谷歌浏览器，火狐浏览器，IE9+1234567if (window.CustomEvent) &#123; var event = new CustomEvent(&apos;my-event&apos;, &#123;detail: &#123;some: &apos;data&apos;&#125;&#125;);&#125; else &#123; var event = document.createEvent(&apos;CustomEvent&apos;); event.initCustomEvent(&apos;my-event&apos;, true, true, &#123;some: &apos;data&apos;&#125;);&#125;el.dispatchEvent(event); Trigger NativejQuery$(el).trigger(&#39;change&#39;);谷歌浏览器，火狐浏览器，IE8+1234567if (document.createEvent) &#123; var event = document.createEvent(&apos;HTMLEvents&apos;); event.initEvent(&apos;change&apos;, true, false); el.dispatchEvent(event);&#125; else &#123; el.fireEvent(&apos;onchange&apos;);&#125; 谷歌浏览器，火狐浏览器，IE9+// For a full list of event types: https://developer.mozilla.org/en-US/docs/Web/API/document.createEvent123var event = document.createEvent(&apos;HTMLEvents&apos;);event.initEvent(&apos;change&apos;, true, false);el.dispatchEvent(event); 技巧Array EachjQuery$.each(array, function(i, item){});谷歌浏览器，火狐浏览器，IE8+12345function forEach(array, fn) &#123; for (i = 0; i &lt; array.length; i++) fn(array[i], i);&#125;forEach(array, function(item, i)&#123;&#125;); 谷歌浏览器，火狐浏览器，IE9+array.forEach(function(item, i){}); 深度扩展jQuery$.extend(true, {}, objA, objB);谷歌浏览器，火狐浏览器，IE8+123456789101112131415161718var deepExtend = function(out) &#123; out = out || &#123;&#125;; for (var i = 1; i &lt; arguments.length; i++) &#123; var obj = arguments[i]; if (!obj) continue; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; if (typeof obj[key] === &apos;object&apos;) deepExtend(out[key], obj[key]); else out[key] = obj[key]; &#125; &#125; &#125; return out;&#125;;deepExtend(&#123;&#125;, objA, objB); BindjQuery$.proxy(fn, context);谷歌浏览器，火狐浏览器，IE8+fn.apply(context, arguments);谷歌浏览器，火狐浏览器，IE9+fn.bind(context);jQuery$.extend({}, objA, objB);谷歌浏览器，火狐浏览器，IE8+12345678910111213var extend = function(out) &#123; out = out || &#123;&#125;; for (var i = 1; i &lt; arguments.length; i++) &#123; if (!arguments[i]) continue; for (var key in arguments[i]) &#123; if (arguments[i].hasOwnProperty(key)) out[key] = arguments[i][key]; &#125; &#125; return out;&#125;;extend(&#123;&#125;, objA, objB); Index OfjQuery$.inArray(item, array);谷歌浏览器，火狐浏览器，IE8+12345678function indexOf(array, item) &#123; for (var i = 0; i &lt; array.length; i++) &#123; if (array[i] === item) return i; &#125; return -1;&#125;indexOf(array, item); 谷歌浏览器，火狐浏览器，IE9+array.indexOf(item); Is ArrayjQuery$.isArray(arr);谷歌浏览器，火狐浏览器，IE8+1234isArray = Array.isArray || function(arr) &#123; return Object.prototype.toString.call(arr) == &apos;[object Array]&apos;;&#125;isArray(arr); 谷歌浏览器，火狐浏览器，IE9+Array.isArray(arr); MapjQuery$.map(array, function(value, index){});谷歌浏览器，火狐浏览器，IE8+123456function map(arr, fn) &#123; var results = []; for (var i = 0; i &lt; arr.length; i++) results.push(fn(arr[i], i)); return results;map(array, function(value, index)&#123;&#125;); 谷歌浏览器，火狐浏览器，IE9+array.map(function(value, index){}); NowjQuery$.now();谷歌浏览器，火狐浏览器，IE8+new Date().getTime();谷歌浏览器，火狐浏览器，IE9+Date.now(); Parse HtmljQuery$.parseHTML(htmlString);谷歌浏览器，火狐浏览器，IE8+123456var parseHTML = function(str) &#123; var el = document.createElement(&apos;div&apos;); el.innerHTML = str; return el.children;&#125;;parseHTML(htmlString); 谷歌浏览器，火狐浏览器，IE9+var parseHTML = function(str) { var tmp = document.implementation.createHTMLDocument(); tmp.body.innerHTML = str; return tmp.body.children; }; parseHTML(htmlString); 解析 JsonjQuery$.parseJSON(string);谷歌浏览器，火狐浏览器，IE8+JSON.parse(string); TrimjQuery$.trim(string);谷歌浏览器，火狐浏览器，IE8+string.replace(/^\\s+|\\s+$/g, &#39;&#39;);谷歌浏览器，火狐浏览器，IE9+string.trim(); TypejQuery$.type(obj);谷歌浏览器，火狐浏览器，IE8+1Object.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, &quot;$1&quot;).toLowerCase(); AJAXJSONjQuery$.getJSON(&#39;/my/url&#39;, function(data) {});谷歌浏览器，火狐浏览器，IE8+1234567891011121314var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onreadystatechange = function() &#123; if (this.readyState === 4) &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123; // Success! var data = JSON.parse(this.responseText); &#125; else &#123; // Error :( &#125; &#125;&#125;;request.send();request = null; 谷歌浏览器，火狐浏览器，IE9+1234567891011121314var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onload = function() &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123; // Success! var data = JSON.parse(request.responseText); &#125; else &#123; // We reached our target server, but it returned an error &#125;&#125;;request.onerror = function() &#123; // There was a connection error of some sort&#125;;request.send(); 谷歌浏览器，火狐浏览器，IE10+1234567891011121314var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onload = function() &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123; // Success! var data = JSON.parse(this.response); &#125; else &#123; // We reached our target server, but it returned an error &#125;&#125;;request.onerror = function() &#123; // There was a connection error of some sort&#125;;request.send(); PostjQuery$.ajax({type: &#39;POST&#39;,url: &#39;/my/url&#39;,data: data});谷歌浏览器，火狐浏览器，IE8+1234var request = new XMLHttpRequest();request.open(&apos;POST&apos;, &apos;/my/url&apos;, true);request.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;);request.send(data); RequestjQuery$.ajax({type: &#39;GET&#39;,url: &#39;/my/url&#39;,success: function(resp) {},error: function() {}});谷歌浏览器，火狐浏览器，IE8+1234567891011121314var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onreadystatechange = function() &#123; if (this.readyState === 4) &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123; // Success! var resp = this.responseText; &#125; else &#123; // Error :( &#125; &#125;&#125;;request.send();request = null; 谷歌浏览器，火狐浏览器，IE9+1234567891011121314var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onload = function() &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123; // Success! var resp = request.responseText; &#125; else &#123; // We reached our target server, but it returned an error &#125;&#125;;request.onerror = function() &#123; // There was a connection error of some sort&#125;;request.send(); 谷歌浏览器，火狐浏览器，IE10+1234567891011121314var request = new XMLHttpRequest();request.open(&apos;GET&apos;, &apos;/my/url&apos;, true);request.onload = function() &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) &#123; // Success! var resp = this.response; &#125; else &#123; // We reached our target server, but it returned an error &#125;&#125;;request.onerror = function() &#123; // There was a connection error of some sort&#125;;request.send(); 特效淡入淡出jQuery$(el).fadeIn();谷歌浏览器，火狐浏览器，IE8+1234567891011121314151617function fadeIn(el) &#123; var opacity = 0; el.style.opacity = 0; el.style.filter = &apos;&apos;; var last = +new Date(); var tick = function() &#123; opacity += (new Date() - last) / 400; el.style.opacity = opacity; el.style.filter = &apos;alpha(opacity=&apos; + (100 * opacity)|0 + &apos;)&apos;; last = +new Date(); if (opacity &lt; 1) &#123; (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16); &#125; &#125;; tick();&#125;fadeIn(el); 谷歌浏览器，火狐浏览器，IE9+fadeIn(el) &#123;123456789101112 el.style.opacity = 0; var last = +new Date(); var tick = function() &#123; el.style.opacity = +el.style.opacity + (new Date() - last) / 400; last = +new Date(); if (+el.style.opacity &lt; 1) &#123; (window.requestAnimationFrame &amp;&amp; requestAnimationFrame(tick)) || setTimeout(tick, 16) &#125; &#125;; tick();&#125;fadeIn(el); 谷歌浏览器，火狐浏览器，IE10+1234el.classList.add(&apos;show&apos;);el.classList.remove(&apos;hide&apos;);.show &#123;transition: opacity 400ms;&#125;.hide &#123;opacity: 0;&#125; HidejQuery$(el).hide();谷歌浏览器，火狐浏览器，IE8+el.style.display = &#39;none&#39;; ShowjQuery$(el).show();谷歌浏览器，火狐浏览器，IE8+el.style.display = &#39;&#39;;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}],"keywords":[]},{"title":"如何避免打开谷歌自动跳转香港GOOGLE.COM.HK","slug":"如何避免打开谷歌自动跳转-香港GOOGLE-COM-HK","date":"2016-10-11T02:24:05.000Z","updated":"2018-07-12T06:47:06.425Z","comments":true,"path":"2016/10/11/如何避免打开谷歌自动跳转-香港GOOGLE-COM-HK/","link":"","permalink":"http://yoursite.com/2016/10/11/如何避免打开谷歌自动跳转-香港GOOGLE-COM-HK/","excerpt":"","text":"谷歌搜索是每个程序员必用都工具，但是在国内我们经常打开谷歌就会自动跳到.HK, 如何避免打开谷歌自动跳转到香港GOOGLE.COM.HK 防止谷歌自动跳转到香港google.com.hk解决办法：123原理：只要告诉Google.com不要进行区域重定向（No Country Redirection, 简称 NCR）。具体做法：在网址栏打入http://www.google.com/ncr，然后回车即可。如果清理了Cookies缓存，还是出现自动跳转现象，重新再在网址栏打入http://www.google.com/ncr输入，回车就行。如果打不开，可能是因为google因触及相关敏感关键词因素，访问受限，过段时间再试，或者通过VPN, Goagent等代理工具进行“番羽土啬”。 知识补充：谷歌自动跳转到香港google.com.hk的原因：谷歌(Google)是目前全球最强的搜索引擎，几乎在全球每个国家和地区都有独立搜索网站（如中国有g.cn 和 google.cn，退出中国市场后，跳转至google.com.hk）全球搜索市场占有率超过75%，为了提升各国google用户有更好的本地搜索体验，google.com根据用户IP进行了区域重定向（或者叫国家重定向）（英文 country Redirection）向这样的设置，这是造成中国大陆&amp;香港用户打开google.com时，自动跳转到google.com.hk的原因。即使选择Google.com.hk首页右下角的英文google.com按钮也不济于事，还是google.com.hk的网址。 谷歌自动跳转到香港google.com.hk造成的不便：对于身处中国大陆的人士，想搜索更多国外有价值信息而言，google.com明显比google.com.hk更能胜任。这种区域重定向显然给这部分人士带来了诸多不便。 小提醒：在中国访问google.com的搜索结果，还是和在美国本地访问搜索结果有所不同。这也同样涉及到Google排名算法的本地优先原则。","categories":[],"tags":[{"name":"google","slug":"google","permalink":"http://yoursite.com/tags/google/"}],"keywords":[]},{"title":"使用webpack压缩图片中遇到的问题","slug":"使用webpack压缩图片遇到的问题","date":"2016-10-10T07:50:08.000Z","updated":"2018-07-12T06:47:06.424Z","comments":true,"path":"2016/10/10/使用webpack压缩图片遇到的问题/","link":"","permalink":"http://yoursite.com/2016/10/10/使用webpack压缩图片遇到的问题/","excerpt":"","text":"因为换了笔记本，所以开发环境从mac变成了linux。从svn把代码拉下来后遇到的问题记录在此。 代码基本运行良好，但是在使用image-webpack-loader时，编译出错…大意如此：png-bin/gifs-bin等等出错。在so上爬贴，终于找到了解决方案，这个问题看起来是常出现的，随手记录。原贴在这里 解决办法也很简单：1234567891011121314151617I can say the cause is pngquant-bin module. I couldn&apos;t track it down to a submodule because after specifying a version, it&apos;s auto-fixed:&#123; &quot;pngquant-bin&quot;: &quot;0.1.6&quot;, &quot;gifsicle&quot;: &quot;0.1.4&quot;, &quot;jpegtran-bin&quot;: &quot;0.2.3&quot;, &quot;optipng-bin&quot;: &quot;0.3.1&quot;, &quot;pngquant-bin&quot;: &quot;0.1.6&quot; &#125;This in my package.json fixed the issueImportant note: specify those in your package.json, CLEAN node_modules directory (completely, even .bin directory), restart your computer, I think it&apos;s an issue with environment or a link to an exe that doesn&apos;t exist, I don&apos;t know, but I didn&apos;t want to track it down so restarting was ok (one time). After restart, run npm install and it should work. 把{ “pngquant-bin”: “0.1.6”, “gifsicle”: “0.1.4”, “jpegtran-bin”: “0.2.3”, “optipng-bin”: “0.3.1”, “pngquant-bin”: “0.1.6”}加入package.json中，删掉node_modules文件夹，重启，重装依赖，重启。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}],"keywords":[]},{"title":"使用nvm安装node","slug":"使用nvm安装node","date":"2016-10-10T03:08:25.000Z","updated":"2018-07-12T06:47:06.423Z","comments":true,"path":"2016/10/10/使用nvm安装node/","link":"","permalink":"http://yoursite.com/2016/10/10/使用nvm安装node/","excerpt":"","text":"如果你想长期做 node 开发, 或者想快速更新 node 版本, 或者想快速切换 node 版本,那么在非 Windows(如 osx, linux) 环境下, 请使用 nvm 来安装你的 node 开发环境, 保持系统的干净.如果你使用 Windows 做开发, 那么你可以使用 nvmw 来替代 nvm git clone nvm直接从 github clone nvm 到本地, 这里假设大家都使用 ~/git 目录存放 git 项目:$ cd ~/git $ git clone https://github.com/creationix/nvm.git 配置终端启动时自动执行 source ~/git/nvm/nvm.sh,在 ~/.zshrc 文件添加以下命令:source ~/git/nvm/nvm.sh重新打开你的终端, 输入 nvm123$ nvmNode Version Manager... 通过 nvm 安装任意版本的 nodenvm 默认是从 http://nodejs.org/dist/ 下载的, 国外服务器, 必然很慢,好在 nvm 以及支持从镜像服务器下载包, 于是我们可以方便地从七牛的 node dist 镜像下载:1$ NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm ls-remote 就可以看到远程服务器上的node版本，选择一个进行安装nvm install v4.6.0(nodevesion)即可。于是你就会看到一段非常快速进度条:12######################################################################## 100.0%Now using node v4.6.0 如果你不想每次都输入环境变量 NVM_NODEJS_ORG_MIRROR, 那么我建议你加入到 .zshrc 文件中:123# nvmexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodesource ~/git/nvm/nvm.sh 然后你可以继续非常方便地安装各个版本的 node 了, 你可以查看一下你当前已经安装的版本: $ nvm ls nvm v0.8.26 v0.10.26 v0.11.11-&gt; v4.3.2","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}],"keywords":[]},{"title":"linux中使用deepinQQ","slug":"linux中使用deepinQQ","date":"2016-10-10T02:09:38.000Z","updated":"2018-07-12T06:47:06.419Z","comments":true,"path":"2016/10/10/linux中使用deepinQQ/","link":"","permalink":"http://yoursite.com/2016/10/10/linux中使用deepinQQ/","excerpt":"","text":"linux 运行QQ我们知道在deepin linux上面，deepin团队做了很多wine的应用程序，但是在其他的linux发行版上却没有这种待遇，下面介绍一下，如何在继续debian的linux发行版上运行deepin的wine应用程序。 本文基于ubuntu16.04 安装crossovercrossover百度网盘下载 注：资源文件夹里面有多个版本的crossover，后缀加了free是临时破解版，请支持正版，但是存在部分功能性问题，不影响deepinwine的软件包使用。没有free的没有功能性问题，但是可能出现deepinwine软件兼容性问题，试用15天的，如果支持crossover的朋友请购买正版。建议大家来回覆盖安装这两个版本使用，基本可以互补。如果有兴趣的朋友可以和我一起讨论研究解决问题。对于什么是来回覆盖安装，举个例子：free版是不能创建容器的，那么我们先安装不是free的版本也就是试用版，把容器创建好了以后，在覆盖安装free版就可以使用了。所以两个版本功能是互补的，虽然麻烦，但还是不影响正常使用的。 添加32位库的支持如果是64位系统，先添加对32位库的支持：1234sudo dpkg --add-architecture i386sudo apt-get update###### 可能需要添加下列32位库sudo apt-get install lib32z1 lib32ncurses5 安装crossover如果要安装14版本，从上面的分享地址里下载crossover_14.1.11-1_all.deb crossover_14.1.11-1_all-free.deb deepin-crossover_0.5.14_all.deb三个文件,依次安装。如果安装15，crossover-15_15.0.3-1_all.deb crossover-15_15.0.3-1_all-free.deb deepin-crossover-helper_1.0deepin0_all.deb 并依次安装。 安装deepin的wine程序QQ 8.x，需要Crossover 15QQ 7.x 支持Crossover 14其他的deepin wine程序 下载，实际上这就是deepin的源 都是deb包，可以直接下载安装。 遇到的问题 安装后启动不起来：重启系统。 点击QQ的退出后，QQ在后台并没有真正关闭。这是需要ps -A |grep QQ,列出所有QQ程序，然后kill掉就可以了。","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"},{"name":"software","slug":"software","permalink":"http://yoursite.com/tags/software/"}],"keywords":[]},{"title":"在ubuntu上安装apache2及mysql","slug":"在ubuntu上安装apache2及mysql","date":"2016-10-09T07:12:20.000Z","updated":"2018-07-12T06:47:06.425Z","comments":true,"path":"2016/10/09/在ubuntu上安装apache2及mysql/","link":"","permalink":"http://yoursite.com/2016/10/09/在ubuntu上安装apache2及mysql/","excerpt":"","text":"安装Apachesudo apt-get install apache2Apache安装完成后，默认的网站根目录是”/var/www/html”，在终端窗口中输入ls /var/www/html,在网站根目录下有一个”index.html”文件,在浏览器中输入”localhost”,就可以打开该页面。 修改网站的根目录 在终端窗口中输入sudo vi /etc/apache2/apache2.conf,找到的位置,更改”/var/www/“为新的根目录”/var/Sites/“就可以了。 在终端窗口中输入sudo vi /etc/apache2/sites-available/000-default.conf,DocumentRoot /var/www/html的位置,更改”/var/www/html”为新的根目录就可以了，这里我把它更改为”/var/Sites/“。 安装mysqlsudo apt-get install mysql-server","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}],"keywords":[]},{"title":"ubuntu1604 git结合beyond compare","slug":"ubuntu1604-git结合beyond-compare","date":"2016-10-09T03:29:28.000Z","updated":"2018-07-12T06:47:06.420Z","comments":true,"path":"2016/10/09/ubuntu1604-git结合beyond-compare/","link":"","permalink":"http://yoursite.com/2016/10/09/ubuntu1604-git结合beyond-compare/","excerpt":"","text":"在beyond compare官网下载Debian选项的安装包，然后dpkg -i *.deb安装依赖等。在~/.gitconfig文件中增加：12345678[diff] tool = bc3[difftool] prompt = false[merge] tool = bc3[mergetool] prompt = false 当执行git difftool的时候，就会启动bcompare比较","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}],"keywords":[]},{"title":"ubuntu设置杂记","slug":"ubuntu 设置杂记","date":"2016-10-08T07:13:34.000Z","updated":"2018-07-12T06:47:06.420Z","comments":true,"path":"2016/10/08/ubuntu 设置杂记/","link":"","permalink":"http://yoursite.com/2016/10/08/ubuntu 设置杂记/","excerpt":"","text":"在任务栏显示网速123sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install indicator-netspeed 设置显示桌面快捷键如果想设置“显示桌面”为“win + D”，步骤如下：12sudo apt-get install compizconfig-settings-managerccsm","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}],"keywords":[]},{"title":"网易云音乐官方linux版！","slug":"网易云音乐官方linux版！","date":"2016-10-08T06:43:34.000Z","updated":"2018-07-12T06:47:06.426Z","comments":true,"path":"2016/10/08/网易云音乐官方linux版！/","link":"","permalink":"http://yoursite.com/2016/10/08/网易云音乐官方linux版！/","excerpt":"","text":"记得以前用的还是开源版本的一个网易云音乐，今天去找，居然发现官方版粗现了~~~网易云果然是良心。安装方法：dpkg -i *.deb","categories":[],"tags":[{"name":"software","slug":"software","permalink":"http://yoursite.com/tags/software/"}],"keywords":[]},{"title":"github添加ssh-key之后push还要输入账号密码的解决方法","slug":"key之后push还要输入账号密码的解决方法","date":"2016-10-08T06:30:09.000Z","updated":"2018-07-12T06:47:06.418Z","comments":true,"path":"2016/10/08/key之后push还要输入账号密码的解决方法/","link":"","permalink":"http://yoursite.com/2016/10/08/key之后push还要输入账号密码的解决方法/","excerpt":"","text":"ssh-keygen -t rsa -C “your_email@example.com”将生成的公钥添加后,但是push的时候还是要输入账号密码。 这是因为clone的时候应该使用ssh的方法，而现在用的是https方法。只需要克隆的时候在github上选择ssh而不是https就可以了(clone的地址下面有)。如果是已经克隆好的只需要改config就可以vim .git/config像下面改url12[remote &quot;origin&quot;]url = git@github.com:wxrbwran/hexo-blog.git","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"安装ubuntu后要做的几件事","slug":"安装ubuntu后要做的几件事","date":"2016-10-08T05:19:10.000Z","updated":"2018-07-12T06:47:06.426Z","comments":true,"path":"2016/10/08/安装ubuntu后要做的几件事/","link":"","permalink":"http://yoursite.com/2016/10/08/安装ubuntu后要做的几件事/","excerpt":"","text":"这几天自己的笔记本坏了，屏幕闪现，几个按键也失灵了…这次上船的姿势可能不对，哎… 闲话少说，换了公司的备用机，重装ubuntu，之后还有很多事要做，记录在此。 更换安装源。国外的源一是特别慢，第二就是大家都懂得～打开System Setting-&gt; Software &amp; Update,在Ubuntu Softwaretab下”Download from”选择阿里云的源。 挂载NTFS磁盘。现在基本默认自动挂载，但有时也会出错，比如我这次。解决也很简单： 检查ntfs-3g 是否已经安装 locate ntfs-3g 若是有一大堆反馈，那么就是已经安装了，要是没有安装，输入下面代码sudo apt install ntfs-3g 挂载的错误。可能一般都是这个吧，除非你一直都不可以访问sudo ntfsfix /dev/sda5不同的分区，记得更换位置与名称，我的是上图中的sda5 挂载ExFat格式U盘。fat格式不支持大文件，ntfs或者hfs日志格式不适合U盘，只好使用exfat咯。支持大文件，并且不是日志式。不过ubuntu默认不支持，需要下载软件支持，一句话解决： sudo apt install exfat-utils 安装flash。这个就是纯粹娱乐了，直接去adobe官网,选择APT方式下载就好了。 安装pip3。现在的linux发行版基本都支持python了，人生苦短，我用python~ sudo apt-get install python3-pip 安装windows字体。好多文件和网页由于字体不全都不怎么好看，那我们直接把windows的字体拷过来就好了。windows字体文件在C:\\windows\\fonts目录下，cp到/usr/share/fonts目录新建winfonts文件夹中，然后: mkfontscale mkfontdir fc-cache 换ubuntu了，markdown用什么写呢？ sudo apt install retext","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}],"keywords":[]},{"title":"Javascript数据结构:队列","slug":"javascript数据结构-队列","date":"2016-10-02T02:15:27.000Z","updated":"2018-07-12T06:47:06.418Z","comments":true,"path":"2016/10/02/javascript数据结构-队列/","link":"","permalink":"http://yoursite.com/2016/10/02/javascript数据结构-队列/","excerpt":"","text":"队列是遵循FIFO(First In First Out,先进先出,也称为先来先服务)原则的一组有序的项。 队列在尾部添加新元素,并从顶部移除元素。最新添加的元素必须排在队列的末尾。在现实中,最常见的队列的例子就是排队，在电影院、自助餐厅、杂货店收银台,我们也都会排队。排在第一位的人会先接受服务。 创建队列队列方法 enqueue(element(s)):向队列尾部添加一个(或多个)新的项。 dequeue():移除队列的第一(即排在队列最前面的)项,并返回被移除的元素。 front():返回队列中第一个元素——最先被添加,也将是最先被移除的元素。队列不做任何变动(不移除元素,只返回元素信息——与Stack类的peek方法非常类似)。 isEmpty():如果队列中不包含任何元素,返回true,否则返回false。 size():返回队列包含的元素个数,与数组的length属性类似。Queue123456789101112131415161718192021funcion Queue()&#123; var items = []; this.enqueue = function(ele)&#123; items.push(ele) &#125; this.dequeue = function()&#123; return items.unshift(); &#125; this.front = function()&#123; return items[0] &#125; this.isEmpty = function()&#123; return items.length===0 &#125; this.size = function()&#123; return items.length &#125; this.print = function()&#123; console.log(items.toString()) &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"Javascript 数据结构:栈","slug":"javascript-数据结构-栈","date":"2016-09-30T09:03:14.000Z","updated":"2018-07-12T06:47:06.417Z","comments":true,"path":"2016/09/30/javascript-数据结构-栈/","link":"","permalink":"http://yoursite.com/2016/09/30/javascript-数据结构-栈/","excerpt":"","text":"栈是一种遵从后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的 末尾,称作栈顶,另一端就叫栈底。在栈里,新元素都靠近栈顶,旧元素都接近栈底。在现实生活中也能发现很多栈的例子。例如,下图里的一摞书或者餐厅里堆放的盘子。 栈的创建栈的方法: push(element(s)):添加一个(或几个)新元素到栈顶。 pop():移除栈顶的元素,同时返回被移除的元素。 peek():返回栈顶的元素,不对栈做任何修改(这个方法不会移除栈顶的元素,仅仅返回它)。 isEmpty():如果栈里没有任何元素就返回true,否则返回false。 clear():移除栈里的所有元素。 size():返回栈里的元素个数。这个方法和数组的length属性很类似。使用数组来保存栈里的元素。 Stack123456789101112131415161718192021222324funcion Stack()&#123; var items = []; this.push = function(ele)&#123; items.push(ele) &#125;; this.pop = function()&#123; return items.pop() &#125;; this.peek = function()&#123; return items[items.length-1] &#125;; this.isEmpty = function()&#123; return items.length ===0 &#125;; this.clear = function()&#123; items.lenth=0 &#125;; this.size = function()&#123; return items.length &#125;; this.print = function()&#123; console.log(items.toString()) &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]}]}