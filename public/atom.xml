<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓然的自留地</title>
  
  <subtitle>路漫漫，上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-09T02:54:30.495Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>织幻z</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭建nextjs脚手架遇到的问题及解决</title>
    <link href="http://yoursite.com/2019/05/08/%E6%90%AD%E5%BB%BAnextjs%E8%84%9A%E6%89%8B%E6%9E%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2019/05/08/搭建nextjs脚手架遇到的问题及解决/</id>
    <published>2019-05-08T09:44:02.000Z</published>
    <updated>2019-05-09T02:54:30.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>nextjs</strong>是react的ssr后端渲染框架，在搭建过程中遇到一些问题，再次记录下来。</p><ol><li>使用antd ui框架，同时使用scss预处理器，在next.config.js中同时使用<del>with-less</del>和<del>with-sass</del>,并没有达到预期中的结果，scss文件解析正常，antd样式全丢。</li><li>实现antd的按需加载</li><li>使用typescript，如何配置。<a id="more"></a></li></ol><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>在next官网上告诉我们的with-sass,with-less串联的方法并不管用，需要自己新建next.config.js文件，配置loader。但是有个特例，<strong>with-typescript</strong>，我们把上面修改好的webpack配置传给他就可以开启typescript支持了，所有代码在下面。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> withTypescript = <span class="built_in">require</span>(<span class="string">'@zeit/next-typescript'</span>);</span><br><span class="line"><span class="keyword">const</span> cssLoaderConfig = <span class="built_in">require</span>(<span class="string">'@zeit/next-css/css-loader-config'</span>);</span><br><span class="line"><span class="keyword">const</span> lessToJS = <span class="built_in">require</span>(<span class="string">'less-vars-to-js'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> themeVariables = lessToJS(</span><br><span class="line">  fs.readFileSync(path.resolve(__dirname, <span class="string">'./assets/antd-custom.less'</span>), <span class="string">'utf8'</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fix: prevents error when .less files are required by node</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">require</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>.extensions[<span class="string">'.less'</span>] = <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = withTypescript(&#123;</span><br><span class="line">  pageExtensions: [<span class="string">'jsx'</span>, <span class="string">'js'</span>, <span class="string">'ts'</span>, <span class="string">'tsx'</span>],</span><br><span class="line">  webpack(config, options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!options.defaultLoaders) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'This plugin is not compatible with Next.js versions below 5.0.0 https://err.sh/next-plugins/upgrade'</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; dev, defaultLoaders, isServer &#125; = options;</span><br><span class="line">    <span class="comment">// const nextConfig = &#123;&#125;;</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      cssModules,</span><br><span class="line">      cssLoaderOptions,</span><br><span class="line">      postcssLoaderOptions,</span><br><span class="line">      lessLoaderOptions = &#123;&#125;,</span><br><span class="line">    &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'options.defaultLoaders'</span>, defaultLoaders);</span><br><span class="line"></span><br><span class="line">    config.resolve.extensions.push(<span class="string">'.ts'</span>, <span class="string">'.tsx'</span>);</span><br><span class="line">    config.resolve.alias = <span class="built_in">Object</span>.assign(&#123;&#125;, config.resolve.alias, &#123;</span><br><span class="line">      <span class="string">'@utils'</span>: path.resolve(__dirname, <span class="string">'utils'</span>),</span><br><span class="line">      <span class="string">'@assets'</span>: path.resolve(__dirname, <span class="string">'assets'</span>),</span><br><span class="line">      <span class="string">'@pages'</span>: path.resolve(__dirname, <span class="string">'pages'</span>),</span><br><span class="line">      <span class="string">'@components'</span>: path.resolve(__dirname, <span class="string">'components'</span>),</span><br><span class="line">      <span class="string">'@services'</span>: path.resolve(__dirname, <span class="string">'services'</span>),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    defaultLoaders.less = cssLoaderConfig(config, &#123;</span><br><span class="line">      extensions: [<span class="string">'less'</span>],</span><br><span class="line">      cssModules,</span><br><span class="line">      cssLoaderOptions,</span><br><span class="line">      postcssLoaderOptions,</span><br><span class="line">      dev,</span><br><span class="line">      isServer,</span><br><span class="line">      loaders: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'less-loader'</span>,</span><br><span class="line">          options: lessLoaderOptions,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    config.module.rules.push(&#123;</span><br><span class="line">      test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      use: options.defaultLoaders.less,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们禁用了antd的cssModules</span></span><br><span class="line">    config.module.rules.push(&#123;</span><br><span class="line">      test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      include: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      use: cssLoaderConfig(config, &#123;</span><br><span class="line">        extensions: [<span class="string">'less'</span>],</span><br><span class="line">        cssModules: <span class="literal">false</span>,</span><br><span class="line">        cssLoaderOptions: &#123;&#125;,</span><br><span class="line">        dev,</span><br><span class="line">        isServer,</span><br><span class="line">        loaders: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'less-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              javascriptEnabled: <span class="literal">true</span>,</span><br><span class="line">              modifyVars: themeVariables,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    config.module.rules.push(&#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      use: cssLoaderConfig(config, &#123;</span><br><span class="line">        extensions: [<span class="string">'scss'</span>],</span><br><span class="line">        cssModules: <span class="literal">true</span>,</span><br><span class="line">        cssLoaderOptions: &#123;</span><br><span class="line">          importLoaders: <span class="number">1</span>,</span><br><span class="line">          localIdentName: <span class="string">'[local]_[hash:base64:6]'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        dev,</span><br><span class="line">        isServer,</span><br><span class="line">        loaders: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              data: <span class="string">'@import "_base.scss";'</span>,</span><br><span class="line">              includePaths: [path.resolve(<span class="string">'./styles'</span>)],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (dev) &#123;</span><br><span class="line">      config.module.rules.push(&#123;</span><br><span class="line">        test: <span class="regexp">/\.(ts|tsx|js|jsx)$/</span>,</span><br><span class="line">        enforce: <span class="string">'pre'</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          configFile: path.resolve(<span class="string">'.eslintrc'</span>),</span><br><span class="line">          eslint: &#123;</span><br><span class="line">            configFile: path.resolve(__dirname, <span class="string">'.eslintrc'</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">          fix: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      config.devtool = <span class="string">'cheap-module-eval-source-map'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>这样less和scss,ts就可以同时使用了.</p><ol><li>常规操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add  babel-plugin-impor</span><br></pre></td></tr></table></figure><p>修改babelrc (add .babelrc file in your project)<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [</span><br><span class="line">        <span class="string">"next/babel"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"import"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"libraryName"</span>: <span class="string">"antd"</span>,</span><br><span class="line">                <span class="attr">"libraryDirectory"</span>:<span class="string">"lib"</span>,</span><br><span class="line">                <span class="attr">"style"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;nextjs&lt;/strong&gt;是react的ssr后端渲染框架，在搭建过程中遇到一些问题，再次记录下来。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用antd ui框架，同时使用scss预处理器，在next.config.js中同时使用&lt;del&gt;with-less&lt;/del&gt;和&lt;del&gt;with-sass&lt;/del&gt;,并没有达到预期中的结果，scss文件解析正常，antd样式全丢。&lt;/li&gt;
&lt;li&gt;实现antd的按需加载&lt;/li&gt;
&lt;li&gt;使用typescript，如何配置。
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="ssr" scheme="http://yoursite.com/tags/ssr/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 16.04 安装 postgresql 10</title>
    <link href="http://yoursite.com/2018/11/05/ubuntu-16-04-%E5%AE%89%E8%A3%85-postgresql-10/"/>
    <id>http://yoursite.com/2018/11/05/ubuntu-16-04-安装-postgresql-10/</id>
    <published>2018-11-05T08:01:24.000Z</published>
    <updated>2019-05-09T03:04:37.106Z</updated>
    
    <content type="html"><![CDATA[<p>添加postgreql源</p><blockquote><p>$ wget -q <a href="https://www.postgresql.org/media/keys/ACCC4CF8.asc" target="_blank" rel="noopener">https://www.postgresql.org/media/keys/ACCC4CF8.asc</a> -O - | sudo apt-key add -<br>  $ sudo sh -c ‘echo “deb <a href="http://apt.postgresql.org/pub/repos/apt/" target="_blank" rel="noopener">http://apt.postgresql.org/pub/repos/apt/</a> <code>lsb_release -cs</code>-pgdg main” &gt;&gt; /etc/apt/sources.list.d/pgdg.list’</p></blockquote><p>安装 postgresql</p><blockquote><p>$ sudo apt-get update<br>  $ sudo apt-get install postgresql postgresql-contrib libpq-dev</p></blockquote><p>添加用户</p><blockquote><p>$ sudo -u postgres createuser –superuser roleuser</p></blockquote><p>设置密码</p><blockquote><p>$ sudo -u postgres psql<br>   \password postgres<br>   \q</p></blockquote><p>修改配置 pg_hba.conf</p><blockquote><p>local   all             all                                     trust #修改peer为trust</p></blockquote><p>修改设置postgresql.conf，让postgresql可远程访问</p><blockquote><p>listen_addresses = ‘*’</p></blockquote><p>在 pg_hba.conf 中添加</p><blockquote><p>host    all         all         192.168.1.0/24          md5</p></blockquote><p>192.168.1.0 ip换为自己的ip，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;添加postgreql源&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ wget -q &lt;a href=&quot;https://www.postgresql.org/media/keys/ACCC4CF8.asc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ht
      
    
    </summary>
    
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>使用travis-ci实现持续部署</title>
    <link href="http://yoursite.com/2018/07/31/%E4%BD%BF%E7%94%A8travis-ci%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/07/31/使用travis-ci实现持续部署/</id>
    <published>2018-07-31T10:16:17.000Z</published>
    <updated>2019-05-09T03:04:37.106Z</updated>
    
    <content type="html"><![CDATA[<p>前面已经使用travis部署自己的gitpage了，有些方法可以扩展到部署项目。这样就能够在我提交代码的时候，travis就可以就自动更新服务器的代码，并自动构建。<br>通过git clone命令把这个项目克隆到本地，然后在项目根目录下添加一个<strong>.travis.yml</strong>文件。这个文件是travis-ci持续集成的关键，它定义了你所有持续集成的操作。为了简单起见，我们仅仅使用它进行自动化部署：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">- &quot;10&quot;</span><br><span class="line">after_success:</span><br><span class="line">- ssh root@xxx.xxx.xxx.xxx -p yyy &apos;cd /home/www/project &amp;&amp; git pull &amp;&amp; npm run build&apos;</span><br></pre></td></tr></table></figure></p><p>配置ssh登录，前面已经写过。这样就可以登录远程服务器并完成，但是暴露密码总是不可以的…</p><h3 id="travis-免密登录"><a href="#travis-免密登录" class="headerlink" title="travis 免密登录"></a>travis 免密登录</h3><ol><li>在本地通过gem安装travis命令行工具（macOS默认支持ruby）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br></pre></td></tr></table></figure></li></ol><p>使用travis登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis login</span><br></pre></td></tr></table></figure></p><p>然后输入github的账号密码即可。<br>加密本地ssh-key并自动写入.travis.yml：<br><strong> –add参数表示自动添加脚本到.travis.yml文件中</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis encrypt-file ~/.ssh/id_rsa --add</span><br></pre></td></tr></table></figure></p><p>这时会看到.travis.yml多了一段before_install的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before_install:</span><br><span class="line">- openssl aes-256-cbc -K $encrypted_e65149523857_key -iv $encrypted_e65149523857_iv</span><br><span class="line">  -in id_rsa.enc -out ~\/.ssh/id_rsa -d</span><br></pre></td></tr></table></figure></p><p>然后把最后一行的“\”转义符删掉，并换行顶格添加如下两条内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- chmod 600 ~/.ssh/id_rsa</span><br><span class="line">- echo -e &quot;Host xxx.xxx.xxx.xxx\n\tStrictHostKeyChecking no\n&quot; &gt;&gt; ~/.ssh/config</span><br></pre></td></tr></table></figure></p><p>切记把xxx.xxx.xxx.xxx换成你服务器的IP。<br>最后把添加.travis.yml的项目push到github即可。<br>重新回到travis-ci.org的页面，进入项目，就能够看到持续集成的效果了。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>使用travis登录远程服务器已经达成，拉去代码也可以，但是这次遇到一个问题：<strong>zsh:1: commad not found:npm</strong>，明明手动登录可以使用npm的，travis就不可以了呢？<br>排查了下发现原因是因为node是使用nvm管理的，npm不在<strong>/usr/bin</strong>下导致的，那一个解决方案就<a href="https://nodejs.org/zh-cn/download/package-manager/#debian-and-ubuntu-based-linux-distributions" target="_blank" rel="noopener">通过包管理器方式安装 Nodejs</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面已经使用travis部署自己的gitpage了，有些方法可以扩展到部署项目。这样就能够在我提交代码的时候，travis就可以就自动更新服务器的代码，并自动构建。&lt;br&gt;通过git clone命令把这个项目克隆到本地，然后在项目根目录下添加一个&lt;strong&gt;.travi
      
    
    </summary>
    
    
      <category term="travis" scheme="http://yoursite.com/tags/travis/"/>
    
  </entry>
  
  <entry>
    <title>使用SSH登录远程服务器</title>
    <link href="http://yoursite.com/2018/07/31/%E4%BD%BF%E7%94%A8SSH%E7%99%BB%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/31/使用SSH登录远程服务器/</id>
    <published>2018-07-31T01:58:11.000Z</published>
    <updated>2019-05-09T02:54:30.493Z</updated>
    
    <content type="html"><![CDATA[<p>一般使用ssh访问远程服务器的命令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@ip地址</span><br></pre></td></tr></table></figure></p><p>例如：ssh root@112.232.12.12，然后输入密码即可访问。<br>&lt;–more–&gt;</p><h3 id="以Mac-OS为例，别名登录"><a href="#以Mac-OS为例，别名登录" class="headerlink" title="以Mac OS为例，别名登录"></a>以Mac OS为例，别名登录</h3><p>使用cd ~/.ssh/ 进入ssh目录，会看到有config、known_hosts两个文件，一般的没有设置的话，只会有known_hosts，可以使用touch config命令创建config文件。</p><p>使用vim编辑config文件，添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host txy</span><br><span class="line">HostName 1xx.1xx.1xx.1</span><br><span class="line">User root</span><br><span class="line">IdentitiesOnly yes</span><br></pre></td></tr></table></figure></p><p>其中：<br>1、Host 后边的是别名，以后可以根据这个名称进行访问；<br>2、HostName是你的主机IP地址；<br>3、User为主机登录的用户名；<br>4、IdentitiesOnly yes固有配置；</p><p>设置完成，后期的话使用:ssh txy 然后输入密码，就可以登录到远程主机啦！</p><h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3><p>每次登录SH都需要输入密码很麻烦，而且可能不太安全。SSH还能使用另外一种登录方式，也就是使用密钥登录。这种登录方式需要客户端生成一堆公钥私钥对，然后将公钥添加到服务器中，这样下次就可以直接登录了。</p><p>首先生成SSH密钥，依照提示输入信息即可。默认生成在用户主目录中的.ssh文件夹中。带pub的是公钥，接下来需要添加到服务器中。</p><p>然后登陆服务器，打开.ssh文件夹，在authorized_keys中添加到对应公钥。然后退出SSH重新登陆试试，成功的话不需要输入密码就会直接进入远程服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般使用ssh访问远程服务器的命令是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>将git项目推送到多个地址</title>
    <link href="http://yoursite.com/2018/07/12/%E5%B0%86git%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0%E5%A4%9A%E4%B8%AA%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2018/07/12/将git项目推送到多个地址/</id>
    <published>2018-07-12T03:53:45.000Z</published>
    <updated>2019-05-09T02:54:30.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git设置"><a href="#git设置" class="headerlink" title="git设置"></a>git设置</h3><p>公司开发项目迁移，中间大约一周左右的测试期，两边地址都要上传，那么如何方便快捷的把代码托管到多个平台呢？<br>例如我有下面两个仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://gitlab.com/***/doctor.git </span><br><span class="line">https://github.com/***/doctor.git</span><br></pre></td></tr></table></figure></p><p>先添加第一个仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://gitlab.com/***/doctor.git</span><br></pre></td></tr></table></figure></p><p>再添加第二个仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url --add origin https://github.com/***/doctor.git</span><br></pre></td></tr></table></figure></p><p>如果还有其他，则可以像添加第二个一样继续添加其他仓库。</p><p>然后使用下面命令提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin --all</span><br><span class="line">或者特定分支</span><br><span class="line">git push origin [branch]</span><br></pre></td></tr></table></figure></p><p>打开.git/config，可以看到这样的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">  url = https://github.com/***/doctor.git</span><br><span class="line">  fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">  url = https://gitlab.com/***/doctor.git</span><br></pre></td></tr></table></figure></p><p>刚才的命令其实就是添加了这些配置。如果不想用命令行，可以直接编辑该文件，添加对应的url即可。<br><strong>如果两个地址的账号还不一样呢？</strong></p><h3 id="多账号ssh设置"><a href="#多账号ssh设置" class="headerlink" title="多账号ssh设置"></a>多账号ssh设置</h3><p>首先生成另一个ssh公钥， 比如id_rsa_doctor,id_rsa_doctor.pub，<br>然后配置<strong>.ssh</strong>文件夹下的config文件，没有的话建立。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host default</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">#second 第二个账号</span><br><span class="line">Host second</span><br><span class="line">    HostName gitlab.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_doctor</span><br></pre></td></tr></table></figure></p><p>这样的话就可以一次操作后，提交到两个仓库地址了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;git设置&quot;&gt;&lt;a href=&quot;#git设置&quot; class=&quot;headerlink&quot; title=&quot;git设置&quot;&gt;&lt;/a&gt;git设置&lt;/h3&gt;&lt;p&gt;公司开发项目迁移，中间大约一周左右的测试期，两边地址都要上传，那么如何方便快捷的把代码托管到多个平台呢？&lt;br&gt;例如
      
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>代码分割结合 Prefetch 完美优化单页应用加载性能</title>
    <link href="http://yoursite.com/2017/10/11/%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2%E7%BB%93%E5%90%88-Prefetch-%E5%AE%8C%E7%BE%8E%E4%BC%98%E5%8C%96%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%8A%A0%E8%BD%BD%E6%80%A7%E8%83%BD/"/>
    <id>http://yoursite.com/2017/10/11/代码分割结合-Prefetch-完美优化单页应用加载性能/</id>
    <published>2017-10-11T09:26:46.000Z</published>
    <updated>2018-07-12T06:47:06.421Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>单页应用性能的最大痛点就是 bundle 体积大导致首屏时间过长。使用 webpack 的 code splitting（代码分割）功能可以将 bundle 分片，加速首屏，但之后的交互势必会受到影响,页面变得不再流畅，稍有卡顿，所以放弃了分片，但是现在发现有webpack插件解决JS文件后加载响应慢的问题，所以记了下来。</p></blockquote><a id="more"></a><p>先说结论：比较理想的解决方案是<strong>code split</strong> + <strong>prefetch</strong> 方式，对于<del>不支持prefetch的safari浏览器</del>另做<strong>preload</strong>处理。</p><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p><strong>preload</strong> 是较新的 web 标准。他可以声明式的告诉浏览器去获取某个资源，并且可以为资源设置优先级。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin&gt;</span><br></pre></td></tr></table></figure></p><p>preload <strong>加载资源后并不会执行</strong>，可以安全的预加载 JavaScript。我们一般使用 preload 来主动通知浏览器获取本页的关键资源。现在浏览器都有 Preloader，可以尽早发现大多数基于标记语言的资源，但依然存在一些隐藏在 CSS 和 JavaScript 中的资源，例如字体文件，其为首屏关键资源又隐藏在 CSS 中。这种场景适合使用 preload 进行声明，尽早进行资源加载，避免页面渲染延迟。<br>preload 的更多细节可参考文章 Preload: <a href="https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/" target="_blank" rel="noopener">What Is It Good For?</a>，它适合用来预加载被隐藏的首屏关键资源。preload 的兼容性并不理想，目前只有最新版的 chrome 和 safari 才支持。</p><h3 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h3><p>使用 prefetch 声明的资源是对浏览器的提示，<strong>暗示该资源可能『未来』会被用到</strong>，适用于对可能跳转到的其他路由页面进行资源缓存。被 prefetch 的资源的加载时机由浏览器决定，一般来说优先级较低，会在浏览器『空闲』时进行下载。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="prefetch" href="//example.com/industry-qualification-audit/js/common-main.550d4.chunk.js"&gt;</span><br><span class="line">&lt;link rel="prefetch" href="//example.com/industry-qualification-audit/js/Food.86661.chunk.js"&gt;</span><br><span class="line">&lt;link rel="prefetch" href="//example.com/industry-qualification-audit/js/Pub.9045b.chunk.js"&gt;</span><br><span class="line">&lt;link rel="prefetch" href="//example.com/industry-qualification-audit/js/Screencast.1eb1a.chunk.js"&gt;</span><br></pre></td></tr></table></figure></p><p>由于关键资源 main.js 已被切分，体积小加载快，prefetch 的资源也未发生抢占带宽的现象，实际效果还是比较符合期望的。<br>prefetch 的兼容性稍好，chrome、firefox、edge、android 4.4+ 都支持，但 safari、IE11-、iOS safari 始终未支持。</p><h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h2><p>经过分析，资源加载方式简单总结如下：<br><strong>首屏关键资源</strong>：优先级高，使用阻塞方式载入，若有隐藏在 CSS、JavaScript 内部的关键资源（如字体），可使用 preload 声明提前开始加载。<br><strong>首屏非关键资源</strong>（第三方插件，如广告、评论、统计、分享）：优先级低，若无执行顺序要求，可使用 async 进行异步加载，但应警惕 onload 事件延迟现象（很多插件和业务逻辑都依赖 onload 事件），若产生了性能问题最好在 onload 事件后手动加载。<br><strong>非首屏资源</strong>（如其他路由的分片 thunk）：优先级最低，可使用 prefetch 声明进行预加载。在 safari、iOS 等不支持 prefetch 的浏览器上，在 onload 事件后手动进行加载。<br>单页应用的分片 <strong>thunk 为非首屏资源</strong>，可以采用 prefetch + onload 手动加载的方式实现全平台的预加载。prefetch 可以使用<a href="https://github.com/GoogleChrome/preload-webpack-plugin" target="_blank" rel="noopener"> <strong>preload-webpack-plugin</strong></a> 插件自动打入，preload可以使用<a href="https://github.com/jin5354/prefetch-polyfill-webpack-plugin" target="_blank" rel="noopener">prefetch-polyfill-webpack-plugin</a>,可以自动生成在 onload 事件触发时执行的 prefetch polyfill 函数，由于其身份是作为 prefetch 的补足，所以仅在 IE、safari、iOS 上执行，可选择使用 image 或者 async模式 对分片 thunk 做预加载。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">'src/index.html'</span>),</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      title: <span class="string">'index'</span>,</span><br><span class="line">      minify: <span class="literal">false</span>,</span><br><span class="line">      inject: <span class="string">'body'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> PreloadWebpackPlugin(&#123;</span><br><span class="line">      rel: <span class="string">'prefetch'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> PrefetchPolyfillPlugin(&#123;</span><br><span class="line">      mode: <span class="string">'async'</span>,</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure></p><p>经过这样细致的优化，就可以保证我们的单页应用既有快速的首屏响应时间，又能享受流畅的交互体验了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;单页应用性能的最大痛点就是 bundle 体积大导致首屏时间过长。使用 webpack 的 code splitting（代码分割）功能可以将 bundle 分片，加速首屏，但之后的交互势必会受到影响,页面变得不再流畅，稍有卡顿，所以放弃了分片，但是现在发现有webpack插件解决JS文件后加载响应慢的问题，所以记了下来。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>使用babel-preset-env替代babel-preset-es2015</title>
    <link href="http://yoursite.com/2017/10/02/%E4%BD%BF%E7%94%A8babel-preset-env%E6%9B%BF%E4%BB%A3babel-preset-es2015/"/>
    <id>http://yoursite.com/2017/10/02/使用babel-preset-env替代babel-preset-es2015/</id>
    <published>2017-10-02T11:12:01.000Z</published>
    <updated>2018-07-12T06:47:06.423Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Babel</strong> 是每个 FEer/Node.js 的使用者都会使用的一个代码转(bian)换(yi)器，它可以把 ES6、ES7 等语法转换成 ES5 的语法，使其能在更多环境下运行。</p></blockquote><p>但是随着浏览器和 Node.js 的版本迭代，他们对新语法的支持也越来越好。但是非常尴尬的是，我们总是使用 Babel 把所有代码一股脑转换成 ES5。这意味着我们抛弃了性能优秀的 let、const 关键字，放弃了简短的代码，而选择了又长又丑像坨屎的经过变换后的代码。</p><p>即使仅仅将代码跑在对 ES5 支持度在 99% 的 Node 6，一旦使用了 import 关键字，你就得用 Babel 对代码进行转换，一般还是全部转换为 ES5，辣鸡 Node.js 竟然还不支持 import 和 export。</p><h2 id="那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的-polyfill-呢？"><a href="#那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的-polyfill-呢？" class="headerlink" title="那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的 polyfill 呢？"></a>那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的 <strong>polyfill</strong> 呢？</h2><a id="more"></a><p>还真有，而且是 Babel 官方提供的，一个名为 <strong>babel-preset-env</strong> 的插件。它不需要你自行添加任何 preset，比如我们最常用的 es2015，它能根据设置智能转换代码。</p><p>具体的配置方法自行看<a href="https://github.com/babel/babel-preset-env#options" target="_blank" rel="noopener">文档</a>，很容易能看懂，这里就提一下值得特别注意的部分。</p><ol><li><p>如果在 .babelrc 中仅仅使用下面的设置的话，那 babel-preset-env 会执行与 babel-preset-latest 一样的转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>targets.browsers 需要使用 browserslist 的配置方法，但是其设置会被 targets.[chrome, opera, edge, firefox, safari, ie, ios, android, node, electron] 覆盖。</p></li><li>targets.node 设置为 true 或 “current” 可以根据当前 Node.js 版本进行动态转换。也可以设置为具体的数字表示需要支持的最低的 Node.js 版本。</li><li>targets.uglify 会把代码完全转换为 ES5 以支持压缩 JS 代码。</li><li>include 和 exclude 可以当作是白名单和黑名单，分别表示一定会执行的转换和一定不会执行的转换，其项是数组。</li><li><p>useBuiltIns 可以根据之前的配置自行添加 polyfill，默认不开启。安装 babel-polyfill 后只要引入一次就行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"babel-polyfill"</span>;</span><br></pre></td></tr></table></figure><h3 id="干货"><a href="#干货" class="headerlink" title="干货"></a>干货</h3><p>作为一个仅仅使用 Node 执行的项目，你可以用下面的 .babelrc 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123;</span><br><span class="line">      <span class="string">"targets"</span>: &#123;</span><br><span class="line">        <span class="string">"node"</span>: <span class="string">"current"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>前端项目：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>:[</span><br><span class="line">    [<span class="string">"env"</span>, &#123;</span><br><span class="line">      <span class="string">"modules"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">"targets"</span>: &#123;</span><br><span class="line">        <span class="string">"browsers"</span>: [<span class="string">"&gt; 1%"</span>, <span class="string">"last 2 versions"</span>, <span class="string">"not ie &lt;= 8"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">"stage-2"</span>,</span><br><span class="line">    <span class="string">"react-app"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"comments"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-runtime"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，别忘了安装 babel-cli，毕竟你还需要使用 babel-node 来执行代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Babel&lt;/strong&gt; 是每个 FEer/Node.js 的使用者都会使用的一个代码转(bian)换(yi)器，它可以把 ES6、ES7 等语法转换成 ES5 的语法，使其能在更多环境下运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是随着浏览器和 Node.js 的版本迭代，他们对新语法的支持也越来越好。但是非常尴尬的是，我们总是使用 Babel 把所有代码一股脑转换成 ES5。这意味着我们抛弃了性能优秀的 let、const 关键字，放弃了简短的代码，而选择了又长又丑像坨屎的经过变换后的代码。&lt;/p&gt;
&lt;p&gt;即使仅仅将代码跑在对 ES5 支持度在 99% 的 Node 6，一旦使用了 import 关键字，你就得用 Babel 对代码进行转换，一般还是全部转换为 ES5，辣鸡 Node.js 竟然还不支持 import 和 export。&lt;/p&gt;
&lt;h2 id=&quot;那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的-polyfill-呢？&quot;&gt;&lt;a href=&quot;#那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的-polyfill-呢？&quot; class=&quot;headerlink&quot; title=&quot;那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的 polyfill 呢？&quot;&gt;&lt;/a&gt;那有没有什么工具能智能识别当前运行环境，并且进行适当的转换，以及填充适当的 &lt;strong&gt;polyfill&lt;/strong&gt; 呢？&lt;/h2&gt;
    
    </summary>
    
    
      <category term="babel" scheme="http://yoursite.com/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>create-react-app和express共同组建的开发环境</title>
    <link href="http://yoursite.com/2017/07/20/create-react-app%E5%92%8Cexpress%E5%85%B1%E5%90%8C%E7%BB%84%E5%BB%BA%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2017/07/20/create-react-app和express共同组建的开发环境/</id>
    <published>2017-07-20T08:55:32.000Z</published>
    <updated>2018-07-12T06:47:06.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="脚手架介绍"><a href="#脚手架介绍" class="headerlink" title="脚手架介绍"></a>脚手架介绍</h2><blockquote><p>在这个环境下，Facebook 提供了一套不需要配置的 React 开发方案，即create-react-app。这个脚手架已经做好了基础 webpack 配置，带有自动更新，错误提示等等功能，仅仅需要创建，启动就可以快速开发。</p></blockquote><p>这时也不得不提前端社区的另一个崛起者：<strong>yarn</strong>。<br><a id="more"></a><br>Yarn与 npm 一样，是一款 NodeJS 包管理工具。 为何要选择使用 yarn 呢？官网的描述是：</p><blockquote><p>Yarn 会缓存它下载的每个包，所以不需要重复下载。它还能并行化操作以最大化资源利用率，所以安装速度之快前所未有。</p><p>Yarn 在每个安装包的代码执行前使用校验码验证包的完整性。</p><p>Yarn 使用一个格式详尽但简洁的 lockfile 和一个精确的算法来安装，能够保证在一个系统上的运行的安装过程也会以同样的方式运行在其他系统上。<br>选用 Yarn 的原因也是因为他的速度提升比npm 要快，使用yarn add <package-name> ，yarn remove <package-name> 增删 node 包（对应npm install和npm uninstall）.</package-name></package-name></p><p>另一点是，yarn 在更新之后，集成了create, 通过yarn create，可以快速启动一个项目。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn create react-app my-app</span><br><span class="line">yarn create react-native-app my-app</span><br><span class="line">yarn create next-app my-app</span><br></pre></td></tr></table></figure><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>假设我们需要创建一个demo-app项目：</p><h4 id="创建目录yarn-create-react-app-demo-app"><a href="#创建目录yarn-create-react-app-demo-app" class="headerlink" title="创建目录yarn create react-app demo-app"></a>创建目录yarn create react-app demo-app</h4><p>稍等片刻，yarn 会为我们创建一个目录，拉取依赖，wepack 的配置通过 yarn 来调用，可以看到目录结构很干净</p><h4 id="开始开发：cd-demo-app-amp-amp-yarn-start"><a href="#开始开发：cd-demo-app-amp-amp-yarn-start" class="headerlink" title="开始开发：cd demo-app &amp;&amp; yarn start"></a>开始开发：cd demo-app &amp;&amp; yarn start</h4><p>这时会启动一个默认端口为3000的页面，如果端口冲突，会提示你是否选用另一个端口<br>进入src目录开始开发即可</p><p>开发完成后需要发布时，运行yarn build进行编译，发布build目录<br>创建完成会自动生成build文件夹，将 js,css 文件放入 static 目录中,发布build目录即可</p><p>三部曲完成，中间省略了非常多配置问题，给需要快速构建项目带来了极大的便利性。当然，默认配置也许不能够满足所有需求，create-react-app也提供了 抛出所有配置项的yarn eject供给开发者使用，如果需要到调整 webpack 的内容，就需要使用到这个命令。不过这样也会导致不能再回滚。官方的更新比较快，如果不是必要的情况建议直接使用内置的行为。</p><h2 id="配合-Express-构建-server-端应用"><a href="#配合-Express-构建-server-端应用" class="headerlink" title="配合 Express 构建 server 端应用"></a>配合 Express 构建 server 端应用</h2><p>如果在项目开发过程中需要 express 构建server 端应用，那么开发模式就需要有小调整。</p><p>首先创建一个叫server的文件夹和初始化 package.json文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir server &amp;&amp; cd server &amp;&amp; yarn init</span><br></pre></td></tr></table></figure></p><h4 id="增加依赖包"><a href="#增加依赖包" class="headerlink" title="增加依赖包"></a>增加依赖包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add express body-parser nodemon babel-cli babel-preset-es2015</span><br></pre></td></tr></table></figure><p>主要用到express, body-parser, nodemon（检测node.js 改动并自动重启，适用于开发阶段）,babel-cli和babel-preset-es2015(以便使用 es6开发)<br>修改package.json，增加npm scripts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;scripts&quot;: &#123;</span><br><span class="line">     &quot;start&quot;: &quot;nodemon --exec babel-node -- ./server.js&quot;,</span><br><span class="line">     &quot;build&quot;: &quot;babel ./server.js --out-file server-compiled.js&quot;,</span><br><span class="line">     &quot;serve&quot;: &quot;node server-compiled.js&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这里使用nodemon在开发阶段检测node.js 改动并自动重启<br>发布build的时候则通过 babel编译成 es5的文件<br>create-react-app会启动一个静态资源服务器，那么同时需要进行 server 端的时候需要怎么做呢？</p><p>我们回过头来去修改一下demo-app目录下的package.json。</p><p>create-react-app会默认添加好3段scripts:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>我们需要对 start和build做调整，以便可以同时启动前端开发页面以及后端服务。在这里引入concurrently这个包来执行两条命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add concurrently</span><br></pre></td></tr></table></figure></p><p>package.json:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;react-start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;concurrently &apos;yarn react-start&apos; &apos;cd server &amp;&amp; yarn start&apos;&quot;,</span><br><span class="line">    &quot;react-build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;concurrently &apos;yarn react-build&apos; &apos;cd server &amp;&amp; yarn build&apos;&quot;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>这样，我们只要执行yarn start会同步启动 webpack 以及 server文件夹下的 nodeman.</p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>如果我们在前端页面用使用fetch(/api/data)这样 请求，默认是会发送到create-react-app 启动的 localhost:3000/api/data去的，无法达到目的。为了指向 server 端，需要指定proxy:</p><p>假设 server 端 express 启动了5000端口，则需要在package.json中增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;proxy&quot;: &quot;http://127.0.0.1:5000&quot;</span><br></pre></td></tr></table></figure></p><p>这时当你使用fetch(/api/data)请求，则会指向到localhost:5000/api/data</p><p>轻松的开始开发吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;脚手架介绍&quot;&gt;&lt;a href=&quot;#脚手架介绍&quot; class=&quot;headerlink&quot; title=&quot;脚手架介绍&quot;&gt;&lt;/a&gt;脚手架介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在这个环境下，Facebook 提供了一套不需要配置的 React 开发方案，即create-react-app。这个脚手架已经做好了基础 webpack 配置，带有自动更新，错误提示等等功能，仅仅需要创建，启动就可以快速开发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时也不得不提前端社区的另一个崛起者：&lt;strong&gt;yarn&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>ES7 and ES8 特性</title>
    <link href="http://yoursite.com/2017/07/18/ES7-and-ES8-%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/07/18/ES7-and-ES8-特性/</id>
    <published>2017-07-18T05:56:47.000Z</published>
    <updated>2018-07-12T06:47:06.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES8-was-Released"><a href="#ES8-was-Released" class="headerlink" title="ES8 was Released"></a>ES8 was Released</h2><blockquote><p>虽然现在开发已经都在用es6，一个不注意，都到了es8了。记录一下新增加的常用功能，方便查阅。</p></blockquote><h2 id="ES7-特性："><a href="#ES7-特性：" class="headerlink" title="ES7 特性："></a>ES7 特性：</h2><ol><li>Array.prototype.includes</li><li>Exponentiation Operator(求冥运算)</li></ol><h2 id="ES8-特性"><a href="#ES8-特性" class="headerlink" title="ES8 特性"></a>ES8 特性</h2><ol><li>Object.values/Object.entries</li><li>String padding(字符串填充)</li><li>Object.getOwnPropertyDescriptors</li><li>函数参数列表和调用中的尾逗号（Trailing commas）</li><li>异步函数（Async Functions）<a id="more"></a><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3>Array.prototype.includes用法都容易和简单。它是一个替代indexOf，开发人员用来检查数组中是否存在值，indexOf是一种尴尬的使用，因为它返回一个元素在数组中的位置或者-1当这样的元素不能被找到的情况下。所以它返回一个数字，而不是一个布尔值。开发人员需要实施额外的检查。<br>在ES6，要检查是否存在值你需要做一些如下所示小技巧，因为他们没有匹配到值，Array.prototype.indexOf返回-1变成了true（转换成true），但是当匹配的元素为0位置时候，该数组包含元素，却变成了false<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'react'</span>, <span class="string">'angular'</span>, <span class="string">'vue'</span>]</span><br><span class="line"><span class="comment">// WRONG</span></span><br><span class="line"><span class="keyword">if</span> (arr.indexOf(<span class="string">'react'</span>)) &#123; <span class="comment">// 0 -&gt; evaluates to false, definitely as we expected</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Can use React'</span>) <span class="comment">// this line would never be executed</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (arr.indexOf(<span class="string">'react'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Can use React'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>或者使用一点点hack 位运算符 ~ 使代码更加紧凑一些，因为~（位异或）对任何数字相当于-(a + 1):<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'react'</span>, <span class="string">'angular'</span>, <span class="string">'vue'</span>]</span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (~arr.indexOf(<span class="string">'react'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Can use React'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在ES7中使用includes代码如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'react'</span>, <span class="string">'angular'</span>, <span class="string">'vue'</span>]</span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="string">'react'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Can use React'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开发者还能在字符串中使用includes:</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'React Quickly'</span></span><br><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">if</span> (str.toLowerCase().includes(<span class="string">'react'</span>)) &#123;  <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Found "react"'</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Exponentiation-Operator-求冥运算"><a href="#Exponentiation-Operator-求冥运算" class="headerlink" title="Exponentiation Operator(求冥运算)"></a>Exponentiation Operator(求冥运算)</h3><p>求冥运算大多数是为开发者做一些数学计算，对于3D，VR，SVG还有数据可视化非常有用。<br>在ES6或者早些版本，你不得不创建一个循环，创建一个递归函数或者使用Math.pow,如果你忘记了什么是指数,当你有相同数字（基数）自相相乘多次（指数）。例如，7的3次方是7<em>7</em>7</p><p>现在在ES7 /ES2016，以数学向导的开发者可以使用更短的语法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">7</span> ** <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span> ** <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="built_in">Math</span>.pow(<span class="number">7</span>,<span class="number">12</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b === <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">7</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 开发者还可以操作结果:</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">7</span></span><br><span class="line">a **= <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">b **= <span class="number">7</span></span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="built_in">Math</span>.pow(<span class="number">7</span>,<span class="number">12</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(b === <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">7</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="Object-values-Object-entries"><a href="#Object-values-Object-entries" class="headerlink" title="Object.values/Object.entries"></a>Object.values/Object.entries</h3><p><strong>Object.entries</strong> 和 <strong>Object.values</strong>是在ES2017规格中，它和Object.keys类似，返回数组类型，其序号和<strong>Object.keys</strong>序号对应。</p><p>Object.entries,Object.values和Object.keys各自项<strong>返回是数组</strong>，相对应包括key,value或者可枚举特定对象property/attribute</p><p>在ES8 /ES2017之前，Javascript开发者需要迭代一个对象的自身属性时候不得不用Object.keys，通过迭代且使用obj[key]获取value值返回一个数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, index</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>而使用ES6/ES2015 中for/of稍微好点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你使用老方式for/in(ES5)也许用的非常好。但是他会迭代所有可以枚举属性（像原型中的带名字的-see MDN）,不仅仅自己的属性，会意外的破坏那些 像prototype和tostring得到意想不到的值。<br>Object.values返回对象自身可以迭代属性值（values）为数组类型。我们最好使用Array.prototype.forEach迭代它，结合ES6的箭头函数隐形返回值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.values(obj).forEach(<span class="function"><span class="params">value</span>=&gt;</span><span class="built_in">console</span>.log(value)) <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure></p><p>或者使用for/of:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.values(obj).forEach(<span class="function"><span class="params">value</span>=&gt;</span><span class="built_in">console</span>.log(value)) <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure></p><p><strong>Object.entries</strong>，在另一方面，将会返回对象自身可迭代属性key-value对数组（作为一个数组），他们（key-value）分别以数组存放数组中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="built_in">Object</span>.entries(obj))</span><br><span class="line"><span class="string">"[["</span>a<span class="string">",1],["</span>b<span class="string">",2],["</span>c<span class="string">",3]]"</span></span><br></pre></td></tr></table></figure></p><p>我们可以使用ES6/ES2015解构（需要深入了解解构请点击这篇文章和课程）,从这嵌套数组中分别声明key和value<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj).forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> is <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// a is 1, b is 2, c is 3</span></span><br></pre></td></tr></table></figure></p><p>你可以猜一猜，我们同样使用ES6for/of（毕竟全部都是数组）遍历Object.entries返回来的结果值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> is <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a is 1, b is 2, c is 3</span></span><br></pre></td></tr></table></figure></p><p>现在从对象中提取values和key-value pairs 变得非常容易了。Object.values和Object.entries这种方式不想之前 Object.keys(自身属性key+顺序相同)结合for/of(ES6)一起，我们不仅仅可以提取他们还可以迭代他们。</p><h3 id="字符填充函数padStart-和-padEnd"><a href="#字符填充函数padStart-和-padEnd" class="headerlink" title="字符填充函数padStart 和 padEnd"></a>字符填充函数padStart 和 padEnd</h3><p><strong>String.prototype.padStart</strong> 和 <strong>String.prototype.padEnd</strong>在javascript字符操作是一个不错的体验，帮助避免依赖而外的库。<br>padStart()在开始部位填充，返回一个给出长度的字符串，填充物给定字符串，把字符串填充到期望的长度。从字符串的左边开始（至少大部分西方语言），一个经典例子是使用空格创建列：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'react'</span>.padStart(<span class="number">10</span>).length)         <span class="comment">// "       react" is 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'backbone'</span>.padStart(<span class="number">10</span>).length)         <span class="comment">// "  backbone" is 10</span></span><br></pre></td></tr></table></figure></p><p>它对于财务方面非常有用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'0.00'</span>.padStart(<span class="number">20</span>))             </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'10,000.00'</span>.padStart(<span class="number">20</span>))    </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'250,000.00'</span>.padStart(<span class="number">20</span>))</span><br><span class="line"><span class="comment">// 这结果作为一个会计总账格式非常漂亮：</span></span><br><span class="line">                <span class="number">0.00</span></span><br><span class="line">           <span class="number">10</span>,<span class="number">000.00</span></span><br><span class="line">          <span class="number">250</span>,<span class="number">000.00</span></span><br></pre></td></tr></table></figure></p><p>第二个参数，让我们放一些其他的填充字符替代空字符串，一个字符串填充：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'react'</span>.padStart(<span class="number">10</span>, <span class="string">'_'</span>))         <span class="comment">// "_____react"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'backbone'</span>.padStart(<span class="number">10</span>, <span class="string">'*'</span>))         <span class="comment">// "**backbone"</span></span><br></pre></td></tr></table></figure></p><p>padEnd顾名思义就是从字符串的尾端右边开始填充。第二个参数，你能实际上用一个任何长度的字符串。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'react'</span>.padEnd(<span class="number">10</span>, <span class="string">':-)'</span>))         <span class="comment">// "react:-):-" is 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'backbone'</span>.padEnd(<span class="number">10</span>, <span class="string">'*'</span>))         <span class="comment">// "backbone**" is 10</span></span><br></pre></td></tr></table></figure></p><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p>这新的 <strong>Object.getOwnPropertyDescriptors</strong>返回对象obj所有自身属性描述。这是一个多参数版本的Object.getOwnPropertyDescriptors(obj,propName)将会返回obj中propName属性的一个单独描述。<br>在我们日常不可变编程（immutable programming）时代中，有了这个方法很方便（记住,Javascript中对象是引用传递）在ES5中，开发者要使用Object.assign()来拷贝对象, Object.assign()分配属性只有copy和定义新的属性。当我们使用更加复杂对象和类原型，这可能会出问题。<br>Object.getOwnPropertyDescriptors允许创建真实的对象浅副本并创建子类,它通过给开发者描述符来做到这一点.在Object.create(prototype, object)放入描述符后，返回一个真正的浅拷贝<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>或者你可以合并两个对象target和source如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(</span><br><span class="line">  target,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(source)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>以上是Object.getOwnPropertyDesciptors用法。但是什么是描述符(descriptor)呢？就是一个对象的描述，废话！<br>好吧！好吧，让我们挖掘一下描述符一点点多信息。这里有两种描述符号类型：</p><ol><li>数据描述符（Data descriptor）</li><li>存取器描述符（Accessor descriptor）<br>存取描述符有必须属性：get 或者set或者get和set两个就是如你所想的getter和setter函数，然后存取描述符还有可选属性configurable和enumerable<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> azatsBooks = &#123;  </span><br><span class="line">  books: [<span class="string">'React Quickly'</span>],</span><br><span class="line">  get latest () &#123;</span><br><span class="line">    <span class="keyword">let</span> numberOfBooks = <span class="keyword">this</span>.books.length</span><br><span class="line">    <span class="keyword">if</span> (numberOfBooks == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.books[numberOfBooks - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个例子数据描述符books由Object.getOwnPropertyDescriptor(azatsBooks, ‘books’)产生结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span></span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">    value: <span class="built_in">Array</span>[<span class="number">1</span>]</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">    __proto__: <span class="built_in">Object</span></span><br></pre></td></tr></table></figure></p><p>同样的，Object.getOwnPropertyDescriptor(azatsBooks, ‘latest’)将会展现latest的描述符，这个latest（get）存取器描述符展现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span></span><br><span class="line">    configurable: truee</span><br><span class="line">    numerable: <span class="literal">true</span></span><br><span class="line">    get: latest()</span><br><span class="line">    set: <span class="literal">undefined</span></span><br><span class="line">    __proto__: <span class="built_in">Object</span></span><br></pre></td></tr></table></figure></p><p>现在我们调用新方法获取所有的描述符：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(azatsBooks))</span><br></pre></td></tr></table></figure></p><p>它会给出这个对象两个描述符books和latest：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span></span><br><span class="line">  books: <span class="built_in">Object</span></span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">    value: <span class="built_in">Array</span>[<span class="number">1</span>]</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">    __proto__: <span class="built_in">Object</span></span><br><span class="line">  latest: <span class="built_in">Object</span></span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">    get: latest()</span><br><span class="line">    set: <span class="literal">undefined</span></span><br><span class="line">    __proto__: <span class="built_in">Object</span></span><br><span class="line">  __proto__: <span class="built_in">Object</span></span><br></pre></td></tr></table></figure></p><h3 id="函数参数列表和调用中的尾逗号"><a href="#函数参数列表和调用中的尾逗号" class="headerlink" title="函数参数列表和调用中的尾逗号"></a>函数参数列表和调用中的尾逗号</h3><p>尾逗号在函数定义中只是一个纯粹语法变化，在ES5中，将会非法语法，在函数参数后面应该是没有逗号的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a,</span></span></span><br><span class="line"><span class="function"><span class="params">  b,</span></span></span><br><span class="line"><span class="function"><span class="params">  c,</span></span></span><br><span class="line"><span class="function"><span class="params">  d</span>) </span>&#123; <span class="comment">// NO COMMA!</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'this'</span>)</span><br></pre></td></tr></table></figure></p><p>在ES8中，这种尾逗号是没有问题的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a,</span></span></span><br><span class="line"><span class="function"><span class="params">  b,</span></span></span><br><span class="line"><span class="function"><span class="params">  c,</span></span></span><br><span class="line"><span class="function"><span class="params">  d,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123; <span class="comment">// COMMA? OK!</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(d)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">'this'</span>)</span><br></pre></td></tr></table></figure></p><p>现在，函数中尾逗号是向数组（ES3）中和字面量对象（ES5）中尾逗号看齐。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,  <span class="comment">// Length == 3</span></span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">]  <span class="comment">// &lt;--- ok</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>,  <span class="comment">// Only 3 properties</span></span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">&#125;  <span class="comment">// &lt;--- ok</span></span><br></pre></td></tr></table></figure></p><p>更不用说他是无用友好的。<br>尾逗号主要有用在使用多行参数风格（典型的是那些很长的参数名），开发者终于可以忘记逗号放在第一位这种奇怪的写法。自从逗号bugs主要原因就是使用他们。而现在你可以到处使用逗号，甚至最后参数都可以。</p><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>异步函数（或者<strong>async</strong>/<strong>await</strong>）特性操作是Promise最重要的功能。所以你大概进一步阅读他们或者看一个进修视频课程来。这种想法是为了在写异步代码中简化它，因为人类大脑最讨厌这种平行非序号思维了。它只是不会演变这种方式。<br>对于我个人来说，我不喜欢Promise，就仅仅相比callback显得特别冗余。幸运的是，在ES8，异步函数是那么给力。开发者定义一个asyc函数里面不包含或者包含await 基于Promise异步操作。在这引擎之下一个异步函数返回一个Promise，无论无何你在任何地方不会看到这样的一个词（注：Promise）(当然了，你非的自己使用)。<br>例如，在ES6中我们可以使用Promise，Axios库向GraphQL服务器发送一个请求：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">`/q?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.data)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.processfetchedData(data) <span class="comment">// Defined somewhere else</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br></pre></td></tr></table></figure></p><p>任何一个Promise库都能兼容新的异步函数，我们可以使用同步try/catch做错误处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> fetchData(url) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(<span class="string">`/q?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">const</span> data = response.data</span><br><span class="line">    <span class="keyword">this</span>.props.processfetchedData(data)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异步函数返回一个Promise，所以我们像下面可以继续执行流程:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> fetchData(query) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(<span class="string">`/q?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">const</span> data = response.data</span><br><span class="line">      <span class="keyword">return</span> data</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fetchData(query).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.processfetchedData(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>你可以看到这段代码在(Babel REPL)生效。请注意，这个例子中，Axios库被代替的，是通过模拟来做相同功能，而HTTP请求通过setTimout代替：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> axios = &#123;  <span class="comment">// mocks</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;<span class="attr">data</span>: x&#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> query = <span class="string">'mangos'</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">query</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(<span class="string">`/q?query=<span class="subst">$&#123;query&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">const</span> data = response.data</span><br><span class="line">      <span class="keyword">return</span> data</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fetchData(query).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">// Got data 2s later... Can use data!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>有了 async/await,我们的代码执行异步看起来像执行同步一样。可以从头到尾读起来非常简单和易懂，因为出现结果顺序和函数题中从头到尾顺序一样.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ES8-was-Released&quot;&gt;&lt;a href=&quot;#ES8-was-Released&quot; class=&quot;headerlink&quot; title=&quot;ES8 was Released&quot;&gt;&lt;/a&gt;ES8 was Released&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;虽然现在开发已经都在用es6，一个不注意，都到了es8了。记录一下新增加的常用功能，方便查阅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ES7-特性：&quot;&gt;&lt;a href=&quot;#ES7-特性：&quot; class=&quot;headerlink&quot; title=&quot;ES7 特性：&quot;&gt;&lt;/a&gt;ES7 特性：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Array.prototype.includes&lt;/li&gt;
&lt;li&gt;Exponentiation Operator(求冥运算)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;ES8-特性&quot;&gt;&lt;a href=&quot;#ES8-特性&quot; class=&quot;headerlink&quot; title=&quot;ES8 特性&quot;&gt;&lt;/a&gt;ES8 特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Object.values/Object.entries&lt;/li&gt;
&lt;li&gt;String padding(字符串填充)&lt;/li&gt;
&lt;li&gt;Object.getOwnPropertyDescriptors&lt;/li&gt;
&lt;li&gt;函数参数列表和调用中的尾逗号（Trailing commas）&lt;/li&gt;
&lt;li&gt;异步函数（Async Functions）
    
    </summary>
    
    
      <category term="es7" scheme="http://yoursite.com/tags/es7/"/>
    
      <category term="es8" scheme="http://yoursite.com/tags/es8/"/>
    
  </entry>
  
  <entry>
    <title>Express 模板传值对象app.locals、res.locals</title>
    <link href="http://yoursite.com/2017/07/12/Express-%E6%A8%A1%E6%9D%BF%E4%BC%A0%E5%80%BC%E5%AF%B9%E8%B1%A1app-locals%E3%80%81res-locals/"/>
    <id>http://yoursite.com/2017/07/12/Express-模板传值对象app-locals、res-locals/</id>
    <published>2017-07-12T07:30:07.000Z</published>
    <updated>2018-07-12T06:47:06.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>locals是Express应用中 Application(app)对象和Response(res)对象中的属性，该属性是一个对象。该对象的主要作用是，将值传递到所渲染的模板中。</p></blockquote><a id="more"></a><h3 id="locals对象"><a href="#locals对象" class="headerlink" title="locals对象"></a>locals对象</h3><p>locals对象用于<strong>将数据传递至所渲染的模板</strong>中。<br>对于如下一个ejs模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">name</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%= url %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">name</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">introduce</span> %&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们可以像下面这样渲染页面，并向页面传递name、url、introduce三个变量的值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;  </span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;<span class="attr">name</span>:<span class="string">'IT'</span>, <span class="attr">url</span>:<span class="string">'http://itbilu.com'</span>, <span class="attr">introduce</span>:<span class="string">'学习'</span>&#125;);</span><br><span class="line">  <span class="comment">// 也可以使用 res.locals 变量</span></span><br><span class="line">  <span class="comment">// res.locals = &#123;</span></span><br><span class="line">  <span class="comment">//   name:'IT', </span></span><br><span class="line">  <span class="comment">//   url:'http://it.com', </span></span><br><span class="line">  <span class="comment">//   introduce:'学习'</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  <span class="comment">// res.render('index');</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>渲染后的页面HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">IT</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://it.com"</span>&gt;</span>IT<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>学习<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>locals对象会被传递到页面，在模板中可以直接引用该对象的属性，也可以通过该对象引用。如：&lt;%= name %&gt;属性同样可以通过&lt;%= locals.name %&gt;来引用。</p><h4 id="app-locals与res-locals"><a href="#app-locals与res-locals" class="headerlink" title="app.locals与res.locals"></a>app.locals与res.locals</h4><ul><li>locals可能存在于app对象中即：app.locals；</li><li>也可能存在于res对象中，即：res.locals。<br>两者都会将该对象传递至所渲染的页面中。不同的是，<strong>app.locals会在<em>整个生命周期</em>中起作用</strong>；而<strong>res.locals只会有<em>当前</em>请求中起作用</strong>。由于app.locals在当前应用所有的渲染模中访问，这样我们就可以在该对象中定义一些顶级/全局的数据，并在渲染模板中使用。</li></ul><h3 id="在中间件中使用"><a href="#在中间件中使用" class="headerlink" title="在中间件中使用"></a>在中间件中使用</h3><p>我们常利用Expres的中间件将复杂的问题拆解成多个简单的问题，实现复杂的问题简单化。locals对象中样也可以应用中间件或路由中间件中引用，该对象和app、req、res一样可以依次传递，添加或修改其属性值后，会在后面的处理中体现出来。</p><p>如，在app中使用locals：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.locals.name = <span class="string">'这是一个APP'</span>; <span class="comment">// 定义可以应用整个生命周期中使用的变量</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  app.locals.name = <span class="string">'新名称'</span>; <span class="comment">// 修改</span></span><br><span class="line">  res.locals.url = <span class="string">'http://it.com'</span></span><br><span class="line">  next(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在路由中间件中使用locals：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>, urlAndIntroduce, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;  </span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;<span class="attr">name</span>:<span class="string">'IT'</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlAndIntroduce</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.locals = &#123; <span class="attr">url</span>:<span class="string">'http://it.com'</span>, <span class="attr">introduce</span>:<span class="string">'学习'</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;locals是Express应用中 Application(app)对象和Response(res)对象中的属性，该属性是一个对象。该对象的主要作用是，将值传递到所渲染的模板中。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB常用语句</title>
    <link href="http://yoursite.com/2017/07/11/MongoDB%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2017/07/11/MongoDB常用语句/</id>
    <published>2017-07-11T09:35:27.000Z</published>
    <updated>2018-07-12T06:47:06.414Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一下MongoDB常用语句，顺带与SQL做个简单的对比.</p></blockquote><h3 id="查询-find"><a href="#查询-find" class="headerlink" title="查询(find)"></a>查询(find)</h3><p>（1）查询所有结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article</span><br><span class="line">db.article.find()</span><br></pre></td></tr></table></figure></p><p>（2）指定返回哪些键<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> title, author <span class="keyword">from</span> article</span><br><span class="line">db.article.find(&#123;&#125;, &#123;<span class="string">"title"</span>: <span class="number">1</span>, <span class="string">"author"</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>（3）where条件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> title = <span class="string">"mongodb"</span></span><br><span class="line">db.article.find(&#123;<span class="string">"title"</span>: <span class="string">"mongodb"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>（4）and条件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> title = <span class="string">"mongodb"</span> <span class="keyword">and</span> author = <span class="string">"god"</span></span><br><span class="line">db.article.find(&#123;<span class="string">"title"</span>: <span class="string">"mongodb"</span>, <span class="string">"author"</span>: <span class="string">"god"</span>&#125;)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>（5）or条件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> title = <span class="string">"mongodb"</span> <span class="keyword">or</span> author = <span class="string">"god"</span></span><br><span class="line">db.article.find(&#123;<span class="string">"$or"</span>: [&#123;<span class="string">"title"</span>: <span class="string">"mongodb"</span>&#125;, &#123;<span class="string">"author"</span>: <span class="string">"god"</span>&#125;]&#125;)</span><br></pre></td></tr></table></figure></p><p>（6）比较条件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> <span class="keyword">read</span> &gt;= <span class="number">100</span>;</span><br><span class="line">db.article.find(&#123;"read": &#123;"$gt": 100&#125;&#125;)</span><br><span class="line">$gt(&gt;)、$gte(&gt;=)、$lt(&lt;)、$lte(&lt;=)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> <span class="keyword">read</span> &gt;= <span class="number">100</span> <span class="keyword">and</span> <span class="keyword">read</span> &lt;= <span class="number">200</span></span><br><span class="line">db.article.find(&#123;<span class="string">"read"</span>: &#123;<span class="string">"$gte"</span>: <span class="number">100</span>, <span class="string">"lte"</span>: <span class="number">200</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>（7）in条件<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> author <span class="keyword">in</span> (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">db.article.find(&#123;<span class="string">"author"</span>: &#123;<span class="string">"$in"</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>（8）like<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> title <span class="keyword">like</span> <span class="string">"%mongodb%"</span></span><br><span class="line">db.article.find(&#123;<span class="string">"title"</span>: /mongodb/&#125;)</span><br></pre></td></tr></table></figure></p><p>（9）count<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> article</span><br><span class="line">db.article.count()</span><br></pre></td></tr></table></figure></p><p>（10）不等于<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> author != <span class="string">"a"</span></span><br><span class="line">db.article.find(&#123; <span class="string">"author"</span>: &#123; <span class="string">"$ne"</span>: <span class="string">"a"</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>（11）排序<br>升序：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> <span class="keyword">type</span> = <span class="string">"mongodb"</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">read</span> <span class="keyword">desc</span></span><br><span class="line">db.article.find(&#123;<span class="string">"type"</span>: <span class="string">"mongodb"</span>&#125;).sort(&#123;<span class="string">"read"</span>: <span class="number">-1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>降序：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> <span class="keyword">type</span> = <span class="string">"mongodb"</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">read</span> <span class="keyword">asc</span></span><br><span class="line">db.article.find(&#123;<span class="string">"type"</span>: <span class="string">"mongodb"</span>&#125;).sort(&#123;<span class="string">"read"</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>findOne()</strong>：除了只返回一个查询结果外，使用方法与find()一样。</p><h3 id="创建（insert）"><a href="#创建（insert）" class="headerlink" title="创建（insert）"></a>创建（insert）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> article(title, author, <span class="keyword">content</span>) <span class="keyword">values</span>(<span class="string">"mongodb"</span>, <span class="string">"tg"</span>, <span class="string">"haha"</span>)</span><br><span class="line">db.article.insert(&#123;<span class="string">"title"</span>: <span class="string">"mongodb"</span>, <span class="string">"author"</span>: <span class="string">"tg"</span>, <span class="string">"content"</span>: <span class="string">"haha"</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="更新（update）"><a href="#更新（update）" class="headerlink" title="更新（update）"></a>更新（update）</h3><h4 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h4><p>语法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collecion.update(query, <span class="keyword">update</span>[, options] )</span><br></pre></td></tr></table></figure></p><blockquote><p>query : 必选，查询条件，类似find中的查询条件。<br>update : 必选，update的对象和一些更新的操作符（如$,$inc…）等<br>options：可选，一些更新配置的对象。<br>upsert：可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。<br>multi：可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。<br>writeConcern：可选，抛出异常的级别。</p></blockquote><p>简单更新：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> article <span class="keyword">set</span> title = <span class="string">"mongodb"</span> <span class="keyword">where</span> <span class="keyword">read</span> &gt; <span class="number">100</span></span><br><span class="line">db.article.update(&#123;<span class="string">"read"</span>: &#123;<span class="string">"$gt"</span>: <span class="number">100</span>&#125;&#125;, &#123;<span class="string">"$set"</span>: &#123; <span class="string">"title"</span>: <span class="string">"mongodb"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="save"><a href="#save" class="headerlink" title="save()"></a>save()</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.save(&#123;_id: 123, title: "mongodb"&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>执行上面的语句，如果集合中已经存在一个_id为123的文档，则更新对应字段;否则插入。<br>注：<strong>如果更新对象不存在_id，系统会自动生成并作为新的文档插入。</strong></p></blockquote><h4 id="更新操作符"><a href="#更新操作符" class="headerlink" title="更新操作符"></a>更新操作符</h4><p>MongoDB提供一些强大的更新操作符。</p><h5 id="更新特定字段（-set）："><a href="#更新特定字段（-set）：" class="headerlink" title="更新特定字段（$set）："></a>更新特定字段（$set）：</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> game <span class="keyword">set</span> <span class="keyword">count</span> = <span class="number">10000</span> <span class="keyword">where</span> _id = <span class="number">123</span></span><br><span class="line">db.game.update(&#123;<span class="string">"_id"</span>: <span class="number">123</span>&#125;, &#123; <span class="string">"$set"</span>: &#123;<span class="string">"count"</span>: <span class="number">10000</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><h5 id="删除特定字段（-unset）："><a href="#删除特定字段（-unset）：" class="headerlink" title="删除特定字段（$unset）："></a>删除特定字段（$unset）：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"_id":123&#125;, &#123;"$unset": &#123;"author":1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>注：$unset指定字段的值只需是任意合法值即可。</p><h5 id="递增或递减（-inc）"><a href="#递增或递减（-inc）" class="headerlink" title="递增或递减（$inc）"></a>递增或递减（$inc）</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123; "$inc": &#123;"count": 10&#125;&#125;) // 每次count都加10</span><br></pre></td></tr></table></figure><p>注意：$inc对应的字段必须是数字，而且递增或递减的值也必须是数字。</p><h5 id="数组追加（-push）："><a href="#数组追加（-push）：" class="headerlink" title="数组追加（$push）："></a>数组追加（$push）：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123; "$push": &#123;"score": 123&#125;&#125;)</span><br></pre></td></tr></table></figure><p>还可以一次追加多个元素：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123;"$push": &#123;"score": [12,123]&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>注：追加字段必须是数组。如果数组字段不存在，则自动新增，然后追加。</p><h5 id="一次追加多个元素（-pushAll）："><a href="#一次追加多个元素（-pushAll）：" class="headerlink" title="一次追加多个元素（$pushAll）："></a>一次追加多个元素（$pushAll）：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123;"$pushAll": &#123;"score": [12,123]&#125;&#125;)</span><br></pre></td></tr></table></figure><h5 id="追加不重复元素（-addToSet）："><a href="#追加不重复元素（-addToSet）：" class="headerlink" title="追加不重复元素（$addToSet）："></a>追加不重复元素（$addToSet）：</h5><p>$addToSet类似集合Set，只有当这个值不在元素内时才增加：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123;"$addToSet": &#123;"score": 123&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="删除元素（-pop）："><a href="#删除元素（-pop）：" class="headerlink" title="删除元素（$pop）："></a>删除元素（$pop）：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123;"$pop": &#123;"score": 1&#125;&#125;)  // 删除最后一个元素</span><br><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123;"$pop": &#123;"score": -1&#125;&#125;)  // 删除第一个元素</span><br></pre></td></tr></table></figure><p>注：$pop每次只能删除数组中的一个元素，1表示删除最后一个，-1表示删除第一个。</p><h5 id="删除特定元素（-pull）："><a href="#删除特定元素（-pull）：" class="headerlink" title="删除特定元素（$pull）："></a>删除特定元素（$pull）：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123;"$pull": &#123;"score": 123&#125;&#125;)</span><br></pre></td></tr></table></figure><p>上面的语句表示删除数组score内值等于123的元素。</p><h5 id="删除多个特定元素（-pullAll）："><a href="#删除多个特定元素（-pullAll）：" class="headerlink" title="删除多个特定元素（$pullAll）："></a>删除多个特定元素（$pullAll）：</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123;"$pullAll": &#123;score: [123,12]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>上面的语句表示删除数组内值等于123或12的元素。</p><h5 id="更新嵌套数组的值："><a href="#更新嵌套数组的值：" class="headerlink" title="更新嵌套数组的值："></a>更新嵌套数组的值：</h5><p>使用数组下标（从0开始）：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  address: [&#123;place: "nanji", tel: 123&#125;, &#123;place: "dongbei", tel: 321&#125;]</span><br><span class="line">&#125;</span><br><span class="line">db.game.update(&#123;"_id": 123&#125;, &#123;"$set": &#123;"address.0.tel": 213&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>如果你不知道要更新数组哪项，我们可以使用$操作符（ $表示自身，也就是按查询条件找出的数组里面的项自身，而且只会应用找到的第一条数组项）：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.game.update(&#123;"address.place": "nanji"&#125;, &#123;"$set": &#123;"address.$.tel": 123&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>在上面的语句中，$就是查询条件{“address.place”: “nanji”}的查询结果，也就是{place: “nanji”, tel: 123}，所以{“address.$.tel”: 123}也就是{“address.{place: “nanji”, tel: 123}.tel”: 123}</p><h3 id="删除（remove）"><a href="#删除（remove）" class="headerlink" title="删除（remove）"></a>删除（remove）</h3><h4 id="删除所有文档："><a href="#删除所有文档：" class="headerlink" title="删除所有文档："></a>删除所有文档：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> article</span><br><span class="line">db.article.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="删除指定文档："><a href="#删除指定文档：" class="headerlink" title="删除指定文档："></a>删除指定文档：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> article <span class="keyword">where</span> title = <span class="string">"mongodb"</span></span><br><span class="line">db.article.remove(&#123;title: <span class="string">"mongodb"</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="MongoDB特有的语句"><a href="#MongoDB特有的语句" class="headerlink" title="MongoDB特有的语句"></a>MongoDB特有的语句</h3><h4 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h4><h5 id="数组的普通查询"><a href="#数组的普通查询" class="headerlink" title="数组的普通查询"></a>数组的普通查询</h5><p>假如type是[“mongodb”, “javascript”]：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"type": "mongodb"&#125;)</span><br></pre></td></tr></table></figure></p><p>上面的语句可以匹配成功。</p><h5 id="多个元素的查询"><a href="#多个元素的查询" class="headerlink" title="多个元素的查询"></a>多个元素的查询</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"type": &#123;"$all": ["mongodb", "javascript"]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>只有type数组同时存在mongodb和javascript才会匹配。</p><h5 id="限制数组长度查询"><a href="#限制数组长度查询" class="headerlink" title="限制数组长度查询"></a>限制数组长度查询</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"type": &#123;"$size": 2&#125;&#125;)</span><br></pre></td></tr></table></figure><p>只有数组的长度是2才会匹配<br>注：type必须是数组</p><h5 id="返回特定数量"><a href="#返回特定数量" class="headerlink" title="返回特定数量"></a>返回特定数量</h5><p>当$slice的参数是一个时，表示返回的数量;当是一个数组时，第一个参数表示偏移量，第二个表示返回的数量：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"type": &#123;"$slice": 1&#125;&#125;) // 返回第1个</span><br><span class="line">db.article.find(&#123;"type": &#123;"$slice": -1&#125;&#125;)  // 返回最后一个</span><br><span class="line">db.article.find(&#123;"type": &#123;"$slice": [20, 10]&#125;&#125;)  // 从第21个开始，返回10个，也就是21～30</span><br></pre></td></tr></table></figure></p><p>注：$slice针对的是数组</p><h5 id="元素匹配"><a href="#元素匹配" class="headerlink" title="元素匹配"></a>元素匹配</h5><p>如果文档中有一个字段的值是数组，可以使用$elemMatch来匹配数组内的元素：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  kown: [&#123; a: 2, b: 4&#125;, 10, &#123; a: 4&#125;, &#123;b:10&#125;]</span><br><span class="line">&#125;</span><br><span class="line">db.article.find(&#123;"kown": &#123; "$elemMatch": &#123;a: 1, b: &#123;"$gt": 2&#125;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>只有a=1且b&gt;2才会匹配。</p><h5 id="取模（-mod）"><a href="#取模（-mod）" class="headerlink" title="取模（$mod）"></a>取模（$mod）</h5><p>比如我们要匹配 read % 5 == 1：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"read": &#123;$mod: [5, 1]&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="是否存在（-exists"><a href="#是否存在（-exists" class="headerlink" title="是否存在（$exists)"></a>是否存在（$exists)</h5><p>如果我们要判断love字段是否存在，可以这样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"love": &#123;"$exists": true&#125;&#125;)  // 如果存在字段love，就返回</span><br></pre></td></tr></table></figure></p><p>我们也可以判断不存在：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"love": &#123;"$exists": false&#125;&#125;) // 如果不存在字段love，就返回</span><br></pre></td></tr></table></figure></p><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>mongodb支持正则表达式，使用方法与正则字面量一样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"title": /mongodb/i&#125;)  // i是忽略大小写</span><br></pre></td></tr></table></figure></p><h5 id="类型查询"><a href="#类型查询" class="headerlink" title="类型查询"></a>类型查询</h5><p>我们可以根据字段类型来返回数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"comments": &#123;"$type": 4&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>只有当comments的类型是数组才匹配<br>注：更多类型的数值可以参考这里：mongodb $type</p><h5 id="内嵌文档"><a href="#内嵌文档" class="headerlink" title="内嵌文档"></a>内嵌文档</h5><p>mongodb是允许内嵌文档的，而且要查询内嵌文档也很简单（使用点语法）：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  address: &#123; name: "nanji" &#125;</span><br><span class="line">&#125;</span><br><span class="line">db.article.find(&#123;"address.name": "nanji"&#125;)</span><br></pre></td></tr></table></figure></p><p>上面的语句是查询comments中的author。<br>数组也可以采取点语法:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  comments: [&#123;title: "mongodb"&#125;, &#123;title: "javascript"&#125;]</span><br><span class="line">&#125;</span><br><span class="line">db.article.find(&#123;"comments.title": "mongodb"&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h5><p>$not是元语句，即可以用在任何其他条件之上：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;"author": &#123;"$not": /mongodb/i&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>只要使用$not操作符，就表示取反。</p><h3 id="MongoDB常用方法"><a href="#MongoDB常用方法" class="headerlink" title="MongoDB常用方法"></a>MongoDB常用方法</h3><h4 id="控制返回数量（limit）"><a href="#控制返回数量（limit）" class="headerlink" title="控制返回数量（limit）"></a>控制返回数量（limit）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find().limit(10)</span><br></pre></td></tr></table></figure><p>返回10条数据</p><h4 id="略过数量"><a href="#略过数量" class="headerlink" title="略过数量"></a>略过数量</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find().skip(5)</span><br></pre></td></tr></table></figure><p>略过前5条数据，也就是从第6条开始返回。<br>可以结合limit()和skip()来达到分页效果：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">limit</span> <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">db.article.find().skip(<span class="number">10</span>).limit(<span class="number">20</span>)</span><br></pre></td></tr></table></figure></p><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p>返回匹配数据的长度：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find().count()</span><br></pre></td></tr></table></figure></p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>pretty()方法可以以格式化的方式显示所有文档：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find().pretty()</span><br></pre></td></tr></table></figure></p><h4 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h4><p>当你要删除一个集合中的所有文档时，直接删除一个集合效率会更高：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.drop()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录一下MongoDB常用语句，顺带与SQL做个简单的对比.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;查询-find&quot;&gt;&lt;a href=&quot;#查询-find&quot; class=&quot;headerlink&quot; title=&quot;查询(find)&quot;&gt;&lt;/a&gt;查询(find)&lt;/h3&gt;&lt;p&gt;（1）查询所有结果&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; article&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;db.article.find()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（2）指定返回哪些键&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; title, author &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; article&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;db.article.find(&amp;#123;&amp;#125;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;author&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（3）where条件&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; article &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; title = &lt;span class=&quot;string&quot;&gt;&quot;mongodb&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;db.article.find(&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;mongodb&quot;&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;（4）and条件&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; article &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; title = &lt;span class=&quot;string&quot;&gt;&quot;mongodb&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; author = &lt;span class=&quot;string&quot;&gt;&quot;god&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;db.article.find(&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;mongodb&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;author&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;god&quot;&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Mongodb之mongoose入门</title>
    <link href="http://yoursite.com/2017/07/11/Mongodb%E4%B9%8Bmongoose%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/07/11/Mongodb之mongoose入门/</id>
    <published>2017-07-11T08:51:46.000Z</published>
    <updated>2018-07-12T06:47:06.414Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近一直在看node，先从简单的express学起，其他的还好说，主要是和数据库的连接。既然是js，那就先从mongodb开始吧，我们使用mongoose中间件连接mongodb。</p></blockquote><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>关于mongoose的基本操作其实网上很多教程，按照mongoose官网的<a href="http://mongoosejs.com/docs/index.html" target="_blank" rel="noopener">quick start guide</a>，很快就能有个大概的了解。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mongoose --save</span><br><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>)</span><br><span class="line">mongoose.connect(<span class="string">'mongodb://ip:port/database'</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这里注意，很多教程都没有详细说明对于有权限的数据库的连接方式，也让我在刚接触时郁闷了很久，数据库加密是防止数据库发生损失的第一道锁，如下(在数据库中操作)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ use database</span><br><span class="line">$ db.createUser(&#123;</span><br><span class="line">    user: user,</span><br><span class="line">    pwd: pwd,</span><br><span class="line">    roles:[</span><br><span class="line">        &#123;</span><br><span class="line">            role: <span class="string">"readWrite ..."</span>, <span class="comment">// 具体的权限</span></span><br><span class="line">            db: <span class="string">""</span> <span class="comment">//datebase</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line">$ db.auth(<span class="string">"userName"</span>,<span class="string">"password"</span>)</span><br></pre></td></tr></table></figure></p><p>注意，在服务器上，如果要直接操作数据库，可以先连接，再通过db.auth()来验证权限，可是如果在node中该怎么做呢？</p><p>example：我的数据库账号是admin,密码为password,需要连接的database为test，数据库地址是111.222.333.444:1024那么再连接的时候就可以直接指定连接的地址为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://admin:password@111.222.333.444:1024/test'</span>)</span><br></pre></td></tr></table></figure></p><p>这样就不会出现由于权限的问题而无法连接了，但是要注意，在mongodb的admin下建的账户，在子数据库中是不能直接验证的，同时也为了安全，应该在每个数据库下都建立不同权限的账户<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ use admin <span class="comment">//切换到admin</span></span><br><span class="line">$ db.system.users.find().pretty()   <span class="comment">//查看系统下所有的账户</span></span><br><span class="line">$ use test  <span class="comment">//切换到test</span></span><br><span class="line">$ show users  <span class="comment">//查询test下的账户</span></span><br></pre></td></tr></table></figure></p><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>在成功连接了数据库并通过正好验证以后，就该对数据库进行增删改查了，很多关于mongoose的入门的教程都是寥寥几句，尤其对于最核心的Schema和Model，并没有过多的深入，而官方文档对于刚接触不深的我来说，也是比较吃力，下面是个人在学习过程中的一些小小的总结</p><p>Schema是mongoose的一种模式，这是比较抽象的一个东西，它对应的是数据库中的collection,比如，db.collection.find({})的数据是这样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="string">'25'</span>,</span><br><span class="line">    date: <span class="string">'2017-05-25'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么对应的这个Schema就是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;,</span><br><span class="line">    age: &#123;<span class="attr">type</span>: <span class="built_in">Number</span>&#125;,</span><br><span class="line">    date: &#123;<span class="attr">type</span>: <span class="built_in">Date</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Schema定义了一个集合中数据的基本格式，但控制数据的，其实是model,关于model稍后再细谈。</p><p>好了，现在就可以进行下一步了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">var</span> newSchema = <span class="keyword">new</span> Schema(</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#123;<span class="attr">type</span>: <span class="built_in">String</span>&#125;,</span><br><span class="line">        age: &#123;<span class="attr">type</span>: <span class="built_in">Number</span>&#125;,</span><br><span class="line">        date: &#123;<span class="attr">type</span>: <span class="built_in">Date</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        collection: <span class="string">""</span> <span class="comment">// 这个是什么？？？</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = mongoose.model(<span class="string">"User"</span>, newSchema)</span><br></pre></td></tr></table></figure></p><p>在这一步里，我们成功的创造了一个Schema的实例，也就是一个新的模式，并通过mongoose.model()生成了一个model，而具体操作数据库的，就是这个model,比如这里的User，下面就插入一条数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先require()到刚才的文件</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">    name: <span class="string">'jesse'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;)</span><br><span class="line">user.save(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>)</span>&#123;...&#125;</span><br><span class="line">我们可以查看一下这个数据</span><br><span class="line"></span><br><span class="line">User.find(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>可以成功打印出刚插入数据的数据库里已经有了这条数据</p><p>看一下服务器：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">show</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">users</span></span><br><span class="line"></span><br><span class="line">$ db.users.find()</span><br><span class="line">......</span><br><span class="line">......  //具体的数据</span><br></pre></td></tr></table></figure></p><p>也没有问题，可是，这个users是怎么来的呢？还有刚刚在定义Schema时，那个collection是干什么的？我们怎么从已有的数据库中取数据呢？<br>带着这三个问题，我们继续探索！</p><h3 id="继续探索"><a href="#继续探索" class="headerlink" title="继续探索"></a>继续探索</h3><p>刚才，我们定义了数据的模式，生成了model，并成功的插入了一条数据，可是我们并没有定义这个collection的名字呀，怎么多出来了一个users，经过网上的搜索，应该是mongoose在生成数据时，自动在User等Schema的后面加上了s，并转换为小写，作为collection的默认名字，但如果想要自定义这个名字该怎么做呢?</p><p><strong>可以这样</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.model(<span class="string">"User"</span>, newSchema,<span class="string">"userseseseses..."</span>)</span><br></pre></td></tr></table></figure></p><p>也就是model()的第三个参数，也可以这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    collection: <span class="string">"collectionName"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>即Schema({},{})的第二个参数.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近一直在看node，先从简单的express学起，其他的还好说，主要是和数据库的连接。既然是js，那就先从mongodb开始吧，我们使用mongoose中间件连接mongodb。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h3&gt;&lt;p&gt;关于mongoose的基本操作其实网上很多教程，按照mongoose官网的&lt;a href=&quot;http://mongoosejs.com/docs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;quick start guide&lt;/a&gt;，很快就能有个大概的了解。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install mongoose --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mongoose = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;mongoose&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mongoose.connect(&lt;span class=&quot;string&quot;&gt;&#39;mongodb://ip:port/database&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>react-router实现按需加载</title>
    <link href="http://yoursite.com/2017/07/08/react-router%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2017/07/08/react-router实现按需加载/</id>
    <published>2017-07-08T13:56:09.000Z</published>
    <updated>2018-07-12T06:47:06.419Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文使用的 react-router 版本为3.0</strong></p><blockquote><p>React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。<br>实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。</p></blockquote><h3 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h3><p>首先在 webpack.config.js 的 output 内加上 chunkFilename<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.join(__dirname, <span class="string">'/../dist/assets'</span>),</span><br><span class="line">  filename: <span class="string">'app.js'</span>,</span><br><span class="line">  publicPath: defaultSettings.publicPath,</span><br><span class="line">  <span class="comment">// 添加 chunkFilename</span></span><br><span class="line">  chunkFilename: <span class="string">'[name].[chunkhash:5].chunk.js'</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>name 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。<br><a id="more"></a><br>chunkhash 是文件的 hash 码，这里只使用前五位。</p><h3 id="添加首页"><a href="#添加首页" class="headerlink" title="添加首页"></a>添加首页</h3><p>以前你的路由大概应该是这样的：（作为需要按需加载的大型应用，路由肯定是相当复杂，这里只列举部分路由举例）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line"> (</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class="line">   &#123;<span class="comment">/* 主页 */</span>&#125;</span><br><span class="line">   &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</span><br><span class="line">    &#123;<span class="comment">/* 默认 */</span>&#125;</span><br><span class="line">    &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    &#123;<span class="comment">/* baidu */</span>&#125;</span><br><span class="line">    &lt;Route path=<span class="string">"/baidu"</span> component=&#123;BaiduPage&#125;&gt;</span><br><span class="line">     &lt;Route path=<span class="string">"result"</span> component=&#123;BaiduResultPage&#125; /&gt;</span><br><span class="line">     &lt;Route path=<span class="string">"frequency"</span> component=&#123;BaiduFrequencyPage&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &#123;/</span>* <span class="number">404</span> *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;Route path='/</span><span class="number">404</span><span class="string">' component=&#123;NotFoundPage&#125; /&gt;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &#123;/* 其他重定向到 404 */&#125;</span></span><br><span class="line"><span class="string">    &lt;Redirect from='</span>*<span class="string">' to='</span>/<span class="number">404</span><span class="string">' /&gt;</span></span><br><span class="line"><span class="string">   &lt;/Route&gt;</span></span><br><span class="line"><span class="string">  &lt;/Router&gt;</span></span><br><span class="line"><span class="string"> ), document.getElementById('</span>app<span class="string">')</span></span><br><span class="line"><span class="string">);</span></span><br></pre></td></tr></table></figure></p><p>按需加载之后，我们需要让路由动态加载组件，需要将 component 换成 getComponent。首先将路由拆出来（因为路由庞大之后全部写在一起会很难看），创建一个根路由 rootRoute：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootRoute = &#123;</span><br><span class="line"> path: <span class="string">'/'</span>,</span><br><span class="line"> indexRoute: &#123;</span><br><span class="line">  getComponent(nextState, cb) &#123;</span><br><span class="line">   <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/HomePage'</span>))</span><br><span class="line">   &#125;, <span class="string">'HomePage'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line"> getComponent(nextState, cb) &#123;</span><br><span class="line">  <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</span><br><span class="line">   cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/Main'</span>))</span><br><span class="line">  &#125;, <span class="string">'Main'</span>)</span><br><span class="line"> &#125;,</span><br><span class="line"> childRoutes: [</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./routes/baidu'</span>),</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./routes/404'</span>),</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./routes/redirect'</span>)</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"> (</span><br><span class="line">  &lt;Router</span><br><span class="line">   history=&#123;browserHistory&#125;</span><br><span class="line">   routes=&#123;rootRoute&#125;</span><br><span class="line">   /&gt;</span><br><span class="line"> ), <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>history 不变，在 Router 中添加 routes 属性，将创建的路由传递进去。<br>这里有四个属性：</p><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>将匹配的路由，也就是以前的 path。</p><h4 id="getComponent"><a href="#getComponent" class="headerlink" title="getComponent"></a>getComponent</h4><p>对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。<br>这里面有个 require.ensure 方法</p><h4 id="require-ensure-dependencies-callback-chunkName"><a href="#require-ensure-dependencies-callback-chunkName" class="headerlink" title="require.ensure(dependencies, callback, chunkName)"></a>require.ensure(dependencies, callback, chunkName)</h4><p>这是 webpack 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 chunkName，用来指定这个 chunk file 的 name。<br>如果需要返回多个子组件，则使用 getComponents 方法，将多个组件作为一个对象的属性通过 cb 返回出去即可。这个在官方示例也有，但是我们这里并不需要，而且根组件是不能返回多个子组件的，所以使用 getComponent。</p><h4 id="indexRoute"><a href="#indexRoute" class="headerlink" title="indexRoute"></a>indexRoute</h4><p>用来设置主页，对应于以前的 <indexroute>。<br>注意这里的 indexRoute 写法， 这是个对象，在对象里面使用 getComponent。</indexroute></p><h4 id="childRoutes"><a href="#childRoutes" class="headerlink" title="childRoutes"></a>childRoutes</h4><p>这里面放置的就是子路由的配置，对应于以前的子路由们。我们将以前的 /baidu、/404 和 * 都拆了出来，接下来将分别为他们创建路由配置。</p><h3 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h3><p>上面的childRoutes 里面，我们 require 了三个子路由，在目录下创建 routes 目录，将这三个路由放置进去。<br>routes/<br>├── 404<br>│  └── index.js<br>├── baidu<br>│  ├── index.js<br>│  └── routes<br>│    ├── frequency<br>│    │  └── index.js<br>│    └── result<br>│      └── index.js<br>└── redirect<br>  └── index.js<br>和 rootRoute 类似，里面的每个 index.js 都是一个路由对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">404</span>/index.js</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> path: <span class="string">'404'</span>,</span><br><span class="line"> getComponent(nextState, cb) &#123;</span><br><span class="line">  <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</span><br><span class="line">   cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/NotFoundPage'</span>))</span><br><span class="line">  &#125;, <span class="string">'NotFoundPage'</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">/baidu/index.js</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> path: <span class="string">'baidu'</span>,</span><br><span class="line"> getChildRoutes(partialNextState, cb) &#123;</span><br><span class="line">  <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</span><br><span class="line">   cb(<span class="literal">null</span>, [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'./routes/result'</span>),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'./routes/frequency'</span>)</span><br><span class="line">   ])</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"> getComponent(nextState, cb) &#123;</span><br><span class="line">  <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</span><br><span class="line">   cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/BaiduPage'</span>))</span><br><span class="line">  &#125;, <span class="string">'BaiduPage'</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">/baidu/routes/frequency/index.js</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> path: <span class="string">'frequency'</span>,</span><br><span class="line"> getComponent(nextState, cb) &#123;</span><br><span class="line">  <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</span><br><span class="line">   cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/BaiduFrequencyPage'</span>))</span><br><span class="line">  &#125;, <span class="string">'BaiduFrequencyPage'</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>举这几个例子应该就差不多了，其他都是一样的，稍微有点特别的是 redirect。</p><h3 id="设置-Redirect"><a href="#设置-Redirect" class="headerlink" title="设置 Redirect"></a>设置 Redirect</h3><p>之前我们在根路由下是这么设置重定向的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class="line">   &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</span><br><span class="line">    &#123;<span class="comment">/* home */</span>&#125;</span><br><span class="line">    &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Route path=<span class="string">"/baidu"</span> component=&#123;BaiduPage&#125;&gt;</span><br><span class="line">     &lt;Route path=<span class="string">"result"</span> component=&#123;BaiduResultPage&#125; /&gt;</span><br><span class="line">     &lt;Route path=<span class="string">"frequency"</span> component=&#123;BaiduFrequencyPage&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;Route path='/</span><span class="number">404</span><span class="string">' component=&#123;NotFoundPage&#125; /&gt;</span></span><br><span class="line"><span class="string">    &#123;/* 如果都不匹配，重定向到 404 */&#125;</span></span><br><span class="line"><span class="string">    &lt;Redirect from='</span>*<span class="string">' to='</span>/<span class="number">404</span><span class="string">' /&gt;</span></span><br><span class="line"><span class="string">   &lt;/Route&gt;</span></span><br><span class="line"><span class="string">  &lt;/Router&gt;</span></span><br></pre></td></tr></table></figure></p><p>当改写之后，我们需要把这个重定向的路由单独拆出来，也就是 * 这个路由，我们上面已经为他创建了一个 redirect 目录。这里使用到 onEnter 方法，然后在这个方法里改变路由状态，调到另外的路由，实现 redirect ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/redirect/index.js</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> path: <span class="string">'*'</span>,</span><br><span class="line"> onEnter: <span class="function">(<span class="params">_, replaceState</span>) =&gt;</span> replaceState(<span class="literal">null</span>, <span class="string">"/404"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="The-root-route-must-render-a-single-element"><a href="#The-root-route-must-render-a-single-element" class="headerlink" title="The root route must render a single element"></a>The root route must render a single element</h4><p>跟着官方示例和上面码出来之后，可能页面并没有渲染出来，而是报 The root route must render a single element 这个异常，这是因为 <strong>module.exports 和 ES6 里的 export default 有区别</strong>。</p><blockquote><p>如果你是使用 es6 的写法，也就是你的组件都是通过 export default 导出的，那么在 getComponent 方法里面需要加入 .default。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getComponent(nextState, cb) &#123;</span><br><span class="line">  <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</span><br><span class="line">   <span class="comment">// 在后面加 .default</span></span><br><span class="line">   cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/ReportPage'</span>)).default</span><br><span class="line">  &#125;, <span class="string">'ReportPage'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>如果你是使用 CommonJS 的写法，也就是通过 module.exports 导出的，那就无须加 .default 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文使用的 react-router 版本为3.0&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。&lt;br&gt;实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Webpack-配置&quot;&gt;&lt;a href=&quot;#Webpack-配置&quot; class=&quot;headerlink&quot; title=&quot;Webpack 配置&quot;&gt;&lt;/a&gt;Webpack 配置&lt;/h3&gt;&lt;p&gt;首先在 webpack.config.js 的 output 内加上 chunkFilename&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;output: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  path: path.join(__dirname, &lt;span class=&quot;string&quot;&gt;&#39;/../dist/assets&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  filename: &lt;span class=&quot;string&quot;&gt;&#39;app.js&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  publicPath: defaultSettings.publicPath,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 添加 chunkFilename&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  chunkFilename: &lt;span class=&quot;string&quot;&gt;&#39;[name].[chunkhash:5].chunk.js&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;name 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>express的上传中间件multer</title>
    <link href="http://yoursite.com/2017/06/10/express%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%AD%E9%97%B4%E4%BB%B6multer/"/>
    <id>http://yoursite.com/2017/06/10/express的上传中间件multer/</id>
    <published>2017-06-10T03:46:22.000Z</published>
    <updated>2018-07-12T06:47:06.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据, 它主要用于上传文件. 它是写在 busboy 之上非常高效。</p></blockquote><p><strong>注意</strong>: Multer <del>不会处理</del>任何非 multipart/form-data 类型的表单数据.</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save multer</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><a id="more"></a><p>Multer 会添加一个 body 对象 以及 <strong>file</strong> 或 <strong>files</strong> 对象 到 request 对象中. body 对象包含表单的文本域信息, file 或 files 对象包含对象表单上传的文件信息.<br>基本使用方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> multer  = <span class="built_in">require</span>(<span class="string">'multer'</span>)</span><br><span class="line"><span class="keyword">var</span> upload = multer(&#123; <span class="attr">dest</span>: <span class="string">'uploads/'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/profile'</span>, upload.single(<span class="string">'avatar'</span>), <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// req.file 是 `avatar` 文件的信息</span></span><br><span class="line">  <span class="comment">// req.body 将具有文本域数据, 如果存在的话</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/photos/upload'</span>, upload.array(<span class="string">'photos'</span>, <span class="number">12</span>), <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// req.files 是 `photos` 文件数组的信息</span></span><br><span class="line">  <span class="comment">// req.body 将具有文本域数据, 如果存在的话</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cpUpload = upload.fields([&#123; <span class="attr">name</span>: <span class="string">'avatar'</span>, <span class="attr">maxCount</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'gallery'</span>, <span class="attr">maxCount</span>: <span class="number">8</span> &#125;])</span><br><span class="line">app.post(<span class="string">'/cool-profile'</span>, cpUpload, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// req.files 是一个对象 (String -&gt; Array) 键是文件名, 值是文件数组</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 例如：</span></span><br><span class="line">  <span class="comment">//  req.files['avatar'][0] -&gt; File</span></span><br><span class="line">  <span class="comment">//  req.files['gallery'] -&gt; Array</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// req.body 将具有文本域数据, 如果存在的话</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>#API</p><h2 id="multer-opts"><a href="#multer-opts" class="headerlink" title="multer(opts)"></a>multer(opts)</h2><p>Multer 接受一个 options 对象, 其中最基本的是 dest 属性, 这将告诉 Multer 将上传文件保存在哪. 如果你省略 options 对象, 这些文件将保存在内存中，永远不会写入磁盘。</p><p>为了避免命名冲突, Multer 会修改上传的文件名. 这个重命名功能可以根据您的需要定制。</p><p>以下是可以传递给Multer的选项.<br>&gt;<br>    Key                      Description<br>    dest or storage         在哪里存储文件<br>    fileFilter             文件过滤器，控制哪些文件可以被接受<br>    limits                 限制上传的数据</p><p>通常, 只需要设置 dest 属性 像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var upload = multer(&#123; dest: &apos;uploads/&apos; &#125;)</span><br></pre></td></tr></table></figure></p><p>如果你想在上传时进行更多的控制, 你可以使用storage选项替代dest. Multer 具有 DiskStorage 和 MemoryStorage 两个存储引擎; 另外还可以从第三方获得更多可用的引擎.</p><h3 id="single-fieldname"><a href="#single-fieldname" class="headerlink" title=".single(fieldname)"></a>.single(fieldname)</h3><p>接受<strong>一个</strong>以 fieldname 命名的文件. 这个文件的信息保存在 <strong>req.file</strong>.</p><h3 id="array-fieldname-maxCount"><a href="#array-fieldname-maxCount" class="headerlink" title=".array(fieldname[, maxCount])"></a>.array(fieldname[, maxCount])</h3><p>接受一个以 fieldname 命名的文件<strong>数组</strong>. 可以配置 maxCount 来限制上传的最大数量. 这些文件的信息保存在 <strong>req.files</strong>.</p><h3 id="fields-fields"><a href="#fields-fields" class="headerlink" title=".fields(fields)"></a>.fields(fields)</h3><p>接受指定 fields 的混合文件. 这些文件的信息保存在 <strong>req.files</strong>.<br>fields 应该是一个对象数组，应该具有 name 和可选的 maxCount属性. Example:<br>[<br>  { name: ‘avatar’, maxCount: 1 },<br>  { name: ‘gallery’, maxCount: 8 }<br>]</p><h3 id="none"><a href="#none" class="headerlink" title=".none()"></a>.none()</h3><p>只接受文本域. 如果任何文件上传到这个模式, 将发生 “LIMIT_UNEXPECTED_FILE” 错误. 这和 upload.fields([]) 的效果一样.</p><h3 id="any"><a href="#any" class="headerlink" title=".any()"></a>.any()</h3><p>接受一切. 文件数组将保存在 <strong>req.files</strong>.<br><strong>警告</strong>: 确保你总是处理了用户的文件上传. 永远不要将multer作为全局中间件使用，因为恶意用户可以上传文件到一个你没有预料到的路由，应该只在你需要处理上传文件的路由上使用.</p><h2 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h2><h3 id="DiskStorage"><a href="#DiskStorage" class="headerlink" title="DiskStorage"></a>DiskStorage</h3><p>磁盘存储引擎可以让你控制文件的存储.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> storage = multer.diskStorage(&#123;</span><br><span class="line">  destination: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>, <span class="string">'/tmp/my-uploads'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  filename: <span class="function"><span class="keyword">function</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>, file.fieldname + <span class="string">'-'</span> + <span class="built_in">Date</span>.now())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upload = multer(&#123; <span class="attr">storage</span>: storage &#125;)</span><br></pre></td></tr></table></figure></p><p>destination 是用来确定上传的文件应该存储在哪个文件夹中. 也可以提供一个 string (例如 ‘/tmp/uploads’). 如果没有设置 destination , 则使用操作默认的临时文件夹.<br>filename 用于确定文件夹中的文件名的确定。 如果没有设置filename , 每个文件将设置为一个随机文件名，并且是<strong>没有扩展名</strong>的<br>注意: Multer 不会为你添加任何扩展名, 你的程序应该返回一个完整的文件名.此时就可以在file.originName中获取扩展名。</p><h3 id="limits"><a href="#limits" class="headerlink" title="limits"></a>limits</h3><p>可以使用下面这些:</p><blockquote><p>Key                                    Description                            Default<br><strong>fieldNameSize</strong>                  field 名字最大长度            <strong>100 bytes</strong><br><strong>fieldSize </strong>                         field 值的最大长度               <strong>1MB</strong><br><strong>fields</strong>                                非文件 field 的最大数量    <strong>无限</strong><br><strong>fileSize</strong>                               在multipart表单中, 文件最大长度 (字节单位)       <strong>无限</strong><br><strong>files</strong>                                   在multipart表单中, 文件最大数量                         <strong>无限</strong><br><strong>parts </strong>                                  在multipart表单中, part传输的最大数量(fields + files)    <strong>无限</strong><br><strong>headerPairs</strong>          For multipart forms, the max number of header key=&gt;value pairs to parse    <strong>2000</strong></p></blockquote><h3 id="fileFilter"><a href="#fileFilter" class="headerlink" title="fileFilter"></a>fileFilter</h3><p>设置一个函数来控制什么文件可以上传以及什么文件应该跳过，这个函数应该看起来像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileFilter</span> (<span class="params">req, file, cb</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个函数应该调用 `cb` 用boolean值来</span></span><br><span class="line">  <span class="comment">// 指示是否应接受该文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拒绝这个文件，使用`false`, 像这样:</span></span><br><span class="line">  cb(<span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接受这个文件，使用`true`, 像这样:</span></span><br><span class="line">  cb(<span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有问题，你可以总是这样发送一个错误:</span></span><br><span class="line">  cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I don\'t have a clue!'</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据, 它主要用于上传文件. 它是写在 busboy 之上非常高效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: Multer &lt;del&gt;不会处理&lt;/del&gt;任何非 multipart/form-data 类型的表单数据.&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save multer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>使用Travis将Hexo同时部署到Coding.net</title>
    <link href="http://yoursite.com/2017/06/02/%E4%BD%BF%E7%94%A8Travis%E5%B0%86Hexo%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%88%B0Coding-net/"/>
    <id>http://yoursite.com/2017/06/02/使用Travis将Hexo同时部署到Coding-net/</id>
    <published>2017-06-02T15:57:18.000Z</published>
    <updated>2018-07-12T06:47:06.423Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>既然使用了Travis在push后发不到github，那就再加点东西，发布到coding.net的Pages服务上，理论上国内服务应该快一点点。<br>  同时搭建的教程可以看看<a href="http://www.ithome.com/html/win10/311572.htm" target="_blank" rel="noopener">这里</a></p></blockquote><ol><li><p>修改.travis文件夹下的<strong>ssh_config,</strong>添加coding.net</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">Host git.coding.net</span><br><span class="line">  User git</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br></pre></td></tr></table></figure></li><li><p>修改hexo的配置文件<strong>_config.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">   type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">   repo:</span></span><br><span class="line"><span class="attr">     coding:</span> <span class="string">git@git.coding.net:wxrbw/wxrbw.coding.me.git,master</span></span><br><span class="line"><span class="attr">     github:</span> <span class="string">git@github.com:wxrbwran/wxrbwran.github.io.git,master</span></span><br></pre></td></tr></table></figure></li></ol><p>再push到github就可以自动发布到两个Pages了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;既然使用了Travis在push后发不到github，那就再加点东西，发布到coding.net的Pages服务上，理论上国内服务应该快一点点。&lt;br&gt;  同时搭建的教程可以看看&lt;a href=&quot;http://www.ithome.com/html
      
    
    </summary>
    
    
      <category term="travis" scheme="http://yoursite.com/tags/travis/"/>
    
  </entry>
  
  <entry>
    <title>在express中使用es2015的新特性</title>
    <link href="http://yoursite.com/2017/06/01/%E5%9C%A8express%E4%B8%AD%E4%BD%BF%E7%94%A8es2015%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/06/01/在express中使用es2015的新特性/</id>
    <published>2017-06-01T10:20:55.000Z</published>
    <updated>2018-07-12T06:47:06.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在前端开发中使用es2015及正在stage中的js特性已经屡见不鲜，但是在express中使用还是第一次尝试，稍微配置下也是可以的。有没有坑，等使用后再补齐。</p></blockquote><h3 id="安装babel"><a href="#安装babel" class="headerlink" title="安装babel"></a>安装babel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;babel-cli&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">&quot;babel-preset-stage-2&quot;: &quot;^6.24.1&quot;,</span><br></pre></td></tr></table></figure><p>###根目录下创建.babelrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;],</span><br><span class="line">  &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="安装nodemon"><a href="#安装nodemon" class="headerlink" title="安装nodemon"></a>安装nodemon</h3><p>不使用supervisor是因为配合不了babel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nodemon -g</span><br></pre></td></tr></table></figure></p><h3 id="修改package-json"><a href="#修改package-json" class="headerlink" title="修改package.json"></a>修改package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;nodemon ./bin/www.js --exec babel-node&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>之后就可以使用es新的语法特性了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在前端开发中使用es2015及正在stage中的js特性已经屡见不鲜，但是在express中使用还是第一次尝试，稍微配置下也是可以的。有没有坑，等使用后再补齐。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装babel&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="es2015" scheme="http://yoursite.com/tags/es2015/"/>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>hexo＋Travis-ci＋github构建自动化博客</title>
    <link href="http://yoursite.com/2017/06/01/hexo%EF%BC%8BTravis-ci%EF%BC%8Bgithub%E6%9E%84%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/06/01/hexo＋Travis-ci＋github构建自动化博客/</id>
    <published>2017-06-01T02:08:52.000Z</published>
    <updated>2018-07-12T06:47:06.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Travis CI：是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清晰。</p></blockquote><p>tarvis－ci是远端服务器构建，跟jenkins 不一样，不用自己搭建一个jenkins服务器。tarvis－ci是用的远端官方提供的服务器。用hexo 搭建博客，然后将博客源码提交到 Git上，用travis－ci 编译git 上的源码，然后将编译后的文件，推送到Github.io仓库下，达到自动化编译构建。</p><hr><h4 id="构建自动化博客的步骤"><a href="#构建自动化博客的步骤" class="headerlink" title="构建自动化博客的步骤"></a>构建自动化博客的步骤</h4><p>由于需要搭建hexo 和本地搭建Travis 所以本地需要有ruby 和 node 环境。本地搭建Travis 是为了和Travis－ci 服务器进行加密解密获得密匙，获得一次即可。</p><ol><li><p>安装rubu 和node.js</p></li><li><p>搭建hexo</p></li><li><p>安装 travis</p></li><li><p>配置git 的ssh key</p></li><li><p>配置Travis</p></li><li><p>验证</p></li></ol><hr><a id="more"></a><h3 id="安装ruby和node"><a href="#安装ruby和node" class="headerlink" title="安装ruby和node"></a>安装ruby和node</h3><p>略</p><h3 id="搭建hexo"><a href="#搭建hexo" class="headerlink" title="搭建hexo"></a>搭建hexo</h3><p>搭建过程略<br>注意的是：博客搭建成功后在github 的your_blog_name.github.io 仓库下新建travis分支，并将博客源码（未编译过的代码）提交到该分支，用于以后<strong>Travis-ci编译</strong>使用。</p><h3 id="安装-travis"><a href="#安装-travis" class="headerlink" title="安装 travis"></a>安装 travis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br></pre></td></tr></table></figure><h3 id="配置git-的ssh-key"><a href="#配置git-的ssh-key" class="headerlink" title="配置git 的ssh key"></a>配置git 的ssh key</h3><p>将本机ssh_key 添加github中。</p><h3 id="配置Travis"><a href="#配置Travis" class="headerlink" title="配置Travis"></a>配置Travis</h3><ol><li>进入travis官网Travis 官网传送门用github账号登陆Travis CI<br><img src="http://oqum9wezj.bkt.clouddn.com/WX20170601-110251.png" alt="CI"></li><li><p>在右上角你的账户名点击进入 account，在Repositories tab页点击Sync now同步你的github项目。选中项目将默认的off改变为on开启项目的持续集成。<br><img src="http://oqum9wezj.bkt.clouddn.com/sync_ci.png" alt="sync_ci"></p></li><li><p>在你项目的根目录建立一个.travis文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd 博客项目文件夹根目录</span><br><span class="line">$ mkdir .travis</span><br></pre></td></tr></table></figure></li><li><p>复制id_rsa 和 创建 ssh_config文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd 博客项目文件夹根目录/.travis</span><br><span class="line">$ cp ~/.ssh/id_rsa ./</span><br></pre></td></tr></table></figure></li><li><p>创建 ssh_config 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd 博客项目文件夹根目录/.travis</span><br><span class="line">$ touch ssh_config</span><br></pre></td></tr></table></figure></li></ol><p>编辑 ssh_config ,输入以下信息</p><blockquote><p>Host github.com<br>User git<br>StrictHostKeyChecking no<br>IdentityFile ~/.ssh/id_rsa<br>IdentitiesOnly yes</p></blockquote><ol><li>travis 登陆<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd 博客项目文件夹根目录/.travis</span><br><span class="line">$ travis login --auto</span><br></pre></td></tr></table></figure></li></ol><p>需要填写github的用户名和密码。</p><ol><li>加密操作<br>在博客项目文件夹下对ssh的私钥进行加密<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd 博客项目文件夹根目录/.travis</span><br><span class="line">$ travis encrypt-file id_rsa --add</span><br></pre></td></tr></table></figure></li></ol><p>此操作会生成加密之后的秘钥文件 id_rsa.enc，删除id_rsa密钥文件(私钥不能随便泄露)。<br>你的travis 目前上已经出现了下面加密解密key :<br>(点击第2步图中的仓库名可进入下图界面，点击setting可看到加密)<br><img src="http://oqum9wezj.bkt.clouddn.com/enc.png" alt="enc_code"></p><ol><li>在你项目的根目录建立一个.travis.yml文件，内容为：<br>此步是在我your_blog_name.github.io仓库的travis 分支下编译源码。<br>（用第7步中Travis 生成的 encrypted_xxxxxxxxx_key -iv 和encrypted_xxxxxxxxx_iv 替换travis.yml 中openssl的 key 和 -iv）</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'7'</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">travis</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_xxxxxxxxx_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_xxxxxxxxx_iv</span></span><br><span class="line"><span class="bullet">  -</span><span class="string">in</span> <span class="string">.travis/id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">eval</span> <span class="string">$(ssh-agent)</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ssh-add</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cp</span> <span class="string">.travis/ssh_config</span> <span class="string">~/.ssh/config</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.name</span> <span class="string">"527515025"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="bullet">--global</span> <span class="string">user.email</span> <span class="string">"527515025@qq.com"</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="bullet">-g</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="bullet">--save</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_success:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>在travis分支中，操作一下，push到分支上就可以自动构建并发布了~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Travis CI：是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清晰。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tarvis－ci是远端服务器构建，跟jenkins 不一样，不用自己搭建一个jenkins服务器。tarvis－ci是用的远端官方提供的服务器。用hexo 搭建博客，然后将博客源码提交到 Git上，用travis－ci 编译git 上的源码，然后将编译后的文件，推送到Github.io仓库下，达到自动化编译构建。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;构建自动化博客的步骤&quot;&gt;&lt;a href=&quot;#构建自动化博客的步骤&quot; class=&quot;headerlink&quot; title=&quot;构建自动化博客的步骤&quot;&gt;&lt;/a&gt;构建自动化博客的步骤&lt;/h4&gt;&lt;p&gt;由于需要搭建hexo 和本地搭建Travis 所以本地需要有ruby 和 node 环境。本地搭建Travis 是为了和Travis－ci 服务器进行加密解密获得密匙，获得一次即可。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装rubu 和node.js&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;搭建hexo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装 travis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置git 的ssh key&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置Travis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;验证&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="ci" scheme="http://yoursite.com/tags/ci/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>react中context的使用</title>
    <link href="http://yoursite.com/2017/05/27/react%E4%B8%ADcontext%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/05/27/react中context的使用/</id>
    <published>2017-05-27T06:29:39.000Z</published>
    <updated>2018-07-12T06:47:06.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-Context-的原因"><a href="#使用-Context-的原因" class="headerlink" title="使用 Context 的原因"></a>使用 Context 的原因</h2><p>为了有时候想传递数据通过组件树，但是不想给每一层级的组件手动传递属性，那么 context 就能帮你 “越级” 传递数据到组件树中你想传递到的深层次组件。</p><a id="more"></a><p>有时候 A组件 为了给 B组件 中的 C组件 传递一个 prop ，而需要把参数在组件中传递两次才能最终将 A组件 中的 prop 传递给 C组件 。</p><p>官方文档的示例代码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button style=&#123;&#123;<span class="attr">background</span>: <span class="keyword">this</span>.props.color&#125;&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var Message = React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">  render: function() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.text&#125; &lt;Button color=&#123;this.props.color&#125;&gt;Delete&lt;/</span>Button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var MessageList = React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">  render: function() &#123;</span></span><br><span class="line"><span class="regexp">    var color = "purple";</span></span><br><span class="line"><span class="regexp">    var children = this.props.messages.map(function(message) &#123;</span></span><br><span class="line"><span class="regexp">      return &lt;Message text=&#123;message.text&#125; color=&#123;color&#125; /</span>&gt;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="使用-context-改进数据传递"><a href="#使用-context-改进数据传递" class="headerlink" title="使用 context 改进数据传递"></a>使用 context 改进数据传递</h3><p>现在我们使用 context 来完成参数的传递试试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Button = React.createClass(&#123;</span><br><span class="line">  <span class="comment">// 必须指定context的数据类型</span></span><br><span class="line">  contextTypes: &#123;</span><br><span class="line">    color: React.PropTypes.string</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button style=&#123;&#123;<span class="attr">background</span>: <span class="keyword">this</span>.context.color&#125;&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var Message = React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">  render: function() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/</span>Button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var MessageList = React.createClass(&#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/</span></span><br><span class="line"><span class="regexp">  childContextTypes: &#123;</span></span><br><span class="line"><span class="regexp">    color: React.PropTypes.string</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  getChildContext: function() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;color: "purple"&#125;;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  render: function() &#123;</span></span><br><span class="line"><span class="regexp">    var children = this.props.messages.map(function(message) &#123;</span></span><br><span class="line"><span class="regexp">      return &lt;Message text=&#123;message.text&#125; /</span>&gt;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>示例代码中通过添加 <strong>childContextTypes</strong> 和<strong>getChildContext()</strong> 到 MessageList （ context 的提供者），React 自动向下传递数据然后在组件树中的任意组件（也就是说任意子组件，在此示例代码中也就是 Button ）都能通过定义 <strong>contextTypes</strong> 访问 context 中的数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>指定数据并要将数据传递下去的父组件要定义 <strong>childContextTypes</strong> 和 <strong>getChildContext()</strong>；</li><li>想要接收到数据的子组件 必须定义 <strong>contextTypes</strong> 来使用传递过来的 context 。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用-Context-的原因&quot;&gt;&lt;a href=&quot;#使用-Context-的原因&quot; class=&quot;headerlink&quot; title=&quot;使用 Context 的原因&quot;&gt;&lt;/a&gt;使用 Context 的原因&lt;/h2&gt;&lt;p&gt;为了有时候想传递数据通过组件树，但是不想给每一层级的组件手动传递属性，那么 context 就能帮你 “越级” 传递数据到组件树中你想传递到的深层次组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>使用ES2015全局对象--webpack下添加polyfill</title>
    <link href="http://yoursite.com/2017/01/22/%E4%BD%BF%E7%94%A8ES2015%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1--webpack%E4%B8%8B%E6%B7%BB%E5%8A%A0polyfill/"/>
    <id>http://yoursite.com/2017/01/22/使用ES2015全局对象--webpack下添加polyfill/</id>
    <published>2017-01-22T08:32:07.000Z</published>
    <updated>2018-07-12T06:47:06.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>公司使用的技术栈是<em>react全家桶</em>，使用<em>axios</em>进行ajax通信,axios使用的基于<strong>Promise</strong>实现。在现代浏览器上使用并没有什么问题，但是<del>IE全系列不支持Promise</del>，包括IE11…</p></blockquote><p>本来想着使用babel后，将代码转换为es5，应该在IE10以上兼容运行，但是实际运行时，报错，没有Promise…orz</p><p>长话短说，解决方案：<a href="http://babeljs.io/docs/usage/polyfill/" target="_blank" rel="noopener">babel-polyfill</a></p><a id="more"></a><hr><p>原来在.babelrc里面添加的是 <em>babel-plugin-transform-runtime</em>，但是在这里并不管用，究竟是为什么呢？</p><ul><li>babel-polyfill 使用场景</li></ul><p>Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。</p><ul><li>babel-runtime 使用场景</li></ul><p>Babel 转译后的代码要实现源代码同样的功能需要借助一些帮助函数，例如，{ [name]: ‘JavaScript’ } 转译后的代码如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperty</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      value: value,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      writable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = _defineProperty(&#123;&#125;, <span class="string">'name'</span>, <span class="string">'JavaScript'</span>);</span><br></pre></td></tr></table></figure></p><p>类似上面的帮助函数 _defineProperty 可能会重复出现在一些模块里，导致编译后的代码体积变大。Babel 为了解决这个问题，提供了单独的包 babel-runtime 供编译模块复用工具函数。</p><p>启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数，转译代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="comment">// 之前的 _defineProperty 函数已经作为公共模块 `babel-runtime/helpers/defineProperty` 使用</span></span><br><span class="line"><span class="keyword">var</span> _defineProperty2 = <span class="built_in">require</span>(<span class="string">'babel-runtime/helpers/defineProperty'</span>);</span><br><span class="line"><span class="keyword">var</span> _defineProperty3 = _interopRequireDefault(_defineProperty2);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;; &#125;</span><br><span class="line"><span class="keyword">var</span> obj = (<span class="number">0</span>, _defineProperty3.default)(&#123;&#125;, <span class="string">'name'</span>, <span class="string">'JavaScript'</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;公司使用的技术栈是&lt;em&gt;react全家桶&lt;/em&gt;，使用&lt;em&gt;axios&lt;/em&gt;进行ajax通信,axios使用的基于&lt;strong&gt;Promise&lt;/strong&gt;实现。在现代浏览器上使用并没有什么问题，但是&lt;del&gt;IE全系列不支持Promise&lt;/del&gt;，包括IE11…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本来想着使用babel后，将代码转换为es5，应该在IE10以上兼容运行，但是实际运行时，报错，没有Promise…orz&lt;/p&gt;
&lt;p&gt;长话短说，解决方案：&lt;a href=&quot;http://babeljs.io/docs/usage/polyfill/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;babel-polyfill&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>调试手机端微信X5浏览器</title>
    <link href="http://yoursite.com/2016/11/15/%E8%B0%83%E8%AF%95%E6%89%8B%E6%9C%BA%E7%AB%AF%E5%BE%AE%E4%BF%A1X5%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://yoursite.com/2016/11/15/调试手机端微信X5浏览器/</id>
    <published>2016-11-15T03:22:04.000Z</published>
    <updated>2018-07-12T06:47:06.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移动调试"><a href="#移动调试" class="headerlink" title="移动调试"></a>移动调试</h3><p>移动端网页的表现，通常和桌面浏览器上有所区别，包括样式的呈现、脚本的逻辑等等，这会给开发者带来一定的困扰。现在，微信安卓客户端 webview 已经开始全面升级至 <strong>X5 Blink</strong> 内核，新的内核无论在渲染能力、API 支持还是在开发辅助上都有很大进步。通过<strong>微信 web 开发者工具</strong>中的远程调试功能，实时映射手机屏幕到微信 web 开发者工具上，将帮助开发者更高效地调试 X5 Blink 内核的网页，具体步骤如下：</p><ol><li>准备工作<ol><li>安装0.5.0或以上版本的微信 web 开发者工具</li><li>确认移动设备是否支持远程调试功能<br>打开微信 web 开发者工具，选择“移动调试”tab，点击验证移动设备是否支持。随后使用移动设备扫描弹出的二维码，在设备上即可获得支持信息。</li><li>打开移动设备中的 USB 调试功能</li><li>打开移动设备，进入“设置”-&gt;“开发人员选项”</li><li>勾选“USB 调试功能”<br><img src="http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4ia39RvTaqRBxuI3A756YjtCoByQQKyHtib7DDPl4UsCTIVeo3iarTcOs6A/0?wx_fmt=jpeg" alt="usb调试"><br>需要注意的是，Android 4.2 之后的设备，开发人员选项默认是隐藏的，通过以下步骤可以打开：</li><li>打开移动设备，进入“设置”-&gt;“关于手机”</li><li>找到并单击“内部版本号”7次</li><li>安装移动设备 USB 驱动</li><li>打开 X5 Blink 内核的 inspector 功能<br>打开微信 web 开发者工具，选择“移动调试”tab ，使用设备扫描“调试步骤”中的二维码。<br>如下图，勾选“是否打开 TBS 内核 Inspector 调试功能”，并重启微信。<br><img src="http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iayIjGCiaY8Fj4kcmickmFjoWoPbicICk9xjNStOmSBsDkRAoYTRjeXHRdQ/0?wx_fmt=jpeg" alt="微信设置"><a id="more"></a></li></ol></li><li>开始调试<br>使用 USB 数据线连接移动设备与 PC 或者 Mac 后，点击打开微信 web 开发者工具“移动调试”tab，选择 X5 Blink 调试功能，将会打开一个新窗口，在微信中访问任意网页即可开始调试。关于 X5 Blink 内核更多信息，可以查看<a href="http://x5.tencent.com/guide?id=4000" target="_blank" rel="noopener">官网介绍</a>。<br>在所有准备工作都完成的情况下，窗口中可以看到当前设备的基本信息：<br><img src="http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaUgGafLxWM42m0ax3Ccf5p1aZh6BpGb0cXfdREicyiaD61ibFZk0Oqmf2g/0?wx_fmt=jpeg" alt="微信打开页面，启动调试"><br>点击任意页面的“inspect”，打开新窗口，开发者会看到熟悉的调试界面：<br><img src="http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iatJNE7NSspCWCAm3NP0niaJuIUs9tYwGv9KVtFtR7l9ibJNbOicdjtW50w/0?wx_fmt=png" alt="调试"><br>点击上图右上角的“手机”图标，将启用屏幕映射功能：<br><img src="http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iaIsXD9S02yz9j5dYaMAAsXxnK8FSzS39bpickcG7UHyry4UkiaCbtM9Dw/0?wx_fmt=png" alt="映射"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;移动调试&quot;&gt;&lt;a href=&quot;#移动调试&quot; class=&quot;headerlink&quot; title=&quot;移动调试&quot;&gt;&lt;/a&gt;移动调试&lt;/h3&gt;&lt;p&gt;移动端网页的表现，通常和桌面浏览器上有所区别，包括样式的呈现、脚本的逻辑等等，这会给开发者带来一定的困扰。现在，微信安卓客户端 webview 已经开始全面升级至 &lt;strong&gt;X5 Blink&lt;/strong&gt; 内核，新的内核无论在渲染能力、API 支持还是在开发辅助上都有很大进步。通过&lt;strong&gt;微信 web 开发者工具&lt;/strong&gt;中的远程调试功能，实时映射手机屏幕到微信 web 开发者工具上，将帮助开发者更高效地调试 X5 Blink 内核的网页，具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备工作&lt;ol&gt;
&lt;li&gt;安装0.5.0或以上版本的微信 web 开发者工具&lt;/li&gt;
&lt;li&gt;确认移动设备是否支持远程调试功能&lt;br&gt;打开微信 web 开发者工具，选择“移动调试”tab，点击验证移动设备是否支持。随后使用移动设备扫描弹出的二维码，在设备上即可获得支持信息。&lt;/li&gt;
&lt;li&gt;打开移动设备中的 USB 调试功能&lt;/li&gt;
&lt;li&gt;打开移动设备，进入“设置”-&amp;gt;“开发人员选项”&lt;/li&gt;
&lt;li&gt;勾选“USB 调试功能”&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4ia39RvTaqRBxuI3A756YjtCoByQQKyHtib7DDPl4UsCTIVeo3iarTcOs6A/0?wx_fmt=jpeg&quot; alt=&quot;usb调试&quot;&gt;&lt;br&gt;需要注意的是，Android 4.2 之后的设备，开发人员选项默认是隐藏的，通过以下步骤可以打开：&lt;/li&gt;
&lt;li&gt;打开移动设备，进入“设置”-&amp;gt;“关于手机”&lt;/li&gt;
&lt;li&gt;找到并单击“内部版本号”7次&lt;/li&gt;
&lt;li&gt;安装移动设备 USB 驱动&lt;/li&gt;
&lt;li&gt;打开 X5 Blink 内核的 inspector 功能&lt;br&gt;打开微信 web 开发者工具，选择“移动调试”tab ，使用设备扫描“调试步骤”中的二维码。&lt;br&gt;如下图，勾选“是否打开 TBS 内核 Inspector 调试功能”，并重启微信。&lt;br&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz/PiajxSqBRaEIQxibpLbyuSK8ibl6QNerU4iayIjGCiaY8Fj4kcmickmFjoWoPbicICk9xjNStOmSBsDkRAoYTRjeXHRdQ/0?wx_fmt=jpeg&quot; alt=&quot;微信设置&quot;&gt;
    
    </summary>
    
    
      <category term="微信" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
</feed>
