---
title: ES7 and ES8 特性
date: 2017-07-18 13:56:47
tags:  
    - es7
    - es8
---
## ES8 was Released
> 虽然现在开发已经都在用es6，一个不注意，都到了es8了。记录一下新增加的常用功能，方便查阅。
## ES7 特性：
1. Array.prototype.includes
2. Exponentiation Operator(求冥运算)

## ES8 特性
1. Object.values/Object.entries
2. String padding(字符串填充)
3. Object.getOwnPropertyDescriptors
4. 函数参数列表和调用中的尾逗号（Trailing commas）
5. 异步函数（Async Functions）

### Array.prototype.includes
Array.prototype.includes用法都容易和简单。它是一个替代indexOf，开发人员用来检查数组中是否存在值，indexOf是一种尴尬的使用，因为它返回一个元素在数组中的位置或者-1当这样的元素不能被找到的情况下。所以它返回一个数字，而不是一个布尔值。开发人员需要实施额外的检查。
在ES6，要检查是否存在值你需要做一些如下所示小技巧，因为他们没有匹配到值，Array.prototype.indexOf返回-1变成了true（转换成true），但是当匹配的元素为0位置时候，该数组包含元素，却变成了false
```js
let arr = ['react', 'angular', 'vue']
// WRONG
if (arr.indexOf('react')) { // 0 -> evaluates to false, definitely as we expected
  console.log('Can use React') // this line would never be executed
}
// Correct
if (arr.indexOf('react') !== -1) {
  console.log('Can use React')
}
```
或者使用一点点hack 位运算符 ~ 使代码更加紧凑一些，因为~（位异或）对任何数字相当于-(a + 1):
```js
let arr = ['react', 'angular', 'vue']
// Correct
if (~arr.indexOf('react')) {
  console.log('Can use React')
}
```
在ES7中使用includes代码如下:
```js
let arr = ['react', 'angular', 'vue']
// Correct
if (arr.includes('react')) {
  console.log('Can use React')
}
// 开发者还能在字符串中使用includes:
let str = 'React Quickly'
// Correct
if (str.toLowerCase().includes('react')) {  // true
  console.log('Found "react"')  
}
```
### Exponentiation Operator(求冥运算)
求冥运算大多数是为开发者做一些数学计算，对于3D，VR，SVG还有数据可视化非常有用。
在ES6或者早些版本，你不得不创建一个循环，创建一个递归函数或者使用Math.pow,如果你忘记了什么是指数,当你有相同数字（基数）自相相乘多次（指数）。例如，7的3次方是7*7*7

现在在ES7 /ES2016，以数学向导的开发者可以使用更短的语法:
```js
let a = 7 ** 12
let b = 2 ** 7
console.log(a === Math.pow(7,12)) // true
console.log(b === Math.pow(2,7)) // true
// 开发者还可以操作结果:
let a = 7
a **= 12
let b = 2
b **= 7
console.log(a === Math.pow(7,12)) // true
console.log(b === Math.pow(2,7)) // true
```
### Object.values/Object.entries
Object.entries 和 Object.values是在ES2017规格中，它和Object.keys类似，返回数组类型，其序号和Object.keys序号对应。

Object.values,Object.values和Object.keys各自项返回是数组，相对应包括key,value或者可枚举特定对象property/attribute

在ES8 /ES2017之前，Javascript开发者需要迭代一个对象的自身属性时候不得不用Object.keys，通过迭代且使用obj[key]获取value值返回一个数组：

let obj = {a: 1, b: 2, c: 3}
Object.keys(obj).forEach((key, index)=>{
  console.log(key, obj[key])
})
而使用ES6/ES2015 中for/of稍微好点：

let obj = {a: 1, b: 2, c: 3}
for (let key of Object.keys(obj)) {
  console.log(key, obj[key])
}
你使用老方式for/in(ES5)也许用的非常好。但是他会迭代所有可以枚举属性（像原型中的带名字的-see MDN）,不仅仅自己的属性，会意外的破坏那些 像prototype和tostring得到意想不到的值。
Object.values返回对象自身可以迭代属性值（values）为数组类型。我们最好使用Array.prototype.forEach迭代它，结合ES6的箭头函数隐形返回值：

let obj = {a: 1, b: 2, c: 3}
Object.values(obj).forEach(value=>console.log(value)) // 1, 2, 3
或者使用for/of:

let obj = {a: 1, b: 2, c: 3}
Object.values(obj).forEach(value=>console.log(value)) // 1, 2, 3
·Object.entries·，在另一方面，将会返回对象自身可迭代属性key-value对数组（作为一个数组），他们（key-value）分别以数组存放数组中。

let obj = {a: 1, b: 2, c: 3}
JSON.stringify(Object.entries(obj))
"[["a",1],["b",2],["c",3]]"
我们可以使用ES6/ES2015解构（需要深入了解解构请点击这篇文章和课程）,从这嵌套数组中分别声明key和value

let obj = {a: 1, b: 2, c: 3}
Object.entries(obj).forEach(([key, value]) => {
 console.log(`${key} is ${value}`)
})
// a is 1, b is 2, c is 3
你可以猜一猜，我们同样使用ES6for/of（毕竟全部都是数组）遍历Object.entries返回来的结果值。

let obj = {a: 1, b: 2, c: 3}
for (let [key, value] of Object.entries(obj)) {
  console.log(`${key} is ${value}`)
}
// a is 1, b is 2, c is 3
现在从对象中提取values和key-value pairs 变得非常容易了。Object.values和Object.entries这种方式不想之前 Object.keys(自身属性key+顺序相同)结合for/of(ES6)一起，我们不仅仅可以提取他们还可以迭代他们。